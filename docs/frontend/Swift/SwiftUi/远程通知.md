## 证书模式

1. 去[Apple开发者官网](https://developer.apple.com/account/resources/identifiers/list)新建一个APP并且开启推送权限。

![](https://upload.kinda.info/image/202212151736791.png)

![](https://upload.kinda.info/image/202212151737433.png)

2. 配置本地测试证书
    1. 本地生成csr文件
       1. 打开Keychain Access
        ![](https://upload.kinda.info/image/202212151757359.png)
       2. 配置证书
       ![](https://upload.kinda.info/image/202212151758906.png)

        选择保存到本地（此时不需要上传到ca认证）
       ![](https://upload.kinda.info/image/202212151800048.png)
    2. 上传CSR文件
        ![](https://upload.kinda.info/image/202212151803306.png)
    3. 下载证书
        ![](https://upload.kinda.info/image/202212151804864.png)

3. 配置发布证书（如果需要，那么具体操作同上）
4. 双击下载下来的证书加到KeyChain Access

## Token模式

### 生成Token

[官网文档](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/establishing_a_token-based_connection_to_apns)

1. 生成新的key

[Apple Developer](https://developer.apple.com/account/resources/authkeys/list)

![](https://upload.kinda.info/image/202212161140314.png)

![](https://upload.kinda.info/image/202212161141832.png)

2. 数据准备

KEYID

![](https://upload.kinda.info/image/202212161143310.png)

[Apple Developer账号信息](https://developer.apple.com/account)

团队ID：

![](https://upload.kinda.info/image/202212161151053.png)

|Key|Description|
|--|--|
|`alg`|编码算法，苹果目前只支持`ES256`|
|`kid`|上面记录下来的Key ID|
|`iss`|你的开发者账号的Team ID|
|`iat`|Token的生成时间（UTC时区，从Epoch以来的秒数）|

JSON示例：

```json
{
   "alg" : "ES256",
   "kid" : "ABC123DEFG"
}
{
   "iss": "DEF123GHIJ",
   "iat": 1437179036
}
```

3. JWT编码

python版本

```python
import jwt
import time

payload = {
    "iss": teamId,
    "iat": time.time()
}

headers = {
    "alg" : "ES256",
    "kid" : keyId
}

# Apple Developer下载的p8文件
with open('./AuthKey_****.p8', 'r') as f:
    privateKey = f.read()

token = jwt.encode(payload=payload, algorithm='ES256', headers=headers, key=privateKey)
print('token:', token)
```

4. 注册终端并且获取deviceToken

新建一个AppDelegate文件去对应应用的生命周期

```swift title=AppDelegate.swift
import SwiftUI

// 扩展Data，将Data编码转成正常字符串
extension Data {
    var hexString: String {
        return map { String(format: "%02.2hhx", arguments: [$0]) }.joined()
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication,
               didFinishLaunchingWithOptions launchOptions:
                     [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
       // Override point for customization after application launch.you’re
       // 申请注册本机
        UIApplication.shared.registerForRemoteNotifications()
        return true
    }

    func application(_ application: UIApplication,
                didRegisterForRemoteNotificationsWithDeviceToken
                    deviceToken: Data) {
                     // 如果注册成功，那么会调用此处函数
        print("deviceToken:", deviceToken.hexString)
//       self.sendDeviceTokenToServer(data: deviceToken)
    }

    func application(_ application: UIApplication,
                didFailToRegisterForRemoteNotificationsWithError
                    error: Error) {
        print("error:", error)
       // Try again later.
    }
}
```

:::note
`didRegisterForRemoteNotificationsWithDeviceToken`返回的deviceToken默认已经变成Data格式，要转成字符串需要扩展Data类型，或者直接处理数据也行。
```swift
// 扩展Data，将Data编码转成正常字符串
extension Data {
    var hexString: String {
        return map { String(format: "%02.2hhx", arguments: [$0]) }.joined()
    }
}
```
:::

5. 应用申请通知权限

```swift
func requestNotificationAuth(){
   let center = UNUserNotificationCenter.current()
   
   center.requestAuthorization(options: [.alert, .badge, .sound]) { success, error in
      if success {
            print("申请权限成功。")
      } else {
            print("D'oh!")
      }
   }
}
```

:::note
如果没有调用`didFinishLaunchingWithOptions`，可能是你没有授权应用，去设置，通知里面检查一下权限状态。
:::