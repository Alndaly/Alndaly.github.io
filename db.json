{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"256917995723ebcd56f38901d319ec1f92e9c72f","modified":1661672339209},{"_id":"source/_posts/Anaconda/环境配置.md","hash":"76e9d09d27af5a7cdb1b9682a730951e9ea9d16c","modified":1661672339189},{"_id":"source/_posts/Anaconda/Pip.md","hash":"d2b4b7aac2c7870803940a91c1dc29d68905be3b","modified":1661672339188},{"_id":"source/_posts/Curl/index.md","hash":"94cec9d1902af1d9ec5b1ea2d656072073d7939a","modified":1661751530342},{"_id":"source/_posts/Git/Git.md","hash":"b988fad7259482ca7d607741b69b2509146fa653","modified":1661672339189},{"_id":"source/_posts/Git/Git大小写默认不敏感.md","hash":"cc5f44b08a36c1fe09bdf6f85458d5b77f33b8c4","modified":1661672339189},{"_id":"source/_posts/Git/forking workflow.md","hash":"20357a40efa6d9dae096e684b4dd409806c433b0","modified":1661672339190},{"_id":"source/_posts/Git/切换Git账号.md","hash":"e9ab1f4537b726cbe8678f2a73db0b131100fe13","modified":1661672339190},{"_id":"source/_posts/NPM/NPM基本操作.md","hash":"a49d118ae9b38ada186093ffa43756e84f332509","modified":1661672339190},{"_id":"source/_posts/Git/gitflow workflow.md","hash":"2c384dbd92ce7ad6d3a665e0e1f2b334327c3bd3","modified":1661672339190},{"_id":"source/_posts/Python绘图/matplotlib.md","hash":"f6aa9e0ce1ce85cbb5a09554da03a9059e7bebb6","modified":1661672339191},{"_id":"source/_posts/Ngrok/index.md","hash":"04fbabbe6d71ed60a7aede72a2f9ce93d663f3de","modified":1661740541864},{"_id":"source/_posts/Vim/README.md","hash":"c526e8f6a29bd4282395728cca176d28fc94414a","modified":1661672339192},{"_id":"source/_posts/Vim/ch00_read_this_first.md","hash":"b8bcab6b0bb01ddc13b31b45bacf0308b3571e4f","modified":1661672339192},{"_id":"source/_posts/Vim/ch01_starting_vim.md","hash":"4258cd7c1f6d211176859a36aebb7bce1a431b2b","modified":1661672339192},{"_id":"source/_posts/Vim/ch02_buffers_windows_tabs.md","hash":"bb268affab7d8a2e27c92cbe919da33f06b5b2d1","modified":1661672339193},{"_id":"source/_posts/Vim/ch04_vim_grammar.md","hash":"142310cbc6e7c7f1fa8498f5f8cd12c908a02299","modified":1661672339193},{"_id":"source/_posts/Vim/ch05_moving_in_file.md","hash":"b9b56cced0f94511499196d196888038d82c6623","modified":1661672339194},{"_id":"source/_posts/Vim/ch06_insert_mode.md","hash":"a1d6a412244fdff6558a8038658aadb0475cea7c","modified":1661672339194},{"_id":"source/_posts/Vim/ch07_the_dot_command.md","hash":"ea48128905d5c186a5a3c55a9f25688621366d7d","modified":1661672339194},{"_id":"source/_posts/Vim/ch03_searching_files.md","hash":"cd6f0d312cb183b22a20b660ba93bab63af09ee6","modified":1661672339193},{"_id":"source/_posts/Vim/ch08_registers.md","hash":"be5efe23e152abdf38f4e30d04360c34ecc0a303","modified":1661672339194},{"_id":"source/_posts/Vim/ch10_undo.md","hash":"d15f984b5c55bf22bb135a5760396a6f6e4ab229","modified":1661672339195},{"_id":"source/_posts/Vim/ch11_visual_mode.md","hash":"e5926c9633867a4d16b7cbf877f21cbf7a2da6d9","modified":1661672339195},{"_id":"source/_posts/Vim/ch09_macros.md","hash":"da383fd25212420cb1f7ba9a5f6367ee2bdb3488","modified":1661672339195},{"_id":"source/_posts/Vim/ch12_search_and_substitute.md","hash":"255f33054e23b25db2b5d7e13caf922301a84fb3","modified":1661672339195},{"_id":"source/_posts/Vim/ch13_the_global_command.md","hash":"1c36b3ccc56a6b067790e85a89a786c78a1c1009","modified":1661672339196},{"_id":"source/_posts/Vim/ch15_command-line_mode.md","hash":"98072bbabcec5d6bce9b95b2543f1c19d1f15746","modified":1661672339196},{"_id":"source/_posts/Vim/ch17_fold.md","hash":"8b3a3776eaaf2cfaaa61a3415971c5f64dd78059","modified":1661672339197},{"_id":"source/_posts/Vim/ch14_external_commands.md","hash":"32ae76e902cf9fa9847603b213be8fc5b2e605a0","modified":1661672339196},{"_id":"source/_posts/Vim/ch16_tags.md","hash":"ad7c8c1a8bf3c1f7bd14fc1fdd6d43b7d0bb6b68","modified":1661672339196},{"_id":"source/_posts/Vim/ch19_compile.md","hash":"7266a0c6414002202482cff6dcb470dc6b48ef87","modified":1661672339197},{"_id":"source/_posts/Vim/ch20_views_sessions_viminfo.md","hash":"8c43488cc379e7a60e883ca70a48f47a00a16bb5","modified":1661672339197},{"_id":"source/_posts/Vim/ch18_git.md","hash":"bb6f014b68ee7ae985dbf55ecde204d6e06e90c9","modified":1661672339197},{"_id":"source/_posts/Vim/ch21_multiple_file_operations.md","hash":"affc036da4d019f37e86c59515f8646893ea20e7","modified":1661672339198},{"_id":"source/_posts/Vim/ch22_vimrc.md","hash":"658209d71e0179e24d554e1e67df83a2731475ec","modified":1661672339198},{"_id":"source/_posts/Vim/ch24_vim_runtime.md","hash":"14e3eceea1e6124b5ff87f71393011d95ee6d4c5","modified":1661672339198},{"_id":"source/_posts/Vim/ch23_vim_packages.md","hash":"1d76b28b063e20b940fb47f204e17ab4a9f397a8","modified":1661672339198},{"_id":"source/_posts/Webpack学习/Day01.md","hash":"445c577a85882e719880bb52029cae711347b566","modified":1661672339205},{"_id":"source/_posts/个人博客/Hexo.md","hash":"81818eceaf9a31c0af9ad9389c05dcdd9b30a624","modified":1661672339206},{"_id":"source/_posts/创业/创业.md","hash":"7e418128b4bae197e8f368c83f8a5290cd1c5864","modified":1661672339206},{"_id":"source/_posts/vue3学习/Day02.md","hash":"a10e2745dcb8b7233ee854c093a73030152b6cc5","modified":1661672339205},{"_id":"source/_posts/vue3学习/Day01.md","hash":"39013483028e99b08c4ec6a4d6a2d3efc2b5cf4f","modified":1661672339205},{"_id":"source/_posts/前端/CSS和SVG中的剪切——clip-path属性和clipPath元素.md","hash":"37e4ab5ca88f644be13e9157c3098bbb679d4d79","modified":1661672339206},{"_id":"source/_posts/旅游/三亚.md","hash":"c32003903d088804120cc82623033680196ac631","modified":1661672339207},{"_id":"source/_posts/后端/Django.md","hash":"6b2cbf0bab82058554714e6d5cfe74ad6809a61e","modified":1661672339206},{"_id":"source/_posts/微信小程序/微信小程序.md","hash":"a35d94709dab44ba894467be1afc6b989fc129f3","modified":1661672339207},{"_id":"source/_posts/数据分析/模型调优 - 删除异常值（箱线图）.md","hash":"d8ff1bf50597a38abbaee0f1232aef41efd81622","modified":1661672339207},{"_id":"source/_posts/服务器/免密登录服务器.md","hash":"166da9a605cfc9e5f8e6fe11150c69a5d6f92d9e","modified":1661672339207},{"_id":"source/_posts/随笔/人人都是自媒体.md","hash":"c2bb03253c9ba5559ae9fb58992095ae2b821ca9","modified":1661672339208},{"_id":"source/_posts/爬虫/mitmproxy.md","hash":"e7699070bde600e6419719733f375e12448ba5d8","modified":1661672339208},{"_id":"source/_posts/面试/面试题.md","hash":"1dc6457d5f8d7151f635c8c49d845431b2b1d2e9","modified":1661672339209},{"_id":"source/_posts/计网/内网穿透.md","hash":"e0ce1d2cd44652822615343c644572801c53f02f","modified":1661672339208},{"_id":"source/_posts/面试/TCP.md","hash":"11f5b0c569445c53e1c55b6ae803d65cd4370d79","modified":1661672339209},{"_id":"source/_posts/Server/Nginx/Nginx.md","hash":"c15553ecb385f94fd64b781b0660f1b1bbf1a7f5","modified":1661672339191},{"_id":"source/_posts/Server/Nginx/Nginx详解.md","hash":"392e968776b6a508ff8c68f5a165dc95148df74a","modified":1661672339191},{"_id":"source/_posts/Server/Django/index.md","hash":"48514858ecc12be7a66e74e02cdc238b41d5472a","modified":1661672339191},{"_id":"source/_posts/Server/Nginx/Nginx转发.md","hash":"ef623001ec1d693b28d3a2204560f1dc3164749f","modified":1661672339192},{"_id":"source/_posts/Vim/images/diffing-apples.png","hash":"aa25727fc0ecf7cb66d81157515596bf7e287715","modified":1661672339199},{"_id":"source/_posts/Vim/images/diffing-basic.png","hash":"81d42503f6dbe1d8865e12f4e71de1dc0c3264fd","modified":1661672339200},{"_id":"source/_posts/Vim/images/session-layout.png","hash":"5d295a7c26d62b773740c5af54aed3aadedf51cb","modified":1661672339205},{"_id":"source/_posts/Vim/images/fugitive-gdiffsplit.png","hash":"2e6728127cf54864ccfbb3f4ec8fada81811887b","modified":1661672339201},{"_id":"source/_posts/Vim/images/fugitive-git-blame.png","hash":"b32051f11a3474431e2d7d654d6ce46ae6b21f18","modified":1661672339202},{"_id":"source/_posts/Vim/images/mergetool-initial.png","hash":"50670492f96642d0e166aa1b11d66d8a2f5439ff","modified":1661672339204},{"_id":"source/_posts/Vim/images/fugitive-git.png","hash":"d40fddb1e35efe9d5ced30e001f746ba61c462a0","modified":1661672339203},{"_id":"source/_posts/Vim/images/fugitive-git-log.png","hash":"5f7f01910a3155cdfb5adac43e281b9e1a02ae15","modified":1661672339203},{"_id":"source/img/favicon.png","hash":"0d63817b3b3c9b898b4c99416c1ef2cf377eb7dd","modified":1661672339211},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"4e3992cacd64c6888218b0346283258e8f82a27d","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1661751572764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1661751572764}],"Category":[{"name":"技术","_id":"cl7ec3i1d0005scvm2l4h9x1n"},{"name":"编辑器","_id":"cl7ec3i1r0010scvmf1jqcy4e"},{"name":"思考","_id":"cl7ec3i2c003gscvmf2v69idi"},{"name":"生活","_id":"cl7ec3i2g0042scvm6kjecxal"},{"name":"随笔","_id":"cl7ec3i2k004kscvm5vfye1lx"}],"Data":[],"Page":[{"title":"关于我","date":"2022-04-04T16:56:43.000Z","layout":"about","_content":"喜欢旅游、摄影、听歌、唱k、运动。\n\n喜欢自己钻研一些有的没的技术。\n\n向着未来，加油！","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-04-05 00:56:43\nlayout: about\n---\n喜欢旅游、摄影、听歌、唱k、运动。\n\n喜欢自己钻研一些有的没的技术。\n\n向着未来，加油！","updated":"2022-08-28T07:38:59.209Z","path":"about/index.html","comments":1,"_id":"cl7ec3i130000scvmh62fgrsb","content":"<p>喜欢旅游、摄影、听歌、唱k、运动。</p>\n<p>喜欢自己钻研一些有的没的技术。</p>\n<p>向着未来，加油！</p>\n","site":{"data":{}},"wordcount":40,"excerpt":"","more":"<p>喜欢旅游、摄影、听歌、唱k、运动。</p>\n<p>喜欢自己钻研一些有的没的技术。</p>\n<p>向着未来，加油！</p>\n"}],"Post":[{"title":"Git基本操作","date":"2022-04-05T09:18:27.000Z","description":"Git相关文档","_content":"\n# Git 安装\n\nGit 可以在 Git 官网下载，目前 Git 支持 Windows 和 Mac， 按默认选项安装即可。(不清楚下载地方的可以关注私信我)\n\n安装教程可参照 廖雪峰老师的安装教程。\n\n# 常用命令\n\n`git config`\n在git中，使用`git config` 命令来配置 git 的配置文件，git配置级别主要有3类：\n1、仓库级别 local 本地 Git 仓库级别配置文件，作用于当前仓库。【优先级最高】\n2、用户级别 global，全局配置文件，作用于所有用户。【优先级次之】\n3、系统级别 system，作用于系统所有用户和所有库。【优先级最低】\n`git config -l` 查看所有的配置信息，依次是系统级别、用户级别、仓库级别\n`git config --local -l` 查看仓库配置\n`git config --global -l` 查看用户配置\n`git config --system -l` 查看系统配置\n`git config` 添加配置文件\n`git config --global user.email “You Email”`\n`git config --global user.name “Your Name”`\n`git config -e `编辑配置文件\n`git config --local -e` 编辑仓库级别配置文件\n`git config --global -e` 编辑用户级别配置文件\n`git config --system -e` 编辑系统级别配置文件\n`git clone`\n`git clone` 复制仓库到新的目录\n`git fetch`\n`git fetch` 创建并更新本地远程分支\n`git fetch origin` 手动指定要 fetch 的 remote,在不指定分支时通常默认为 master；\n`git fetch origin master:temp` 如在本地新建一个temp分支，并将远程 origin 仓库的 master 分支代码下载到本地 temp 分支\n`git diff temp` 比较本地代码与刚刚从远程下载下来的代码的区别\n`git merge temp` 合并代码\n`git branch -d temp` 不想要 tmp 分支，删除分支\n`git pull`\n`git pull` 将更新从远程仓库合并到当前分支。在默认模式下，`git pull` == `git fetch` + `git merge`。\n`git pull` :\n\n如 `git pull origin master`\n\n`git pull `取回远程仓库某个分支的更新，再与本地的指定分支自动合并，可能会出现代码冲突。\n\n`git fetch` 先获取远程仓库某个分支的更新，再执行 merge，相比 pull ，fetch 更可控。\n\n`git add`\n\n`git add -A` 添加所有文件到暂存区\n\n`git add -u` 添加被修改(modified)和被删除(deleted)文件到暂存区，不包括新文件(new)\n\n`git add .` 添加新文件(new)和被修改(modified)文件到暂存区，不包括被删除(deleted)文件\n\n可以通过 `git status` 检查文件是否已添加完毕。\n\n`git commit`\n\n`git commit -m` \"\" 比较常见的用法，-m \"填写更新记录\"\n\n`git commit -a -m` \"\" 提交所有已跟踪的执行修改或删除、新建的文件，即使没有执行 git add 添加到暂存区的文件。\n\n`git commit --amend` 修改上一次提交，可以在不增加新的 commit-id 的情况下将新修改的代码追加到前一次 commit-id 中。如不小心提交了一版没有修改完成的版本上去，\n\n还需要修改完善后再提交，又不想再次增加一个 commit-id 时，可以使用追加提交。\n\n`git commit --help` 查看帮助\n\n`git push`\n\n`git push `将已经 commit 的文件推送到远程仓库的分支\n\n`git push origin master` 推送到 master 分支\n\n`git push --all origin` 推送本地仓库所有分支到远程仓库分支\n\n`git push origin :master` 删除远程分支，等同于 `git push origin --delete master`\n\n`git push -u origin master `将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机。\n\n`git remote`\n\n`git remote -v` 查看远程仓库地址\n\n`git remote set-url origin` 修改远程仓库地址\n\n`git remote rm origin` 删除远程仓库地址\n\n`git remote add origin [url]` 添加远程仓库地址\n\n`git merge`\n\n`git merge` 合并代码\n\n`git merge --no-commit` 防止合并失败不自动提交\n\n`git merge --no-ff` 不使用fast-forward方式合并，创建一个 merge 的 commit 信息。\n\n\n一、版本回退  \n我们用readme文件举例子，修改好内容之后，重新提交  \n`git add readme.txt`  \n`git commit -m \"说明\"`  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-8619843d359e464a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n返回结果\n我们可以多修改几次，来试一下版本回退功能  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-934dca2c8cf7697e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n修改之后的git log,按Q推出\n\n回到上一个版本`git reset --hard HEAD^`  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-660b9a45ac97a052.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n终端截图\n![](https://upload-images.jianshu.io/upload_images/21452414-6a040fe5e32e04e5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\ncat命令查看文件内容\n\n以此类推回到上上个版本就是`git reset --hard HEAD^^`  \n当往上的版本比较多，比如往上50个版本的时候我们用`git reset --hard HEAD~50`\n\n退回以后出现一个奇怪的事情，我们再执行`git log`命令发现看不到第三版了  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-9da314cc6a740f47.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\ngit log结果\n\n这时，我们想要回到第三版需要用以下命令来  \n`git rest hard 63ef`  \n`63ef`是第三次提交时的版本号，我们没必要去写全，git会自动检索，但也不能只写一两位。因为版本号多了会有重复的。  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-9803aaf3afe72e31.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n恢复到第三版\n\n-   问题①:如果我们没有记录被恢复版本的版本号,怎么找回呢?\n\nGit提供了一个命令`git reflog`,通过这个命令我们可以看到每次git的操作记录\n\n-   问题②:如果我们通过git回到第一版,那么`git log`命令还能看到第二版吗?\n\n小结:\n\n-   HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`\n    \n-   穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n    \n-   要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n\n**直接拉取并覆盖本地的所有代码**\n两个电脑同时对git上的项目进行跟新时，不免要用到将git上的代码拉取到本地更新本地代码的操作，鉴于自己对git使用的还不是很熟练，所以就直接采取暴力的方法，直接拉取并覆盖本地的所有代码，命令如下\n\n```sh\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n# Difference between ^ and ~\n## Rules of thumb\n\n-   Use `~` most of the time — to go back a number of generations, usually what you want\n-   Use `^` on merge commits — because they have two or more (immediate) parents\n\nMnemonics:\n\n-   Tilde `~` is almost linear in appearance and wants to go backward in a straight line\n-   Caret `^` suggests an interesting segment of a tree or a fork in the road\n\n## Tilde\n\nThe [“Specifying Revisions” section of the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtltngtemegemmaster3em) defines `~` as\n\n> **`<rev>~<n>`, e.g. `master~3`**  \n> A suffix `~<n>` to a revision parameter means the commit object that is the _n_thgeneration ancestor of the named commit object, following only the first parents. For example, `<rev>~3` is equivalent to `<rev>^^^` which is equivalent to `<rev>^1^1^1` …\n\nYou can get to parents of any commit, not just `HEAD`. You can also move back through generations: for example, `master~2` means the grandparent of the tip of the master branch, favoring the first parent on merge commits.\n\n## Caret\n\nGit history is nonlinear: a directed acyclic graph (DAG) or tree. For a commit with only one parent, `rev~` and `rev^` mean the same thing. The caret selector becomes useful with merge commits because each one is the child of two or more parents — and strains language borrowed from biology.\n\n`HEAD^` means the first _immediate_ parent of the tip of the current branch. `HEAD^` is short for `HEAD^1`, and you can also address `HEAD^2` and so on as appropriate. The [same section of the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtemegemHEADv1510em) defines it as\n\n> **`<rev>^`, _e.g._ `HEAD^`, `v1.5.1^0`**  \n> A suffix `^` to a revision parameter means the first parent of that commit object. `^<n>`means the _n_th parent ([_e.g._] `<rev>^` is equivalent to `<rev>^1`). As a special rule, `<rev>^0` means the commit itself and is used when `<rev>` is the object name of a tag object that refers to a commit object.\n\n## Examples\n\nThese specifiers or selectors can be chained arbitrarily, _e.g._, `topic~3^2` in English is the second parent of the merge commit that is the great-grandparent (three generations back) of the current tip of the branch `topic`.\n\nThe [aforementioned section of the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#_specifying_revisions) traces many paths through a notional git history. Time flows generally downward. Commits D, F, B, and A are merge commits.\n\n> Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right. (N.B. The `git log --graph` command displays history in the opposite order.)\n>\n> ```sh\n> G   H   I   J\n> \\ /     \\ /\n> D   E   F\n> \\  |  / \\\n>  \\ | /   |\n>   \\|/    |\n>    B     C\n>     \\   /\n>      \\ /\n>       A\n> \n> A =      = A^0\n> B = A^   = A^1     = A~1\n> C = A^2\n> D = A^^  = A^1^1   = A~2\n> E = B^2  = A^^2\n> F = B^3  = A^^3\n> G = A^^^ = A^1^1^1 = A~3\n> H = D^2  = B^^2    = A^^^2  = A~2^2\n> I = F^   = B^3^    = A^^3^\n> J = F^2  = B^3^2   = A^^3^2\n> ```\n\nRun the code below to create a git repository whose history matches the quoted illustration.\n\n```perl\n#! /usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse subs qw/ postorder /;\nuse File::Temp qw/ mkdtemp /;\n\nmy %sha1;\nmy %parents = (\n  A => [ qw/ B C /               ],\n  B => [ qw/     D E F /         ],\n  C => [ qw/         F /         ],\n  D => [ qw/           G H /     ],\n  F => [ qw/               I J / ],\n);\n\nsub postorder {\n  my($root,$hash) = @_;\n  my @parents = @{ $parents{$root} || [] };\n  postorder($_, $hash) for @parents;\n  return if $sha1{$root};\n  @parents = map \"-p $sha1{$_}\", @parents;\n  chomp($sha1{$root} = `git commit-tree @parents -m \"$root\" $hash`);\n  die \"$0: git commit-tree failed\" if $?;\n  system(\"git tag -a -m '$sha1{$root}' '$root' '$sha1{$root}'\") == 0 or die \"$0: git tag failed\";\n}\n\n$0 =~ s!^.*/!!;  # / fix Stack Overflow highlighting\nmy $repo = mkdtemp \"repoXXXXXXXX\";\nchdir $repo or die \"$0: chdir: $!\";\nsystem(\"git init\") == 0               or die \"$0: git init failed\";\nchomp(my $tree = `git write-tree`);      die \"$0: git write-tree failed\" if $?;\n\npostorder 'A', $tree;\nsystem \"git update-ref HEAD   $sha1{A}\"; die \"$0: git update-ref failed\" if $?;\nsystem \"git update-ref master $sha1{A}\"; die \"$0: git update-ref failed\" if $?;\n\n# for browsing history - http://blog.kfish.org/2010/04/git-lola.html\nsystem \"git config alias.lol  'log --graph --decorate --pretty=oneline --abbrev-commit'\";\nsystem \"git config alias.lola 'log --graph --decorate --pretty=oneline --abbrev-commit --all'\";\n```\n\nIt adds aliases in the new throwaway repo only for [`git lol` and `git lola`](http://blog.kfish.org/2010/04/git-lola.html) so you can view history as in\n\n```sh\n$ git lol\n*   29392c8 (HEAD -> master, tag: A) A\n|\\\n| * a1ef6fd (tag: C) C\n| |\n|  \\\n*-. \\   8ae20e9 (tag: B) B\n|\\ \\ \\\n| | |/\n| | *   03160db (tag: F) F\n| | |\\\n| | | * 9df28cb (tag: J) J\n| | * 2afd329 (tag: I) I\n| * a77cb1f (tag: E) E\n*   cd75703 (tag: D) D\n|\\\n| * 3043d25 (tag: H) H\n* 4ab0473 (tag: G) G\n```\n\nNote that on your machine the SHA-1 object names will differ from those above, but the tags allow you to address commits by name and check your understanding.\n\n```sh\n$ git log -1 --format=%f $(git rev-parse A^)\nB\n$ git log -1 --format=%f $(git rev-parse A~^3~)\nI\n$ git log -1 --format=%f $(git rev-parse A^2~)\nF\n```\n\nThe [“Specifying Revisions” in the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#_specifying_revisions) is full of great information and is worth an in-depth read. See also [Git Tools - Revision Selection](https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection) from the book [_Pro Git_](https://git-scm.com/book/en/v2/).\n\n## Order of Parent Commits\n\nThe commit [89e4fcb0dd](https://github.com/git/git/commit/89e4fcb0dd01b42e82b8f27f9a575111a26844df) from git’s own history is a merge commit, as `git show 89e4fcb0dd`indicates with the Merge header line that displays the immediate ancestors’ object names.\n\n>  ```sh\n>  commit 89e4fcb0dd01b42e82b8f27f9a575111a26844df\n>  Merge: c670b1f876 649bf3a42f b67d40adbb\n>  Author: Junio C Hamano <gitster@pobox.com>\n>  Date:   Mon Oct 29 10:15:31 2018 +0900\n>  \n>   Merge branches 'bp/reset-quiet' and 'js/mingw-http-ssl' into nd/config-split […]\n>  ```\n\nWe can confirm the ordering by asking `git rev-parse` to show 89e4fcb0dd’s immediate parents in sequence.\n\n```sh\n$ git rev-parse 89e4fcb0dd^1 89e4fcb0dd^2 89e4fcb0dd^3\nc670b1f876521c9f7cd40184bf7ed05aad843433\n649bf3a42f344e71b1b5a7f562576f911a1f7423\nb67d40adbbaf4f5c4898001bf062a9fd67e43368\n```\n\nQuerying the non-existent fourth parent results in an error.\n\n```sh\n$ git rev-parse 89e4fcb0dd^4\n89e4fcb0dd^4\nfatal: ambiguous argument '89e4fcb0dd^4': unknown revision or path not in the working tree.\nUse '--' to separate paths from revisions, like this:\n'git <command> [<revision>...] -- [<file>...]'\n```\n\nIf you want to extract the parents only, use [pretty format](https://git-scm.com/docs/git-log#_pretty_formats) `%P` for the full hashes\n\n```sh\n$ git log -1 --pretty=%P 89e4fcb0dd\nc670b1f876521c9f7cd40184bf7ed05aad843433 649bf3a42f344e71b1b5a7f562576f911a1f7423 b67d40adbbaf4f5c4898001bf062a9fd67e43368\n```\n\nor `%p` for abbreviated parents.\n\n```sh\n$ git log -1 --pretty=%p 89e4fcb0dd\nc670b1f876 649bf3a42f b67d40adbb\n```\n\n# 个性化自定义git命令别名\n文件名：.gitconfig_1\n```note\n[init]\n\tdefaultBranch = main\n[user]\n\tname = Alndaly\n\temail = 1142704468@qq.com\n[filter \"lfs\"]\n\tclean = git-lfs clean -- %f\n\tsmudge = git-lfs smudge -- %f\n\tprocess = git-lfs filter-process\n\trequired = true\n[alias] \n\tlm = log --color --date=format:'%Y-%m-%d %H:%M:%S' --author='Alndaly' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n\tls = log --color --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n```\n文件名：.gitconfig_2\n```note\n[init]\n\tdefaultBranch = main\n[user]\n\tname = Smiling22\n\temail = lucky.always.h@gmail.com\n[filter \"lfs\"]\n\tclean = git-lfs clean -- %f\n\tsmudge = git-lfs smudge -- %f\n\tprocess = git-lfs filter-process\n\trequired = true\n[alias] \n\tlm = log --color --date=format:'%Y-%m-%d %H:%M:%S' --author='Alndaly' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n\tls = log --color --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n```\n\n\n## The default branch has been renamed!（当远程分支改了名字）\n\nmain is now named master\n\nIf you have a local clone, you can update it by running the following commands.\n\n```sh\ngit branch -m main master\ngit fetch origin\ngit branch -u origin/master master\ngit remote set-head origin -a\n```\n\n![GitFlow Workflow](/Users/alnda/Developer/hexo-blog/source/_posts/Git/GitFlow Workflow.md)\n![Forking Workflow](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/20220405171749.md)\n\n# Resetting, Checking Out & Reverting\n\nThe `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)`, `[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)`, and `[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)` commands are some of the most useful tools in your Git toolbox. They all let you undo some kind of change in your repository, and the first two commands can be used to manipulate either commits or individual files.\n\nBecause they’re so similar, it’s very easy to mix up which command should be used in any given development scenario. In this article, we’ll compare the most common configurations of `git reset`, `git checkout`, and `git revert`. Hopefully, you’ll walk away with the confidence to navigate your repository using any of these commands.\n\n![The three trees of Git](https://wac-cdn.atlassian.com/dam/jcr:0c5257d5-ff01-4014-af12-faf2aec53cc3/01.svg?cdnVersion=116)\n\nIt helps to think about each command in terms of their effect on the three state management mechanisms of a Git repository: the working directory, the staged snapshot, and the commit history. These components are sometimes known as \"The three trees\" of Git. We explore the three trees in depth on the `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)` page. Keep these mechanisms in mind as you read through this article.\n\nA checkout is an operation that moves the `HEAD` ref pointer to a specified commit. To demonstrate this consider the following example.\n\n![Move the HEAD ref pointer to a specified commit](https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion=116)\n\nThis example demonstrates a sequence of commits on the `main` branch. The `HEAD` ref and `main` branch ref currently point to commit d. Now let us execute `git checkout b`\n\n![Sequence of commits on the master branch](https://wac-cdn.atlassian.com/dam/jcr:f45c4a34-8968-4c81-83cf-d55ebf01a447/02%20git-checkout-transparent%20kopiera.png?cdnVersion=116)\n\nThis is an update to the \"Commit History\" tree. The `git checkout` command can be used in a commit, or file level scope. A file level checkout will change the file's contents to those of the specific commit.\n\nA revert is an operation that takes a specified commit and creates a new commit which inverses the specified commit. `git revert`can only be run at a commit level scope and has no file level functionality.\n\nA reset is an operation that takes a specified commit and resets the \"three trees\" to match the state of the repository at that specified commit. A reset can be invoked in three different modes which correspond to the three trees.\n\nCheckout and reset are generally used for making local or private 'undos'. They modify the history of a repository that can cause conflicts when pushing to remote shared repositories. Revert is considered a safe operation for 'public undos' as it creates new history which can be shared remotely and doesn't overwrite history remote team members may be dependent on.\n\n## Git Reset vs Revert vs Checkout reference\n\nThe table below sums up the most common use cases for all of these commands. Be sure to keep this reference handy, as you’ll undoubtedly need to use at least some of them during your Git career.\n\nCommand\n\nScope\n\nCommon use cases\n\n`git reset`\n\nCommit-level\n\nDiscard commits in a private branch or throw away uncommited changes\n\n`git reset`\n\nFile-level\n\nUnstage a file\n\n`git checkout`\n\nCommit-level\n\nSwitch between branches or inspect old snapshots\n\n`git checkout`\n\nFile-level\n\nDiscard changes in the working directory\n\n`git revert`\n\nCommit-level\n\nUndo commits in a public branch\n\n`git revert`\n\nFile-level\n\n(N/A)\n\n## Commit Level Operations\n\nThe parameters that you pass to `git reset` and `git checkout`determine their scope. When you don’t include a file path as a parameter, they operate on whole commits. That’s what we’ll be exploring in this section. Note that `git revert` has no file-level counterpart.\n\n### Reset A Specific Commit\n\nOn the commit-level, resetting is a way to move the tip of a branch to a different commit. This can be used to remove commits from the current branch. For example, the following command moves the `hotfix` branch backwards by two commits.\n\n```sh\ngit checkout hotfix git reset HEAD~2\n```\n\nThe two commits that were on the end of `hotfix` are now dangling, or orphaned commits. This means they will be deleted the next time Git performs a garbage collection. In other words, you’re saying that you want to throw away these commits. This can be visualized as the following:\n\n![Resetting the hotfix branch to HEAD-2](https://wac-cdn.atlassian.com/dam/jcr:e8a43261-2460-4783-9731-1197dc8959ab/03-04%20Reset%20a%20specific%20commit.png?cdnVersion=116)\n\nThis usage of `git reset` is a simple way to undo changes that haven’t been shared with anyone else. It’s your go-to command when you’ve started working on a feature and find yourself thinking, “Oh crap, what am I doing? I should just start over.”\n\nIn addition to moving the current branch, you can also get `git reset` to alter the staged snapshot and/or the working directory by passing it one of the following flags:\n\n-   `--soft` – The staged snapshot and working directory are not altered in any way.\n-   `--mixed` – The staged snapshot is updated to match the specified commit, but the working directory is not affected. This is the default option.\n-   `--hard` – The staged snapshot and the working directory are both updated to match the specified commit.  \n    \n\nIt’s easier to think of these modes as defining the scope of a `git reset` operation. For further detailed information visit the `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)` page.\n\n### Checkout old commits\n\nThe `git checkout` command is used to update the state of the repository to a specific point in the projects history. When passed with a branch name, it lets you switch between branches.\n\n `git checkout hotfix`\n\nInternally, all the above command does is move `HEAD` to a different branch and update the working directory to match. Since this has the potential to overwrite local changes, Git forces you to commit or [stash](https://www.atlassian.com/git/tutorials/saving-changes/git-stash) any changes in the working directory that will be lost during the checkout operation. Unlike `git reset`, `git checkout` doesn’t move any branches around.\n\n![Moving HEAD from master to hotfix](https://wac-cdn.atlassian.com/dam/jcr:7dffc21e-29c6-4bfd-acd1-2965fcdd923e/05-06%20Checkout%20old%20commits.png?cdnVersion=116)\n\nYou can also check out arbitrary commits by passing the commit reference instead of a branch. This does the exact same thing as checking out a branch: it moves the `HEAD` reference to the specified commit. For example, the following command will check out the grandparent of the current commit:\n\n `git checkout HEAD~2`\n\n![Moving `HEAD` to an arbitrary commit](https://wac-cdn.atlassian.com/dam/jcr:9b4d9562-7ed1-441c-bbd1-1897bea5676e/07.svg?cdnVersion=116)\n\nThis is useful for quickly inspecting an old version of your project. However, since there is no branch reference to the current `HEAD`, this puts you in a detached `HEAD` state. This can be dangerous if you start adding new commits because there will be no way to get back to them after you switch to another branch. For this reason, you should always create a new branch before adding commits to a detached `HEAD`.\n\n### Undo Public Commits with Revert\n\nReverting undoes a commit by creating a new commit. This is a safe way to undo changes, as it has no chance of re-writing the commit history. For example, the following command will figure out the changes contained in the 2nd to last commit, create a new commit undoing those changes, and tack the new commit onto the existing project.\n\n```sh\ngit checkout hotfix git revert HEAD~2\n```\n\nThis can be visualized as the following:\n\n![Reverting the 2nd to last commit](https://wac-cdn.atlassian.com/dam/jcr:f02c67ca-d7b8-47f8-98f8-e0017dc9f7c5/08-09%20Undo%20public%20commits.svg?cdnVersion=116)\n\nContrast this with `git reset`, which _does_ alter the existing commit history. For this reason, `git revert` should be used to undo changes on a public branch, and `git reset` should be reserved for undoing changes on a private branch.\n\nYou can also think of `git revert` as a tool for undoing _committed_changes, while `git reset HEAD` is for undoing _uncommitted_changes.\n\nLike `git checkout`, `git revert` has the potential to overwrite files in the working directory, so it will ask you to commit or [stash changes](https://www.atlassian.com/git/tutorials/saving-changes/git-stash) that would be lost during the revert operation.\n\n## File-level Operations\n\nThe `git reset` and `git checkout` commands also accept an optional file path as a parameter. This dramatically alters their behavior. Instead of operating on entire snapshots, this forces them to limit their operations to a single file.\n\n### Git Reset A Specific File\n\nWhen invoked with a file path, `git reset` updates the _staged snapshot_ to match the version from the specified commit. For example, this command will fetch the version of `foo.py` in the 2nd-to-last commit and stage it for the next commit:\n\n```sh\ngit reset HEAD~2 foo.py\n```\n\nAs with the commit-level version of `git reset`, this is more commonly used with `HEAD` rather than an arbitrary commit. Running `git reset HEAD foo.py` will unstage `foo.py`. The changes it contains will still be present in the working directory.\n\n![Moving a file from the commit history into the staged snapshot](https://wac-cdn.atlassian.com/dam/jcr:1a010f5a-c90d-49ee-a0e6-31054433e2d4/07.svg?cdnVersion=116)\n\nThe `--soft`, `--mixed`, and `--hard` flags do not have any effect on the file-level version of `git reset`, as the staged snapshot is _always_ updated, and the working directory is _never_ updated.\n\n### Git Checkout File\n\nChecking out a file is similar to using `git reset` with a file path, except it updates the _working directory_ instead of the stage. Unlike the commit-level version of this command, this does not move the `HEAD` reference, which means that you won’t switch branches.\n\n![Moving a file from the commit history into the working directory](https://wac-cdn.atlassian.com/dam/jcr:cc252fc0-fc76-4740-8458-9c0d7af94bca/08.svg?cdnVersion=116)\n\nFor example, the following command makes `foo.py` in the working directory match the one from the 2nd-to-last commit:\n**（要将特定的文件而不是所有文件退回某个版本时）**\n```sh\ngit checkout HEAD~2 foo.py\n```\n\nJust like the commit-level invocation of `git checkout`, this can be used to inspect old versions of a project—but the scope is limited to the specified file.\n\nIf you stage and commit the checked-out file, this has the effect of “reverting” to the old version of that file. Note that this removes _all_ of the subsequent changes to the file, whereas the `git revert` command undoes only the changes introduced by the specified commit.\n\nLike `git reset`, this is commonly used with `HEAD` as the commit reference. For instance, `git checkout HEAD foo.py` has the effect of discarding unstaged changes to `foo.py`. This is similar behavior to `git reset HEAD --hard`, but it operates only on the specified file.\n\n## Summary\n\nYou should now have all the tools you could ever need to undo changes in a Git repository. The `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)`, `[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)`, and `[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)`commands can be confusing, but when you think about their effects on the working directory, staged snapshot, and commit history, it should be easier to discern which command fits the development task at hand.","source":"_posts/Git/Git.md","raw":"---\ntitle: Git基本操作\ndate: 2022-04-05 17:18:27\ntags:\n  - [git]\ncategories:\n  - [技术]\ndescription: Git相关文档\n---\n\n# Git 安装\n\nGit 可以在 Git 官网下载，目前 Git 支持 Windows 和 Mac， 按默认选项安装即可。(不清楚下载地方的可以关注私信我)\n\n安装教程可参照 廖雪峰老师的安装教程。\n\n# 常用命令\n\n`git config`\n在git中，使用`git config` 命令来配置 git 的配置文件，git配置级别主要有3类：\n1、仓库级别 local 本地 Git 仓库级别配置文件，作用于当前仓库。【优先级最高】\n2、用户级别 global，全局配置文件，作用于所有用户。【优先级次之】\n3、系统级别 system，作用于系统所有用户和所有库。【优先级最低】\n`git config -l` 查看所有的配置信息，依次是系统级别、用户级别、仓库级别\n`git config --local -l` 查看仓库配置\n`git config --global -l` 查看用户配置\n`git config --system -l` 查看系统配置\n`git config` 添加配置文件\n`git config --global user.email “You Email”`\n`git config --global user.name “Your Name”`\n`git config -e `编辑配置文件\n`git config --local -e` 编辑仓库级别配置文件\n`git config --global -e` 编辑用户级别配置文件\n`git config --system -e` 编辑系统级别配置文件\n`git clone`\n`git clone` 复制仓库到新的目录\n`git fetch`\n`git fetch` 创建并更新本地远程分支\n`git fetch origin` 手动指定要 fetch 的 remote,在不指定分支时通常默认为 master；\n`git fetch origin master:temp` 如在本地新建一个temp分支，并将远程 origin 仓库的 master 分支代码下载到本地 temp 分支\n`git diff temp` 比较本地代码与刚刚从远程下载下来的代码的区别\n`git merge temp` 合并代码\n`git branch -d temp` 不想要 tmp 分支，删除分支\n`git pull`\n`git pull` 将更新从远程仓库合并到当前分支。在默认模式下，`git pull` == `git fetch` + `git merge`。\n`git pull` :\n\n如 `git pull origin master`\n\n`git pull `取回远程仓库某个分支的更新，再与本地的指定分支自动合并，可能会出现代码冲突。\n\n`git fetch` 先获取远程仓库某个分支的更新，再执行 merge，相比 pull ，fetch 更可控。\n\n`git add`\n\n`git add -A` 添加所有文件到暂存区\n\n`git add -u` 添加被修改(modified)和被删除(deleted)文件到暂存区，不包括新文件(new)\n\n`git add .` 添加新文件(new)和被修改(modified)文件到暂存区，不包括被删除(deleted)文件\n\n可以通过 `git status` 检查文件是否已添加完毕。\n\n`git commit`\n\n`git commit -m` \"\" 比较常见的用法，-m \"填写更新记录\"\n\n`git commit -a -m` \"\" 提交所有已跟踪的执行修改或删除、新建的文件，即使没有执行 git add 添加到暂存区的文件。\n\n`git commit --amend` 修改上一次提交，可以在不增加新的 commit-id 的情况下将新修改的代码追加到前一次 commit-id 中。如不小心提交了一版没有修改完成的版本上去，\n\n还需要修改完善后再提交，又不想再次增加一个 commit-id 时，可以使用追加提交。\n\n`git commit --help` 查看帮助\n\n`git push`\n\n`git push `将已经 commit 的文件推送到远程仓库的分支\n\n`git push origin master` 推送到 master 分支\n\n`git push --all origin` 推送本地仓库所有分支到远程仓库分支\n\n`git push origin :master` 删除远程分支，等同于 `git push origin --delete master`\n\n`git push -u origin master `将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机。\n\n`git remote`\n\n`git remote -v` 查看远程仓库地址\n\n`git remote set-url origin` 修改远程仓库地址\n\n`git remote rm origin` 删除远程仓库地址\n\n`git remote add origin [url]` 添加远程仓库地址\n\n`git merge`\n\n`git merge` 合并代码\n\n`git merge --no-commit` 防止合并失败不自动提交\n\n`git merge --no-ff` 不使用fast-forward方式合并，创建一个 merge 的 commit 信息。\n\n\n一、版本回退  \n我们用readme文件举例子，修改好内容之后，重新提交  \n`git add readme.txt`  \n`git commit -m \"说明\"`  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-8619843d359e464a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n返回结果\n我们可以多修改几次，来试一下版本回退功能  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-934dca2c8cf7697e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n修改之后的git log,按Q推出\n\n回到上一个版本`git reset --hard HEAD^`  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-660b9a45ac97a052.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n终端截图\n![](https://upload-images.jianshu.io/upload_images/21452414-6a040fe5e32e04e5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\ncat命令查看文件内容\n\n以此类推回到上上个版本就是`git reset --hard HEAD^^`  \n当往上的版本比较多，比如往上50个版本的时候我们用`git reset --hard HEAD~50`\n\n退回以后出现一个奇怪的事情，我们再执行`git log`命令发现看不到第三版了  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-9da314cc6a740f47.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\ngit log结果\n\n这时，我们想要回到第三版需要用以下命令来  \n`git rest hard 63ef`  \n`63ef`是第三次提交时的版本号，我们没必要去写全，git会自动检索，但也不能只写一两位。因为版本号多了会有重复的。  \n\n![](https://upload-images.jianshu.io/upload_images/21452414-9803aaf3afe72e31.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)\n\n恢复到第三版\n\n-   问题①:如果我们没有记录被恢复版本的版本号,怎么找回呢?\n\nGit提供了一个命令`git reflog`,通过这个命令我们可以看到每次git的操作记录\n\n-   问题②:如果我们通过git回到第一版,那么`git log`命令还能看到第二版吗?\n\n小结:\n\n-   HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`\n    \n-   穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n    \n-   要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n\n**直接拉取并覆盖本地的所有代码**\n两个电脑同时对git上的项目进行跟新时，不免要用到将git上的代码拉取到本地更新本地代码的操作，鉴于自己对git使用的还不是很熟练，所以就直接采取暴力的方法，直接拉取并覆盖本地的所有代码，命令如下\n\n```sh\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n# Difference between ^ and ~\n## Rules of thumb\n\n-   Use `~` most of the time — to go back a number of generations, usually what you want\n-   Use `^` on merge commits — because they have two or more (immediate) parents\n\nMnemonics:\n\n-   Tilde `~` is almost linear in appearance and wants to go backward in a straight line\n-   Caret `^` suggests an interesting segment of a tree or a fork in the road\n\n## Tilde\n\nThe [“Specifying Revisions” section of the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtltngtemegemmaster3em) defines `~` as\n\n> **`<rev>~<n>`, e.g. `master~3`**  \n> A suffix `~<n>` to a revision parameter means the commit object that is the _n_thgeneration ancestor of the named commit object, following only the first parents. For example, `<rev>~3` is equivalent to `<rev>^^^` which is equivalent to `<rev>^1^1^1` …\n\nYou can get to parents of any commit, not just `HEAD`. You can also move back through generations: for example, `master~2` means the grandparent of the tip of the master branch, favoring the first parent on merge commits.\n\n## Caret\n\nGit history is nonlinear: a directed acyclic graph (DAG) or tree. For a commit with only one parent, `rev~` and `rev^` mean the same thing. The caret selector becomes useful with merge commits because each one is the child of two or more parents — and strains language borrowed from biology.\n\n`HEAD^` means the first _immediate_ parent of the tip of the current branch. `HEAD^` is short for `HEAD^1`, and you can also address `HEAD^2` and so on as appropriate. The [same section of the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtemegemHEADv1510em) defines it as\n\n> **`<rev>^`, _e.g._ `HEAD^`, `v1.5.1^0`**  \n> A suffix `^` to a revision parameter means the first parent of that commit object. `^<n>`means the _n_th parent ([_e.g._] `<rev>^` is equivalent to `<rev>^1`). As a special rule, `<rev>^0` means the commit itself and is used when `<rev>` is the object name of a tag object that refers to a commit object.\n\n## Examples\n\nThese specifiers or selectors can be chained arbitrarily, _e.g._, `topic~3^2` in English is the second parent of the merge commit that is the great-grandparent (three generations back) of the current tip of the branch `topic`.\n\nThe [aforementioned section of the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#_specifying_revisions) traces many paths through a notional git history. Time flows generally downward. Commits D, F, B, and A are merge commits.\n\n> Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right. (N.B. The `git log --graph` command displays history in the opposite order.)\n>\n> ```sh\n> G   H   I   J\n> \\ /     \\ /\n> D   E   F\n> \\  |  / \\\n>  \\ | /   |\n>   \\|/    |\n>    B     C\n>     \\   /\n>      \\ /\n>       A\n> \n> A =      = A^0\n> B = A^   = A^1     = A~1\n> C = A^2\n> D = A^^  = A^1^1   = A~2\n> E = B^2  = A^^2\n> F = B^3  = A^^3\n> G = A^^^ = A^1^1^1 = A~3\n> H = D^2  = B^^2    = A^^^2  = A~2^2\n> I = F^   = B^3^    = A^^3^\n> J = F^2  = B^3^2   = A^^3^2\n> ```\n\nRun the code below to create a git repository whose history matches the quoted illustration.\n\n```perl\n#! /usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse subs qw/ postorder /;\nuse File::Temp qw/ mkdtemp /;\n\nmy %sha1;\nmy %parents = (\n  A => [ qw/ B C /               ],\n  B => [ qw/     D E F /         ],\n  C => [ qw/         F /         ],\n  D => [ qw/           G H /     ],\n  F => [ qw/               I J / ],\n);\n\nsub postorder {\n  my($root,$hash) = @_;\n  my @parents = @{ $parents{$root} || [] };\n  postorder($_, $hash) for @parents;\n  return if $sha1{$root};\n  @parents = map \"-p $sha1{$_}\", @parents;\n  chomp($sha1{$root} = `git commit-tree @parents -m \"$root\" $hash`);\n  die \"$0: git commit-tree failed\" if $?;\n  system(\"git tag -a -m '$sha1{$root}' '$root' '$sha1{$root}'\") == 0 or die \"$0: git tag failed\";\n}\n\n$0 =~ s!^.*/!!;  # / fix Stack Overflow highlighting\nmy $repo = mkdtemp \"repoXXXXXXXX\";\nchdir $repo or die \"$0: chdir: $!\";\nsystem(\"git init\") == 0               or die \"$0: git init failed\";\nchomp(my $tree = `git write-tree`);      die \"$0: git write-tree failed\" if $?;\n\npostorder 'A', $tree;\nsystem \"git update-ref HEAD   $sha1{A}\"; die \"$0: git update-ref failed\" if $?;\nsystem \"git update-ref master $sha1{A}\"; die \"$0: git update-ref failed\" if $?;\n\n# for browsing history - http://blog.kfish.org/2010/04/git-lola.html\nsystem \"git config alias.lol  'log --graph --decorate --pretty=oneline --abbrev-commit'\";\nsystem \"git config alias.lola 'log --graph --decorate --pretty=oneline --abbrev-commit --all'\";\n```\n\nIt adds aliases in the new throwaway repo only for [`git lol` and `git lola`](http://blog.kfish.org/2010/04/git-lola.html) so you can view history as in\n\n```sh\n$ git lol\n*   29392c8 (HEAD -> master, tag: A) A\n|\\\n| * a1ef6fd (tag: C) C\n| |\n|  \\\n*-. \\   8ae20e9 (tag: B) B\n|\\ \\ \\\n| | |/\n| | *   03160db (tag: F) F\n| | |\\\n| | | * 9df28cb (tag: J) J\n| | * 2afd329 (tag: I) I\n| * a77cb1f (tag: E) E\n*   cd75703 (tag: D) D\n|\\\n| * 3043d25 (tag: H) H\n* 4ab0473 (tag: G) G\n```\n\nNote that on your machine the SHA-1 object names will differ from those above, but the tags allow you to address commits by name and check your understanding.\n\n```sh\n$ git log -1 --format=%f $(git rev-parse A^)\nB\n$ git log -1 --format=%f $(git rev-parse A~^3~)\nI\n$ git log -1 --format=%f $(git rev-parse A^2~)\nF\n```\n\nThe [“Specifying Revisions” in the `git rev-parse` documentation](https://git-scm.com/docs/git-rev-parse#_specifying_revisions) is full of great information and is worth an in-depth read. See also [Git Tools - Revision Selection](https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection) from the book [_Pro Git_](https://git-scm.com/book/en/v2/).\n\n## Order of Parent Commits\n\nThe commit [89e4fcb0dd](https://github.com/git/git/commit/89e4fcb0dd01b42e82b8f27f9a575111a26844df) from git’s own history is a merge commit, as `git show 89e4fcb0dd`indicates with the Merge header line that displays the immediate ancestors’ object names.\n\n>  ```sh\n>  commit 89e4fcb0dd01b42e82b8f27f9a575111a26844df\n>  Merge: c670b1f876 649bf3a42f b67d40adbb\n>  Author: Junio C Hamano <gitster@pobox.com>\n>  Date:   Mon Oct 29 10:15:31 2018 +0900\n>  \n>   Merge branches 'bp/reset-quiet' and 'js/mingw-http-ssl' into nd/config-split […]\n>  ```\n\nWe can confirm the ordering by asking `git rev-parse` to show 89e4fcb0dd’s immediate parents in sequence.\n\n```sh\n$ git rev-parse 89e4fcb0dd^1 89e4fcb0dd^2 89e4fcb0dd^3\nc670b1f876521c9f7cd40184bf7ed05aad843433\n649bf3a42f344e71b1b5a7f562576f911a1f7423\nb67d40adbbaf4f5c4898001bf062a9fd67e43368\n```\n\nQuerying the non-existent fourth parent results in an error.\n\n```sh\n$ git rev-parse 89e4fcb0dd^4\n89e4fcb0dd^4\nfatal: ambiguous argument '89e4fcb0dd^4': unknown revision or path not in the working tree.\nUse '--' to separate paths from revisions, like this:\n'git <command> [<revision>...] -- [<file>...]'\n```\n\nIf you want to extract the parents only, use [pretty format](https://git-scm.com/docs/git-log#_pretty_formats) `%P` for the full hashes\n\n```sh\n$ git log -1 --pretty=%P 89e4fcb0dd\nc670b1f876521c9f7cd40184bf7ed05aad843433 649bf3a42f344e71b1b5a7f562576f911a1f7423 b67d40adbbaf4f5c4898001bf062a9fd67e43368\n```\n\nor `%p` for abbreviated parents.\n\n```sh\n$ git log -1 --pretty=%p 89e4fcb0dd\nc670b1f876 649bf3a42f b67d40adbb\n```\n\n# 个性化自定义git命令别名\n文件名：.gitconfig_1\n```note\n[init]\n\tdefaultBranch = main\n[user]\n\tname = Alndaly\n\temail = 1142704468@qq.com\n[filter \"lfs\"]\n\tclean = git-lfs clean -- %f\n\tsmudge = git-lfs smudge -- %f\n\tprocess = git-lfs filter-process\n\trequired = true\n[alias] \n\tlm = log --color --date=format:'%Y-%m-%d %H:%M:%S' --author='Alndaly' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n\tls = log --color --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n```\n文件名：.gitconfig_2\n```note\n[init]\n\tdefaultBranch = main\n[user]\n\tname = Smiling22\n\temail = lucky.always.h@gmail.com\n[filter \"lfs\"]\n\tclean = git-lfs clean -- %f\n\tsmudge = git-lfs smudge -- %f\n\tprocess = git-lfs filter-process\n\trequired = true\n[alias] \n\tlm = log --color --date=format:'%Y-%m-%d %H:%M:%S' --author='Alndaly' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n\tls = log --color --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)<%an>%Creset' --abbrev-commit --graph\n```\n\n\n## The default branch has been renamed!（当远程分支改了名字）\n\nmain is now named master\n\nIf you have a local clone, you can update it by running the following commands.\n\n```sh\ngit branch -m main master\ngit fetch origin\ngit branch -u origin/master master\ngit remote set-head origin -a\n```\n\n![GitFlow Workflow](/Users/alnda/Developer/hexo-blog/source/_posts/Git/GitFlow Workflow.md)\n![Forking Workflow](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/20220405171749.md)\n\n# Resetting, Checking Out & Reverting\n\nThe `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)`, `[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)`, and `[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)` commands are some of the most useful tools in your Git toolbox. They all let you undo some kind of change in your repository, and the first two commands can be used to manipulate either commits or individual files.\n\nBecause they’re so similar, it’s very easy to mix up which command should be used in any given development scenario. In this article, we’ll compare the most common configurations of `git reset`, `git checkout`, and `git revert`. Hopefully, you’ll walk away with the confidence to navigate your repository using any of these commands.\n\n![The three trees of Git](https://wac-cdn.atlassian.com/dam/jcr:0c5257d5-ff01-4014-af12-faf2aec53cc3/01.svg?cdnVersion=116)\n\nIt helps to think about each command in terms of their effect on the three state management mechanisms of a Git repository: the working directory, the staged snapshot, and the commit history. These components are sometimes known as \"The three trees\" of Git. We explore the three trees in depth on the `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)` page. Keep these mechanisms in mind as you read through this article.\n\nA checkout is an operation that moves the `HEAD` ref pointer to a specified commit. To demonstrate this consider the following example.\n\n![Move the HEAD ref pointer to a specified commit](https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion=116)\n\nThis example demonstrates a sequence of commits on the `main` branch. The `HEAD` ref and `main` branch ref currently point to commit d. Now let us execute `git checkout b`\n\n![Sequence of commits on the master branch](https://wac-cdn.atlassian.com/dam/jcr:f45c4a34-8968-4c81-83cf-d55ebf01a447/02%20git-checkout-transparent%20kopiera.png?cdnVersion=116)\n\nThis is an update to the \"Commit History\" tree. The `git checkout` command can be used in a commit, or file level scope. A file level checkout will change the file's contents to those of the specific commit.\n\nA revert is an operation that takes a specified commit and creates a new commit which inverses the specified commit. `git revert`can only be run at a commit level scope and has no file level functionality.\n\nA reset is an operation that takes a specified commit and resets the \"three trees\" to match the state of the repository at that specified commit. A reset can be invoked in three different modes which correspond to the three trees.\n\nCheckout and reset are generally used for making local or private 'undos'. They modify the history of a repository that can cause conflicts when pushing to remote shared repositories. Revert is considered a safe operation for 'public undos' as it creates new history which can be shared remotely and doesn't overwrite history remote team members may be dependent on.\n\n## Git Reset vs Revert vs Checkout reference\n\nThe table below sums up the most common use cases for all of these commands. Be sure to keep this reference handy, as you’ll undoubtedly need to use at least some of them during your Git career.\n\nCommand\n\nScope\n\nCommon use cases\n\n`git reset`\n\nCommit-level\n\nDiscard commits in a private branch or throw away uncommited changes\n\n`git reset`\n\nFile-level\n\nUnstage a file\n\n`git checkout`\n\nCommit-level\n\nSwitch between branches or inspect old snapshots\n\n`git checkout`\n\nFile-level\n\nDiscard changes in the working directory\n\n`git revert`\n\nCommit-level\n\nUndo commits in a public branch\n\n`git revert`\n\nFile-level\n\n(N/A)\n\n## Commit Level Operations\n\nThe parameters that you pass to `git reset` and `git checkout`determine their scope. When you don’t include a file path as a parameter, they operate on whole commits. That’s what we’ll be exploring in this section. Note that `git revert` has no file-level counterpart.\n\n### Reset A Specific Commit\n\nOn the commit-level, resetting is a way to move the tip of a branch to a different commit. This can be used to remove commits from the current branch. For example, the following command moves the `hotfix` branch backwards by two commits.\n\n```sh\ngit checkout hotfix git reset HEAD~2\n```\n\nThe two commits that were on the end of `hotfix` are now dangling, or orphaned commits. This means they will be deleted the next time Git performs a garbage collection. In other words, you’re saying that you want to throw away these commits. This can be visualized as the following:\n\n![Resetting the hotfix branch to HEAD-2](https://wac-cdn.atlassian.com/dam/jcr:e8a43261-2460-4783-9731-1197dc8959ab/03-04%20Reset%20a%20specific%20commit.png?cdnVersion=116)\n\nThis usage of `git reset` is a simple way to undo changes that haven’t been shared with anyone else. It’s your go-to command when you’ve started working on a feature and find yourself thinking, “Oh crap, what am I doing? I should just start over.”\n\nIn addition to moving the current branch, you can also get `git reset` to alter the staged snapshot and/or the working directory by passing it one of the following flags:\n\n-   `--soft` – The staged snapshot and working directory are not altered in any way.\n-   `--mixed` – The staged snapshot is updated to match the specified commit, but the working directory is not affected. This is the default option.\n-   `--hard` – The staged snapshot and the working directory are both updated to match the specified commit.  \n    \n\nIt’s easier to think of these modes as defining the scope of a `git reset` operation. For further detailed information visit the `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)` page.\n\n### Checkout old commits\n\nThe `git checkout` command is used to update the state of the repository to a specific point in the projects history. When passed with a branch name, it lets you switch between branches.\n\n `git checkout hotfix`\n\nInternally, all the above command does is move `HEAD` to a different branch and update the working directory to match. Since this has the potential to overwrite local changes, Git forces you to commit or [stash](https://www.atlassian.com/git/tutorials/saving-changes/git-stash) any changes in the working directory that will be lost during the checkout operation. Unlike `git reset`, `git checkout` doesn’t move any branches around.\n\n![Moving HEAD from master to hotfix](https://wac-cdn.atlassian.com/dam/jcr:7dffc21e-29c6-4bfd-acd1-2965fcdd923e/05-06%20Checkout%20old%20commits.png?cdnVersion=116)\n\nYou can also check out arbitrary commits by passing the commit reference instead of a branch. This does the exact same thing as checking out a branch: it moves the `HEAD` reference to the specified commit. For example, the following command will check out the grandparent of the current commit:\n\n `git checkout HEAD~2`\n\n![Moving `HEAD` to an arbitrary commit](https://wac-cdn.atlassian.com/dam/jcr:9b4d9562-7ed1-441c-bbd1-1897bea5676e/07.svg?cdnVersion=116)\n\nThis is useful for quickly inspecting an old version of your project. However, since there is no branch reference to the current `HEAD`, this puts you in a detached `HEAD` state. This can be dangerous if you start adding new commits because there will be no way to get back to them after you switch to another branch. For this reason, you should always create a new branch before adding commits to a detached `HEAD`.\n\n### Undo Public Commits with Revert\n\nReverting undoes a commit by creating a new commit. This is a safe way to undo changes, as it has no chance of re-writing the commit history. For example, the following command will figure out the changes contained in the 2nd to last commit, create a new commit undoing those changes, and tack the new commit onto the existing project.\n\n```sh\ngit checkout hotfix git revert HEAD~2\n```\n\nThis can be visualized as the following:\n\n![Reverting the 2nd to last commit](https://wac-cdn.atlassian.com/dam/jcr:f02c67ca-d7b8-47f8-98f8-e0017dc9f7c5/08-09%20Undo%20public%20commits.svg?cdnVersion=116)\n\nContrast this with `git reset`, which _does_ alter the existing commit history. For this reason, `git revert` should be used to undo changes on a public branch, and `git reset` should be reserved for undoing changes on a private branch.\n\nYou can also think of `git revert` as a tool for undoing _committed_changes, while `git reset HEAD` is for undoing _uncommitted_changes.\n\nLike `git checkout`, `git revert` has the potential to overwrite files in the working directory, so it will ask you to commit or [stash changes](https://www.atlassian.com/git/tutorials/saving-changes/git-stash) that would be lost during the revert operation.\n\n## File-level Operations\n\nThe `git reset` and `git checkout` commands also accept an optional file path as a parameter. This dramatically alters their behavior. Instead of operating on entire snapshots, this forces them to limit their operations to a single file.\n\n### Git Reset A Specific File\n\nWhen invoked with a file path, `git reset` updates the _staged snapshot_ to match the version from the specified commit. For example, this command will fetch the version of `foo.py` in the 2nd-to-last commit and stage it for the next commit:\n\n```sh\ngit reset HEAD~2 foo.py\n```\n\nAs with the commit-level version of `git reset`, this is more commonly used with `HEAD` rather than an arbitrary commit. Running `git reset HEAD foo.py` will unstage `foo.py`. The changes it contains will still be present in the working directory.\n\n![Moving a file from the commit history into the staged snapshot](https://wac-cdn.atlassian.com/dam/jcr:1a010f5a-c90d-49ee-a0e6-31054433e2d4/07.svg?cdnVersion=116)\n\nThe `--soft`, `--mixed`, and `--hard` flags do not have any effect on the file-level version of `git reset`, as the staged snapshot is _always_ updated, and the working directory is _never_ updated.\n\n### Git Checkout File\n\nChecking out a file is similar to using `git reset` with a file path, except it updates the _working directory_ instead of the stage. Unlike the commit-level version of this command, this does not move the `HEAD` reference, which means that you won’t switch branches.\n\n![Moving a file from the commit history into the working directory](https://wac-cdn.atlassian.com/dam/jcr:cc252fc0-fc76-4740-8458-9c0d7af94bca/08.svg?cdnVersion=116)\n\nFor example, the following command makes `foo.py` in the working directory match the one from the 2nd-to-last commit:\n**（要将特定的文件而不是所有文件退回某个版本时）**\n```sh\ngit checkout HEAD~2 foo.py\n```\n\nJust like the commit-level invocation of `git checkout`, this can be used to inspect old versions of a project—but the scope is limited to the specified file.\n\nIf you stage and commit the checked-out file, this has the effect of “reverting” to the old version of that file. Note that this removes _all_ of the subsequent changes to the file, whereas the `git revert` command undoes only the changes introduced by the specified commit.\n\nLike `git reset`, this is commonly used with `HEAD` as the commit reference. For instance, `git checkout HEAD foo.py` has the effect of discarding unstaged changes to `foo.py`. This is similar behavior to `git reset HEAD --hard`, but it operates only on the specified file.\n\n## Summary\n\nYou should now have all the tools you could ever need to undo changes in a Git repository. The `[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)`, `[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)`, and `[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)`commands can be confusing, but when you think about their effects on the working directory, staged snapshot, and commit history, it should be easier to discern which command fits the development task at hand.","slug":"Git/Git","published":1,"updated":"2022-08-28T07:38:59.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i160001scvm4yezei93","content":"<h1 id=\"Git-安装\"><a href=\"#Git-安装\" class=\"headerlink\" title=\"Git 安装\"></a>Git 安装</h1><p>Git 可以在 Git 官网下载，目前 Git 支持 Windows 和 Mac， 按默认选项安装即可。(不清楚下载地方的可以关注私信我)</p>\n<p>安装教程可参照 廖雪峰老师的安装教程。</p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p><code>git config</code><br>在git中，使用<code>git config</code> 命令来配置 git 的配置文件，git配置级别主要有3类：<br>1、仓库级别 local 本地 Git 仓库级别配置文件，作用于当前仓库。【优先级最高】<br>2、用户级别 global，全局配置文件，作用于所有用户。【优先级次之】<br>3、系统级别 system，作用于系统所有用户和所有库。【优先级最低】<br><code>git config -l</code> 查看所有的配置信息，依次是系统级别、用户级别、仓库级别<br><code>git config --local -l</code> 查看仓库配置<br><code>git config --global -l</code> 查看用户配置<br><code>git config --system -l</code> 查看系统配置<br><code>git config</code> 添加配置文件<br><code>git config --global user.email “You Email”</code><br><code>git config --global user.name “Your Name”</code><br><code>git config -e </code>编辑配置文件<br><code>git config --local -e</code> 编辑仓库级别配置文件<br><code>git config --global -e</code> 编辑用户级别配置文件<br><code>git config --system -e</code> 编辑系统级别配置文件<br><code>git clone</code><br><code>git clone</code> 复制仓库到新的目录<br><code>git fetch</code><br><code>git fetch</code> 创建并更新本地远程分支<br><code>git fetch origin</code> 手动指定要 fetch 的 remote,在不指定分支时通常默认为 master；<br><code>git fetch origin master:temp</code> 如在本地新建一个temp分支，并将远程 origin 仓库的 master 分支代码下载到本地 temp 分支<br><code>git diff temp</code> 比较本地代码与刚刚从远程下载下来的代码的区别<br><code>git merge temp</code> 合并代码<br><code>git branch -d temp</code> 不想要 tmp 分支，删除分支<br><code>git pull</code><br><code>git pull</code> 将更新从远程仓库合并到当前分支。在默认模式下，<code>git pull</code> &#x3D;&#x3D; <code>git fetch</code> + <code>git merge</code>。<br><code>git pull</code> :</p>\n<p>如 <code>git pull origin master</code></p>\n<p><code>git pull </code>取回远程仓库某个分支的更新，再与本地的指定分支自动合并，可能会出现代码冲突。</p>\n<p><code>git fetch</code> 先获取远程仓库某个分支的更新，再执行 merge，相比 pull ，fetch 更可控。</p>\n<p><code>git add</code></p>\n<p><code>git add -A</code> 添加所有文件到暂存区</p>\n<p><code>git add -u</code> 添加被修改(modified)和被删除(deleted)文件到暂存区，不包括新文件(new)</p>\n<p><code>git add .</code> 添加新文件(new)和被修改(modified)文件到暂存区，不包括被删除(deleted)文件</p>\n<p>可以通过 <code>git status</code> 检查文件是否已添加完毕。</p>\n<p><code>git commit</code></p>\n<p><code>git commit -m</code> “” 比较常见的用法，-m “填写更新记录”</p>\n<p><code>git commit -a -m</code> “” 提交所有已跟踪的执行修改或删除、新建的文件，即使没有执行 git add 添加到暂存区的文件。</p>\n<p><code>git commit --amend</code> 修改上一次提交，可以在不增加新的 commit-id 的情况下将新修改的代码追加到前一次 commit-id 中。如不小心提交了一版没有修改完成的版本上去，</p>\n<p>还需要修改完善后再提交，又不想再次增加一个 commit-id 时，可以使用追加提交。</p>\n<p><code>git commit --help</code> 查看帮助</p>\n<p><code>git push</code></p>\n<p><code>git push </code>将已经 commit 的文件推送到远程仓库的分支</p>\n<p><code>git push origin master</code> 推送到 master 分支</p>\n<p><code>git push --all origin</code> 推送本地仓库所有分支到远程仓库分支</p>\n<p><code>git push origin :master</code> 删除远程分支，等同于 <code>git push origin --delete master</code></p>\n<p><code>git push -u origin master </code>将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机。</p>\n<p><code>git remote</code></p>\n<p><code>git remote -v</code> 查看远程仓库地址</p>\n<p><code>git remote set-url origin</code> 修改远程仓库地址</p>\n<p><code>git remote rm origin</code> 删除远程仓库地址</p>\n<p><code>git remote add origin [url]</code> 添加远程仓库地址</p>\n<p><code>git merge</code></p>\n<p><code>git merge</code> 合并代码</p>\n<p><code>git merge --no-commit</code> 防止合并失败不自动提交</p>\n<p><code>git merge --no-ff</code> 不使用fast-forward方式合并，创建一个 merge 的 commit 信息。</p>\n<p>一、版本回退<br>我们用readme文件举例子，修改好内容之后，重新提交<br><code>git add readme.txt</code><br><code>git commit -m &quot;说明&quot;</code>  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-8619843d359e464a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>返回结果<br>我们可以多修改几次，来试一下版本回退功能  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-934dca2c8cf7697e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>修改之后的git log,按Q推出</p>\n<p>回到上一个版本<code>git reset --hard HEAD^</code>  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-660b9a45ac97a052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"><br>终端截图<br><img src=\"https://upload-images.jianshu.io/upload_images/21452414-6a040fe5e32e04e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>cat命令查看文件内容</p>\n<p>以此类推回到上上个版本就是<code>git reset --hard HEAD^^</code><br>当往上的版本比较多，比如往上50个版本的时候我们用<code>git reset --hard HEAD~50</code></p>\n<p>退回以后出现一个奇怪的事情，我们再执行<code>git log</code>命令发现看不到第三版了  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-9da314cc6a740f47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>git log结果</p>\n<p>这时，我们想要回到第三版需要用以下命令来<br><code>git rest hard 63ef</code><br><code>63ef</code>是第三次提交时的版本号，我们没必要去写全，git会自动检索，但也不能只写一两位。因为版本号多了会有重复的。  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-9803aaf3afe72e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>恢复到第三版</p>\n<ul>\n<li>问题①:如果我们没有记录被恢复版本的版本号,怎么找回呢?</li>\n</ul>\n<p>Git提供了一个命令<code>git reflog</code>,通过这个命令我们可以看到每次git的操作记录</p>\n<ul>\n<li>问题②:如果我们通过git回到第一版,那么<code>git log</code>命令还能看到第二版吗?</li>\n</ul>\n<p>小结:</p>\n<ul>\n<li><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code></p>\n</li>\n<li><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>\n</li>\n<li><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>\n</li>\n</ul>\n<p><strong>直接拉取并覆盖本地的所有代码</strong><br>两个电脑同时对git上的项目进行跟新时，不免要用到将git上的代码拉取到本地更新本地代码的操作，鉴于自己对git使用的还不是很熟练，所以就直接采取暴力的方法，直接拉取并覆盖本地的所有代码，命令如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs sh\">git fetch --all<br>git reset --hard origin/master<br>git pull<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Difference-between-and\"><a href=\"#Difference-between-and\" class=\"headerlink\" title=\"Difference between ^ and ~\"></a>Difference between ^ and ~</h1><h2 id=\"Rules-of-thumb\"><a href=\"#Rules-of-thumb\" class=\"headerlink\" title=\"Rules of thumb\"></a>Rules of thumb</h2><ul>\n<li>Use <code>~</code> most of the time — to go back a number of generations, usually what you want</li>\n<li>Use <code>^</code> on merge commits — because they have two or more (immediate) parents</li>\n</ul>\n<p>Mnemonics:</p>\n<ul>\n<li>Tilde <code>~</code> is almost linear in appearance and wants to go backward in a straight line</li>\n<li>Caret <code>^</code> suggests an interesting segment of a tree or a fork in the road</li>\n</ul>\n<h2 id=\"Tilde\"><a href=\"#Tilde\" class=\"headerlink\" title=\"Tilde\"></a>Tilde</h2><p>The <a href=\"https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtltngtemegemmaster3em\">“Specifying Revisions” section of the <code>git rev-parse</code> documentation</a> defines <code>~</code> as</p>\n<blockquote>\n<p><strong><code>&lt;rev&gt;~&lt;n&gt;</code>, e.g. <code>master~3</code></strong><br>A suffix <code>~&lt;n&gt;</code> to a revision parameter means the commit object that is the _n_thgeneration ancestor of the named commit object, following only the first parents. For example, <code>&lt;rev&gt;~3</code> is equivalent to <code>&lt;rev&gt;^^^</code> which is equivalent to <code>&lt;rev&gt;^1^1^1</code> …</p>\n</blockquote>\n<p>You can get to parents of any commit, not just <code>HEAD</code>. You can also move back through generations: for example, <code>master~2</code> means the grandparent of the tip of the master branch, favoring the first parent on merge commits.</p>\n<h2 id=\"Caret\"><a href=\"#Caret\" class=\"headerlink\" title=\"Caret\"></a>Caret</h2><p>Git history is nonlinear: a directed acyclic graph (DAG) or tree. For a commit with only one parent, <code>rev~</code> and <code>rev^</code> mean the same thing. The caret selector becomes useful with merge commits because each one is the child of two or more parents — and strains language borrowed from biology.</p>\n<p><code>HEAD^</code> means the first <em>immediate</em> parent of the tip of the current branch. <code>HEAD^</code> is short for <code>HEAD^1</code>, and you can also address <code>HEAD^2</code> and so on as appropriate. The <a href=\"https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtemegemHEADv1510em\">same section of the <code>git rev-parse</code> documentation</a> defines it as</p>\n<blockquote>\n<p><strong><code>&lt;rev&gt;^</code>, <em>e.g.</em> <code>HEAD^</code>, <code>v1.5.1^0</code></strong><br>A suffix <code>^</code> to a revision parameter means the first parent of that commit object. <code>^&lt;n&gt;</code>means the _n_th parent ([<em>e.g.</em>] <code>&lt;rev&gt;^</code> is equivalent to <code>&lt;rev&gt;^1</code>). As a special rule, <code>&lt;rev&gt;^0</code> means the commit itself and is used when <code>&lt;rev&gt;</code> is the object name of a tag object that refers to a commit object.</p>\n</blockquote>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><p>These specifiers or selectors can be chained arbitrarily, <em>e.g.</em>, <code>topic~3^2</code> in English is the second parent of the merge commit that is the great-grandparent (three generations back) of the current tip of the branch <code>topic</code>.</p>\n<p>The <a href=\"https://git-scm.com/docs/git-rev-parse#_specifying_revisions\">aforementioned section of the <code>git rev-parse</code> documentation</a> traces many paths through a notional git history. Time flows generally downward. Commits D, F, B, and A are merge commits.</p>\n<blockquote>\n<p>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right. (N.B. The <code>git log --graph</code> command displays history in the opposite order.)</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">G   H   I   J<br>\\ /     \\ /<br>D   E   F<br>\\  |  / \\<br> \\ | /   |<br>  \\|/    |<br>   B     C<br>    \\   /<br>     \\ /<br>      A<br><br>A =      = A^0<br>B = A^   = A^1     = A~1<br>C = A^2<br>D = A^^  = A^1^1   = A~2<br>E = B^2  = A^^2<br>F = B^3  = A^^3<br>G = A^^^ = A^1^1^1 = A~3<br>H = D^2  = B^^2    = A^^^2  = A~2^2<br>I = F^   = B^3^    = A^^3^<br>J = F^2  = B^3^2   = A^^3^2<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>Run the code below to create a git repository whose history matches the quoted illustration.</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\"><span class=\"hljs-comment\">#! /usr/bin/env perl</span><br><br><span class=\"hljs-keyword\">use</span> strict;<br><span class=\"hljs-keyword\">use</span> warnings;<br><span class=\"hljs-keyword\">use</span> subs <span class=\"hljs-keyword\">qw</span>/ postorder /;<br><span class=\"hljs-keyword\">use</span> File::Temp <span class=\"hljs-keyword\">qw</span>/ mkdtemp /;<br><br><span class=\"hljs-keyword\">my</span> %sha1;<br><span class=\"hljs-keyword\">my</span> %parents = (<br>  <span class=\"hljs-string\">A =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/ B C /               ],<br>  <span class=\"hljs-string\">B =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/     D E F /         ],<br>  <span class=\"hljs-string\">C =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/         F /         ],<br>  <span class=\"hljs-string\">D =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/           G H /     ],<br>  <span class=\"hljs-string\">F =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/               I J / ],<br>);<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">sub</span> <span class=\"hljs-title\">postorder</span> </span>&#123;<br>  <span class=\"hljs-keyword\">my</span>($root,$hash) = @_;<br>  <span class=\"hljs-keyword\">my</span> @parents = @&#123; $parents&#123;$root&#125; || [] &#125;;<br>  postorder($_, $hash) <span class=\"hljs-keyword\">for</span> @parents;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">if</span> $sha1&#123;$root&#125;;<br>  @parents = <span class=\"hljs-keyword\">map</span> <span class=\"hljs-string\">&quot;-p $sha1&#123;$_&#125;&quot;</span>, @parents;<br>  <span class=\"hljs-keyword\">chomp</span>($sha1&#123;$root&#125; = <span class=\"hljs-string\">`git commit-tree @parents -m &quot;$root&quot; $hash`</span>);<br>  <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git commit-tree failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br>  <span class=\"hljs-keyword\">system</span>(<span class=\"hljs-string\">&quot;git tag -a -m &#x27;$sha1&#123;$root&#125;&#x27; &#x27;$root&#x27; &#x27;$sha1&#123;$root&#125;&#x27;&quot;</span>) == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git tag failed&quot;</span>;<br>&#125;<br><br>$0 =~ s!^.*<span class=\"hljs-regexp\">/!!;  # /</span> fix Stack Overflow highlighting<br><span class=\"hljs-keyword\">my</span> $repo = mkdtemp <span class=\"hljs-string\">&quot;repoXXXXXXXX&quot;</span>;<br><span class=\"hljs-keyword\">chdir</span> $repo <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: chdir: $!&quot;</span>;<br><span class=\"hljs-keyword\">system</span>(<span class=\"hljs-string\">&quot;git init&quot;</span>) == <span class=\"hljs-number\">0</span>               <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git init failed&quot;</span>;<br><span class=\"hljs-keyword\">chomp</span>(<span class=\"hljs-keyword\">my</span> $tree = <span class=\"hljs-string\">`git write-tree`</span>);      <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git write-tree failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br><br>postorder <span class=\"hljs-string\">&#x27;A&#x27;</span>, $tree;<br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git update-ref HEAD   $sha1&#123;A&#125;&quot;</span>; <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git update-ref failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git update-ref master $sha1&#123;A&#125;&quot;</span>; <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git update-ref failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br><br><span class=\"hljs-comment\"># for browsing history - http://blog.kfish.org/2010/04/git-lola.html</span><br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git config alias.lol  &#x27;log --graph --decorate --pretty=oneline --abbrev-commit&#x27;&quot;</span>;<br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git config alias.lola &#x27;log --graph --decorate --pretty=oneline --abbrev-commit --all&#x27;&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>It adds aliases in the new throwaway repo only for <a href=\"http://blog.kfish.org/2010/04/git-lola.html\"><code>git lol</code> and <code>git lola</code></a> so you can view history as in</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git lol<br>*   29392c8 (HEAD -&gt; master, tag: A) A<br>|\\<br>| * a1ef6fd (tag: C) C<br>| |<br>|  \\<br>*-. \\   8ae20e9 (tag: B) B<br>|\\ \\ \\<br>| | |/<br>| | *   03160db (tag: F) F<br>| | |\\<br>| | | * 9df28cb (tag: J) J<br>| | * 2afd329 (tag: I) I<br>| * a77cb1f (tag: E) E<br>*   cd75703 (tag: D) D<br>|\\<br>| * 3043d25 (tag: H) H<br>* 4ab0473 (tag: G) G<br></code></pre></td></tr></table></figure>\n\n<p>Note that on your machine the SHA-1 object names will differ from those above, but the tags allow you to address commits by name and check your understanding.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git <span class=\"hljs-built_in\">log</span> -1 --format=%f $(git rev-parse A^)<br>B<br>$ git <span class=\"hljs-built_in\">log</span> -1 --format=%f $(git rev-parse A~^3~)<br>I<br>$ git <span class=\"hljs-built_in\">log</span> -1 --format=%f $(git rev-parse A^2~)<br>F<br></code></pre></td></tr></table></figure>\n\n<p>The <a href=\"https://git-scm.com/docs/git-rev-parse#_specifying_revisions\">“Specifying Revisions” in the <code>git rev-parse</code> documentation</a> is full of great information and is worth an in-depth read. See also <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection\">Git Tools - Revision Selection</a> from the book <a href=\"https://git-scm.com/book/en/v2/\"><em>Pro Git</em></a>.</p>\n<h2 id=\"Order-of-Parent-Commits\"><a href=\"#Order-of-Parent-Commits\" class=\"headerlink\" title=\"Order of Parent Commits\"></a>Order of Parent Commits</h2><p>The commit <a href=\"https://github.com/git/git/commit/89e4fcb0dd01b42e82b8f27f9a575111a26844df\">89e4fcb0dd</a> from git’s own history is a merge commit, as <code>git show 89e4fcb0dd</code>indicates with the Merge header line that displays the immediate ancestors’ object names.</p>\n<blockquote>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">commit 89e4fcb0dd01b42e82b8f27f9a575111a26844df<br>Merge: c670b1f876 649bf3a42f b67d40adbb<br>Author: Junio C Hamano &lt;gitster@pobox.com&gt;<br>Date:   Mon Oct 29 10:15:31 2018 +0900<br><br> Merge branches <span class=\"hljs-string\">&#x27;bp/reset-quiet&#x27;</span> and <span class=\"hljs-string\">&#x27;js/mingw-http-ssl&#x27;</span> into nd/config-split […]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>We can confirm the ordering by asking <code>git rev-parse</code> to show 89e4fcb0dd’s immediate parents in sequence.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git rev-parse 89e4fcb0dd^1 89e4fcb0dd^2 89e4fcb0dd^3<br>c670b1f876521c9f7cd40184bf7ed05aad843433<br>649bf3a42f344e71b1b5a7f562576f911a1f7423<br>b67d40adbbaf4f5c4898001bf062a9fd67e43368<br></code></pre></td></tr></table></figure>\n\n<p>Querying the non-existent fourth parent results in an error.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git rev-parse 89e4fcb0dd^4<br>89e4fcb0dd^4<br>fatal: ambiguous argument <span class=\"hljs-string\">&#x27;89e4fcb0dd^4&#x27;</span>: unknown revision or path not <span class=\"hljs-keyword\">in</span> the working tree.<br>Use <span class=\"hljs-string\">&#x27;--&#x27;</span> to separate paths from revisions, like this:<br><span class=\"hljs-string\">&#x27;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>If you want to extract the parents only, use <a href=\"https://git-scm.com/docs/git-log#_pretty_formats\">pretty format</a> <code>%P</code> for the full hashes</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git <span class=\"hljs-built_in\">log</span> -1 --pretty=%P 89e4fcb0dd<br>c670b1f876521c9f7cd40184bf7ed05aad843433 649bf3a42f344e71b1b5a7f562576f911a1f7423 b67d40adbbaf4f5c4898001bf062a9fd67e43368<br></code></pre></td></tr></table></figure>\n\n<p>or <code>%p</code> for abbreviated parents.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git <span class=\"hljs-built_in\">log</span> -1 --pretty=%p 89e4fcb0dd<br>c670b1f876 649bf3a42f b67d40adbb<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"个性化自定义git命令别名\"><a href=\"#个性化自定义git命令别名\" class=\"headerlink\" title=\"个性化自定义git命令别名\"></a>个性化自定义git命令别名</h1><p>文件名：.gitconfig_1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs note\">[init]<br>\tdefaultBranch = main<br>[user]<br>\tname = Alndaly<br>\temail = 1142704468@qq.com<br>[filter &quot;lfs&quot;]<br>\tclean = git-lfs clean -- %f<br>\tsmudge = git-lfs smudge -- %f<br>\tprocess = git-lfs filter-process<br>\trequired = true<br>[alias] <br>\tlm = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;Alndaly&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br>\tls = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br></code></pre></td></tr></table></figure>\n<p>文件名：.gitconfig_2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs note\">[init]<br>\tdefaultBranch = main<br>[user]<br>\tname = Smiling22<br>\temail = lucky.always.h@gmail.com<br>[filter &quot;lfs&quot;]<br>\tclean = git-lfs clean -- %f<br>\tsmudge = git-lfs smudge -- %f<br>\tprocess = git-lfs filter-process<br>\trequired = true<br>[alias] <br>\tlm = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;Alndaly&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br>\tls = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"The-default-branch-has-been-renamed-（当远程分支改了名字）\"><a href=\"#The-default-branch-has-been-renamed-（当远程分支改了名字）\" class=\"headerlink\" title=\"The default branch has been renamed!（当远程分支改了名字）\"></a>The default branch has been renamed!（当远程分支改了名字）</h2><p>main is now named master</p>\n<p>If you have a local clone, you can update it by running the following commands.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git branch -m main master<br>git fetch origin<br>git branch -u origin/master master<br>git remote set-head origin -a<br></code></pre></td></tr></table></figure>\n\n<p>![GitFlow Workflow](&#x2F;Users&#x2F;alnda&#x2F;Developer&#x2F;hexo-blog&#x2F;source&#x2F;_posts&#x2F;Git&#x2F;GitFlow Workflow.md)<br><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/20220405171749.md\" alt=\"Forking Workflow\"></p>\n<h1 id=\"Resetting-Checking-Out-amp-Reverting\"><a href=\"#Resetting-Checking-Out-amp-Reverting\" class=\"headerlink\" title=\"Resetting, Checking Out &amp; Reverting\"></a>Resetting, Checking Out &amp; Reverting</h1><p>The <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code>, <code>[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)</code>, and <code>[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)</code> commands are some of the most useful tools in your Git toolbox. They all let you undo some kind of change in your repository, and the first two commands can be used to manipulate either commits or individual files.</p>\n<p>Because they’re so similar, it’s very easy to mix up which command should be used in any given development scenario. In this article, we’ll compare the most common configurations of <code>git reset</code>, <code>git checkout</code>, and <code>git revert</code>. Hopefully, you’ll walk away with the confidence to navigate your repository using any of these commands.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:0c5257d5-ff01-4014-af12-faf2aec53cc3/01.svg?cdnVersion=116\" alt=\"The three trees of Git\"></p>\n<p>It helps to think about each command in terms of their effect on the three state management mechanisms of a Git repository: the working directory, the staged snapshot, and the commit history. These components are sometimes known as “The three trees” of Git. We explore the three trees in depth on the <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code> page. Keep these mechanisms in mind as you read through this article.</p>\n<p>A checkout is an operation that moves the <code>HEAD</code> ref pointer to a specified commit. To demonstrate this consider the following example.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion=116\" alt=\"Move the HEAD ref pointer to a specified commit\"></p>\n<p>This example demonstrates a sequence of commits on the <code>main</code> branch. The <code>HEAD</code> ref and <code>main</code> branch ref currently point to commit d. Now let us execute <code>git checkout b</code></p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:f45c4a34-8968-4c81-83cf-d55ebf01a447/02%20git-checkout-transparent%20kopiera.png?cdnVersion=116\" alt=\"Sequence of commits on the master branch\"></p>\n<p>This is an update to the “Commit History” tree. The <code>git checkout</code> command can be used in a commit, or file level scope. A file level checkout will change the file’s contents to those of the specific commit.</p>\n<p>A revert is an operation that takes a specified commit and creates a new commit which inverses the specified commit. <code>git revert</code>can only be run at a commit level scope and has no file level functionality.</p>\n<p>A reset is an operation that takes a specified commit and resets the “three trees” to match the state of the repository at that specified commit. A reset can be invoked in three different modes which correspond to the three trees.</p>\n<p>Checkout and reset are generally used for making local or private ‘undos’. They modify the history of a repository that can cause conflicts when pushing to remote shared repositories. Revert is considered a safe operation for ‘public undos’ as it creates new history which can be shared remotely and doesn’t overwrite history remote team members may be dependent on.</p>\n<h2 id=\"Git-Reset-vs-Revert-vs-Checkout-reference\"><a href=\"#Git-Reset-vs-Revert-vs-Checkout-reference\" class=\"headerlink\" title=\"Git Reset vs Revert vs Checkout reference\"></a>Git Reset vs Revert vs Checkout reference</h2><p>The table below sums up the most common use cases for all of these commands. Be sure to keep this reference handy, as you’ll undoubtedly need to use at least some of them during your Git career.</p>\n<p>Command</p>\n<p>Scope</p>\n<p>Common use cases</p>\n<p><code>git reset</code></p>\n<p>Commit-level</p>\n<p>Discard commits in a private branch or throw away uncommited changes</p>\n<p><code>git reset</code></p>\n<p>File-level</p>\n<p>Unstage a file</p>\n<p><code>git checkout</code></p>\n<p>Commit-level</p>\n<p>Switch between branches or inspect old snapshots</p>\n<p><code>git checkout</code></p>\n<p>File-level</p>\n<p>Discard changes in the working directory</p>\n<p><code>git revert</code></p>\n<p>Commit-level</p>\n<p>Undo commits in a public branch</p>\n<p><code>git revert</code></p>\n<p>File-level</p>\n<p>(N&#x2F;A)</p>\n<h2 id=\"Commit-Level-Operations\"><a href=\"#Commit-Level-Operations\" class=\"headerlink\" title=\"Commit Level Operations\"></a>Commit Level Operations</h2><p>The parameters that you pass to <code>git reset</code> and <code>git checkout</code>determine their scope. When you don’t include a file path as a parameter, they operate on whole commits. That’s what we’ll be exploring in this section. Note that <code>git revert</code> has no file-level counterpart.</p>\n<h3 id=\"Reset-A-Specific-Commit\"><a href=\"#Reset-A-Specific-Commit\" class=\"headerlink\" title=\"Reset A Specific Commit\"></a>Reset A Specific Commit</h3><p>On the commit-level, resetting is a way to move the tip of a branch to a different commit. This can be used to remove commits from the current branch. For example, the following command moves the <code>hotfix</code> branch backwards by two commits.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout hotfix git reset HEAD~2<br></code></pre></td></tr></table></figure>\n\n<p>The two commits that were on the end of <code>hotfix</code> are now dangling, or orphaned commits. This means they will be deleted the next time Git performs a garbage collection. In other words, you’re saying that you want to throw away these commits. This can be visualized as the following:</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:e8a43261-2460-4783-9731-1197dc8959ab/03-04%20Reset%20a%20specific%20commit.png?cdnVersion=116\" alt=\"Resetting the hotfix branch to HEAD-2\"></p>\n<p>This usage of <code>git reset</code> is a simple way to undo changes that haven’t been shared with anyone else. It’s your go-to command when you’ve started working on a feature and find yourself thinking, “Oh crap, what am I doing? I should just start over.”</p>\n<p>In addition to moving the current branch, you can also get <code>git reset</code> to alter the staged snapshot and&#x2F;or the working directory by passing it one of the following flags:</p>\n<ul>\n<li><code>--soft</code> – The staged snapshot and working directory are not altered in any way.</li>\n<li><code>--mixed</code> – The staged snapshot is updated to match the specified commit, but the working directory is not affected. This is the default option.</li>\n<li><code>--hard</code> – The staged snapshot and the working directory are both updated to match the specified commit.</li>\n</ul>\n<p>It’s easier to think of these modes as defining the scope of a <code>git reset</code> operation. For further detailed information visit the <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code> page.</p>\n<h3 id=\"Checkout-old-commits\"><a href=\"#Checkout-old-commits\" class=\"headerlink\" title=\"Checkout old commits\"></a>Checkout old commits</h3><p>The <code>git checkout</code> command is used to update the state of the repository to a specific point in the projects history. When passed with a branch name, it lets you switch between branches.</p>\n<p> <code>git checkout hotfix</code></p>\n<p>Internally, all the above command does is move <code>HEAD</code> to a different branch and update the working directory to match. Since this has the potential to overwrite local changes, Git forces you to commit or <a href=\"https://www.atlassian.com/git/tutorials/saving-changes/git-stash\">stash</a> any changes in the working directory that will be lost during the checkout operation. Unlike <code>git reset</code>, <code>git checkout</code> doesn’t move any branches around.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:7dffc21e-29c6-4bfd-acd1-2965fcdd923e/05-06%20Checkout%20old%20commits.png?cdnVersion=116\" alt=\"Moving HEAD from master to hotfix\"></p>\n<p>You can also check out arbitrary commits by passing the commit reference instead of a branch. This does the exact same thing as checking out a branch: it moves the <code>HEAD</code> reference to the specified commit. For example, the following command will check out the grandparent of the current commit:</p>\n<p> <code>git checkout HEAD~2</code></p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:9b4d9562-7ed1-441c-bbd1-1897bea5676e/07.svg?cdnVersion=116\" alt=\"Moving `HEAD` to an arbitrary commit\"></p>\n<p>This is useful for quickly inspecting an old version of your project. However, since there is no branch reference to the current <code>HEAD</code>, this puts you in a detached <code>HEAD</code> state. This can be dangerous if you start adding new commits because there will be no way to get back to them after you switch to another branch. For this reason, you should always create a new branch before adding commits to a detached <code>HEAD</code>.</p>\n<h3 id=\"Undo-Public-Commits-with-Revert\"><a href=\"#Undo-Public-Commits-with-Revert\" class=\"headerlink\" title=\"Undo Public Commits with Revert\"></a>Undo Public Commits with Revert</h3><p>Reverting undoes a commit by creating a new commit. This is a safe way to undo changes, as it has no chance of re-writing the commit history. For example, the following command will figure out the changes contained in the 2nd to last commit, create a new commit undoing those changes, and tack the new commit onto the existing project.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout hotfix git revert HEAD~2<br></code></pre></td></tr></table></figure>\n\n<p>This can be visualized as the following:</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:f02c67ca-d7b8-47f8-98f8-e0017dc9f7c5/08-09%20Undo%20public%20commits.svg?cdnVersion=116\" alt=\"Reverting the 2nd to last commit\"></p>\n<p>Contrast this with <code>git reset</code>, which <em>does</em> alter the existing commit history. For this reason, <code>git revert</code> should be used to undo changes on a public branch, and <code>git reset</code> should be reserved for undoing changes on a private branch.</p>\n<p>You can also think of <code>git revert</code> as a tool for undoing _committed_changes, while <code>git reset HEAD</code> is for undoing _uncommitted_changes.</p>\n<p>Like <code>git checkout</code>, <code>git revert</code> has the potential to overwrite files in the working directory, so it will ask you to commit or <a href=\"https://www.atlassian.com/git/tutorials/saving-changes/git-stash\">stash changes</a> that would be lost during the revert operation.</p>\n<h2 id=\"File-level-Operations\"><a href=\"#File-level-Operations\" class=\"headerlink\" title=\"File-level Operations\"></a>File-level Operations</h2><p>The <code>git reset</code> and <code>git checkout</code> commands also accept an optional file path as a parameter. This dramatically alters their behavior. Instead of operating on entire snapshots, this forces them to limit their operations to a single file.</p>\n<h3 id=\"Git-Reset-A-Specific-File\"><a href=\"#Git-Reset-A-Specific-File\" class=\"headerlink\" title=\"Git Reset A Specific File\"></a>Git Reset A Specific File</h3><p>When invoked with a file path, <code>git reset</code> updates the <em>staged snapshot</em> to match the version from the specified commit. For example, this command will fetch the version of <code>foo.py</code> in the 2nd-to-last commit and stage it for the next commit:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git reset HEAD~2 foo.py<br></code></pre></td></tr></table></figure>\n\n<p>As with the commit-level version of <code>git reset</code>, this is more commonly used with <code>HEAD</code> rather than an arbitrary commit. Running <code>git reset HEAD foo.py</code> will unstage <code>foo.py</code>. The changes it contains will still be present in the working directory.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:1a010f5a-c90d-49ee-a0e6-31054433e2d4/07.svg?cdnVersion=116\" alt=\"Moving a file from the commit history into the staged snapshot\"></p>\n<p>The <code>--soft</code>, <code>--mixed</code>, and <code>--hard</code> flags do not have any effect on the file-level version of <code>git reset</code>, as the staged snapshot is <em>always</em> updated, and the working directory is <em>never</em> updated.</p>\n<h3 id=\"Git-Checkout-File\"><a href=\"#Git-Checkout-File\" class=\"headerlink\" title=\"Git Checkout File\"></a>Git Checkout File</h3><p>Checking out a file is similar to using <code>git reset</code> with a file path, except it updates the <em>working directory</em> instead of the stage. Unlike the commit-level version of this command, this does not move the <code>HEAD</code> reference, which means that you won’t switch branches.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:cc252fc0-fc76-4740-8458-9c0d7af94bca/08.svg?cdnVersion=116\" alt=\"Moving a file from the commit history into the working directory\"></p>\n<p>For example, the following command makes <code>foo.py</code> in the working directory match the one from the 2nd-to-last commit:<br><strong>（要将特定的文件而不是所有文件退回某个版本时）</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout HEAD~2 foo.py<br></code></pre></td></tr></table></figure>\n\n<p>Just like the commit-level invocation of <code>git checkout</code>, this can be used to inspect old versions of a project—but the scope is limited to the specified file.</p>\n<p>If you stage and commit the checked-out file, this has the effect of “reverting” to the old version of that file. Note that this removes <em>all</em> of the subsequent changes to the file, whereas the <code>git revert</code> command undoes only the changes introduced by the specified commit.</p>\n<p>Like <code>git reset</code>, this is commonly used with <code>HEAD</code> as the commit reference. For instance, <code>git checkout HEAD foo.py</code> has the effect of discarding unstaged changes to <code>foo.py</code>. This is similar behavior to <code>git reset HEAD --hard</code>, but it operates only on the specified file.</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>You should now have all the tools you could ever need to undo changes in a Git repository. The <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code>, <code>[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)</code>, and <code>[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)</code>commands can be confusing, but when you think about their effects on the working directory, staged snapshot, and commit history, it should be easier to discern which command fits the development task at hand.</p>\n","site":{"data":{}},"wordcount":18498,"excerpt":"","more":"<h1 id=\"Git-安装\"><a href=\"#Git-安装\" class=\"headerlink\" title=\"Git 安装\"></a>Git 安装</h1><p>Git 可以在 Git 官网下载，目前 Git 支持 Windows 和 Mac， 按默认选项安装即可。(不清楚下载地方的可以关注私信我)</p>\n<p>安装教程可参照 廖雪峰老师的安装教程。</p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p><code>git config</code><br>在git中，使用<code>git config</code> 命令来配置 git 的配置文件，git配置级别主要有3类：<br>1、仓库级别 local 本地 Git 仓库级别配置文件，作用于当前仓库。【优先级最高】<br>2、用户级别 global，全局配置文件，作用于所有用户。【优先级次之】<br>3、系统级别 system，作用于系统所有用户和所有库。【优先级最低】<br><code>git config -l</code> 查看所有的配置信息，依次是系统级别、用户级别、仓库级别<br><code>git config --local -l</code> 查看仓库配置<br><code>git config --global -l</code> 查看用户配置<br><code>git config --system -l</code> 查看系统配置<br><code>git config</code> 添加配置文件<br><code>git config --global user.email “You Email”</code><br><code>git config --global user.name “Your Name”</code><br><code>git config -e </code>编辑配置文件<br><code>git config --local -e</code> 编辑仓库级别配置文件<br><code>git config --global -e</code> 编辑用户级别配置文件<br><code>git config --system -e</code> 编辑系统级别配置文件<br><code>git clone</code><br><code>git clone</code> 复制仓库到新的目录<br><code>git fetch</code><br><code>git fetch</code> 创建并更新本地远程分支<br><code>git fetch origin</code> 手动指定要 fetch 的 remote,在不指定分支时通常默认为 master；<br><code>git fetch origin master:temp</code> 如在本地新建一个temp分支，并将远程 origin 仓库的 master 分支代码下载到本地 temp 分支<br><code>git diff temp</code> 比较本地代码与刚刚从远程下载下来的代码的区别<br><code>git merge temp</code> 合并代码<br><code>git branch -d temp</code> 不想要 tmp 分支，删除分支<br><code>git pull</code><br><code>git pull</code> 将更新从远程仓库合并到当前分支。在默认模式下，<code>git pull</code> &#x3D;&#x3D; <code>git fetch</code> + <code>git merge</code>。<br><code>git pull</code> :</p>\n<p>如 <code>git pull origin master</code></p>\n<p><code>git pull </code>取回远程仓库某个分支的更新，再与本地的指定分支自动合并，可能会出现代码冲突。</p>\n<p><code>git fetch</code> 先获取远程仓库某个分支的更新，再执行 merge，相比 pull ，fetch 更可控。</p>\n<p><code>git add</code></p>\n<p><code>git add -A</code> 添加所有文件到暂存区</p>\n<p><code>git add -u</code> 添加被修改(modified)和被删除(deleted)文件到暂存区，不包括新文件(new)</p>\n<p><code>git add .</code> 添加新文件(new)和被修改(modified)文件到暂存区，不包括被删除(deleted)文件</p>\n<p>可以通过 <code>git status</code> 检查文件是否已添加完毕。</p>\n<p><code>git commit</code></p>\n<p><code>git commit -m</code> “” 比较常见的用法，-m “填写更新记录”</p>\n<p><code>git commit -a -m</code> “” 提交所有已跟踪的执行修改或删除、新建的文件，即使没有执行 git add 添加到暂存区的文件。</p>\n<p><code>git commit --amend</code> 修改上一次提交，可以在不增加新的 commit-id 的情况下将新修改的代码追加到前一次 commit-id 中。如不小心提交了一版没有修改完成的版本上去，</p>\n<p>还需要修改完善后再提交，又不想再次增加一个 commit-id 时，可以使用追加提交。</p>\n<p><code>git commit --help</code> 查看帮助</p>\n<p><code>git push</code></p>\n<p><code>git push </code>将已经 commit 的文件推送到远程仓库的分支</p>\n<p><code>git push origin master</code> 推送到 master 分支</p>\n<p><code>git push --all origin</code> 推送本地仓库所有分支到远程仓库分支</p>\n<p><code>git push origin :master</code> 删除远程分支，等同于 <code>git push origin --delete master</code></p>\n<p><code>git push -u origin master </code>将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机。</p>\n<p><code>git remote</code></p>\n<p><code>git remote -v</code> 查看远程仓库地址</p>\n<p><code>git remote set-url origin</code> 修改远程仓库地址</p>\n<p><code>git remote rm origin</code> 删除远程仓库地址</p>\n<p><code>git remote add origin [url]</code> 添加远程仓库地址</p>\n<p><code>git merge</code></p>\n<p><code>git merge</code> 合并代码</p>\n<p><code>git merge --no-commit</code> 防止合并失败不自动提交</p>\n<p><code>git merge --no-ff</code> 不使用fast-forward方式合并，创建一个 merge 的 commit 信息。</p>\n<p>一、版本回退<br>我们用readme文件举例子，修改好内容之后，重新提交<br><code>git add readme.txt</code><br><code>git commit -m &quot;说明&quot;</code>  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-8619843d359e464a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>返回结果<br>我们可以多修改几次，来试一下版本回退功能  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-934dca2c8cf7697e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>修改之后的git log,按Q推出</p>\n<p>回到上一个版本<code>git reset --hard HEAD^</code>  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-660b9a45ac97a052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"><br>终端截图<br><img src=\"https://upload-images.jianshu.io/upload_images/21452414-6a040fe5e32e04e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>cat命令查看文件内容</p>\n<p>以此类推回到上上个版本就是<code>git reset --hard HEAD^^</code><br>当往上的版本比较多，比如往上50个版本的时候我们用<code>git reset --hard HEAD~50</code></p>\n<p>退回以后出现一个奇怪的事情，我们再执行<code>git log</code>命令发现看不到第三版了  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-9da314cc6a740f47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>git log结果</p>\n<p>这时，我们想要回到第三版需要用以下命令来<br><code>git rest hard 63ef</code><br><code>63ef</code>是第三次提交时的版本号，我们没必要去写全，git会自动检索，但也不能只写一两位。因为版本号多了会有重复的。  </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/21452414-9803aaf3afe72e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200\"></p>\n<p>恢复到第三版</p>\n<ul>\n<li>问题①:如果我们没有记录被恢复版本的版本号,怎么找回呢?</li>\n</ul>\n<p>Git提供了一个命令<code>git reflog</code>,通过这个命令我们可以看到每次git的操作记录</p>\n<ul>\n<li>问题②:如果我们通过git回到第一版,那么<code>git log</code>命令还能看到第二版吗?</li>\n</ul>\n<p>小结:</p>\n<ul>\n<li><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code></p>\n</li>\n<li><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>\n</li>\n<li><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>\n</li>\n</ul>\n<p><strong>直接拉取并覆盖本地的所有代码</strong><br>两个电脑同时对git上的项目进行跟新时，不免要用到将git上的代码拉取到本地更新本地代码的操作，鉴于自己对git使用的还不是很熟练，所以就直接采取暴力的方法，直接拉取并覆盖本地的所有代码，命令如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git fetch --all<br>git reset --hard origin/master<br>git pull<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Difference-between-and\"><a href=\"#Difference-between-and\" class=\"headerlink\" title=\"Difference between ^ and ~\"></a>Difference between ^ and ~</h1><h2 id=\"Rules-of-thumb\"><a href=\"#Rules-of-thumb\" class=\"headerlink\" title=\"Rules of thumb\"></a>Rules of thumb</h2><ul>\n<li>Use <code>~</code> most of the time — to go back a number of generations, usually what you want</li>\n<li>Use <code>^</code> on merge commits — because they have two or more (immediate) parents</li>\n</ul>\n<p>Mnemonics:</p>\n<ul>\n<li>Tilde <code>~</code> is almost linear in appearance and wants to go backward in a straight line</li>\n<li>Caret <code>^</code> suggests an interesting segment of a tree or a fork in the road</li>\n</ul>\n<h2 id=\"Tilde\"><a href=\"#Tilde\" class=\"headerlink\" title=\"Tilde\"></a>Tilde</h2><p>The <a href=\"https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtltngtemegemmaster3em\">“Specifying Revisions” section of the <code>git rev-parse</code> documentation</a> defines <code>~</code> as</p>\n<blockquote>\n<p><strong><code>&lt;rev&gt;~&lt;n&gt;</code>, e.g. <code>master~3</code></strong><br>A suffix <code>~&lt;n&gt;</code> to a revision parameter means the commit object that is the _n_thgeneration ancestor of the named commit object, following only the first parents. For example, <code>&lt;rev&gt;~3</code> is equivalent to <code>&lt;rev&gt;^^^</code> which is equivalent to <code>&lt;rev&gt;^1^1^1</code> …</p>\n</blockquote>\n<p>You can get to parents of any commit, not just <code>HEAD</code>. You can also move back through generations: for example, <code>master~2</code> means the grandparent of the tip of the master branch, favoring the first parent on merge commits.</p>\n<h2 id=\"Caret\"><a href=\"#Caret\" class=\"headerlink\" title=\"Caret\"></a>Caret</h2><p>Git history is nonlinear: a directed acyclic graph (DAG) or tree. For a commit with only one parent, <code>rev~</code> and <code>rev^</code> mean the same thing. The caret selector becomes useful with merge commits because each one is the child of two or more parents — and strains language borrowed from biology.</p>\n<p><code>HEAD^</code> means the first <em>immediate</em> parent of the tip of the current branch. <code>HEAD^</code> is short for <code>HEAD^1</code>, and you can also address <code>HEAD^2</code> and so on as appropriate. The <a href=\"https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrevgtemegemHEADv1510em\">same section of the <code>git rev-parse</code> documentation</a> defines it as</p>\n<blockquote>\n<p><strong><code>&lt;rev&gt;^</code>, <em>e.g.</em> <code>HEAD^</code>, <code>v1.5.1^0</code></strong><br>A suffix <code>^</code> to a revision parameter means the first parent of that commit object. <code>^&lt;n&gt;</code>means the _n_th parent ([<em>e.g.</em>] <code>&lt;rev&gt;^</code> is equivalent to <code>&lt;rev&gt;^1</code>). As a special rule, <code>&lt;rev&gt;^0</code> means the commit itself and is used when <code>&lt;rev&gt;</code> is the object name of a tag object that refers to a commit object.</p>\n</blockquote>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><p>These specifiers or selectors can be chained arbitrarily, <em>e.g.</em>, <code>topic~3^2</code> in English is the second parent of the merge commit that is the great-grandparent (three generations back) of the current tip of the branch <code>topic</code>.</p>\n<p>The <a href=\"https://git-scm.com/docs/git-rev-parse#_specifying_revisions\">aforementioned section of the <code>git rev-parse</code> documentation</a> traces many paths through a notional git history. Time flows generally downward. Commits D, F, B, and A are merge commits.</p>\n<blockquote>\n<p>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right. (N.B. The <code>git log --graph</code> command displays history in the opposite order.)</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">G   H   I   J<br>\\ /     \\ /<br>D   E   F<br>\\  |  / \\<br> \\ | /   |<br>  \\|/    |<br>   B     C<br>    \\   /<br>     \\ /<br>      A<br><br>A =      = A^0<br>B = A^   = A^1     = A~1<br>C = A^2<br>D = A^^  = A^1^1   = A~2<br>E = B^2  = A^^2<br>F = B^3  = A^^3<br>G = A^^^ = A^1^1^1 = A~3<br>H = D^2  = B^^2    = A^^^2  = A~2^2<br>I = F^   = B^3^    = A^^3^<br>J = F^2  = B^3^2   = A^^3^2<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>Run the code below to create a git repository whose history matches the quoted illustration.</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\"><span class=\"hljs-comment\">#! /usr/bin/env perl</span><br><br><span class=\"hljs-keyword\">use</span> strict;<br><span class=\"hljs-keyword\">use</span> warnings;<br><span class=\"hljs-keyword\">use</span> subs <span class=\"hljs-keyword\">qw</span>/ postorder /;<br><span class=\"hljs-keyword\">use</span> File::Temp <span class=\"hljs-keyword\">qw</span>/ mkdtemp /;<br><br><span class=\"hljs-keyword\">my</span> %sha1;<br><span class=\"hljs-keyword\">my</span> %parents = (<br>  <span class=\"hljs-string\">A =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/ B C /               ],<br>  <span class=\"hljs-string\">B =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/     D E F /         ],<br>  <span class=\"hljs-string\">C =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/         F /         ],<br>  <span class=\"hljs-string\">D =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/           G H /     ],<br>  <span class=\"hljs-string\">F =&gt;</span> [ <span class=\"hljs-keyword\">qw</span>/               I J / ],<br>);<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">sub</span> <span class=\"hljs-title\">postorder</span> </span>&#123;<br>  <span class=\"hljs-keyword\">my</span>($root,$hash) = @_;<br>  <span class=\"hljs-keyword\">my</span> @parents = @&#123; $parents&#123;$root&#125; || [] &#125;;<br>  postorder($_, $hash) <span class=\"hljs-keyword\">for</span> @parents;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">if</span> $sha1&#123;$root&#125;;<br>  @parents = <span class=\"hljs-keyword\">map</span> <span class=\"hljs-string\">&quot;-p $sha1&#123;$_&#125;&quot;</span>, @parents;<br>  <span class=\"hljs-keyword\">chomp</span>($sha1&#123;$root&#125; = <span class=\"hljs-string\">`git commit-tree @parents -m &quot;$root&quot; $hash`</span>);<br>  <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git commit-tree failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br>  <span class=\"hljs-keyword\">system</span>(<span class=\"hljs-string\">&quot;git tag -a -m &#x27;$sha1&#123;$root&#125;&#x27; &#x27;$root&#x27; &#x27;$sha1&#123;$root&#125;&#x27;&quot;</span>) == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git tag failed&quot;</span>;<br>&#125;<br><br>$0 =~ s!^.*<span class=\"hljs-regexp\">/!!;  # /</span> fix Stack Overflow highlighting<br><span class=\"hljs-keyword\">my</span> $repo = mkdtemp <span class=\"hljs-string\">&quot;repoXXXXXXXX&quot;</span>;<br><span class=\"hljs-keyword\">chdir</span> $repo <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: chdir: $!&quot;</span>;<br><span class=\"hljs-keyword\">system</span>(<span class=\"hljs-string\">&quot;git init&quot;</span>) == <span class=\"hljs-number\">0</span>               <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git init failed&quot;</span>;<br><span class=\"hljs-keyword\">chomp</span>(<span class=\"hljs-keyword\">my</span> $tree = <span class=\"hljs-string\">`git write-tree`</span>);      <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git write-tree failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br><br>postorder <span class=\"hljs-string\">&#x27;A&#x27;</span>, $tree;<br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git update-ref HEAD   $sha1&#123;A&#125;&quot;</span>; <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git update-ref failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git update-ref master $sha1&#123;A&#125;&quot;</span>; <span class=\"hljs-keyword\">die</span> <span class=\"hljs-string\">&quot;$0: git update-ref failed&quot;</span> <span class=\"hljs-keyword\">if</span> $?;<br><br><span class=\"hljs-comment\"># for browsing history - http://blog.kfish.org/2010/04/git-lola.html</span><br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git config alias.lol  &#x27;log --graph --decorate --pretty=oneline --abbrev-commit&#x27;&quot;</span>;<br><span class=\"hljs-keyword\">system</span> <span class=\"hljs-string\">&quot;git config alias.lola &#x27;log --graph --decorate --pretty=oneline --abbrev-commit --all&#x27;&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>It adds aliases in the new throwaway repo only for <a href=\"http://blog.kfish.org/2010/04/git-lola.html\"><code>git lol</code> and <code>git lola</code></a> so you can view history as in</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git lol<br>*   29392c8 (HEAD -&gt; master, tag: A) A<br>|\\<br>| * a1ef6fd (tag: C) C<br>| |<br>|  \\<br>*-. \\   8ae20e9 (tag: B) B<br>|\\ \\ \\<br>| | |/<br>| | *   03160db (tag: F) F<br>| | |\\<br>| | | * 9df28cb (tag: J) J<br>| | * 2afd329 (tag: I) I<br>| * a77cb1f (tag: E) E<br>*   cd75703 (tag: D) D<br>|\\<br>| * 3043d25 (tag: H) H<br>* 4ab0473 (tag: G) G<br></code></pre></td></tr></table></figure>\n\n<p>Note that on your machine the SHA-1 object names will differ from those above, but the tags allow you to address commits by name and check your understanding.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git <span class=\"hljs-built_in\">log</span> -1 --format=%f $(git rev-parse A^)<br>B<br>$ git <span class=\"hljs-built_in\">log</span> -1 --format=%f $(git rev-parse A~^3~)<br>I<br>$ git <span class=\"hljs-built_in\">log</span> -1 --format=%f $(git rev-parse A^2~)<br>F<br></code></pre></td></tr></table></figure>\n\n<p>The <a href=\"https://git-scm.com/docs/git-rev-parse#_specifying_revisions\">“Specifying Revisions” in the <code>git rev-parse</code> documentation</a> is full of great information and is worth an in-depth read. See also <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection\">Git Tools - Revision Selection</a> from the book <a href=\"https://git-scm.com/book/en/v2/\"><em>Pro Git</em></a>.</p>\n<h2 id=\"Order-of-Parent-Commits\"><a href=\"#Order-of-Parent-Commits\" class=\"headerlink\" title=\"Order of Parent Commits\"></a>Order of Parent Commits</h2><p>The commit <a href=\"https://github.com/git/git/commit/89e4fcb0dd01b42e82b8f27f9a575111a26844df\">89e4fcb0dd</a> from git’s own history is a merge commit, as <code>git show 89e4fcb0dd</code>indicates with the Merge header line that displays the immediate ancestors’ object names.</p>\n<blockquote>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">commit 89e4fcb0dd01b42e82b8f27f9a575111a26844df<br>Merge: c670b1f876 649bf3a42f b67d40adbb<br>Author: Junio C Hamano &lt;gitster@pobox.com&gt;<br>Date:   Mon Oct 29 10:15:31 2018 +0900<br><br> Merge branches <span class=\"hljs-string\">&#x27;bp/reset-quiet&#x27;</span> and <span class=\"hljs-string\">&#x27;js/mingw-http-ssl&#x27;</span> into nd/config-split […]<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>We can confirm the ordering by asking <code>git rev-parse</code> to show 89e4fcb0dd’s immediate parents in sequence.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git rev-parse 89e4fcb0dd^1 89e4fcb0dd^2 89e4fcb0dd^3<br>c670b1f876521c9f7cd40184bf7ed05aad843433<br>649bf3a42f344e71b1b5a7f562576f911a1f7423<br>b67d40adbbaf4f5c4898001bf062a9fd67e43368<br></code></pre></td></tr></table></figure>\n\n<p>Querying the non-existent fourth parent results in an error.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git rev-parse 89e4fcb0dd^4<br>89e4fcb0dd^4<br>fatal: ambiguous argument <span class=\"hljs-string\">&#x27;89e4fcb0dd^4&#x27;</span>: unknown revision or path not <span class=\"hljs-keyword\">in</span> the working tree.<br>Use <span class=\"hljs-string\">&#x27;--&#x27;</span> to separate paths from revisions, like this:<br><span class=\"hljs-string\">&#x27;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>If you want to extract the parents only, use <a href=\"https://git-scm.com/docs/git-log#_pretty_formats\">pretty format</a> <code>%P</code> for the full hashes</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git <span class=\"hljs-built_in\">log</span> -1 --pretty=%P 89e4fcb0dd<br>c670b1f876521c9f7cd40184bf7ed05aad843433 649bf3a42f344e71b1b5a7f562576f911a1f7423 b67d40adbbaf4f5c4898001bf062a9fd67e43368<br></code></pre></td></tr></table></figure>\n\n<p>or <code>%p</code> for abbreviated parents.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git <span class=\"hljs-built_in\">log</span> -1 --pretty=%p 89e4fcb0dd<br>c670b1f876 649bf3a42f b67d40adbb<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"个性化自定义git命令别名\"><a href=\"#个性化自定义git命令别名\" class=\"headerlink\" title=\"个性化自定义git命令别名\"></a>个性化自定义git命令别名</h1><p>文件名：.gitconfig_1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs note\">[init]<br>\tdefaultBranch = main<br>[user]<br>\tname = Alndaly<br>\temail = 1142704468@qq.com<br>[filter &quot;lfs&quot;]<br>\tclean = git-lfs clean -- %f<br>\tsmudge = git-lfs smudge -- %f<br>\tprocess = git-lfs filter-process<br>\trequired = true<br>[alias] <br>\tlm = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;Alndaly&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br>\tls = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br></code></pre></td></tr></table></figure>\n<p>文件名：.gitconfig_2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs note\">[init]<br>\tdefaultBranch = main<br>[user]<br>\tname = Smiling22<br>\temail = lucky.always.h@gmail.com<br>[filter &quot;lfs&quot;]<br>\tclean = git-lfs clean -- %f<br>\tsmudge = git-lfs smudge -- %f<br>\tprocess = git-lfs filter-process<br>\trequired = true<br>[alias] <br>\tlm = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;Alndaly&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br>\tls = log --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%C(cyan) %s %Cgreen(%cd) %C(bold white)&lt;%an&gt;%Creset&#x27; --abbrev-commit --graph<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"The-default-branch-has-been-renamed-（当远程分支改了名字）\"><a href=\"#The-default-branch-has-been-renamed-（当远程分支改了名字）\" class=\"headerlink\" title=\"The default branch has been renamed!（当远程分支改了名字）\"></a>The default branch has been renamed!（当远程分支改了名字）</h2><p>main is now named master</p>\n<p>If you have a local clone, you can update it by running the following commands.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git branch -m main master<br>git fetch origin<br>git branch -u origin/master master<br>git remote set-head origin -a<br></code></pre></td></tr></table></figure>\n\n<p>![GitFlow Workflow](&#x2F;Users&#x2F;alnda&#x2F;Developer&#x2F;hexo-blog&#x2F;source&#x2F;_posts&#x2F;Git&#x2F;GitFlow Workflow.md)<br><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/20220405171749.md\" alt=\"Forking Workflow\"></p>\n<h1 id=\"Resetting-Checking-Out-amp-Reverting\"><a href=\"#Resetting-Checking-Out-amp-Reverting\" class=\"headerlink\" title=\"Resetting, Checking Out &amp; Reverting\"></a>Resetting, Checking Out &amp; Reverting</h1><p>The <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code>, <code>[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)</code>, and <code>[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)</code> commands are some of the most useful tools in your Git toolbox. They all let you undo some kind of change in your repository, and the first two commands can be used to manipulate either commits or individual files.</p>\n<p>Because they’re so similar, it’s very easy to mix up which command should be used in any given development scenario. In this article, we’ll compare the most common configurations of <code>git reset</code>, <code>git checkout</code>, and <code>git revert</code>. Hopefully, you’ll walk away with the confidence to navigate your repository using any of these commands.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:0c5257d5-ff01-4014-af12-faf2aec53cc3/01.svg?cdnVersion=116\" alt=\"The three trees of Git\"></p>\n<p>It helps to think about each command in terms of their effect on the three state management mechanisms of a Git repository: the working directory, the staged snapshot, and the commit history. These components are sometimes known as “The three trees” of Git. We explore the three trees in depth on the <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code> page. Keep these mechanisms in mind as you read through this article.</p>\n<p>A checkout is an operation that moves the <code>HEAD</code> ref pointer to a specified commit. To demonstrate this consider the following example.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion=116\" alt=\"Move the HEAD ref pointer to a specified commit\"></p>\n<p>This example demonstrates a sequence of commits on the <code>main</code> branch. The <code>HEAD</code> ref and <code>main</code> branch ref currently point to commit d. Now let us execute <code>git checkout b</code></p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:f45c4a34-8968-4c81-83cf-d55ebf01a447/02%20git-checkout-transparent%20kopiera.png?cdnVersion=116\" alt=\"Sequence of commits on the master branch\"></p>\n<p>This is an update to the “Commit History” tree. The <code>git checkout</code> command can be used in a commit, or file level scope. A file level checkout will change the file’s contents to those of the specific commit.</p>\n<p>A revert is an operation that takes a specified commit and creates a new commit which inverses the specified commit. <code>git revert</code>can only be run at a commit level scope and has no file level functionality.</p>\n<p>A reset is an operation that takes a specified commit and resets the “three trees” to match the state of the repository at that specified commit. A reset can be invoked in three different modes which correspond to the three trees.</p>\n<p>Checkout and reset are generally used for making local or private ‘undos’. They modify the history of a repository that can cause conflicts when pushing to remote shared repositories. Revert is considered a safe operation for ‘public undos’ as it creates new history which can be shared remotely and doesn’t overwrite history remote team members may be dependent on.</p>\n<h2 id=\"Git-Reset-vs-Revert-vs-Checkout-reference\"><a href=\"#Git-Reset-vs-Revert-vs-Checkout-reference\" class=\"headerlink\" title=\"Git Reset vs Revert vs Checkout reference\"></a>Git Reset vs Revert vs Checkout reference</h2><p>The table below sums up the most common use cases for all of these commands. Be sure to keep this reference handy, as you’ll undoubtedly need to use at least some of them during your Git career.</p>\n<p>Command</p>\n<p>Scope</p>\n<p>Common use cases</p>\n<p><code>git reset</code></p>\n<p>Commit-level</p>\n<p>Discard commits in a private branch or throw away uncommited changes</p>\n<p><code>git reset</code></p>\n<p>File-level</p>\n<p>Unstage a file</p>\n<p><code>git checkout</code></p>\n<p>Commit-level</p>\n<p>Switch between branches or inspect old snapshots</p>\n<p><code>git checkout</code></p>\n<p>File-level</p>\n<p>Discard changes in the working directory</p>\n<p><code>git revert</code></p>\n<p>Commit-level</p>\n<p>Undo commits in a public branch</p>\n<p><code>git revert</code></p>\n<p>File-level</p>\n<p>(N&#x2F;A)</p>\n<h2 id=\"Commit-Level-Operations\"><a href=\"#Commit-Level-Operations\" class=\"headerlink\" title=\"Commit Level Operations\"></a>Commit Level Operations</h2><p>The parameters that you pass to <code>git reset</code> and <code>git checkout</code>determine their scope. When you don’t include a file path as a parameter, they operate on whole commits. That’s what we’ll be exploring in this section. Note that <code>git revert</code> has no file-level counterpart.</p>\n<h3 id=\"Reset-A-Specific-Commit\"><a href=\"#Reset-A-Specific-Commit\" class=\"headerlink\" title=\"Reset A Specific Commit\"></a>Reset A Specific Commit</h3><p>On the commit-level, resetting is a way to move the tip of a branch to a different commit. This can be used to remove commits from the current branch. For example, the following command moves the <code>hotfix</code> branch backwards by two commits.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout hotfix git reset HEAD~2<br></code></pre></td></tr></table></figure>\n\n<p>The two commits that were on the end of <code>hotfix</code> are now dangling, or orphaned commits. This means they will be deleted the next time Git performs a garbage collection. In other words, you’re saying that you want to throw away these commits. This can be visualized as the following:</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:e8a43261-2460-4783-9731-1197dc8959ab/03-04%20Reset%20a%20specific%20commit.png?cdnVersion=116\" alt=\"Resetting the hotfix branch to HEAD-2\"></p>\n<p>This usage of <code>git reset</code> is a simple way to undo changes that haven’t been shared with anyone else. It’s your go-to command when you’ve started working on a feature and find yourself thinking, “Oh crap, what am I doing? I should just start over.”</p>\n<p>In addition to moving the current branch, you can also get <code>git reset</code> to alter the staged snapshot and&#x2F;or the working directory by passing it one of the following flags:</p>\n<ul>\n<li><code>--soft</code> – The staged snapshot and working directory are not altered in any way.</li>\n<li><code>--mixed</code> – The staged snapshot is updated to match the specified commit, but the working directory is not affected. This is the default option.</li>\n<li><code>--hard</code> – The staged snapshot and the working directory are both updated to match the specified commit.</li>\n</ul>\n<p>It’s easier to think of these modes as defining the scope of a <code>git reset</code> operation. For further detailed information visit the <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code> page.</p>\n<h3 id=\"Checkout-old-commits\"><a href=\"#Checkout-old-commits\" class=\"headerlink\" title=\"Checkout old commits\"></a>Checkout old commits</h3><p>The <code>git checkout</code> command is used to update the state of the repository to a specific point in the projects history. When passed with a branch name, it lets you switch between branches.</p>\n<p> <code>git checkout hotfix</code></p>\n<p>Internally, all the above command does is move <code>HEAD</code> to a different branch and update the working directory to match. Since this has the potential to overwrite local changes, Git forces you to commit or <a href=\"https://www.atlassian.com/git/tutorials/saving-changes/git-stash\">stash</a> any changes in the working directory that will be lost during the checkout operation. Unlike <code>git reset</code>, <code>git checkout</code> doesn’t move any branches around.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:7dffc21e-29c6-4bfd-acd1-2965fcdd923e/05-06%20Checkout%20old%20commits.png?cdnVersion=116\" alt=\"Moving HEAD from master to hotfix\"></p>\n<p>You can also check out arbitrary commits by passing the commit reference instead of a branch. This does the exact same thing as checking out a branch: it moves the <code>HEAD</code> reference to the specified commit. For example, the following command will check out the grandparent of the current commit:</p>\n<p> <code>git checkout HEAD~2</code></p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:9b4d9562-7ed1-441c-bbd1-1897bea5676e/07.svg?cdnVersion=116\" alt=\"Moving `HEAD` to an arbitrary commit\"></p>\n<p>This is useful for quickly inspecting an old version of your project. However, since there is no branch reference to the current <code>HEAD</code>, this puts you in a detached <code>HEAD</code> state. This can be dangerous if you start adding new commits because there will be no way to get back to them after you switch to another branch. For this reason, you should always create a new branch before adding commits to a detached <code>HEAD</code>.</p>\n<h3 id=\"Undo-Public-Commits-with-Revert\"><a href=\"#Undo-Public-Commits-with-Revert\" class=\"headerlink\" title=\"Undo Public Commits with Revert\"></a>Undo Public Commits with Revert</h3><p>Reverting undoes a commit by creating a new commit. This is a safe way to undo changes, as it has no chance of re-writing the commit history. For example, the following command will figure out the changes contained in the 2nd to last commit, create a new commit undoing those changes, and tack the new commit onto the existing project.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout hotfix git revert HEAD~2<br></code></pre></td></tr></table></figure>\n\n<p>This can be visualized as the following:</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:f02c67ca-d7b8-47f8-98f8-e0017dc9f7c5/08-09%20Undo%20public%20commits.svg?cdnVersion=116\" alt=\"Reverting the 2nd to last commit\"></p>\n<p>Contrast this with <code>git reset</code>, which <em>does</em> alter the existing commit history. For this reason, <code>git revert</code> should be used to undo changes on a public branch, and <code>git reset</code> should be reserved for undoing changes on a private branch.</p>\n<p>You can also think of <code>git revert</code> as a tool for undoing _committed_changes, while <code>git reset HEAD</code> is for undoing _uncommitted_changes.</p>\n<p>Like <code>git checkout</code>, <code>git revert</code> has the potential to overwrite files in the working directory, so it will ask you to commit or <a href=\"https://www.atlassian.com/git/tutorials/saving-changes/git-stash\">stash changes</a> that would be lost during the revert operation.</p>\n<h2 id=\"File-level-Operations\"><a href=\"#File-level-Operations\" class=\"headerlink\" title=\"File-level Operations\"></a>File-level Operations</h2><p>The <code>git reset</code> and <code>git checkout</code> commands also accept an optional file path as a parameter. This dramatically alters their behavior. Instead of operating on entire snapshots, this forces them to limit their operations to a single file.</p>\n<h3 id=\"Git-Reset-A-Specific-File\"><a href=\"#Git-Reset-A-Specific-File\" class=\"headerlink\" title=\"Git Reset A Specific File\"></a>Git Reset A Specific File</h3><p>When invoked with a file path, <code>git reset</code> updates the <em>staged snapshot</em> to match the version from the specified commit. For example, this command will fetch the version of <code>foo.py</code> in the 2nd-to-last commit and stage it for the next commit:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git reset HEAD~2 foo.py<br></code></pre></td></tr></table></figure>\n\n<p>As with the commit-level version of <code>git reset</code>, this is more commonly used with <code>HEAD</code> rather than an arbitrary commit. Running <code>git reset HEAD foo.py</code> will unstage <code>foo.py</code>. The changes it contains will still be present in the working directory.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:1a010f5a-c90d-49ee-a0e6-31054433e2d4/07.svg?cdnVersion=116\" alt=\"Moving a file from the commit history into the staged snapshot\"></p>\n<p>The <code>--soft</code>, <code>--mixed</code>, and <code>--hard</code> flags do not have any effect on the file-level version of <code>git reset</code>, as the staged snapshot is <em>always</em> updated, and the working directory is <em>never</em> updated.</p>\n<h3 id=\"Git-Checkout-File\"><a href=\"#Git-Checkout-File\" class=\"headerlink\" title=\"Git Checkout File\"></a>Git Checkout File</h3><p>Checking out a file is similar to using <code>git reset</code> with a file path, except it updates the <em>working directory</em> instead of the stage. Unlike the commit-level version of this command, this does not move the <code>HEAD</code> reference, which means that you won’t switch branches.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:cc252fc0-fc76-4740-8458-9c0d7af94bca/08.svg?cdnVersion=116\" alt=\"Moving a file from the commit history into the working directory\"></p>\n<p>For example, the following command makes <code>foo.py</code> in the working directory match the one from the 2nd-to-last commit:<br><strong>（要将特定的文件而不是所有文件退回某个版本时）</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout HEAD~2 foo.py<br></code></pre></td></tr></table></figure>\n\n<p>Just like the commit-level invocation of <code>git checkout</code>, this can be used to inspect old versions of a project—but the scope is limited to the specified file.</p>\n<p>If you stage and commit the checked-out file, this has the effect of “reverting” to the old version of that file. Note that this removes <em>all</em> of the subsequent changes to the file, whereas the <code>git revert</code> command undoes only the changes introduced by the specified commit.</p>\n<p>Like <code>git reset</code>, this is commonly used with <code>HEAD</code> as the commit reference. For instance, <code>git checkout HEAD foo.py</code> has the effect of discarding unstaged changes to <code>foo.py</code>. This is similar behavior to <code>git reset HEAD --hard</code>, but it operates only on the specified file.</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>You should now have all the tools you could ever need to undo changes in a Git repository. The <code>[git reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset)</code>, <code>[git checkout](https://www.atlassian.com/git/tutorials/using-branches/git-checkout)</code>, and <code>[git revert](https://www.atlassian.com/git/tutorials/undoing-changes/git-revert)</code>commands can be confusing, but when you think about their effects on the working directory, staged snapshot, and commit history, it should be easier to discern which command fits the development task at hand.</p>\n"},{"title":"Git 大小写不敏感引发的问题","date":"2022-04-07T15:35:27.000Z","description":"Git相关文档","_content":"\n# Git 大小写不敏感引发的问题\n\n![【Git系列】Git 大小写不敏感引发的血案](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2eae29e98142dfb3584c2317e9328a~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image)\n\n## 前言\n\n> 由于当年太年轻，资历不够深！！！导致文件命名不规范，现在想更正文件夹名字（`common => COMMON`），结果发现一个很奇特的现象！ git 对文件(夹)名的大小写不敏感！！！！引发了一些问题。最终经过查阅资料得以解决，遂！写下这篇帖子记录一下。走~跟着渣渣一起吃着花生 🥜 喝着啤酒 🍺 燥起来~\n\n![13.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c755d04984c446708721485b8bff8d28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## demo 部分目录结构\n\n- `master` 分支的代码及文件目录情况\n\n  ```bash\n  # master分支原始目录\n  .\n  ├── main.js\n  └── src\n      └── components\n          └── common\n              ├── FootCell\n              │   └── index.vue\n              ├── Pagination\n              │   └── index.vue\n              ├── Table\n              │   └── index.vue\n              └── TitleCell\n                  └── index.vue\n  ```\n  \n  ```js\n  // main.js\n  const files = require.context('../components/common', true, /\\.vue$/)\n  ```\n\n## 准备工作\n\n### 模拟多用户\n\n- `user1` 分支：`feature/user1`\n\n- `user2` 分支：`feature/user2`\n\n  此时分别有两个用户`user1`和`user2`在各自的电脑上拉取了这个项目。\n\n# 骚操作开始 第一种\n\n> 文件名的变更未同步到远端，但是引用路径却同步到远端了！\n\n- `user1` 不知道 `git` 大小写不敏感,`user2` 可知可不知，反正最后都!会!知!道!!!\n\n  ![09.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22443ba58c794d919058c0879836bfad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## [user1]向远端同步变更\n\n### 更改文件名 + 更改引用路径\n\n> 因为 这里 `git` 大小写不敏感所以只进行文件名变更(大小写)的话，不会被 `git` 检测到，所以必须要改动一个文件，让 `git` 检测到变更。才能进行`commit`!刚好文件名的变更导致了引用路径也需要变更！因此本次可以进行提交\n\n- 由于被绿太狠了，心情不太好就开始了骚操作坑队友！`common => COMMON`结果如下：\n\n  ```bash\n    # common => COMMON\n    .\n    ├── main.js\n    └── src\n        └── components\n            └── COMMON\n                ├── FootCell\n                │   └── index.vue\n                ├── Pagination\n                │   └── index.vue\n                ├── Table\n                │   └── index.vue\n                └── TitleCell\n                    └── index.vue\n  复制代码\n  ```\n\n  ```js\n  // main.js\n  const files = require.context('../components/common', true, /\\.vue$/)\n  ```\n  \n\n最后并把代码提交到了远端,并且告诉 `user2` 代码有更新\n\n## [user2]的响应\n\n### `pull` 代码\n\n- `user2`于是乎就先`pull`然后`merge`了一下，把 `user1` 的代码同步到自己的分支，结果如下：\n\n  ```bash\n    # 此时 common => common 没有变化！！！\n    .\n    ├── main.js\n    └── src\n        └── components\n            └── common\n                ├── FootCell\n                │   └── index.vue\n                ├── Pagination\n                │   └── index.vue\n                ├── Table\n                │   └── index.vue\n                └── TitleCell\n                    └── index.vue\n  ```\n  \n```js\n  // main.js 有变化！！！\n  const files = require.context('../components/COMMON', true, /\\.vue$/)\n```\n\n  这个时候，“~~报应~~”来的太突然，项目报错了！引用的路径是`COMMON`而实际项目的路径是`common`\n\n  ![18.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a073f83286924f99bf704bead00db36e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n- 然后`user2`就好奇为啥会是这种情况,文件名没有变化？？于是乎开启了探索之路~~\n\n### 探索问题\n\n> 因为`user1`被绿了一波，心情不好搞事情，害得`user2`引发了 bug，但是刚好激发了`user2`的好奇心。\n\n- 为啥`user1`的是 `COMMON`,到我这里是 `common`？？？\n\n  最后`user2`查到了答案！ 原来是 `git` 对文件名的大小写不敏感，才会引发这个问题。好了那么接下来就是这么去解决这个问题呢？？\n\n**温馨提示**\n\n> 因为 `git` 默认不区分大小写，所以如果只更改文件名的话 `git` 并不会检测到文件有变化，固！无法进行 `commit`，所有这次测试在更改文件名的时候附带的改动了其他地方，以便提交！\n\n### 解决问题\n\n既然`user2`已经知道了 `git` 默认大小写不敏感，那就让他敏感呗。多简单！\n\n## [user2]更新变更\n\n### 1. 开启 敏感模式\n\n```bash\ngit config core.ignorecase false # 让你变的敏感\n```\n\n![21.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bcd4ced859947e79225ba37c62c01b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n> 其实`user1`压根就没有把文件名更改同步到到远端!(所以开头才说，他不知道 `git` 大小写不敏感!但是文件引用路径变更了，这个就导致其他人`(user2)`因为文件路径改变导致项目报错)\n\n### 2. 切换分支，拉取最新代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git che master\n  ```\n  \n- 拉代码 `pull`\n\n  ```bash\n  git pull\n  ```\n  \n> 这个时候就会发现项目无法启动，因为 `main.js` 中的文件路径引用已经由 `common => COMMON` 了，但实际文件名依旧是 `common`\n\n### 3. 手动更改文件名\n\n- `common` => `COMMON`\n\n  ![19_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/19_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n### 4. 暂存、提交、push、切分支、merge 到 feature/user2 分支\n\n- 暂存 `add`\n\n  ```bash\n  git add .\n  ```\n  \n- 提交 `commit`\n\n  ```bash\n  git commit -m user2手动同步更新文件名\n  ```\n  \n  ![20_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6c3930f274425b8a8f7e851d6d1a15~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n- 推送 `push`\n\n  ```bash\n  # 这一步是替user1，将文件名变更同步到远端，供user3……等使用\n  #（此时如果其他用户是之前拉取的分支那么也会出现本篇文章所描述的问题！）\n  # 方法嘛~~ 就是当前文章~~哈哈哈\n  git push\n  ```\n  \n- 切分支 `checkout`\n\n  ```bash\n  git che feature/user2\n  ```\n  \n  ![08_D_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1bcad27960452eb1a6c49ae8b58c9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n  ![09_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61453f98e4ea4a508027ecc39cbae4cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n- `merge` master 到 `feature/user2` 分支\n\n  ```bash\n  git merge master\n  ```\n  \n\n![10_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5949cfb1676b41ef9d44b58f3f173259~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811b5a7041f54b08a2b4b0ab47be5460~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 查看 `commit` 记录\n\n![12_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d3ab1becd9c45c3b9caeba5a2b1c3be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n# 骚操作开始 第二种\n\n> 文件名变更实际已经同步到远端了，且引用路径也同步到了远端！\n\n- 这次`user1` 知道 `git` 大小写不敏感, `user2` 同样可知可不知，于是一开始就逼迫她，让她变得敏感再敏感！\n\n  ![16.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490d0d4ad6094906b2265b12dde0797f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## [user1]向远端同步变更\n\n- `user1` 的分支：`feature/user1`\n\n### 1. 让她敏感敏感再敏感\n\n```bash\ngit config core.ignorecase false # emmmmm……俺敏感了\n```\n\n### 2. 更改文件名 & 文件引用路径\n\n- `common => COMMON`\n\n- 更改引用路径\n\n  ```js\n  // 旧\n  const files = require.context('../components/common', true, /\\.vue$/)\n  \n  // 新\n  const files = require.context('../components/COMMON', true, /\\.vue$/)\n  ```\n\n### 3. 暂存（add）& 提交(commit)\n\n- 暂存 `add`\n\n  ```bash\n  git add .\n  ```\n  \n- 提交 `commit`\n\n  ```bash\n  git commit -m <msg>\n  ```\n\n### 4. 切换分支\n\n- `git checkout master`\n\n  ![08_D_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n  ![09_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd6b53edeb94401c877e27e2ab7d397d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 4.merge 到 master 并 pull 向远端\n\n- `merge` 结果如下：\n\n  ```bash\n  git merge feature/user1 # user1的分支合并到本地master\n  ```\n  \n  ![10_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0411bb699b343a9a588d424481eb5ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n  ![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3bc59c816414a0d81c6b08ce98b8fe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n- 推送 `push`\n\n  ```bash\n  git push # 推送到远端master\n  ```\n\n## [user2]更新变更\n\n- `user2` 的分支：`feature/user2`\n\n### 1. 开启 敏感模式·情况一\n\n```bash\ngit config core.ignorecase false\n```\n\n### 2. 切分支 & pull 代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout master\n  ```\n  \n- 拉代码 `pull`\n\n  ```bash\n  git pull # 更新 master 分支\n  ```\n  \n- 结果如下：\n\n  ```bash\n  # 结果 error\n  KaKa:test2  xxx$ git pull\n  更新 5f318b9..5174f2e\n  error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n          src/components/COMMON/FootCell/index.vue\n          src/components/COMMON/Pagination/index.vue\n          src/components/COMMON/Table/index.vue\n          src/components/COMMON/TitleCell/index.vue\n  请在合并前移动或删除。\n  正在终止\n  ```\n  \n  > 注意！上面那个问题一旦触发，那么你接下来所有的操作比如 `check`,`switch`,`pull`等操作都会报这个错误！！\n\n  其实上面已经告诉你怎么操作了，按照提示 `删除`或者`移动`原有的`common文件夹`,然后再`pull`(`check`,`switch`)即可解决\n\n  - 结果如下图：\n\n    `common`文件名已经变更为`COMMON`\n\n    ![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34243070d2a24aeca70341c0df0b05d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 3. 切换分支 & merge 代码\n\n如果上一步问题解决了那么这一步就没什么异常了，`user2` 的分支代码已经被更新了\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout feature/user2\n  ```\n  \n- `merge` 代码\n\n  ```bash\n  git merge master # 更新 feature/user2 分支\n  ```\n\n### 4 查看 `commit` 记录\n\n- 如下图：\n\n  ![15_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n### 5 恭喜同步成功\n\n![33.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ade974c64e4ad19f2fe72f6d90886c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 1 关闭 敏感模式·情况二\n\n```bash\ngit config core.ignorecase true # git 默认不敏感\n```\n\n### 2. 切分支 & pull 代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout master\n  ```\n  \n- 拉代码 `pull`\n\n  ```bash\n  git pull # 更新 master 分支\n  ```\n  \n\n结果如下图：\n\n![13_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4aa62317a0d45b996b4346f0c55bc28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n惊不惊喜意不意外？\n\n![40.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637c79a4d8e244e7b1823eb5c6bb4e4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n虽然远端的文件名已经由`common` => `COMMON`,但是当`user2` 执行`pull`的时候本地的文件名依旧还是老的`common`\n\n### 3. 更改文件名、切换分支、merge master\n\n- 先更改文件名\n  `common` => `COMMON`\n\n- 再切换分支：\n\n  ```bash\n  git checkout feature/user2\n  ```\n  \n  `COMMON文件夹`变成空的了\n  \n  ![08_D_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n  \n  ![09_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/09_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n  \n- 最后执行 `merge` 后的变化如下：\n\n  ```bash\n  git merge master\n  ```\n  \n\n`COMMON文件夹`又有内容了\n\n![14_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f391d8a96f248bc962b63bede21d5fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 4. 查看 `commit`\n\n- 记录如下：\n\n  ![15_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n### 5. 恭喜同步成功\n\n![03.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c5e8f29c454bd6820cc72bf3de7417~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n# 另外一种方式 git rm\n\n- 删除文件夹 `rm`\n\n  ```bash\n  git rm <文件夹路径> -r # -r 表示递归\n  ```\n  \n- 删除文件 `rm`\n\n  ```bash\n  git rm <文件路径>\n  ```\n\n## [user1]向远端同步变更\n\n### 1. 开启 敏感模式·情况一\n\n```bash\ngit config core.ignorecase false\n```\n\n### 2. 制作副本\n\n```\ncommon` => `common copy\n```\n\n复制副本以后不能直接将 `common copy` 改成 `COMMON` (此时 `common` 还存在)\n\n### 3. 使用 rm 删除 common 文件夹\n\n```bash\n git rm ./src/components/common -r # -r 表示递归\n```\n\n### 4. 还原名字\n\n- `common copy` => `COMMON`\n\n  看到这里有的同学该问了为啥不拷贝副本 `common copy` 以后立马直接对其变更名字(`common copy => COMMON`),然后执行`第3步`操作呢？？？？问的好啊。鼓掌 👏\n\n  ![16_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11277325b5004da78d9b5c49d802515e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n  看到这个结果·····\n\n  ![06.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e312d8e54524e1bbde83ea6add468a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n  其实本人也是很想这么操作的，可是现在回头想想，在不区分大小写的情况下:\n\n  ```js\n  common === COMMON // true,\n  ```\n  \n\n所以上面的提示是没有问题的 我个人认为\n\n### 5. 暂存、commit、merge 到 master、推到远端\n\n在这一步 你将遇到如下错误信息导致切换分支失败 (跟上面的还不太一样)\n\n- `check` 出问题\n\n  ```bash\n  KaKa:test xxxx$ git che master\n  \n  error: 工作区中下列未跟踪的文件将会因为检出操作而被覆盖：\n          src/components/common/FootCell/index.vue\n          src/components/common/Pagination/index.vue\n          src/components/common/Table/index.vue\n          src/components/common/TitleCell/index.vue\n  请在切换分支前移动或删除。\n  正在终止\n  ```\n  \n  此时的项目结构是这样子的：\n  \n  ~~~bash\n  .\n  ├── README.md\n  ├── main.js\n  └── src\n      └── components\n          └── COMMON  <= # 重点！这里!!! 并没有 common\n              ├── FootCell\n              │   └── index.vue\n              ├── Pagination\n              │   └── index.vue\n              ├── Table\n              │   └── index.vue\n              └── TitleCell\n                  └── index.vue\n  ~~~\n  \n  并没有`common`文件夹！!那么就无解了？？但是否定的！那我们就:\n  \n  - 把`COMMON`=> `common`\n  \n  - 再删除`common`\n  \n    ![22_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/22_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)![23_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34a54996c1047b1ad5323ac80d6eb63~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n  - 最后执行 `git check master`\n  \n  忽略执行删除后的文件变更，直接 `git checkout master`\n  \n- `merge` 出问题\n\n  ```bash\n  KaKa-3:test xxxx$ git merge feature/user1\n  \n  更新 5f318b9..24b399d\n  error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n          src/components/COMMON/FootCell/index.vue\n          src/components/COMMON/Pagination/index.vue\n          src/components/COMMON/Table/index.vue\n          src/components/COMMON/TitleCell/index.vue\n  请在合并前移动或删除。\n  正在终止\n  ```\n  \n  并没有`COMMON`,处理方法同上:\n  \n  - 把`common`=> `COMMON`\n  - 再删除`COMMON`\n    ![24_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/24_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)![23_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb8b56621944f0da593a1f6e99e3477~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  - 最后`git merge feature/user1`就可以了~\n\n### 6. 查看 `commit` 记录\n\n- 如下图： ![17_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a361ed790bf94b7691f468c63c080841~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 1. 关闭 敏感模式·情况二\n\n```bash\ngit config core.ignorecase true\n```\n\n### 2. 更改文件名\n\n- `common` => `COMMON`\n\n  然而尴尬的一幕它发生了！！！如下图：\n\n  ![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928907269477471d856d2496dce8e50e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n  ![10_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/10_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n  卧槽！ `Git` 并没有检测到 文件有变化！\n\n### 3. 卒!\n\n- 这种情况要么放弃，要么开启敏感模式！如果开启那就是`情况一`了\n\n  ![46.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e41e7a1c4e5c4673ac3a42d6bdf680ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## [user2]更新变更\n\n- 此时 `user2`的`master` 分支初始目录如下：\n\n  ```bash\n  .\n  ├── README.md\n  ├── main.js\n  └── src\n      └── components\n          └── common\n              ├── FootCell\n              │   └── index.vue\n              ├── Pagination\n              │   └── index.vue\n              ├── Table\n              │   └── index.vue\n              └── TitleCell\n                  └── index.vue\n  ```\n\n### 1. 开启 敏感模式·情况一\n\n```bash\ngit config core.ignorecase false\n```\n\n### 2. pull 最新代码\n\n```bash\nKaKa:test2  xxxx$ git pull\n更新 5f318b9..24b399d\nerror: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n        src/components/COMMON/FootCell/index.vue\n        src/components/COMMON/Pagination/index.vue\n        src/components/COMMON/Table/index.vue\n        src/components/COMMON/TitleCell/index.vue\n请在合并前移动或删除。\n正在终止\n```\n\n不出所料 会跟开头讲的 状况一致，这里就不重复赘述了，参考上面的即可解决。\n\n### 3. 查看 `commit` 记录\n\n- 如下图:\n\n  ![17_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc4f8cfc7d548b9801ea7fb7f854e72~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 1. 关闭 敏感模式·情况二\n\n```bash\ngit config core.ignorecase true\n```\n\n### 2. `pull` 最新代码\n\n- 如下图\n\n  ![18_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/18_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n  同前面所说,变更都过来了，唯独文件名由于本地的大小写不敏感，所以没有自动变更名字\n\n### 3. 手动更改文件名\n\n```\ncommon` => `COMMON\n```\n\n### 4. 切换分支，mer master 代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout feature/user2\n  ```\n  \n- `merge` 代码\n\n  ```bash\n  git merge master\n  ```\n\n### 5. 查看 `commit` 记录\n\n- 如下图:\n\n  ![17_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/17_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n## 总结\n\n综上的出来的结论就是多人协作开发的时候存在已下情况\n\n- 第一种方式 `user1` 两种， `user2` 两种，总共四种情况。且文件都被标记为A\n\n  - 都未开启敏感模式（绝大多数都是这个情况）\n    这种情况可想而知，远端的文件名一直都是 common 而非 COMMON，所有人乃至以后都会一直存在这个问题（自己本地需要去手动的更改文件名），\n  - 都开启了敏感模式\n    这种情况 `user2` 在同步更新 `master` 分支代码的时候会遇到 `error`，根据提示删除或移动文件位置即可！（删除最简单直观）\n  - 修改方(`user1`)开起了敏感模式，被通知方(`user2`)未开启 虽然文件名已经被改动且同步到了远端，但是当 user2 （master）拉取的时候会发现自己本地的文件名依旧是 common 未改动。这个时候只需要手动的去更改文件名，然后 `merge` 到 `user2` 的分支即可\n  - 修改方(`user1`)未开启敏感模式，被通知方(`user2`)开启了\n    `user1` 自以为文件名已经更改成功且同步到了远端，实际并没有同步到远端，`user2` 自己手动更改，更改后 `push` 到远端，这样所有人的文件引用路径错误问题都能得到解决\n\n- 第二种方式\n\n  通过`git rm` 这个操作来处理。通过这种方式变更文件会被标记为R\n\n## 结束语\n\n已上所有内容都是经过好几遍测试，一遍实践一遍记录的形式来撰写的，最后也反复检查了好几遍，目测没有什么问题，如果有问题了就请留言告知吧~\n\n![47.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b9c2f3777647d1a0650f753e57cfd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)","source":"_posts/Git/Git大小写默认不敏感.md","raw":"---\ntitle: Git 大小写不敏感引发的问题\ndate: 2022-04-07 23:35:27\ntags:\n  - [git]\ncategories:\n  - [技术]\ndescription: Git相关文档\n---\n\n# Git 大小写不敏感引发的问题\n\n![【Git系列】Git 大小写不敏感引发的血案](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2eae29e98142dfb3584c2317e9328a~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image)\n\n## 前言\n\n> 由于当年太年轻，资历不够深！！！导致文件命名不规范，现在想更正文件夹名字（`common => COMMON`），结果发现一个很奇特的现象！ git 对文件(夹)名的大小写不敏感！！！！引发了一些问题。最终经过查阅资料得以解决，遂！写下这篇帖子记录一下。走~跟着渣渣一起吃着花生 🥜 喝着啤酒 🍺 燥起来~\n\n![13.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c755d04984c446708721485b8bff8d28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## demo 部分目录结构\n\n- `master` 分支的代码及文件目录情况\n\n  ```bash\n  # master分支原始目录\n  .\n  ├── main.js\n  └── src\n      └── components\n          └── common\n              ├── FootCell\n              │   └── index.vue\n              ├── Pagination\n              │   └── index.vue\n              ├── Table\n              │   └── index.vue\n              └── TitleCell\n                  └── index.vue\n  ```\n  \n  ```js\n  // main.js\n  const files = require.context('../components/common', true, /\\.vue$/)\n  ```\n\n## 准备工作\n\n### 模拟多用户\n\n- `user1` 分支：`feature/user1`\n\n- `user2` 分支：`feature/user2`\n\n  此时分别有两个用户`user1`和`user2`在各自的电脑上拉取了这个项目。\n\n# 骚操作开始 第一种\n\n> 文件名的变更未同步到远端，但是引用路径却同步到远端了！\n\n- `user1` 不知道 `git` 大小写不敏感,`user2` 可知可不知，反正最后都!会!知!道!!!\n\n  ![09.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22443ba58c794d919058c0879836bfad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## [user1]向远端同步变更\n\n### 更改文件名 + 更改引用路径\n\n> 因为 这里 `git` 大小写不敏感所以只进行文件名变更(大小写)的话，不会被 `git` 检测到，所以必须要改动一个文件，让 `git` 检测到变更。才能进行`commit`!刚好文件名的变更导致了引用路径也需要变更！因此本次可以进行提交\n\n- 由于被绿太狠了，心情不太好就开始了骚操作坑队友！`common => COMMON`结果如下：\n\n  ```bash\n    # common => COMMON\n    .\n    ├── main.js\n    └── src\n        └── components\n            └── COMMON\n                ├── FootCell\n                │   └── index.vue\n                ├── Pagination\n                │   └── index.vue\n                ├── Table\n                │   └── index.vue\n                └── TitleCell\n                    └── index.vue\n  复制代码\n  ```\n\n  ```js\n  // main.js\n  const files = require.context('../components/common', true, /\\.vue$/)\n  ```\n  \n\n最后并把代码提交到了远端,并且告诉 `user2` 代码有更新\n\n## [user2]的响应\n\n### `pull` 代码\n\n- `user2`于是乎就先`pull`然后`merge`了一下，把 `user1` 的代码同步到自己的分支，结果如下：\n\n  ```bash\n    # 此时 common => common 没有变化！！！\n    .\n    ├── main.js\n    └── src\n        └── components\n            └── common\n                ├── FootCell\n                │   └── index.vue\n                ├── Pagination\n                │   └── index.vue\n                ├── Table\n                │   └── index.vue\n                └── TitleCell\n                    └── index.vue\n  ```\n  \n```js\n  // main.js 有变化！！！\n  const files = require.context('../components/COMMON', true, /\\.vue$/)\n```\n\n  这个时候，“~~报应~~”来的太突然，项目报错了！引用的路径是`COMMON`而实际项目的路径是`common`\n\n  ![18.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a073f83286924f99bf704bead00db36e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n- 然后`user2`就好奇为啥会是这种情况,文件名没有变化？？于是乎开启了探索之路~~\n\n### 探索问题\n\n> 因为`user1`被绿了一波，心情不好搞事情，害得`user2`引发了 bug，但是刚好激发了`user2`的好奇心。\n\n- 为啥`user1`的是 `COMMON`,到我这里是 `common`？？？\n\n  最后`user2`查到了答案！ 原来是 `git` 对文件名的大小写不敏感，才会引发这个问题。好了那么接下来就是这么去解决这个问题呢？？\n\n**温馨提示**\n\n> 因为 `git` 默认不区分大小写，所以如果只更改文件名的话 `git` 并不会检测到文件有变化，固！无法进行 `commit`，所有这次测试在更改文件名的时候附带的改动了其他地方，以便提交！\n\n### 解决问题\n\n既然`user2`已经知道了 `git` 默认大小写不敏感，那就让他敏感呗。多简单！\n\n## [user2]更新变更\n\n### 1. 开启 敏感模式\n\n```bash\ngit config core.ignorecase false # 让你变的敏感\n```\n\n![21.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bcd4ced859947e79225ba37c62c01b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n> 其实`user1`压根就没有把文件名更改同步到到远端!(所以开头才说，他不知道 `git` 大小写不敏感!但是文件引用路径变更了，这个就导致其他人`(user2)`因为文件路径改变导致项目报错)\n\n### 2. 切换分支，拉取最新代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git che master\n  ```\n  \n- 拉代码 `pull`\n\n  ```bash\n  git pull\n  ```\n  \n> 这个时候就会发现项目无法启动，因为 `main.js` 中的文件路径引用已经由 `common => COMMON` 了，但实际文件名依旧是 `common`\n\n### 3. 手动更改文件名\n\n- `common` => `COMMON`\n\n  ![19_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/19_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n### 4. 暂存、提交、push、切分支、merge 到 feature/user2 分支\n\n- 暂存 `add`\n\n  ```bash\n  git add .\n  ```\n  \n- 提交 `commit`\n\n  ```bash\n  git commit -m user2手动同步更新文件名\n  ```\n  \n  ![20_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6c3930f274425b8a8f7e851d6d1a15~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n- 推送 `push`\n\n  ```bash\n  # 这一步是替user1，将文件名变更同步到远端，供user3……等使用\n  #（此时如果其他用户是之前拉取的分支那么也会出现本篇文章所描述的问题！）\n  # 方法嘛~~ 就是当前文章~~哈哈哈\n  git push\n  ```\n  \n- 切分支 `checkout`\n\n  ```bash\n  git che feature/user2\n  ```\n  \n  ![08_D_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1bcad27960452eb1a6c49ae8b58c9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n  ![09_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61453f98e4ea4a508027ecc39cbae4cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n- `merge` master 到 `feature/user2` 分支\n\n  ```bash\n  git merge master\n  ```\n  \n\n![10_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5949cfb1676b41ef9d44b58f3f173259~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811b5a7041f54b08a2b4b0ab47be5460~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 查看 `commit` 记录\n\n![12_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d3ab1becd9c45c3b9caeba5a2b1c3be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n# 骚操作开始 第二种\n\n> 文件名变更实际已经同步到远端了，且引用路径也同步到了远端！\n\n- 这次`user1` 知道 `git` 大小写不敏感, `user2` 同样可知可不知，于是一开始就逼迫她，让她变得敏感再敏感！\n\n  ![16.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490d0d4ad6094906b2265b12dde0797f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## [user1]向远端同步变更\n\n- `user1` 的分支：`feature/user1`\n\n### 1. 让她敏感敏感再敏感\n\n```bash\ngit config core.ignorecase false # emmmmm……俺敏感了\n```\n\n### 2. 更改文件名 & 文件引用路径\n\n- `common => COMMON`\n\n- 更改引用路径\n\n  ```js\n  // 旧\n  const files = require.context('../components/common', true, /\\.vue$/)\n  \n  // 新\n  const files = require.context('../components/COMMON', true, /\\.vue$/)\n  ```\n\n### 3. 暂存（add）& 提交(commit)\n\n- 暂存 `add`\n\n  ```bash\n  git add .\n  ```\n  \n- 提交 `commit`\n\n  ```bash\n  git commit -m <msg>\n  ```\n\n### 4. 切换分支\n\n- `git checkout master`\n\n  ![08_D_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n  ![09_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd6b53edeb94401c877e27e2ab7d397d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 4.merge 到 master 并 pull 向远端\n\n- `merge` 结果如下：\n\n  ```bash\n  git merge feature/user1 # user1的分支合并到本地master\n  ```\n  \n  ![10_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0411bb699b343a9a588d424481eb5ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n  ![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3bc59c816414a0d81c6b08ce98b8fe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n- 推送 `push`\n\n  ```bash\n  git push # 推送到远端master\n  ```\n\n## [user2]更新变更\n\n- `user2` 的分支：`feature/user2`\n\n### 1. 开启 敏感模式·情况一\n\n```bash\ngit config core.ignorecase false\n```\n\n### 2. 切分支 & pull 代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout master\n  ```\n  \n- 拉代码 `pull`\n\n  ```bash\n  git pull # 更新 master 分支\n  ```\n  \n- 结果如下：\n\n  ```bash\n  # 结果 error\n  KaKa:test2  xxx$ git pull\n  更新 5f318b9..5174f2e\n  error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n          src/components/COMMON/FootCell/index.vue\n          src/components/COMMON/Pagination/index.vue\n          src/components/COMMON/Table/index.vue\n          src/components/COMMON/TitleCell/index.vue\n  请在合并前移动或删除。\n  正在终止\n  ```\n  \n  > 注意！上面那个问题一旦触发，那么你接下来所有的操作比如 `check`,`switch`,`pull`等操作都会报这个错误！！\n\n  其实上面已经告诉你怎么操作了，按照提示 `删除`或者`移动`原有的`common文件夹`,然后再`pull`(`check`,`switch`)即可解决\n\n  - 结果如下图：\n\n    `common`文件名已经变更为`COMMON`\n\n    ![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34243070d2a24aeca70341c0df0b05d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 3. 切换分支 & merge 代码\n\n如果上一步问题解决了那么这一步就没什么异常了，`user2` 的分支代码已经被更新了\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout feature/user2\n  ```\n  \n- `merge` 代码\n\n  ```bash\n  git merge master # 更新 feature/user2 分支\n  ```\n\n### 4 查看 `commit` 记录\n\n- 如下图：\n\n  ![15_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n### 5 恭喜同步成功\n\n![33.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ade974c64e4ad19f2fe72f6d90886c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 1 关闭 敏感模式·情况二\n\n```bash\ngit config core.ignorecase true # git 默认不敏感\n```\n\n### 2. 切分支 & pull 代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout master\n  ```\n  \n- 拉代码 `pull`\n\n  ```bash\n  git pull # 更新 master 分支\n  ```\n  \n\n结果如下图：\n\n![13_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4aa62317a0d45b996b4346f0c55bc28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n惊不惊喜意不意外？\n\n![40.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637c79a4d8e244e7b1823eb5c6bb4e4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n虽然远端的文件名已经由`common` => `COMMON`,但是当`user2` 执行`pull`的时候本地的文件名依旧还是老的`common`\n\n### 3. 更改文件名、切换分支、merge master\n\n- 先更改文件名\n  `common` => `COMMON`\n\n- 再切换分支：\n\n  ```bash\n  git checkout feature/user2\n  ```\n  \n  `COMMON文件夹`变成空的了\n  \n  ![08_D_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n  \n  ![09_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/09_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n  \n- 最后执行 `merge` 后的变化如下：\n\n  ```bash\n  git merge master\n  ```\n  \n\n`COMMON文件夹`又有内容了\n\n![14_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f391d8a96f248bc962b63bede21d5fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 4. 查看 `commit`\n\n- 记录如下：\n\n  ![15_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n### 5. 恭喜同步成功\n\n![03.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c5e8f29c454bd6820cc72bf3de7417~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n# 另外一种方式 git rm\n\n- 删除文件夹 `rm`\n\n  ```bash\n  git rm <文件夹路径> -r # -r 表示递归\n  ```\n  \n- 删除文件 `rm`\n\n  ```bash\n  git rm <文件路径>\n  ```\n\n## [user1]向远端同步变更\n\n### 1. 开启 敏感模式·情况一\n\n```bash\ngit config core.ignorecase false\n```\n\n### 2. 制作副本\n\n```\ncommon` => `common copy\n```\n\n复制副本以后不能直接将 `common copy` 改成 `COMMON` (此时 `common` 还存在)\n\n### 3. 使用 rm 删除 common 文件夹\n\n```bash\n git rm ./src/components/common -r # -r 表示递归\n```\n\n### 4. 还原名字\n\n- `common copy` => `COMMON`\n\n  看到这里有的同学该问了为啥不拷贝副本 `common copy` 以后立马直接对其变更名字(`common copy => COMMON`),然后执行`第3步`操作呢？？？？问的好啊。鼓掌 👏\n\n  ![16_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11277325b5004da78d9b5c49d802515e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n  看到这个结果·····\n\n  ![06.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e312d8e54524e1bbde83ea6add468a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n  其实本人也是很想这么操作的，可是现在回头想想，在不区分大小写的情况下:\n\n  ```js\n  common === COMMON // true,\n  ```\n  \n\n所以上面的提示是没有问题的 我个人认为\n\n### 5. 暂存、commit、merge 到 master、推到远端\n\n在这一步 你将遇到如下错误信息导致切换分支失败 (跟上面的还不太一样)\n\n- `check` 出问题\n\n  ```bash\n  KaKa:test xxxx$ git che master\n  \n  error: 工作区中下列未跟踪的文件将会因为检出操作而被覆盖：\n          src/components/common/FootCell/index.vue\n          src/components/common/Pagination/index.vue\n          src/components/common/Table/index.vue\n          src/components/common/TitleCell/index.vue\n  请在切换分支前移动或删除。\n  正在终止\n  ```\n  \n  此时的项目结构是这样子的：\n  \n  ~~~bash\n  .\n  ├── README.md\n  ├── main.js\n  └── src\n      └── components\n          └── COMMON  <= # 重点！这里!!! 并没有 common\n              ├── FootCell\n              │   └── index.vue\n              ├── Pagination\n              │   └── index.vue\n              ├── Table\n              │   └── index.vue\n              └── TitleCell\n                  └── index.vue\n  ~~~\n  \n  并没有`common`文件夹！!那么就无解了？？但是否定的！那我们就:\n  \n  - 把`COMMON`=> `common`\n  \n  - 再删除`common`\n  \n    ![22_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/22_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)![23_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34a54996c1047b1ad5323ac80d6eb63~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  \n  - 最后执行 `git check master`\n  \n  忽略执行删除后的文件变更，直接 `git checkout master`\n  \n- `merge` 出问题\n\n  ```bash\n  KaKa-3:test xxxx$ git merge feature/user1\n  \n  更新 5f318b9..24b399d\n  error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n          src/components/COMMON/FootCell/index.vue\n          src/components/COMMON/Pagination/index.vue\n          src/components/COMMON/Table/index.vue\n          src/components/COMMON/TitleCell/index.vue\n  请在合并前移动或删除。\n  正在终止\n  ```\n  \n  并没有`COMMON`,处理方法同上:\n  \n  - 把`common`=> `COMMON`\n  - 再删除`COMMON`\n    ![24_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/24_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)![23_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb8b56621944f0da593a1f6e99e3477~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n  - 最后`git merge feature/user1`就可以了~\n\n### 6. 查看 `commit` 记录\n\n- 如下图： ![17_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a361ed790bf94b7691f468c63c080841~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 1. 关闭 敏感模式·情况二\n\n```bash\ngit config core.ignorecase true\n```\n\n### 2. 更改文件名\n\n- `common` => `COMMON`\n\n  然而尴尬的一幕它发生了！！！如下图：\n\n  ![11_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928907269477471d856d2496dce8e50e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n  ![10_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/10_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n  卧槽！ `Git` 并没有检测到 文件有变化！\n\n### 3. 卒!\n\n- 这种情况要么放弃，要么开启敏感模式！如果开启那就是`情况一`了\n\n  ![46.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e41e7a1c4e5c4673ac3a42d6bdf680ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n## [user2]更新变更\n\n- 此时 `user2`的`master` 分支初始目录如下：\n\n  ```bash\n  .\n  ├── README.md\n  ├── main.js\n  └── src\n      └── components\n          └── common\n              ├── FootCell\n              │   └── index.vue\n              ├── Pagination\n              │   └── index.vue\n              ├── Table\n              │   └── index.vue\n              └── TitleCell\n                  └── index.vue\n  ```\n\n### 1. 开启 敏感模式·情况一\n\n```bash\ngit config core.ignorecase false\n```\n\n### 2. pull 最新代码\n\n```bash\nKaKa:test2  xxxx$ git pull\n更新 5f318b9..24b399d\nerror: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n        src/components/COMMON/FootCell/index.vue\n        src/components/COMMON/Pagination/index.vue\n        src/components/COMMON/Table/index.vue\n        src/components/COMMON/TitleCell/index.vue\n请在合并前移动或删除。\n正在终止\n```\n\n不出所料 会跟开头讲的 状况一致，这里就不重复赘述了，参考上面的即可解决。\n\n### 3. 查看 `commit` 记录\n\n- 如下图:\n\n  ![17_git大小写不敏感引发的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc4f8cfc7d548b9801ea7fb7f854e72~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)\n\n### 1. 关闭 敏感模式·情况二\n\n```bash\ngit config core.ignorecase true\n```\n\n### 2. `pull` 最新代码\n\n- 如下图\n\n  ![18_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/18_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n  同前面所说,变更都过来了，唯独文件名由于本地的大小写不敏感，所以没有自动变更名字\n\n### 3. 手动更改文件名\n\n```\ncommon` => `COMMON\n```\n\n### 4. 切换分支，mer master 代码\n\n- 切分支 `checkout`\n\n  ```bash\n  git checkout feature/user2\n  ```\n  \n- `merge` 代码\n\n  ```bash\n  git merge master\n  ```\n\n### 5. 查看 `commit` 记录\n\n- 如下图:\n\n  ![17_git大小写不敏感引发的问题](https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/17_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png)\n\n## 总结\n\n综上的出来的结论就是多人协作开发的时候存在已下情况\n\n- 第一种方式 `user1` 两种， `user2` 两种，总共四种情况。且文件都被标记为A\n\n  - 都未开启敏感模式（绝大多数都是这个情况）\n    这种情况可想而知，远端的文件名一直都是 common 而非 COMMON，所有人乃至以后都会一直存在这个问题（自己本地需要去手动的更改文件名），\n  - 都开启了敏感模式\n    这种情况 `user2` 在同步更新 `master` 分支代码的时候会遇到 `error`，根据提示删除或移动文件位置即可！（删除最简单直观）\n  - 修改方(`user1`)开起了敏感模式，被通知方(`user2`)未开启 虽然文件名已经被改动且同步到了远端，但是当 user2 （master）拉取的时候会发现自己本地的文件名依旧是 common 未改动。这个时候只需要手动的去更改文件名，然后 `merge` 到 `user2` 的分支即可\n  - 修改方(`user1`)未开启敏感模式，被通知方(`user2`)开启了\n    `user1` 自以为文件名已经更改成功且同步到了远端，实际并没有同步到远端，`user2` 自己手动更改，更改后 `push` 到远端，这样所有人的文件引用路径错误问题都能得到解决\n\n- 第二种方式\n\n  通过`git rm` 这个操作来处理。通过这种方式变更文件会被标记为R\n\n## 结束语\n\n已上所有内容都是经过好几遍测试，一遍实践一遍记录的形式来撰写的，最后也反复检查了好几遍，目测没有什么问题，如果有问题了就请留言告知吧~\n\n![47.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b9c2f3777647d1a0650f753e57cfd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image)","slug":"Git/Git大小写默认不敏感","published":1,"updated":"2022-08-28T07:38:59.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i190002scvmc3isbfll","content":"<h1 id=\"Git-大小写不敏感引发的问题\"><a href=\"#Git-大小写不敏感引发的问题\" class=\"headerlink\" title=\"Git 大小写不敏感引发的问题\"></a>Git 大小写不敏感引发的问题</h1><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2eae29e98142dfb3584c2317e9328a~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image\" alt=\"【Git系列】Git 大小写不敏感引发的血案\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>由于当年太年轻，资历不够深！！！导致文件命名不规范，现在想更正文件夹名字（<code>common =&gt; COMMON</code>），结果发现一个很奇特的现象！ git 对文件(夹)名的大小写不敏感！！！！引发了一些问题。最终经过查阅资料得以解决，遂！写下这篇帖子记录一下。走<del>跟着渣渣一起吃着花生 🥜 喝着啤酒 🍺 燥起来</del></p>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c755d04984c446708721485b8bff8d28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"13.jpg\"></p>\n<h2 id=\"demo-部分目录结构\"><a href=\"#demo-部分目录结构\" class=\"headerlink\" title=\"demo 部分目录结构\"></a>demo 部分目录结构</h2><ul>\n<li><p><code>master</code> 分支的代码及文件目录情况</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># master分支原始目录</span><br>.<br>├── main.js<br>└── src<br>    └── components<br>        └── common<br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/common&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"模拟多用户\"><a href=\"#模拟多用户\" class=\"headerlink\" title=\"模拟多用户\"></a>模拟多用户</h3><ul>\n<li><p><code>user1</code> 分支：<code>feature/user1</code></p>\n</li>\n<li><p><code>user2</code> 分支：<code>feature/user2</code></p>\n<p>此时分别有两个用户<code>user1</code>和<code>user2</code>在各自的电脑上拉取了这个项目。</p>\n</li>\n</ul>\n<h1 id=\"骚操作开始-第一种\"><a href=\"#骚操作开始-第一种\" class=\"headerlink\" title=\"骚操作开始 第一种\"></a>骚操作开始 第一种</h1><blockquote>\n<p>文件名的变更未同步到远端，但是引用路径却同步到远端了！</p>\n</blockquote>\n<ul>\n<li><p><code>user1</code> 不知道 <code>git</code> 大小写不敏感,<code>user2</code> 可知可不知，反正最后都!会!知!道!!!</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22443ba58c794d919058c0879836bfad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"09.gif\"></p>\n</li>\n</ul>\n<h2 id=\"user1-向远端同步变更\"><a href=\"#user1-向远端同步变更\" class=\"headerlink\" title=\"[user1]向远端同步变更\"></a>[user1]向远端同步变更</h2><h3 id=\"更改文件名-更改引用路径\"><a href=\"#更改文件名-更改引用路径\" class=\"headerlink\" title=\"更改文件名 + 更改引用路径\"></a>更改文件名 + 更改引用路径</h3><blockquote>\n<p>因为 这里 <code>git</code> 大小写不敏感所以只进行文件名变更(大小写)的话，不会被 <code>git</code> 检测到，所以必须要改动一个文件，让 <code>git</code> 检测到变更。才能进行<code>commit</code>!刚好文件名的变更导致了引用路径也需要变更！因此本次可以进行提交</p>\n</blockquote>\n<ul>\n<li><p>由于被绿太狠了，心情不太好就开始了骚操作坑队友！<code>common =&gt; COMMON</code>结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">  <span class=\"hljs-comment\"># common =&gt; COMMON</span><br>  .<br>  ├── main.js<br>  └── src<br>      └── components<br>          └── COMMON<br>              ├── FootCell<br>              │   └── index.vue<br>              ├── Pagination<br>              │   └── index.vue<br>              ├── Table<br>              │   └── index.vue<br>              └── TitleCell<br>                  └── index.vue<br>复制代码<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/common&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>最后并把代码提交到了远端,并且告诉 <code>user2</code> 代码有更新</p>\n<h2 id=\"user2-的响应\"><a href=\"#user2-的响应\" class=\"headerlink\" title=\"[user2]的响应\"></a>[user2]的响应</h2><h3 id=\"pull-代码\"><a href=\"#pull-代码\" class=\"headerlink\" title=\"pull 代码\"></a><code>pull</code> 代码</h3><ul>\n<li><p><code>user2</code>于是乎就先<code>pull</code>然后<code>merge</code>了一下，把 <code>user1</code> 的代码同步到自己的分支，结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 此时 common =&gt; common 没有变化！！！</span><br>.<br>├── main.js<br>└── src<br>    └── components<br>        └── common<br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js 有变化！！！</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/COMMON&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure>\n\n<p>  这个时候，“<del>报应</del>”来的太突然，项目报错了！引用的路径是<code>COMMON</code>而实际项目的路径是<code>common</code></p>\n<p>  <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a073f83286924f99bf704bead00db36e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"18.jpg\"></p>\n<ul>\n<li>然后<code>user2</code>就好奇为啥会是这种情况,文件名没有变化？？于是乎开启了探索之路~~</li>\n</ul>\n<h3 id=\"探索问题\"><a href=\"#探索问题\" class=\"headerlink\" title=\"探索问题\"></a>探索问题</h3><blockquote>\n<p>因为<code>user1</code>被绿了一波，心情不好搞事情，害得<code>user2</code>引发了 bug，但是刚好激发了<code>user2</code>的好奇心。</p>\n</blockquote>\n<ul>\n<li><p>为啥<code>user1</code>的是 <code>COMMON</code>,到我这里是 <code>common</code>？？？</p>\n<p>最后<code>user2</code>查到了答案！ 原来是 <code>git</code> 对文件名的大小写不敏感，才会引发这个问题。好了那么接下来就是这么去解决这个问题呢？？</p>\n</li>\n</ul>\n<p><strong>温馨提示</strong></p>\n<blockquote>\n<p>因为 <code>git</code> 默认不区分大小写，所以如果只更改文件名的话 <code>git</code> 并不会检测到文件有变化，固！无法进行 <code>commit</code>，所有这次测试在更改文件名的时候附带的改动了其他地方，以便提交！</p>\n</blockquote>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>既然<code>user2</code>已经知道了 <code>git</code> 默认大小写不敏感，那就让他敏感呗。多简单！</p>\n<h2 id=\"user2-更新变更\"><a href=\"#user2-更新变更\" class=\"headerlink\" title=\"[user2]更新变更\"></a>[user2]更新变更</h2><h3 id=\"1-开启-敏感模式\"><a href=\"#1-开启-敏感模式\" class=\"headerlink\" title=\"1. 开启 敏感模式\"></a>1. 开启 敏感模式</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\"># 让你变的敏感</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bcd4ced859947e79225ba37c62c01b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"21.jpg\"></p>\n<blockquote>\n<p>其实<code>user1</code>压根就没有把文件名更改同步到到远端!(所以开头才说，他不知道 <code>git</code> 大小写不敏感!但是文件引用路径变更了，这个就导致其他人<code>(user2)</code>因为文件路径改变导致项目报错)</p>\n</blockquote>\n<h3 id=\"2-切换分支，拉取最新代码\"><a href=\"#2-切换分支，拉取最新代码\" class=\"headerlink\" title=\"2. 切换分支，拉取最新代码\"></a>2. 切换分支，拉取最新代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git che master<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>拉代码 <code>pull</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git pull<br></code></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>这个时候就会发现项目无法启动，因为 <code>main.js</code> 中的文件路径引用已经由 <code>common =&gt; COMMON</code> 了，但实际文件名依旧是 <code>common</code></p>\n</blockquote>\n<h3 id=\"3-手动更改文件名\"><a href=\"#3-手动更改文件名\" class=\"headerlink\" title=\"3. 手动更改文件名\"></a>3. 手动更改文件名</h3><ul>\n<li><p><code>common</code> &#x3D;&gt; <code>COMMON</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/19_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"19_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"4-暂存、提交、push、切分支、merge-到-feature-x2F-user2-分支\"><a href=\"#4-暂存、提交、push、切分支、merge-到-feature-x2F-user2-分支\" class=\"headerlink\" title=\"4. 暂存、提交、push、切分支、merge 到 feature&#x2F;user2 分支\"></a>4. 暂存、提交、push、切分支、merge 到 feature&#x2F;user2 分支</h3><ul>\n<li><p>暂存 <code>add</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add .<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>提交 <code>commit</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m user2手动同步更新文件名<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6c3930f274425b8a8f7e851d6d1a15~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"20_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>推送 <code>push</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 这一步是替user1，将文件名变更同步到远端，供user3……等使用</span><br><span class=\"hljs-comment\">#（此时如果其他用户是之前拉取的分支那么也会出现本篇文章所描述的问题！）</span><br><span class=\"hljs-comment\"># 方法嘛~~ 就是当前文章~~哈哈哈</span><br>git push<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git che feature/user2<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1bcad27960452eb1a6c49ae8b58c9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"08_D_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61453f98e4ea4a508027ecc39cbae4cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"09_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p><code>merge</code> master 到 <code>feature/user2</code> 分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5949cfb1676b41ef9d44b58f3f173259~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"10_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811b5a7041f54b08a2b4b0ab47be5460~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n<h3 id=\"查看-commit-记录\"><a href=\"#查看-commit-记录\" class=\"headerlink\" title=\"查看 commit 记录\"></a>查看 <code>commit</code> 记录</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d3ab1becd9c45c3b9caeba5a2b1c3be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"12_git大小写不敏感引发的问题\"></p>\n<h1 id=\"骚操作开始-第二种\"><a href=\"#骚操作开始-第二种\" class=\"headerlink\" title=\"骚操作开始 第二种\"></a>骚操作开始 第二种</h1><blockquote>\n<p>文件名变更实际已经同步到远端了，且引用路径也同步到了远端！</p>\n</blockquote>\n<ul>\n<li><p>这次<code>user1</code> 知道 <code>git</code> 大小写不敏感, <code>user2</code> 同样可知可不知，于是一开始就逼迫她，让她变得敏感再敏感！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490d0d4ad6094906b2265b12dde0797f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"16.jpg\"></p>\n</li>\n</ul>\n<h2 id=\"user1-向远端同步变更-1\"><a href=\"#user1-向远端同步变更-1\" class=\"headerlink\" title=\"[user1]向远端同步变更\"></a>[user1]向远端同步变更</h2><ul>\n<li><code>user1</code> 的分支：<code>feature/user1</code></li>\n</ul>\n<h3 id=\"1-让她敏感敏感再敏感\"><a href=\"#1-让她敏感敏感再敏感\" class=\"headerlink\" title=\"1. 让她敏感敏感再敏感\"></a>1. 让她敏感敏感再敏感</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\"># emmmmm……俺敏感了</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-更改文件名-amp-文件引用路径\"><a href=\"#2-更改文件名-amp-文件引用路径\" class=\"headerlink\" title=\"2. 更改文件名 &amp; 文件引用路径\"></a>2. 更改文件名 &amp; 文件引用路径</h3><ul>\n<li><p><code>common =&gt; COMMON</code></p>\n</li>\n<li><p>更改引用路径</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 旧</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/common&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br><br><span class=\"hljs-comment\">// 新</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/COMMON&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-暂存（add）-amp-提交-commit\"><a href=\"#3-暂存（add）-amp-提交-commit\" class=\"headerlink\" title=\"3. 暂存（add）&amp; 提交(commit)\"></a>3. 暂存（add）&amp; 提交(commit)</h3><ul>\n<li><p>暂存 <code>add</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add .<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>提交 <code>commit</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m &lt;msg&gt;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-切换分支\"><a href=\"#4-切换分支\" class=\"headerlink\" title=\"4. 切换分支\"></a>4. 切换分支</h3><ul>\n<li><p><code>git checkout master</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"08_D_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd6b53edeb94401c877e27e2ab7d397d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"09_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"4-merge-到-master-并-pull-向远端\"><a href=\"#4-merge-到-master-并-pull-向远端\" class=\"headerlink\" title=\"4.merge 到 master 并 pull 向远端\"></a>4.merge 到 master 并 pull 向远端</h3><ul>\n<li><p><code>merge</code> 结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge feature/user1 <span class=\"hljs-comment\"># user1的分支合并到本地master</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0411bb699b343a9a588d424481eb5ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"10_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3bc59c816414a0d81c6b08ce98b8fe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>推送 <code>push</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push <span class=\"hljs-comment\"># 推送到远端master</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"user2-更新变更-1\"><a href=\"#user2-更新变更-1\" class=\"headerlink\" title=\"[user2]更新变更\"></a>[user2]更新变更</h2><ul>\n<li><code>user2</code> 的分支：<code>feature/user2</code></li>\n</ul>\n<h3 id=\"1-开启-敏感模式·情况一\"><a href=\"#1-开启-敏感模式·情况一\" class=\"headerlink\" title=\"1. 开启 敏感模式·情况一\"></a>1. 开启 敏感模式·情况一</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-切分支-amp-pull-代码\"><a href=\"#2-切分支-amp-pull-代码\" class=\"headerlink\" title=\"2. 切分支 &amp; pull 代码\"></a>2. 切分支 &amp; pull 代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout master<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>拉代码 <code>pull</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git pull <span class=\"hljs-comment\"># 更新 master 分支</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 结果 error</span><br>KaKa:test2  xxx$ git pull<br>更新 5f318b9..5174f2e<br>error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：<br>        src/components/COMMON/FootCell/index.vue<br>        src/components/COMMON/Pagination/index.vue<br>        src/components/COMMON/Table/index.vue<br>        src/components/COMMON/TitleCell/index.vue<br>请在合并前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意！上面那个问题一旦触发，那么你接下来所有的操作比如 <code>check</code>,<code>switch</code>,<code>pull</code>等操作都会报这个错误！！</p>\n</blockquote>\n<p>其实上面已经告诉你怎么操作了，按照提示 <code>删除</code>或者<code>移动</code>原有的<code>common文件夹</code>,然后再<code>pull</code>(<code>check</code>,<code>switch</code>)即可解决</p>\n<ul>\n<li><p>结果如下图：</p>\n<p><code>common</code>文件名已经变更为<code>COMMON</code></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34243070d2a24aeca70341c0df0b05d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-切换分支-amp-merge-代码\"><a href=\"#3-切换分支-amp-merge-代码\" class=\"headerlink\" title=\"3. 切换分支 &amp; merge 代码\"></a>3. 切换分支 &amp; merge 代码</h3><p>如果上一步问题解决了那么这一步就没什么异常了，<code>user2</code> 的分支代码已经被更新了</p>\n<ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout feature/user2<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>merge</code> 代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master <span class=\"hljs-comment\"># 更新 feature/user2 分支</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-查看-commit-记录\"><a href=\"#4-查看-commit-记录\" class=\"headerlink\" title=\"4 查看 commit 记录\"></a>4 查看 <code>commit</code> 记录</h3><ul>\n<li><p>如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"15_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"5-恭喜同步成功\"><a href=\"#5-恭喜同步成功\" class=\"headerlink\" title=\"5 恭喜同步成功\"></a>5 恭喜同步成功</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ade974c64e4ad19f2fe72f6d90886c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"33.jpg\"></p>\n<h3 id=\"1-关闭-敏感模式·情况二\"><a href=\"#1-关闭-敏感模式·情况二\" class=\"headerlink\" title=\"1 关闭 敏感模式·情况二\"></a>1 关闭 敏感模式·情况二</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\"># git 默认不敏感</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-切分支-amp-pull-代码-1\"><a href=\"#2-切分支-amp-pull-代码-1\" class=\"headerlink\" title=\"2. 切分支 &amp; pull 代码\"></a>2. 切分支 &amp; pull 代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout master<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>拉代码 <code>pull</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git pull <span class=\"hljs-comment\"># 更新 master 分支</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>结果如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4aa62317a0d45b996b4346f0c55bc28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"13_git大小写不敏感引发的问题\"></p>\n<p>惊不惊喜意不意外？</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637c79a4d8e244e7b1823eb5c6bb4e4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"40.jpg\"></p>\n<p>虽然远端的文件名已经由<code>common</code> &#x3D;&gt; <code>COMMON</code>,但是当<code>user2</code> 执行<code>pull</code>的时候本地的文件名依旧还是老的<code>common</code></p>\n<h3 id=\"3-更改文件名、切换分支、merge-master\"><a href=\"#3-更改文件名、切换分支、merge-master\" class=\"headerlink\" title=\"3. 更改文件名、切换分支、merge master\"></a>3. 更改文件名、切换分支、merge master</h3><ul>\n<li><p>先更改文件名<br><code>common</code> &#x3D;&gt; <code>COMMON</code></p>\n</li>\n<li><p>再切换分支：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout feature/user2<br></code></pre></td></tr></table></figure>\n\n<p><code>COMMON文件夹</code>变成空的了</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"08_D_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/09_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"09_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>最后执行 <code>merge</code> 后的变化如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p><code>COMMON文件夹</code>又有内容了</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f391d8a96f248bc962b63bede21d5fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"14_git大小写不敏感引发的问题\"></p>\n<h3 id=\"4-查看-commit\"><a href=\"#4-查看-commit\" class=\"headerlink\" title=\"4. 查看 commit\"></a>4. 查看 <code>commit</code></h3><ul>\n<li><p>记录如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"15_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"5-恭喜同步成功-1\"><a href=\"#5-恭喜同步成功-1\" class=\"headerlink\" title=\"5. 恭喜同步成功\"></a>5. 恭喜同步成功</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c5e8f29c454bd6820cc72bf3de7417~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"03.jpg\"></p>\n<h1 id=\"另外一种方式-git-rm\"><a href=\"#另外一种方式-git-rm\" class=\"headerlink\" title=\"另外一种方式 git rm\"></a>另外一种方式 git rm</h1><ul>\n<li><p>删除文件夹 <code>rm</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">rm</span> &lt;文件夹路径&gt; -r <span class=\"hljs-comment\"># -r 表示递归</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>删除文件 <code>rm</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">rm</span> &lt;文件路径&gt;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"user1-向远端同步变更-2\"><a href=\"#user1-向远端同步变更-2\" class=\"headerlink\" title=\"[user1]向远端同步变更\"></a>[user1]向远端同步变更</h2><h3 id=\"1-开启-敏感模式·情况一-1\"><a href=\"#1-开启-敏感模式·情况一-1\" class=\"headerlink\" title=\"1. 开启 敏感模式·情况一\"></a>1. 开启 敏感模式·情况一</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-制作副本\"><a href=\"#2-制作副本\" class=\"headerlink\" title=\"2. 制作副本\"></a>2. 制作副本</h3><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">common` =&gt; `common copy<br></code></pre></td></tr></table></figure>\n\n<p>复制副本以后不能直接将 <code>common copy</code> 改成 <code>COMMON</code> (此时 <code>common</code> 还存在)</p>\n<h3 id=\"3-使用-rm-删除-common-文件夹\"><a href=\"#3-使用-rm-删除-common-文件夹\" class=\"headerlink\" title=\"3. 使用 rm 删除 common 文件夹\"></a>3. 使用 rm 删除 common 文件夹</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">rm</span> ./src/components/common -r <span class=\"hljs-comment\"># -r 表示递归</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-还原名字\"><a href=\"#4-还原名字\" class=\"headerlink\" title=\"4. 还原名字\"></a>4. 还原名字</h3><ul>\n<li><p><code>common copy</code> &#x3D;&gt; <code>COMMON</code></p>\n<p>看到这里有的同学该问了为啥不拷贝副本 <code>common copy</code> 以后立马直接对其变更名字(<code>common copy =&gt; COMMON</code>),然后执行<code>第3步</code>操作呢？？？？问的好啊。鼓掌 👏</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11277325b5004da78d9b5c49d802515e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"16_git大小写不敏感引发的问题\"></p>\n<p>看到这个结果·····</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e312d8e54524e1bbde83ea6add468a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"06.jpg\"></p>\n<p>其实本人也是很想这么操作的，可是现在回头想想，在不区分大小写的情况下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">common === <span class=\"hljs-variable constant_\">COMMON</span> <span class=\"hljs-comment\">// true,</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>所以上面的提示是没有问题的 我个人认为</p>\n<h3 id=\"5-暂存、commit、merge-到-master、推到远端\"><a href=\"#5-暂存、commit、merge-到-master、推到远端\" class=\"headerlink\" title=\"5. 暂存、commit、merge 到 master、推到远端\"></a>5. 暂存、commit、merge 到 master、推到远端</h3><p>在这一步 你将遇到如下错误信息导致切换分支失败 (跟上面的还不太一样)</p>\n<ul>\n<li><p><code>check</code> 出问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">KaKa:<span class=\"hljs-built_in\">test</span> xxxx$ git che master<br><br>error: 工作区中下列未跟踪的文件将会因为检出操作而被覆盖：<br>        src/components/common/FootCell/index.vue<br>        src/components/common/Pagination/index.vue<br>        src/components/common/Table/index.vue<br>        src/components/common/TitleCell/index.vue<br>请在切换分支前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<p>此时的项目结构是这样子的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">.<br>├── README.md<br>├── main.js<br>└── src<br>    └── components<br>        └── COMMON  &lt;= <span class=\"hljs-comment\"># 重点！这里!!! 并没有 common</span><br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure>\n\n<p>并没有<code>common</code>文件夹！!那么就无解了？？但是否定的！那我们就:</p>\n<ul>\n<li><p>把<code>COMMON</code>&#x3D;&gt; <code>common</code></p>\n</li>\n<li><p>再删除<code>common</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/22_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"22_git大小写不敏感引发的问题\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34a54996c1047b1ad5323ac80d6eb63~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"23_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>最后执行 <code>git check master</code></p>\n</li>\n</ul>\n<p>忽略执行删除后的文件变更，直接 <code>git checkout master</code></p>\n</li>\n<li><p><code>merge</code> 出问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">KaKa-3:<span class=\"hljs-built_in\">test</span> xxxx$ git merge feature/user1<br><br>更新 5f318b9..24b399d<br>error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：<br>        src/components/COMMON/FootCell/index.vue<br>        src/components/COMMON/Pagination/index.vue<br>        src/components/COMMON/Table/index.vue<br>        src/components/COMMON/TitleCell/index.vue<br>请在合并前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<p>并没有<code>COMMON</code>,处理方法同上:</p>\n<ul>\n<li>把<code>common</code>&#x3D;&gt; <code>COMMON</code></li>\n<li>再删除<code>COMMON</code><br><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/24_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"24_git大小写不敏感引发的问题\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb8b56621944f0da593a1f6e99e3477~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"23_git大小写不敏感引发的问题\"></li>\n<li>最后<code>git merge feature/user1</code>就可以了~</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-查看-commit-记录\"><a href=\"#6-查看-commit-记录\" class=\"headerlink\" title=\"6. 查看 commit 记录\"></a>6. 查看 <code>commit</code> 记录</h3><ul>\n<li>如下图： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a361ed790bf94b7691f468c63c080841~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"17_git大小写不敏感引发的问题\"></li>\n</ul>\n<h3 id=\"1-关闭-敏感模式·情况二-1\"><a href=\"#1-关闭-敏感模式·情况二-1\" class=\"headerlink\" title=\"1. 关闭 敏感模式·情况二\"></a>1. 关闭 敏感模式·情况二</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-更改文件名\"><a href=\"#2-更改文件名\" class=\"headerlink\" title=\"2. 更改文件名\"></a>2. 更改文件名</h3><ul>\n<li><p><code>common</code> &#x3D;&gt; <code>COMMON</code></p>\n<p>然而尴尬的一幕它发生了！！！如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928907269477471d856d2496dce8e50e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/10_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"10_git大小写不敏感引发的问题\"></p>\n<p>卧槽！ <code>Git</code> 并没有检测到 文件有变化！</p>\n</li>\n</ul>\n<h3 id=\"3-卒\"><a href=\"#3-卒\" class=\"headerlink\" title=\"3. 卒!\"></a>3. 卒!</h3><ul>\n<li><p>这种情况要么放弃，要么开启敏感模式！如果开启那就是<code>情况一</code>了</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e41e7a1c4e5c4673ac3a42d6bdf680ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"46.jpg\"></p>\n</li>\n</ul>\n<h2 id=\"user2-更新变更-2\"><a href=\"#user2-更新变更-2\" class=\"headerlink\" title=\"[user2]更新变更\"></a>[user2]更新变更</h2><ul>\n<li><p>此时 <code>user2</code>的<code>master</code> 分支初始目录如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">.<br>├── README.md<br>├── main.js<br>└── src<br>    └── components<br>        └── common<br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-开启-敏感模式·情况一-2\"><a href=\"#1-开启-敏感模式·情况一-2\" class=\"headerlink\" title=\"1. 开启 敏感模式·情况一\"></a>1. 开启 敏感模式·情况一</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-pull-最新代码\"><a href=\"#2-pull-最新代码\" class=\"headerlink\" title=\"2. pull 最新代码\"></a>2. pull 最新代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">KaKa:test2  xxxx$ git pull<br>更新 5f318b9..24b399d<br>error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：<br>        src/components/COMMON/FootCell/index.vue<br>        src/components/COMMON/Pagination/index.vue<br>        src/components/COMMON/Table/index.vue<br>        src/components/COMMON/TitleCell/index.vue<br>请在合并前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<p>不出所料 会跟开头讲的 状况一致，这里就不重复赘述了，参考上面的即可解决。</p>\n<h3 id=\"3-查看-commit-记录\"><a href=\"#3-查看-commit-记录\" class=\"headerlink\" title=\"3. 查看 commit 记录\"></a>3. 查看 <code>commit</code> 记录</h3><ul>\n<li><p>如下图:</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc4f8cfc7d548b9801ea7fb7f854e72~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"17_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"1-关闭-敏感模式·情况二-2\"><a href=\"#1-关闭-敏感模式·情况二-2\" class=\"headerlink\" title=\"1. 关闭 敏感模式·情况二\"></a>1. 关闭 敏感模式·情况二</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-pull-最新代码-1\"><a href=\"#2-pull-最新代码-1\" class=\"headerlink\" title=\"2. pull 最新代码\"></a>2. <code>pull</code> 最新代码</h3><ul>\n<li><p>如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/18_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"18_git大小写不敏感引发的问题\"></p>\n<p>同前面所说,变更都过来了，唯独文件名由于本地的大小写不敏感，所以没有自动变更名字</p>\n</li>\n</ul>\n<h3 id=\"3-手动更改文件名-1\"><a href=\"#3-手动更改文件名-1\" class=\"headerlink\" title=\"3. 手动更改文件名\"></a>3. 手动更改文件名</h3><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">common` =&gt; `COMMON<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-切换分支，mer-master-代码\"><a href=\"#4-切换分支，mer-master-代码\" class=\"headerlink\" title=\"4. 切换分支，mer master 代码\"></a>4. 切换分支，mer master 代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout feature/user2<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>merge</code> 代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-查看-commit-记录\"><a href=\"#5-查看-commit-记录\" class=\"headerlink\" title=\"5. 查看 commit 记录\"></a>5. 查看 <code>commit</code> 记录</h3><ul>\n<li><p>如下图:</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/17_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"17_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综上的出来的结论就是多人协作开发的时候存在已下情况</p>\n<ul>\n<li><p>第一种方式 <code>user1</code> 两种， <code>user2</code> 两种，总共四种情况。且文件都被标记为A</p>\n<ul>\n<li>都未开启敏感模式（绝大多数都是这个情况）<br>这种情况可想而知，远端的文件名一直都是 common 而非 COMMON，所有人乃至以后都会一直存在这个问题（自己本地需要去手动的更改文件名），</li>\n<li>都开启了敏感模式<br>这种情况 <code>user2</code> 在同步更新 <code>master</code> 分支代码的时候会遇到 <code>error</code>，根据提示删除或移动文件位置即可！（删除最简单直观）</li>\n<li>修改方(<code>user1</code>)开起了敏感模式，被通知方(<code>user2</code>)未开启 虽然文件名已经被改动且同步到了远端，但是当 user2 （master）拉取的时候会发现自己本地的文件名依旧是 common 未改动。这个时候只需要手动的去更改文件名，然后 <code>merge</code> 到 <code>user2</code> 的分支即可</li>\n<li>修改方(<code>user1</code>)未开启敏感模式，被通知方(<code>user2</code>)开启了<br><code>user1</code> 自以为文件名已经更改成功且同步到了远端，实际并没有同步到远端，<code>user2</code> 自己手动更改，更改后 <code>push</code> 到远端，这样所有人的文件引用路径错误问题都能得到解决</li>\n</ul>\n</li>\n<li><p>第二种方式</p>\n<p>通过<code>git rm</code> 这个操作来处理。通过这种方式变更文件会被标记为R</p>\n</li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>已上所有内容都是经过好几遍测试，一遍实践一遍记录的形式来撰写的，最后也反复检查了好几遍，目测没有什么问题，如果有问题了就请留言告知吧~</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b9c2f3777647d1a0650f753e57cfd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"47.jpg\"></p>\n","site":{"data":{}},"wordcount":6942,"excerpt":"","more":"<h1 id=\"Git-大小写不敏感引发的问题\"><a href=\"#Git-大小写不敏感引发的问题\" class=\"headerlink\" title=\"Git 大小写不敏感引发的问题\"></a>Git 大小写不敏感引发的问题</h1><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2eae29e98142dfb3584c2317e9328a~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.image\" alt=\"【Git系列】Git 大小写不敏感引发的血案\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>由于当年太年轻，资历不够深！！！导致文件命名不规范，现在想更正文件夹名字（<code>common =&gt; COMMON</code>），结果发现一个很奇特的现象！ git 对文件(夹)名的大小写不敏感！！！！引发了一些问题。最终经过查阅资料得以解决，遂！写下这篇帖子记录一下。走<del>跟着渣渣一起吃着花生 🥜 喝着啤酒 🍺 燥起来</del></p>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c755d04984c446708721485b8bff8d28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"13.jpg\"></p>\n<h2 id=\"demo-部分目录结构\"><a href=\"#demo-部分目录结构\" class=\"headerlink\" title=\"demo 部分目录结构\"></a>demo 部分目录结构</h2><ul>\n<li><p><code>master</code> 分支的代码及文件目录情况</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># master分支原始目录</span><br>.<br>├── main.js<br>└── src<br>    └── components<br>        └── common<br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/common&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"模拟多用户\"><a href=\"#模拟多用户\" class=\"headerlink\" title=\"模拟多用户\"></a>模拟多用户</h3><ul>\n<li><p><code>user1</code> 分支：<code>feature/user1</code></p>\n</li>\n<li><p><code>user2</code> 分支：<code>feature/user2</code></p>\n<p>此时分别有两个用户<code>user1</code>和<code>user2</code>在各自的电脑上拉取了这个项目。</p>\n</li>\n</ul>\n<h1 id=\"骚操作开始-第一种\"><a href=\"#骚操作开始-第一种\" class=\"headerlink\" title=\"骚操作开始 第一种\"></a>骚操作开始 第一种</h1><blockquote>\n<p>文件名的变更未同步到远端，但是引用路径却同步到远端了！</p>\n</blockquote>\n<ul>\n<li><p><code>user1</code> 不知道 <code>git</code> 大小写不敏感,<code>user2</code> 可知可不知，反正最后都!会!知!道!!!</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22443ba58c794d919058c0879836bfad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"09.gif\"></p>\n</li>\n</ul>\n<h2 id=\"user1-向远端同步变更\"><a href=\"#user1-向远端同步变更\" class=\"headerlink\" title=\"[user1]向远端同步变更\"></a>[user1]向远端同步变更</h2><h3 id=\"更改文件名-更改引用路径\"><a href=\"#更改文件名-更改引用路径\" class=\"headerlink\" title=\"更改文件名 + 更改引用路径\"></a>更改文件名 + 更改引用路径</h3><blockquote>\n<p>因为 这里 <code>git</code> 大小写不敏感所以只进行文件名变更(大小写)的话，不会被 <code>git</code> 检测到，所以必须要改动一个文件，让 <code>git</code> 检测到变更。才能进行<code>commit</code>!刚好文件名的变更导致了引用路径也需要变更！因此本次可以进行提交</p>\n</blockquote>\n<ul>\n<li><p>由于被绿太狠了，心情不太好就开始了骚操作坑队友！<code>common =&gt; COMMON</code>结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">  <span class=\"hljs-comment\"># common =&gt; COMMON</span><br>  .<br>  ├── main.js<br>  └── src<br>      └── components<br>          └── COMMON<br>              ├── FootCell<br>              │   └── index.vue<br>              ├── Pagination<br>              │   └── index.vue<br>              ├── Table<br>              │   └── index.vue<br>              └── TitleCell<br>                  └── index.vue<br>复制代码<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/common&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>最后并把代码提交到了远端,并且告诉 <code>user2</code> 代码有更新</p>\n<h2 id=\"user2-的响应\"><a href=\"#user2-的响应\" class=\"headerlink\" title=\"[user2]的响应\"></a>[user2]的响应</h2><h3 id=\"pull-代码\"><a href=\"#pull-代码\" class=\"headerlink\" title=\"pull 代码\"></a><code>pull</code> 代码</h3><ul>\n<li><p><code>user2</code>于是乎就先<code>pull</code>然后<code>merge</code>了一下，把 <code>user1</code> 的代码同步到自己的分支，结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 此时 common =&gt; common 没有变化！！！</span><br>.<br>├── main.js<br>└── src<br>    └── components<br>        └── common<br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js 有变化！！！</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/COMMON&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure>\n\n<p>  这个时候，“<del>报应</del>”来的太突然，项目报错了！引用的路径是<code>COMMON</code>而实际项目的路径是<code>common</code></p>\n<p>  <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a073f83286924f99bf704bead00db36e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"18.jpg\"></p>\n<ul>\n<li>然后<code>user2</code>就好奇为啥会是这种情况,文件名没有变化？？于是乎开启了探索之路~~</li>\n</ul>\n<h3 id=\"探索问题\"><a href=\"#探索问题\" class=\"headerlink\" title=\"探索问题\"></a>探索问题</h3><blockquote>\n<p>因为<code>user1</code>被绿了一波，心情不好搞事情，害得<code>user2</code>引发了 bug，但是刚好激发了<code>user2</code>的好奇心。</p>\n</blockquote>\n<ul>\n<li><p>为啥<code>user1</code>的是 <code>COMMON</code>,到我这里是 <code>common</code>？？？</p>\n<p>最后<code>user2</code>查到了答案！ 原来是 <code>git</code> 对文件名的大小写不敏感，才会引发这个问题。好了那么接下来就是这么去解决这个问题呢？？</p>\n</li>\n</ul>\n<p><strong>温馨提示</strong></p>\n<blockquote>\n<p>因为 <code>git</code> 默认不区分大小写，所以如果只更改文件名的话 <code>git</code> 并不会检测到文件有变化，固！无法进行 <code>commit</code>，所有这次测试在更改文件名的时候附带的改动了其他地方，以便提交！</p>\n</blockquote>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>既然<code>user2</code>已经知道了 <code>git</code> 默认大小写不敏感，那就让他敏感呗。多简单！</p>\n<h2 id=\"user2-更新变更\"><a href=\"#user2-更新变更\" class=\"headerlink\" title=\"[user2]更新变更\"></a>[user2]更新变更</h2><h3 id=\"1-开启-敏感模式\"><a href=\"#1-开启-敏感模式\" class=\"headerlink\" title=\"1. 开启 敏感模式\"></a>1. 开启 敏感模式</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\"># 让你变的敏感</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bcd4ced859947e79225ba37c62c01b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"21.jpg\"></p>\n<blockquote>\n<p>其实<code>user1</code>压根就没有把文件名更改同步到到远端!(所以开头才说，他不知道 <code>git</code> 大小写不敏感!但是文件引用路径变更了，这个就导致其他人<code>(user2)</code>因为文件路径改变导致项目报错)</p>\n</blockquote>\n<h3 id=\"2-切换分支，拉取最新代码\"><a href=\"#2-切换分支，拉取最新代码\" class=\"headerlink\" title=\"2. 切换分支，拉取最新代码\"></a>2. 切换分支，拉取最新代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git che master<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>拉代码 <code>pull</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git pull<br></code></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>这个时候就会发现项目无法启动，因为 <code>main.js</code> 中的文件路径引用已经由 <code>common =&gt; COMMON</code> 了，但实际文件名依旧是 <code>common</code></p>\n</blockquote>\n<h3 id=\"3-手动更改文件名\"><a href=\"#3-手动更改文件名\" class=\"headerlink\" title=\"3. 手动更改文件名\"></a>3. 手动更改文件名</h3><ul>\n<li><p><code>common</code> &#x3D;&gt; <code>COMMON</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/19_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"19_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"4-暂存、提交、push、切分支、merge-到-feature-x2F-user2-分支\"><a href=\"#4-暂存、提交、push、切分支、merge-到-feature-x2F-user2-分支\" class=\"headerlink\" title=\"4. 暂存、提交、push、切分支、merge 到 feature&#x2F;user2 分支\"></a>4. 暂存、提交、push、切分支、merge 到 feature&#x2F;user2 分支</h3><ul>\n<li><p>暂存 <code>add</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add .<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>提交 <code>commit</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m user2手动同步更新文件名<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6c3930f274425b8a8f7e851d6d1a15~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"20_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>推送 <code>push</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 这一步是替user1，将文件名变更同步到远端，供user3……等使用</span><br><span class=\"hljs-comment\">#（此时如果其他用户是之前拉取的分支那么也会出现本篇文章所描述的问题！）</span><br><span class=\"hljs-comment\"># 方法嘛~~ 就是当前文章~~哈哈哈</span><br>git push<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git che feature/user2<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1bcad27960452eb1a6c49ae8b58c9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"08_D_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61453f98e4ea4a508027ecc39cbae4cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"09_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p><code>merge</code> master 到 <code>feature/user2</code> 分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5949cfb1676b41ef9d44b58f3f173259~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"10_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811b5a7041f54b08a2b4b0ab47be5460~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n<h3 id=\"查看-commit-记录\"><a href=\"#查看-commit-记录\" class=\"headerlink\" title=\"查看 commit 记录\"></a>查看 <code>commit</code> 记录</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d3ab1becd9c45c3b9caeba5a2b1c3be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"12_git大小写不敏感引发的问题\"></p>\n<h1 id=\"骚操作开始-第二种\"><a href=\"#骚操作开始-第二种\" class=\"headerlink\" title=\"骚操作开始 第二种\"></a>骚操作开始 第二种</h1><blockquote>\n<p>文件名变更实际已经同步到远端了，且引用路径也同步到了远端！</p>\n</blockquote>\n<ul>\n<li><p>这次<code>user1</code> 知道 <code>git</code> 大小写不敏感, <code>user2</code> 同样可知可不知，于是一开始就逼迫她，让她变得敏感再敏感！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490d0d4ad6094906b2265b12dde0797f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"16.jpg\"></p>\n</li>\n</ul>\n<h2 id=\"user1-向远端同步变更-1\"><a href=\"#user1-向远端同步变更-1\" class=\"headerlink\" title=\"[user1]向远端同步变更\"></a>[user1]向远端同步变更</h2><ul>\n<li><code>user1</code> 的分支：<code>feature/user1</code></li>\n</ul>\n<h3 id=\"1-让她敏感敏感再敏感\"><a href=\"#1-让她敏感敏感再敏感\" class=\"headerlink\" title=\"1. 让她敏感敏感再敏感\"></a>1. 让她敏感敏感再敏感</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\"># emmmmm……俺敏感了</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-更改文件名-amp-文件引用路径\"><a href=\"#2-更改文件名-amp-文件引用路径\" class=\"headerlink\" title=\"2. 更改文件名 &amp; 文件引用路径\"></a>2. 更改文件名 &amp; 文件引用路径</h3><ul>\n<li><p><code>common =&gt; COMMON</code></p>\n</li>\n<li><p>更改引用路径</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 旧</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/common&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br><br><span class=\"hljs-comment\">// 新</span><br><span class=\"hljs-keyword\">const</span> files = <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">context</span>(<span class=\"hljs-string\">&#x27;../components/COMMON&#x27;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-regexp\">/\\.vue$/</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-暂存（add）-amp-提交-commit\"><a href=\"#3-暂存（add）-amp-提交-commit\" class=\"headerlink\" title=\"3. 暂存（add）&amp; 提交(commit)\"></a>3. 暂存（add）&amp; 提交(commit)</h3><ul>\n<li><p>暂存 <code>add</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add .<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>提交 <code>commit</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m &lt;msg&gt;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-切换分支\"><a href=\"#4-切换分支\" class=\"headerlink\" title=\"4. 切换分支\"></a>4. 切换分支</h3><ul>\n<li><p><code>git checkout master</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"08_D_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd6b53edeb94401c877e27e2ab7d397d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"09_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"4-merge-到-master-并-pull-向远端\"><a href=\"#4-merge-到-master-并-pull-向远端\" class=\"headerlink\" title=\"4.merge 到 master 并 pull 向远端\"></a>4.merge 到 master 并 pull 向远端</h3><ul>\n<li><p><code>merge</code> 结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge feature/user1 <span class=\"hljs-comment\"># user1的分支合并到本地master</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0411bb699b343a9a588d424481eb5ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"10_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3bc59c816414a0d81c6b08ce98b8fe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>推送 <code>push</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push <span class=\"hljs-comment\"># 推送到远端master</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"user2-更新变更-1\"><a href=\"#user2-更新变更-1\" class=\"headerlink\" title=\"[user2]更新变更\"></a>[user2]更新变更</h2><ul>\n<li><code>user2</code> 的分支：<code>feature/user2</code></li>\n</ul>\n<h3 id=\"1-开启-敏感模式·情况一\"><a href=\"#1-开启-敏感模式·情况一\" class=\"headerlink\" title=\"1. 开启 敏感模式·情况一\"></a>1. 开启 敏感模式·情况一</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-切分支-amp-pull-代码\"><a href=\"#2-切分支-amp-pull-代码\" class=\"headerlink\" title=\"2. 切分支 &amp; pull 代码\"></a>2. 切分支 &amp; pull 代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout master<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>拉代码 <code>pull</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git pull <span class=\"hljs-comment\"># 更新 master 分支</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 结果 error</span><br>KaKa:test2  xxx$ git pull<br>更新 5f318b9..5174f2e<br>error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：<br>        src/components/COMMON/FootCell/index.vue<br>        src/components/COMMON/Pagination/index.vue<br>        src/components/COMMON/Table/index.vue<br>        src/components/COMMON/TitleCell/index.vue<br>请在合并前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意！上面那个问题一旦触发，那么你接下来所有的操作比如 <code>check</code>,<code>switch</code>,<code>pull</code>等操作都会报这个错误！！</p>\n</blockquote>\n<p>其实上面已经告诉你怎么操作了，按照提示 <code>删除</code>或者<code>移动</code>原有的<code>common文件夹</code>,然后再<code>pull</code>(<code>check</code>,<code>switch</code>)即可解决</p>\n<ul>\n<li><p>结果如下图：</p>\n<p><code>common</code>文件名已经变更为<code>COMMON</code></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34243070d2a24aeca70341c0df0b05d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-切换分支-amp-merge-代码\"><a href=\"#3-切换分支-amp-merge-代码\" class=\"headerlink\" title=\"3. 切换分支 &amp; merge 代码\"></a>3. 切换分支 &amp; merge 代码</h3><p>如果上一步问题解决了那么这一步就没什么异常了，<code>user2</code> 的分支代码已经被更新了</p>\n<ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout feature/user2<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>merge</code> 代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master <span class=\"hljs-comment\"># 更新 feature/user2 分支</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-查看-commit-记录\"><a href=\"#4-查看-commit-记录\" class=\"headerlink\" title=\"4 查看 commit 记录\"></a>4 查看 <code>commit</code> 记录</h3><ul>\n<li><p>如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"15_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"5-恭喜同步成功\"><a href=\"#5-恭喜同步成功\" class=\"headerlink\" title=\"5 恭喜同步成功\"></a>5 恭喜同步成功</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ade974c64e4ad19f2fe72f6d90886c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"33.jpg\"></p>\n<h3 id=\"1-关闭-敏感模式·情况二\"><a href=\"#1-关闭-敏感模式·情况二\" class=\"headerlink\" title=\"1 关闭 敏感模式·情况二\"></a>1 关闭 敏感模式·情况二</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\"># git 默认不敏感</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-切分支-amp-pull-代码-1\"><a href=\"#2-切分支-amp-pull-代码-1\" class=\"headerlink\" title=\"2. 切分支 &amp; pull 代码\"></a>2. 切分支 &amp; pull 代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout master<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>拉代码 <code>pull</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git pull <span class=\"hljs-comment\"># 更新 master 分支</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>结果如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4aa62317a0d45b996b4346f0c55bc28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"13_git大小写不敏感引发的问题\"></p>\n<p>惊不惊喜意不意外？</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637c79a4d8e244e7b1823eb5c6bb4e4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"40.jpg\"></p>\n<p>虽然远端的文件名已经由<code>common</code> &#x3D;&gt; <code>COMMON</code>,但是当<code>user2</code> 执行<code>pull</code>的时候本地的文件名依旧还是老的<code>common</code></p>\n<h3 id=\"3-更改文件名、切换分支、merge-master\"><a href=\"#3-更改文件名、切换分支、merge-master\" class=\"headerlink\" title=\"3. 更改文件名、切换分支、merge master\"></a>3. 更改文件名、切换分支、merge master</h3><ul>\n<li><p>先更改文件名<br><code>common</code> &#x3D;&gt; <code>COMMON</code></p>\n</li>\n<li><p>再切换分支：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout feature/user2<br></code></pre></td></tr></table></figure>\n\n<p><code>COMMON文件夹</code>变成空的了</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/08_D_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"08_D_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/09_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"09_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>最后执行 <code>merge</code> 后的变化如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p><code>COMMON文件夹</code>又有内容了</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f391d8a96f248bc962b63bede21d5fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"14_git大小写不敏感引发的问题\"></p>\n<h3 id=\"4-查看-commit\"><a href=\"#4-查看-commit\" class=\"headerlink\" title=\"4. 查看 commit\"></a>4. 查看 <code>commit</code></h3><ul>\n<li><p>记录如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/15_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"15_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"5-恭喜同步成功-1\"><a href=\"#5-恭喜同步成功-1\" class=\"headerlink\" title=\"5. 恭喜同步成功\"></a>5. 恭喜同步成功</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c5e8f29c454bd6820cc72bf3de7417~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"03.jpg\"></p>\n<h1 id=\"另外一种方式-git-rm\"><a href=\"#另外一种方式-git-rm\" class=\"headerlink\" title=\"另外一种方式 git rm\"></a>另外一种方式 git rm</h1><ul>\n<li><p>删除文件夹 <code>rm</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">rm</span> &lt;文件夹路径&gt; -r <span class=\"hljs-comment\"># -r 表示递归</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>删除文件 <code>rm</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">rm</span> &lt;文件路径&gt;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"user1-向远端同步变更-2\"><a href=\"#user1-向远端同步变更-2\" class=\"headerlink\" title=\"[user1]向远端同步变更\"></a>[user1]向远端同步变更</h2><h3 id=\"1-开启-敏感模式·情况一-1\"><a href=\"#1-开启-敏感模式·情况一-1\" class=\"headerlink\" title=\"1. 开启 敏感模式·情况一\"></a>1. 开启 敏感模式·情况一</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-制作副本\"><a href=\"#2-制作副本\" class=\"headerlink\" title=\"2. 制作副本\"></a>2. 制作副本</h3><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">common` =&gt; `common copy<br></code></pre></td></tr></table></figure>\n\n<p>复制副本以后不能直接将 <code>common copy</code> 改成 <code>COMMON</code> (此时 <code>common</code> 还存在)</p>\n<h3 id=\"3-使用-rm-删除-common-文件夹\"><a href=\"#3-使用-rm-删除-common-文件夹\" class=\"headerlink\" title=\"3. 使用 rm 删除 common 文件夹\"></a>3. 使用 rm 删除 common 文件夹</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">rm</span> ./src/components/common -r <span class=\"hljs-comment\"># -r 表示递归</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-还原名字\"><a href=\"#4-还原名字\" class=\"headerlink\" title=\"4. 还原名字\"></a>4. 还原名字</h3><ul>\n<li><p><code>common copy</code> &#x3D;&gt; <code>COMMON</code></p>\n<p>看到这里有的同学该问了为啥不拷贝副本 <code>common copy</code> 以后立马直接对其变更名字(<code>common copy =&gt; COMMON</code>),然后执行<code>第3步</code>操作呢？？？？问的好啊。鼓掌 👏</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11277325b5004da78d9b5c49d802515e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"16_git大小写不敏感引发的问题\"></p>\n<p>看到这个结果·····</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e312d8e54524e1bbde83ea6add468a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"06.jpg\"></p>\n<p>其实本人也是很想这么操作的，可是现在回头想想，在不区分大小写的情况下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">common === <span class=\"hljs-variable constant_\">COMMON</span> <span class=\"hljs-comment\">// true,</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>所以上面的提示是没有问题的 我个人认为</p>\n<h3 id=\"5-暂存、commit、merge-到-master、推到远端\"><a href=\"#5-暂存、commit、merge-到-master、推到远端\" class=\"headerlink\" title=\"5. 暂存、commit、merge 到 master、推到远端\"></a>5. 暂存、commit、merge 到 master、推到远端</h3><p>在这一步 你将遇到如下错误信息导致切换分支失败 (跟上面的还不太一样)</p>\n<ul>\n<li><p><code>check</code> 出问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">KaKa:<span class=\"hljs-built_in\">test</span> xxxx$ git che master<br><br>error: 工作区中下列未跟踪的文件将会因为检出操作而被覆盖：<br>        src/components/common/FootCell/index.vue<br>        src/components/common/Pagination/index.vue<br>        src/components/common/Table/index.vue<br>        src/components/common/TitleCell/index.vue<br>请在切换分支前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<p>此时的项目结构是这样子的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">.<br>├── README.md<br>├── main.js<br>└── src<br>    └── components<br>        └── COMMON  &lt;= <span class=\"hljs-comment\"># 重点！这里!!! 并没有 common</span><br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure>\n\n<p>并没有<code>common</code>文件夹！!那么就无解了？？但是否定的！那我们就:</p>\n<ul>\n<li><p>把<code>COMMON</code>&#x3D;&gt; <code>common</code></p>\n</li>\n<li><p>再删除<code>common</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/22_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"22_git大小写不敏感引发的问题\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34a54996c1047b1ad5323ac80d6eb63~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"23_git大小写不敏感引发的问题\"></p>\n</li>\n<li><p>最后执行 <code>git check master</code></p>\n</li>\n</ul>\n<p>忽略执行删除后的文件变更，直接 <code>git checkout master</code></p>\n</li>\n<li><p><code>merge</code> 出问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">KaKa-3:<span class=\"hljs-built_in\">test</span> xxxx$ git merge feature/user1<br><br>更新 5f318b9..24b399d<br>error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：<br>        src/components/COMMON/FootCell/index.vue<br>        src/components/COMMON/Pagination/index.vue<br>        src/components/COMMON/Table/index.vue<br>        src/components/COMMON/TitleCell/index.vue<br>请在合并前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<p>并没有<code>COMMON</code>,处理方法同上:</p>\n<ul>\n<li>把<code>common</code>&#x3D;&gt; <code>COMMON</code></li>\n<li>再删除<code>COMMON</code><br><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/24_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"24_git大小写不敏感引发的问题\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb8b56621944f0da593a1f6e99e3477~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"23_git大小写不敏感引发的问题\"></li>\n<li>最后<code>git merge feature/user1</code>就可以了~</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-查看-commit-记录\"><a href=\"#6-查看-commit-记录\" class=\"headerlink\" title=\"6. 查看 commit 记录\"></a>6. 查看 <code>commit</code> 记录</h3><ul>\n<li>如下图： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a361ed790bf94b7691f468c63c080841~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"17_git大小写不敏感引发的问题\"></li>\n</ul>\n<h3 id=\"1-关闭-敏感模式·情况二-1\"><a href=\"#1-关闭-敏感模式·情况二-1\" class=\"headerlink\" title=\"1. 关闭 敏感模式·情况二\"></a>1. 关闭 敏感模式·情况二</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-更改文件名\"><a href=\"#2-更改文件名\" class=\"headerlink\" title=\"2. 更改文件名\"></a>2. 更改文件名</h3><ul>\n<li><p><code>common</code> &#x3D;&gt; <code>COMMON</code></p>\n<p>然而尴尬的一幕它发生了！！！如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928907269477471d856d2496dce8e50e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"11_git大小写不敏感引发的问题\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/10_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"10_git大小写不敏感引发的问题\"></p>\n<p>卧槽！ <code>Git</code> 并没有检测到 文件有变化！</p>\n</li>\n</ul>\n<h3 id=\"3-卒\"><a href=\"#3-卒\" class=\"headerlink\" title=\"3. 卒!\"></a>3. 卒!</h3><ul>\n<li><p>这种情况要么放弃，要么开启敏感模式！如果开启那就是<code>情况一</code>了</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e41e7a1c4e5c4673ac3a42d6bdf680ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"46.jpg\"></p>\n</li>\n</ul>\n<h2 id=\"user2-更新变更-2\"><a href=\"#user2-更新变更-2\" class=\"headerlink\" title=\"[user2]更新变更\"></a>[user2]更新变更</h2><ul>\n<li><p>此时 <code>user2</code>的<code>master</code> 分支初始目录如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">.<br>├── README.md<br>├── main.js<br>└── src<br>    └── components<br>        └── common<br>            ├── FootCell<br>            │   └── index.vue<br>            ├── Pagination<br>            │   └── index.vue<br>            ├── Table<br>            │   └── index.vue<br>            └── TitleCell<br>                └── index.vue<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-开启-敏感模式·情况一-2\"><a href=\"#1-开启-敏感模式·情况一-2\" class=\"headerlink\" title=\"1. 开启 敏感模式·情况一\"></a>1. 开启 敏感模式·情况一</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-pull-最新代码\"><a href=\"#2-pull-最新代码\" class=\"headerlink\" title=\"2. pull 最新代码\"></a>2. pull 最新代码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">KaKa:test2  xxxx$ git pull<br>更新 5f318b9..24b399d<br>error: 工作区中下列未跟踪的文件将会因为合并操作而被覆盖：<br>        src/components/COMMON/FootCell/index.vue<br>        src/components/COMMON/Pagination/index.vue<br>        src/components/COMMON/Table/index.vue<br>        src/components/COMMON/TitleCell/index.vue<br>请在合并前移动或删除。<br>正在终止<br></code></pre></td></tr></table></figure>\n\n<p>不出所料 会跟开头讲的 状况一致，这里就不重复赘述了，参考上面的即可解决。</p>\n<h3 id=\"3-查看-commit-记录\"><a href=\"#3-查看-commit-记录\" class=\"headerlink\" title=\"3. 查看 commit 记录\"></a>3. 查看 <code>commit</code> 记录</h3><ul>\n<li><p>如下图:</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc4f8cfc7d548b9801ea7fb7f854e72~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"17_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h3 id=\"1-关闭-敏感模式·情况二-2\"><a href=\"#1-关闭-敏感模式·情况二-2\" class=\"headerlink\" title=\"1. 关闭 敏感模式·情况二\"></a>1. 关闭 敏感模式·情况二</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config core.ignorecase <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-pull-最新代码-1\"><a href=\"#2-pull-最新代码-1\" class=\"headerlink\" title=\"2. pull 最新代码\"></a>2. <code>pull</code> 最新代码</h3><ul>\n<li><p>如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/18_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"18_git大小写不敏感引发的问题\"></p>\n<p>同前面所说,变更都过来了，唯独文件名由于本地的大小写不敏感，所以没有自动变更名字</p>\n</li>\n</ul>\n<h3 id=\"3-手动更改文件名-1\"><a href=\"#3-手动更改文件名-1\" class=\"headerlink\" title=\"3. 手动更改文件名\"></a>3. 手动更改文件名</h3><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">common` =&gt; `COMMON<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-切换分支，mer-master-代码\"><a href=\"#4-切换分支，mer-master-代码\" class=\"headerlink\" title=\"4. 切换分支，mer master 代码\"></a>4. 切换分支，mer master 代码</h3><ul>\n<li><p>切分支 <code>checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git checkout feature/user2<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>merge</code> 代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git merge master<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-查看-commit-记录\"><a href=\"#5-查看-commit-记录\" class=\"headerlink\" title=\"5. 查看 commit 记录\"></a>5. 查看 <code>commit</code> 记录</h3><ul>\n<li><p>如下图:</p>\n<p><img src=\"https://raw.githubusercontent.com/Popxie/kaka-img-repo/master/img/blogs/17_git%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98.png\" alt=\"17_git大小写不敏感引发的问题\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综上的出来的结论就是多人协作开发的时候存在已下情况</p>\n<ul>\n<li><p>第一种方式 <code>user1</code> 两种， <code>user2</code> 两种，总共四种情况。且文件都被标记为A</p>\n<ul>\n<li>都未开启敏感模式（绝大多数都是这个情况）<br>这种情况可想而知，远端的文件名一直都是 common 而非 COMMON，所有人乃至以后都会一直存在这个问题（自己本地需要去手动的更改文件名），</li>\n<li>都开启了敏感模式<br>这种情况 <code>user2</code> 在同步更新 <code>master</code> 分支代码的时候会遇到 <code>error</code>，根据提示删除或移动文件位置即可！（删除最简单直观）</li>\n<li>修改方(<code>user1</code>)开起了敏感模式，被通知方(<code>user2</code>)未开启 虽然文件名已经被改动且同步到了远端，但是当 user2 （master）拉取的时候会发现自己本地的文件名依旧是 common 未改动。这个时候只需要手动的去更改文件名，然后 <code>merge</code> 到 <code>user2</code> 的分支即可</li>\n<li>修改方(<code>user1</code>)未开启敏感模式，被通知方(<code>user2</code>)开启了<br><code>user1</code> 自以为文件名已经更改成功且同步到了远端，实际并没有同步到远端，<code>user2</code> 自己手动更改，更改后 <code>push</code> 到远端，这样所有人的文件引用路径错误问题都能得到解决</li>\n</ul>\n</li>\n<li><p>第二种方式</p>\n<p>通过<code>git rm</code> 这个操作来处理。通过这种方式变更文件会被标记为R</p>\n</li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>已上所有内容都是经过好几遍测试，一遍实践一遍记录的形式来撰写的，最后也反复检查了好几遍，目测没有什么问题，如果有问题了就请留言告知吧~</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b9c2f3777647d1a0650f753e57cfd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image\" alt=\"47.jpg\"></p>\n"},{"title":"Curl命令使用","date":"2022-08-28T07:45:27.000Z","description":"Curl相关文档","_content":"\n```shell\ncrul -[选项] [URL]\n```\n\n\n## 代理访问\n\n```shell\ncurl --proxy [protocol]://[host][:port] https://alnda.cn\ncurl -x http://127.0.0.1:5000 https://alnda.cn\n```\n\n## 显示连接信息\n\n```shell\ncurl -v www.baidu.com\ncurl -I www.baidu.com #只显示返回的头信息\n```\n\n## 带参数的连接\n\n```shell\ncurl -d 'user=xiaoruan&age=22' http://127.0.0.1/index.html\n```\n\n## 指定请求方式\n\n```shell\ncurl -XGET www.baidu.com\n```\n\n## 将请求返回输入到某一个文件中\n\n```shell\ncurl www.baidu.com -o \n```","source":"_posts/Curl/index.md","raw":"---\ntitle: Curl命令使用\ndate: 2022-08-28 15:45:27\ntags:\n  - [curl]\ncategories:\n  - [技术]\ndescription: Curl相关文档\n---\n\n```shell\ncrul -[选项] [URL]\n```\n\n\n## 代理访问\n\n```shell\ncurl --proxy [protocol]://[host][:port] https://alnda.cn\ncurl -x http://127.0.0.1:5000 https://alnda.cn\n```\n\n## 显示连接信息\n\n```shell\ncurl -v www.baidu.com\ncurl -I www.baidu.com #只显示返回的头信息\n```\n\n## 带参数的连接\n\n```shell\ncurl -d 'user=xiaoruan&age=22' http://127.0.0.1/index.html\n```\n\n## 指定请求方式\n\n```shell\ncurl -XGET www.baidu.com\n```\n\n## 将请求返回输入到某一个文件中\n\n```shell\ncurl www.baidu.com -o \n```","slug":"Curl/index","published":1,"updated":"2022-08-29T05:49:10.329Z","_id":"cl7ec3i1c0004scvm9avugh1d","comments":1,"layout":"post","photos":[],"link":"","content":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs shell\">crul -[选项] [URL]<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"代理访问\"><a href=\"#代理访问\" class=\"headerlink\" title=\"代理访问\"></a>代理访问</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl --proxy [protocol]://[host][:port] https://alnda.cn<br>curl -x http://127.0.0.1:5000 https://alnda.cn<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"显示连接信息\"><a href=\"#显示连接信息\" class=\"headerlink\" title=\"显示连接信息\"></a>显示连接信息</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -v www.baidu.com<br>curl -I www.baidu.com #只显示返回的头信息<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"带参数的连接\"><a href=\"#带参数的连接\" class=\"headerlink\" title=\"带参数的连接\"></a>带参数的连接</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -d &#x27;user=xiaoruan&amp;age=22&#x27; http://127.0.0.1/index.html<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"指定请求方式\"><a href=\"#指定请求方式\" class=\"headerlink\" title=\"指定请求方式\"></a>指定请求方式</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -XGET www.baidu.com<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"将请求返回输入到某一个文件中\"><a href=\"#将请求返回输入到某一个文件中\" class=\"headerlink\" title=\"将请求返回输入到某一个文件中\"></a>将请求返回输入到某一个文件中</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl www.baidu.com -o <br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":312,"excerpt":"","more":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">crul -[选项] [URL]<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"代理访问\"><a href=\"#代理访问\" class=\"headerlink\" title=\"代理访问\"></a>代理访问</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl --proxy [protocol]://[host][:port] https://alnda.cn<br>curl -x http://127.0.0.1:5000 https://alnda.cn<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"显示连接信息\"><a href=\"#显示连接信息\" class=\"headerlink\" title=\"显示连接信息\"></a>显示连接信息</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -v www.baidu.com<br>curl -I www.baidu.com #只显示返回的头信息<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"带参数的连接\"><a href=\"#带参数的连接\" class=\"headerlink\" title=\"带参数的连接\"></a>带参数的连接</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -d &#x27;user=xiaoruan&amp;age=22&#x27; http://127.0.0.1/index.html<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"指定请求方式\"><a href=\"#指定请求方式\" class=\"headerlink\" title=\"指定请求方式\"></a>指定请求方式</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -XGET www.baidu.com<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"将请求返回输入到某一个文件中\"><a href=\"#将请求返回输入到某一个文件中\" class=\"headerlink\" title=\"将请求返回输入到某一个文件中\"></a>将请求返回输入到某一个文件中</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl www.baidu.com -o <br></code></pre></td></tr></table></figure>"},{"title":"Anaconda环境配置/基本操作","date":"2022-04-05T09:20:27.000Z","description":"Python Anaconda 虚拟环境相关文档","_content":"\n# 环境切换\n## 一、先创建一个新的虚拟环境\n```shell\n#创建一个名称为my__test\nconda create --name my__test python=3.7\n```\n## 二、激活虚拟环境\n```shell\nconda activate my_test\n```\n## 三、切换环境\n1、查看已有的虚拟环境\n```shell\nconda env list\n```\n![](https://pic2.zhimg.com/80/v2-2855cfd302e331d8c9a1ee1dfd84d925_1440w.jpg)\n\n2、切换到想要的虚拟环境，这里我切换到my_test\n```shell\nconda activate my_test\n```\n3、在当前环境里安装ipykernel\n```shell\nconda install ipykernel\n```\n![](https://pic4.zhimg.com/80/v2-3fe468e3a7647d138d6054a0c1c641bb_1440w.jpg)\n## 4、python -m ipykernel install --name my_test\n![](https://pic1.zhimg.com/80/v2-abb56915ea64e5583f1dea223876144c_1440w.jpg)\n## 5、打开jupyter新建一个notebook,如下所示：\n![](https://pic3.zhimg.com/80/v2-b6ccaa26c129ca4d0e284b645f74bbde_1440w.jpg)\n\n# 更新升级\n## 更新conda\n先执行\n```shell\nconda update conda\n```\n把conda更新到最新版\n```shell\nconda update anaconda\n```\n然后输入，把anaconda更新的新版。\n## 更新某一python环境所有的库\n切换到对应python环境\n```shell\nconda activate python_environment\n```\n执行\n```shell\nconda update --all\n```\n\n## 针对更新速度缓慢的问题我自己测试目前有两种解决办法：\n1.使用全局代理\n2.添加国内镜像源\n全局代理这个办法，这里不做讲解了，需要使用的朋友可以自己去研究一下。这里说一下添加国内镜像源的方法。\n```shell\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\n```\n2.设置启动设置好的国内镜像源\n```shell\nconda config --set show_channel_urls yes\n```\n3.查看是否添加上了源\n```text\nconda config --show\n```\n![](https://pic1.zhimg.com/80/v2-f7e47bb903a26d77bdb47c7c4932cc24_1440w.jpg)\n这个是默认的，如果你添加成功了，会在上面出现两个刚才添加的地址\n如果镜像源失效了，或者想换成其他的源，怎么删除呢？\n```shell\nconda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\n```\n```shell\nconda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\n```\n这样就可以删除了。\n出现更新慢的问题的，先把代理或者源设置好，然后就可以更新你的Anaconda了。看到这里估计可能会有人放弃了，太麻烦了，又得找代理，又得用国内镜像的，太费劲了，当然还有一种更简单粗暴的方式，卸载掉目前用的版本，安装个最新版的。但是配置好的环境应该都没有了，我没敢尝试这样的方法。如果大家有更好的办法解决Anaconda升级的问题，欢迎一起讨论一下，这个给遇到升级问题的小伙伴们一个参考，不足之处请指正。","source":"_posts/Anaconda/环境配置.md","raw":"---\ntitle: Anaconda环境配置/基本操作\ndate: 2022-04-05 17:20:27\ntags:\n  - [python]\n  - [anaconda]\ncategories:\n  - [技术]\ndescription: Python Anaconda 虚拟环境相关文档\n---\n\n# 环境切换\n## 一、先创建一个新的虚拟环境\n```shell\n#创建一个名称为my__test\nconda create --name my__test python=3.7\n```\n## 二、激活虚拟环境\n```shell\nconda activate my_test\n```\n## 三、切换环境\n1、查看已有的虚拟环境\n```shell\nconda env list\n```\n![](https://pic2.zhimg.com/80/v2-2855cfd302e331d8c9a1ee1dfd84d925_1440w.jpg)\n\n2、切换到想要的虚拟环境，这里我切换到my_test\n```shell\nconda activate my_test\n```\n3、在当前环境里安装ipykernel\n```shell\nconda install ipykernel\n```\n![](https://pic4.zhimg.com/80/v2-3fe468e3a7647d138d6054a0c1c641bb_1440w.jpg)\n## 4、python -m ipykernel install --name my_test\n![](https://pic1.zhimg.com/80/v2-abb56915ea64e5583f1dea223876144c_1440w.jpg)\n## 5、打开jupyter新建一个notebook,如下所示：\n![](https://pic3.zhimg.com/80/v2-b6ccaa26c129ca4d0e284b645f74bbde_1440w.jpg)\n\n# 更新升级\n## 更新conda\n先执行\n```shell\nconda update conda\n```\n把conda更新到最新版\n```shell\nconda update anaconda\n```\n然后输入，把anaconda更新的新版。\n## 更新某一python环境所有的库\n切换到对应python环境\n```shell\nconda activate python_environment\n```\n执行\n```shell\nconda update --all\n```\n\n## 针对更新速度缓慢的问题我自己测试目前有两种解决办法：\n1.使用全局代理\n2.添加国内镜像源\n全局代理这个办法，这里不做讲解了，需要使用的朋友可以自己去研究一下。这里说一下添加国内镜像源的方法。\n```shell\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\n```\n2.设置启动设置好的国内镜像源\n```shell\nconda config --set show_channel_urls yes\n```\n3.查看是否添加上了源\n```text\nconda config --show\n```\n![](https://pic1.zhimg.com/80/v2-f7e47bb903a26d77bdb47c7c4932cc24_1440w.jpg)\n这个是默认的，如果你添加成功了，会在上面出现两个刚才添加的地址\n如果镜像源失效了，或者想换成其他的源，怎么删除呢？\n```shell\nconda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\n```\n```shell\nconda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\n```\n这样就可以删除了。\n出现更新慢的问题的，先把代理或者源设置好，然后就可以更新你的Anaconda了。看到这里估计可能会有人放弃了，太麻烦了，又得找代理，又得用国内镜像的，太费劲了，当然还有一种更简单粗暴的方式，卸载掉目前用的版本，安装个最新版的。但是配置好的环境应该都没有了，我没敢尝试这样的方法。如果大家有更好的办法解决Anaconda升级的问题，欢迎一起讨论一下，这个给遇到升级问题的小伙伴们一个参考，不足之处请指正。","slug":"Anaconda/环境配置","published":1,"updated":"2022-08-28T07:38:59.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1e0006scvme7v1fwuy","content":"<h1 id=\"环境切换\"><a href=\"#环境切换\" class=\"headerlink\" title=\"环境切换\"></a>环境切换</h1><h2 id=\"一、先创建一个新的虚拟环境\"><a href=\"#一、先创建一个新的虚拟环境\" class=\"headerlink\" title=\"一、先创建一个新的虚拟环境\"></a>一、先创建一个新的虚拟环境</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">创建一个名称为my__test</span><br>conda create --name my__test python=3.7<br></code></pre></td></tr></table></figure>\n<h2 id=\"二、激活虚拟环境\"><a href=\"#二、激活虚拟环境\" class=\"headerlink\" title=\"二、激活虚拟环境\"></a>二、激活虚拟环境</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda activate my_test<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、切换环境\"><a href=\"#三、切换环境\" class=\"headerlink\" title=\"三、切换环境\"></a>三、切换环境</h2><p>1、查看已有的虚拟环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda env list<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://pic2.zhimg.com/80/v2-2855cfd302e331d8c9a1ee1dfd84d925_1440w.jpg\"></p>\n<p>2、切换到想要的虚拟环境，这里我切换到my_test</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda activate my_test<br></code></pre></td></tr></table></figure>\n<p>3、在当前环境里安装ipykernel</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda install ipykernel<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-3fe468e3a7647d138d6054a0c1c641bb_1440w.jpg\"></p>\n<h2 id=\"4、python-m-ipykernel-install-–name-my-test\"><a href=\"#4、python-m-ipykernel-install-–name-my-test\" class=\"headerlink\" title=\"4、python -m ipykernel install –name my_test\"></a>4、python -m ipykernel install –name my_test</h2><p><img src=\"https://pic1.zhimg.com/80/v2-abb56915ea64e5583f1dea223876144c_1440w.jpg\"></p>\n<h2 id=\"5、打开jupyter新建一个notebook-如下所示：\"><a href=\"#5、打开jupyter新建一个notebook-如下所示：\" class=\"headerlink\" title=\"5、打开jupyter新建一个notebook,如下所示：\"></a>5、打开jupyter新建一个notebook,如下所示：</h2><p><img src=\"https://pic3.zhimg.com/80/v2-b6ccaa26c129ca4d0e284b645f74bbde_1440w.jpg\"></p>\n<h1 id=\"更新升级\"><a href=\"#更新升级\" class=\"headerlink\" title=\"更新升级\"></a>更新升级</h1><h2 id=\"更新conda\"><a href=\"#更新conda\" class=\"headerlink\" title=\"更新conda\"></a>更新conda</h2><p>先执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda update conda<br></code></pre></td></tr></table></figure>\n<p>把conda更新到最新版</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda update anaconda<br></code></pre></td></tr></table></figure>\n<p>然后输入，把anaconda更新的新版。</p>\n<h2 id=\"更新某一python环境所有的库\"><a href=\"#更新某一python环境所有的库\" class=\"headerlink\" title=\"更新某一python环境所有的库\"></a>更新某一python环境所有的库</h2><p>切换到对应python环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda activate python_environment<br></code></pre></td></tr></table></figure>\n<p>执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda update --all<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"针对更新速度缓慢的问题我自己测试目前有两种解决办法：\"><a href=\"#针对更新速度缓慢的问题我自己测试目前有两种解决办法：\" class=\"headerlink\" title=\"针对更新速度缓慢的问题我自己测试目前有两种解决办法：\"></a>针对更新速度缓慢的问题我自己测试目前有两种解决办法：</h2><p>1.使用全局代理<br>2.添加国内镜像源<br>全局代理这个办法，这里不做讲解了，需要使用的朋友可以自己去研究一下。这里说一下添加国内镜像源的方法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/<br></code></pre></td></tr></table></figure>\n<p>2.设置启动设置好的国内镜像源</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --set show_channel_urls yes<br></code></pre></td></tr></table></figure>\n<p>3.查看是否添加上了源</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">conda config --show<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://pic1.zhimg.com/80/v2-f7e47bb903a26d77bdb47c7c4932cc24_1440w.jpg\"><br>这个是默认的，如果你添加成功了，会在上面出现两个刚才添加的地址<br>如果镜像源失效了，或者想换成其他的源，怎么删除呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/<br></code></pre></td></tr></table></figure>\n<p>这样就可以删除了。<br>出现更新慢的问题的，先把代理或者源设置好，然后就可以更新你的Anaconda了。看到这里估计可能会有人放弃了，太麻烦了，又得找代理，又得用国内镜像的，太费劲了，当然还有一种更简单粗暴的方式，卸载掉目前用的版本，安装个最新版的。但是配置好的环境应该都没有了，我没敢尝试这样的方法。如果大家有更好的办法解决Anaconda升级的问题，欢迎一起讨论一下，这个给遇到升级问题的小伙伴们一个参考，不足之处请指正。</p>\n","site":{"data":{}},"wordcount":1109,"excerpt":"","more":"<h1 id=\"环境切换\"><a href=\"#环境切换\" class=\"headerlink\" title=\"环境切换\"></a>环境切换</h1><h2 id=\"一、先创建一个新的虚拟环境\"><a href=\"#一、先创建一个新的虚拟环境\" class=\"headerlink\" title=\"一、先创建一个新的虚拟环境\"></a>一、先创建一个新的虚拟环境</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">创建一个名称为my__test</span><br>conda create --name my__test python=3.7<br></code></pre></td></tr></table></figure>\n<h2 id=\"二、激活虚拟环境\"><a href=\"#二、激活虚拟环境\" class=\"headerlink\" title=\"二、激活虚拟环境\"></a>二、激活虚拟环境</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda activate my_test<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、切换环境\"><a href=\"#三、切换环境\" class=\"headerlink\" title=\"三、切换环境\"></a>三、切换环境</h2><p>1、查看已有的虚拟环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda env list<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://pic2.zhimg.com/80/v2-2855cfd302e331d8c9a1ee1dfd84d925_1440w.jpg\"></p>\n<p>2、切换到想要的虚拟环境，这里我切换到my_test</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda activate my_test<br></code></pre></td></tr></table></figure>\n<p>3、在当前环境里安装ipykernel</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda install ipykernel<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://pic4.zhimg.com/80/v2-3fe468e3a7647d138d6054a0c1c641bb_1440w.jpg\"></p>\n<h2 id=\"4、python-m-ipykernel-install-–name-my-test\"><a href=\"#4、python-m-ipykernel-install-–name-my-test\" class=\"headerlink\" title=\"4、python -m ipykernel install –name my_test\"></a>4、python -m ipykernel install –name my_test</h2><p><img src=\"https://pic1.zhimg.com/80/v2-abb56915ea64e5583f1dea223876144c_1440w.jpg\"></p>\n<h2 id=\"5、打开jupyter新建一个notebook-如下所示：\"><a href=\"#5、打开jupyter新建一个notebook-如下所示：\" class=\"headerlink\" title=\"5、打开jupyter新建一个notebook,如下所示：\"></a>5、打开jupyter新建一个notebook,如下所示：</h2><p><img src=\"https://pic3.zhimg.com/80/v2-b6ccaa26c129ca4d0e284b645f74bbde_1440w.jpg\"></p>\n<h1 id=\"更新升级\"><a href=\"#更新升级\" class=\"headerlink\" title=\"更新升级\"></a>更新升级</h1><h2 id=\"更新conda\"><a href=\"#更新conda\" class=\"headerlink\" title=\"更新conda\"></a>更新conda</h2><p>先执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda update conda<br></code></pre></td></tr></table></figure>\n<p>把conda更新到最新版</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda update anaconda<br></code></pre></td></tr></table></figure>\n<p>然后输入，把anaconda更新的新版。</p>\n<h2 id=\"更新某一python环境所有的库\"><a href=\"#更新某一python环境所有的库\" class=\"headerlink\" title=\"更新某一python环境所有的库\"></a>更新某一python环境所有的库</h2><p>切换到对应python环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda activate python_environment<br></code></pre></td></tr></table></figure>\n<p>执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda update --all<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"针对更新速度缓慢的问题我自己测试目前有两种解决办法：\"><a href=\"#针对更新速度缓慢的问题我自己测试目前有两种解决办法：\" class=\"headerlink\" title=\"针对更新速度缓慢的问题我自己测试目前有两种解决办法：\"></a>针对更新速度缓慢的问题我自己测试目前有两种解决办法：</h2><p>1.使用全局代理<br>2.添加国内镜像源<br>全局代理这个办法，这里不做讲解了，需要使用的朋友可以自己去研究一下。这里说一下添加国内镜像源的方法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/<br></code></pre></td></tr></table></figure>\n<p>2.设置启动设置好的国内镜像源</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --set show_channel_urls yes<br></code></pre></td></tr></table></figure>\n<p>3.查看是否添加上了源</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">conda config --show<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://pic1.zhimg.com/80/v2-f7e47bb903a26d77bdb47c7c4932cc24_1440w.jpg\"><br>这个是默认的，如果你添加成功了，会在上面出现两个刚才添加的地址<br>如果镜像源失效了，或者想换成其他的源，怎么删除呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">conda config --remove channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/<br></code></pre></td></tr></table></figure>\n<p>这样就可以删除了。<br>出现更新慢的问题的，先把代理或者源设置好，然后就可以更新你的Anaconda了。看到这里估计可能会有人放弃了，太麻烦了，又得找代理，又得用国内镜像的，太费劲了，当然还有一种更简单粗暴的方式，卸载掉目前用的版本，安装个最新版的。但是配置好的环境应该都没有了，我没敢尝试这样的方法。如果大家有更好的办法解决Anaconda升级的问题，欢迎一起讨论一下，这个给遇到升级问题的小伙伴们一个参考，不足之处请指正。</p>\n"},{"title":"Forking Workflow","date":"2022-04-05T09:16:27.000Z","description":"Git相关文档","_content":"\n# Forking Workflow\n\nThe Forking Workflow is fundamentally different than other popular Git workflows. Instead of using a single server-side repository to act as the “central” codebase, it gives every developer their own server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. The Forking Workflow is most often seen in public open source projects.\n\nThe main advantage of the Forking Workflow is that contributions can be integrated without the need for everybody to push to a single central repository. Developers push to their own server-side repositories, and only the project maintainer can push to the official repository. This allows the maintainer to accept commits from any developer without giving them write access to the official codebase.\n\nThe Forking Workflow typically follows a branching model based on the [Gitflow Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow). This means that complete feature branches will be purposed for merge into the original project maintainer's repository. The result is a distributed workflow that provides a flexible way for large, organic teams (including untrusted third-parties) to collaborate securely. This also makes it an ideal workflow for open source projects.  \n\n\n## How it works\n\nAs in the other [Git workflows](https://www.atlassian.com/git/tutorials/comparing-workflows), the Forking Workflow begins with an official public repository stored on a server. But when a new developer wants to start working on the project, they do not directly clone the official repository.\n\nInstead, they fork the official repository to create a copy of it on the server. This new copy serves as their personal public repository—no other developers are allowed to push to it, but they can pull changes from it (we’ll see why this is important in a moment). After they have created their server-side copy, the developer performs a `[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)` to get a copy of it onto their local machine. This serves as their private development environment, just like in the other workflows.\n\nWhen they're ready to publish a local commit, they push the commit to their own public repository—not the official one. Then, they file a pull request with the main repository, which lets the project maintainer know that an update is ready to be integrated. The pull request also serves as a convenient discussion thread if there are issues with the contributed code. The following is a step-by-step example of this workflow.\n\n1.  A developer 'forks' an 'official' server-side repository. This creates their own server-side copy.\n2.  The new server-side copy is cloned to their local system.\n3.  A Git remote path for the 'official' repository is added to the local clone.\n4.  A new local feature branch is created.\n5.  The developer makes changes on the new branch.\n6.  New commits are created for the changes.\n7.  The branch gets pushed to the developer's own server-side copy.\n8.  The developer opens a pull request from the new branch to the 'official' repository.\n9.  The pull request gets approved for merge and is merged into the original server-side repository  \n    \n\nTo integrate the feature into the official codebase, the maintainer pulls the contributor’s changes into their local repository, checks to make sure it doesn’t break the project, merges it into their local `main` branch, then pushes the `main` branch to the official repository on the server. The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.\n\nIt’s important to understand that the notion of an “official” repository in the Forking Workflow is merely a convention. In fact, the only thing that makes the official repository so official is that it’s the public repository of the project maintainer.\n\n## Forking vs cloning\n\nIt's important to note that \"forked\" repositories and \"forking\" are not special operations. Forked repositories are created using the standard `[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)` command. Forked repositories are generally \"server-side clones\" and usually managed and hosted by a 3rd party Git service like [Bitbucket](https://bitbucket.org/product). There is no unique Git command to create forked repositories. A clone operation is essentially a copy of a repository and its history. \n\n## Branching in the Forking Workflow\n\nAll of these personal public repositories are really just a convenient way to share branches with other developers. Everybody should still be using branches to isolate individual features, just like in the [Feature Branch Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow) and the [Gitflow Workflow.](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow) The only difference is how those branches get shared. In the Forking Workflow, they are pulled into another developer’s local repository, while in the Feature Branch and Gitflow Workflows they are pushed to the official repository.\n\n## Fork a repository\n\n![git fork workflow - fork a repositiory](https://wac-cdn.atlassian.com/dam/jcr:642c56e3-ddc6-43ff-ab86-c5cd845afd05/03.svg?cdnVersion=116)\n\nAll new developers to a Forking Workflow project need to fork the official repository. As previously stated, forking is just a standard `git clone` operation. It’s possible to do this by SSH’ing into the server and running `git clone` to copy it to another location on the server. Popular Git hosting services like Bitbucket, offer repo forking features that automate this step.\n\n## Clone your fork\n\nNext each developer needs to clone their own public forked repository. They can do this with the familiar `git clone`command.\n\nAssuming the use of Bitbucket to host these repositories, developers on a project should have their own Bitbucket account and they should clone their forked copy of the repository with:\n\n```sh\ngit clone https://user@bitbucket.org/user/repo.git\n```\n\n## Adding a remote\n\nWhereas other Git workflows use a single origin remote that points to the central repository, the Forking Workflow requires two remotes—one for the official repository, and one for the developer’s personal server-side repository. While you can call these remotes anything you want, a common convention is to use origin as the remote for your forked repository (this will be created automatically when you run `git clone`) and upstream for the official repository.\n\n```sh\ngit remote add upstream https://bitbucket.org/maintainer/repo\n```\n\nYou’ll need to create the upstream remote yourself using the above command. This will let you easily keep your local repository up-to-date as the official project progresses. Note that if your upstream repository has authentication enabled (i.e., it's not open source), you'll need to supply a username, like so:\n\n```sh\ngit remote add upstream https://user@bitbucket.org/maintainer/repo.git\n```\n\nThis requires users to supply a valid password before cloning or pulling from the official codebase.\n\n## Working in a branch: making & pushing changes\n\nIn the developer's local copy of the forked repository they can edit code, commit changes, and create branches just like in other Git workflows:\n\n `git checkout -b some-feature # Edit some code git commit -a -m \"Add first draft of some feature\"`\n\nAll of their changes will be entirely private until they push it to their public repository. And, if the official project has moved forward, they can access new commits with `git pull`:\n\n `git pull upstream main`\n\nSince developers should be working in a dedicated feature branch, this should generally result in a fast-forward merge.\n\n## Making a Pull Request\n\n![Git Fork Workflow - Making a pull request](https://wac-cdn.atlassian.com/dam/jcr:0de71551-5c08-4fc4-ab6d-dc8a51bfcc5a/05.svg?cdnVersion=116)\n\nOnce a developer is ready to share their new feature, they need to do two things. First, they have to make their contribution accessible to other developers by pushing it to their public repository. Their origin remote should already be set up, so all they should have to do is the following:\n\n```sh\ngit push origin feature-branch\n```\n\nThis diverges from the other workflows in that the origin remote points to the developer’s personal server-side repository, not the main codebase.\n\nSecond, they need to notify the project maintainer that they want to merge their feature into the official codebase. Bitbucket provides a “pull request” button that leads to a form asking you to specify which branch you want to merge into the official repository. Typically, you’ll want to integrate your `feature` branch into the upstream remote’s `main` branch.\n\n## Summary\n\nTo recap, the Forking Workflow is commonly used in public open-source projects. Forking is a `git clone` operation executed on a server copy of a projects repo. A Forking Workflow is often used in conjunction with a Git hosting service like Bitbucket. A high-level example of a Forking Workflow is:\n\n1.  You want to contribute to an open source library hosted at bitbucket.org/userA/open-project\n2.  Using Bitbucket you create a fork of the repo to bitbucket.org/YourName/open-project\n3.  On your local system you execute `git clone` on https://bitbucket.org/YourName/open-project to get a local copy of the repo\n4.  You create a new `feature` branch in your local repo\n5.  Work is done to complete the new feature and `git commit`is executed to save the changes\n6.  You then push the new `feature` branch to your remote forked repo\n7.  Using Bitbucket you open up a pull request for the new branch against the original repo at bitbucket.org/userA/open-project  \n    \n\nThe Forking Workflow helps a maintainer of a project open up the repository to contributions from any developer without having to manually manage authorization settings for each individual contributor. This gives the maintainer more of a \"pull\" style workflow. Most commonly used in open-source projects, the Forking Workflow can also be applied to private business workflows to give more authoritative control over what is merged into a release. This can be useful in teams that have Deploy Managers or strict release cycles.","source":"_posts/Git/forking workflow.md","raw":"---\ntitle: Forking Workflow\ndate: 2022-04-05 17:16:27\ntags:\n  - [git]\ncategories:\n  - [技术]\ndescription: Git相关文档\n---\n\n# Forking Workflow\n\nThe Forking Workflow is fundamentally different than other popular Git workflows. Instead of using a single server-side repository to act as the “central” codebase, it gives every developer their own server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. The Forking Workflow is most often seen in public open source projects.\n\nThe main advantage of the Forking Workflow is that contributions can be integrated without the need for everybody to push to a single central repository. Developers push to their own server-side repositories, and only the project maintainer can push to the official repository. This allows the maintainer to accept commits from any developer without giving them write access to the official codebase.\n\nThe Forking Workflow typically follows a branching model based on the [Gitflow Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow). This means that complete feature branches will be purposed for merge into the original project maintainer's repository. The result is a distributed workflow that provides a flexible way for large, organic teams (including untrusted third-parties) to collaborate securely. This also makes it an ideal workflow for open source projects.  \n\n\n## How it works\n\nAs in the other [Git workflows](https://www.atlassian.com/git/tutorials/comparing-workflows), the Forking Workflow begins with an official public repository stored on a server. But when a new developer wants to start working on the project, they do not directly clone the official repository.\n\nInstead, they fork the official repository to create a copy of it on the server. This new copy serves as their personal public repository—no other developers are allowed to push to it, but they can pull changes from it (we’ll see why this is important in a moment). After they have created their server-side copy, the developer performs a `[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)` to get a copy of it onto their local machine. This serves as their private development environment, just like in the other workflows.\n\nWhen they're ready to publish a local commit, they push the commit to their own public repository—not the official one. Then, they file a pull request with the main repository, which lets the project maintainer know that an update is ready to be integrated. The pull request also serves as a convenient discussion thread if there are issues with the contributed code. The following is a step-by-step example of this workflow.\n\n1.  A developer 'forks' an 'official' server-side repository. This creates their own server-side copy.\n2.  The new server-side copy is cloned to their local system.\n3.  A Git remote path for the 'official' repository is added to the local clone.\n4.  A new local feature branch is created.\n5.  The developer makes changes on the new branch.\n6.  New commits are created for the changes.\n7.  The branch gets pushed to the developer's own server-side copy.\n8.  The developer opens a pull request from the new branch to the 'official' repository.\n9.  The pull request gets approved for merge and is merged into the original server-side repository  \n    \n\nTo integrate the feature into the official codebase, the maintainer pulls the contributor’s changes into their local repository, checks to make sure it doesn’t break the project, merges it into their local `main` branch, then pushes the `main` branch to the official repository on the server. The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.\n\nIt’s important to understand that the notion of an “official” repository in the Forking Workflow is merely a convention. In fact, the only thing that makes the official repository so official is that it’s the public repository of the project maintainer.\n\n## Forking vs cloning\n\nIt's important to note that \"forked\" repositories and \"forking\" are not special operations. Forked repositories are created using the standard `[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)` command. Forked repositories are generally \"server-side clones\" and usually managed and hosted by a 3rd party Git service like [Bitbucket](https://bitbucket.org/product). There is no unique Git command to create forked repositories. A clone operation is essentially a copy of a repository and its history. \n\n## Branching in the Forking Workflow\n\nAll of these personal public repositories are really just a convenient way to share branches with other developers. Everybody should still be using branches to isolate individual features, just like in the [Feature Branch Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow) and the [Gitflow Workflow.](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow) The only difference is how those branches get shared. In the Forking Workflow, they are pulled into another developer’s local repository, while in the Feature Branch and Gitflow Workflows they are pushed to the official repository.\n\n## Fork a repository\n\n![git fork workflow - fork a repositiory](https://wac-cdn.atlassian.com/dam/jcr:642c56e3-ddc6-43ff-ab86-c5cd845afd05/03.svg?cdnVersion=116)\n\nAll new developers to a Forking Workflow project need to fork the official repository. As previously stated, forking is just a standard `git clone` operation. It’s possible to do this by SSH’ing into the server and running `git clone` to copy it to another location on the server. Popular Git hosting services like Bitbucket, offer repo forking features that automate this step.\n\n## Clone your fork\n\nNext each developer needs to clone their own public forked repository. They can do this with the familiar `git clone`command.\n\nAssuming the use of Bitbucket to host these repositories, developers on a project should have their own Bitbucket account and they should clone their forked copy of the repository with:\n\n```sh\ngit clone https://user@bitbucket.org/user/repo.git\n```\n\n## Adding a remote\n\nWhereas other Git workflows use a single origin remote that points to the central repository, the Forking Workflow requires two remotes—one for the official repository, and one for the developer’s personal server-side repository. While you can call these remotes anything you want, a common convention is to use origin as the remote for your forked repository (this will be created automatically when you run `git clone`) and upstream for the official repository.\n\n```sh\ngit remote add upstream https://bitbucket.org/maintainer/repo\n```\n\nYou’ll need to create the upstream remote yourself using the above command. This will let you easily keep your local repository up-to-date as the official project progresses. Note that if your upstream repository has authentication enabled (i.e., it's not open source), you'll need to supply a username, like so:\n\n```sh\ngit remote add upstream https://user@bitbucket.org/maintainer/repo.git\n```\n\nThis requires users to supply a valid password before cloning or pulling from the official codebase.\n\n## Working in a branch: making & pushing changes\n\nIn the developer's local copy of the forked repository they can edit code, commit changes, and create branches just like in other Git workflows:\n\n `git checkout -b some-feature # Edit some code git commit -a -m \"Add first draft of some feature\"`\n\nAll of their changes will be entirely private until they push it to their public repository. And, if the official project has moved forward, they can access new commits with `git pull`:\n\n `git pull upstream main`\n\nSince developers should be working in a dedicated feature branch, this should generally result in a fast-forward merge.\n\n## Making a Pull Request\n\n![Git Fork Workflow - Making a pull request](https://wac-cdn.atlassian.com/dam/jcr:0de71551-5c08-4fc4-ab6d-dc8a51bfcc5a/05.svg?cdnVersion=116)\n\nOnce a developer is ready to share their new feature, they need to do two things. First, they have to make their contribution accessible to other developers by pushing it to their public repository. Their origin remote should already be set up, so all they should have to do is the following:\n\n```sh\ngit push origin feature-branch\n```\n\nThis diverges from the other workflows in that the origin remote points to the developer’s personal server-side repository, not the main codebase.\n\nSecond, they need to notify the project maintainer that they want to merge their feature into the official codebase. Bitbucket provides a “pull request” button that leads to a form asking you to specify which branch you want to merge into the official repository. Typically, you’ll want to integrate your `feature` branch into the upstream remote’s `main` branch.\n\n## Summary\n\nTo recap, the Forking Workflow is commonly used in public open-source projects. Forking is a `git clone` operation executed on a server copy of a projects repo. A Forking Workflow is often used in conjunction with a Git hosting service like Bitbucket. A high-level example of a Forking Workflow is:\n\n1.  You want to contribute to an open source library hosted at bitbucket.org/userA/open-project\n2.  Using Bitbucket you create a fork of the repo to bitbucket.org/YourName/open-project\n3.  On your local system you execute `git clone` on https://bitbucket.org/YourName/open-project to get a local copy of the repo\n4.  You create a new `feature` branch in your local repo\n5.  Work is done to complete the new feature and `git commit`is executed to save the changes\n6.  You then push the new `feature` branch to your remote forked repo\n7.  Using Bitbucket you open up a pull request for the new branch against the original repo at bitbucket.org/userA/open-project  \n    \n\nThe Forking Workflow helps a maintainer of a project open up the repository to contributions from any developer without having to manually manage authorization settings for each individual contributor. This gives the maintainer more of a \"pull\" style workflow. Most commonly used in open-source projects, the Forking Workflow can also be applied to private business workflows to give more authoritative control over what is merged into a release. This can be useful in teams that have Deploy Managers or strict release cycles.","slug":"Git/forking workflow","published":1,"updated":"2022-08-28T07:38:59.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1f0007scvmae4s2zet","content":"<h1 id=\"Forking-Workflow\"><a href=\"#Forking-Workflow\" class=\"headerlink\" title=\"Forking Workflow\"></a>Forking Workflow</h1><p>The Forking Workflow is fundamentally different than other popular Git workflows. Instead of using a single server-side repository to act as the “central” codebase, it gives every developer their own server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. The Forking Workflow is most often seen in public open source projects.</p>\n<p>The main advantage of the Forking Workflow is that contributions can be integrated without the need for everybody to push to a single central repository. Developers push to their own server-side repositories, and only the project maintainer can push to the official repository. This allows the maintainer to accept commits from any developer without giving them write access to the official codebase.</p>\n<p>The Forking Workflow typically follows a branching model based on the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\">Gitflow Workflow</a>. This means that complete feature branches will be purposed for merge into the original project maintainer’s repository. The result is a distributed workflow that provides a flexible way for large, organic teams (including untrusted third-parties) to collaborate securely. This also makes it an ideal workflow for open source projects.  </p>\n<h2 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h2><p>As in the other <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows\">Git workflows</a>, the Forking Workflow begins with an official public repository stored on a server. But when a new developer wants to start working on the project, they do not directly clone the official repository.</p>\n<p>Instead, they fork the official repository to create a copy of it on the server. This new copy serves as their personal public repository—no other developers are allowed to push to it, but they can pull changes from it (we’ll see why this is important in a moment). After they have created their server-side copy, the developer performs a <code>[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)</code> to get a copy of it onto their local machine. This serves as their private development environment, just like in the other workflows.</p>\n<p>When they’re ready to publish a local commit, they push the commit to their own public repository—not the official one. Then, they file a pull request with the main repository, which lets the project maintainer know that an update is ready to be integrated. The pull request also serves as a convenient discussion thread if there are issues with the contributed code. The following is a step-by-step example of this workflow.</p>\n<ol>\n<li>A developer ‘forks’ an ‘official’ server-side repository. This creates their own server-side copy.</li>\n<li>The new server-side copy is cloned to their local system.</li>\n<li>A Git remote path for the ‘official’ repository is added to the local clone.</li>\n<li>A new local feature branch is created.</li>\n<li>The developer makes changes on the new branch.</li>\n<li>New commits are created for the changes.</li>\n<li>The branch gets pushed to the developer’s own server-side copy.</li>\n<li>The developer opens a pull request from the new branch to the ‘official’ repository.</li>\n<li>The pull request gets approved for merge and is merged into the original server-side repository</li>\n</ol>\n<p>To integrate the feature into the official codebase, the maintainer pulls the contributor’s changes into their local repository, checks to make sure it doesn’t break the project, merges it into their local <code>main</code> branch, then pushes the <code>main</code> branch to the official repository on the server. The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.</p>\n<p>It’s important to understand that the notion of an “official” repository in the Forking Workflow is merely a convention. In fact, the only thing that makes the official repository so official is that it’s the public repository of the project maintainer.</p>\n<h2 id=\"Forking-vs-cloning\"><a href=\"#Forking-vs-cloning\" class=\"headerlink\" title=\"Forking vs cloning\"></a>Forking vs cloning</h2><p>It’s important to note that “forked” repositories and “forking” are not special operations. Forked repositories are created using the standard <code>[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)</code> command. Forked repositories are generally “server-side clones” and usually managed and hosted by a 3rd party Git service like <a href=\"https://bitbucket.org/product\">Bitbucket</a>. There is no unique Git command to create forked repositories. A clone operation is essentially a copy of a repository and its history. </p>\n<h2 id=\"Branching-in-the-Forking-Workflow\"><a href=\"#Branching-in-the-Forking-Workflow\" class=\"headerlink\" title=\"Branching in the Forking Workflow\"></a>Branching in the Forking Workflow</h2><p>All of these personal public repositories are really just a convenient way to share branches with other developers. Everybody should still be using branches to isolate individual features, just like in the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow\">Feature Branch Workflow</a> and the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\">Gitflow Workflow.</a> The only difference is how those branches get shared. In the Forking Workflow, they are pulled into another developer’s local repository, while in the Feature Branch and Gitflow Workflows they are pushed to the official repository.</p>\n<h2 id=\"Fork-a-repository\"><a href=\"#Fork-a-repository\" class=\"headerlink\" title=\"Fork a repository\"></a>Fork a repository</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:642c56e3-ddc6-43ff-ab86-c5cd845afd05/03.svg?cdnVersion=116\" alt=\"git fork workflow - fork a repositiory\"></p>\n<p>All new developers to a Forking Workflow project need to fork the official repository. As previously stated, forking is just a standard <code>git clone</code> operation. It’s possible to do this by SSH’ing into the server and running <code>git clone</code> to copy it to another location on the server. Popular Git hosting services like Bitbucket, offer repo forking features that automate this step.</p>\n<h2 id=\"Clone-your-fork\"><a href=\"#Clone-your-fork\" class=\"headerlink\" title=\"Clone your fork\"></a>Clone your fork</h2><p>Next each developer needs to clone their own public forked repository. They can do this with the familiar <code>git clone</code>command.</p>\n<p>Assuming the use of Bitbucket to host these repositories, developers on a project should have their own Bitbucket account and they should clone their forked copy of the repository with:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs sh\">git <span class=\"hljs-built_in\">clone</span> https://user@bitbucket.org/user/repo.git<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Adding-a-remote\"><a href=\"#Adding-a-remote\" class=\"headerlink\" title=\"Adding a remote\"></a>Adding a remote</h2><p>Whereas other Git workflows use a single origin remote that points to the central repository, the Forking Workflow requires two remotes—one for the official repository, and one for the developer’s personal server-side repository. While you can call these remotes anything you want, a common convention is to use origin as the remote for your forked repository (this will be created automatically when you run <code>git clone</code>) and upstream for the official repository.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git remote add upstream https://bitbucket.org/maintainer/repo<br></code></pre></td></tr></table></figure>\n\n<p>You’ll need to create the upstream remote yourself using the above command. This will let you easily keep your local repository up-to-date as the official project progresses. Note that if your upstream repository has authentication enabled (i.e., it’s not open source), you’ll need to supply a username, like so:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git remote add upstream https://user@bitbucket.org/maintainer/repo.git<br></code></pre></td></tr></table></figure>\n\n<p>This requires users to supply a valid password before cloning or pulling from the official codebase.</p>\n<h2 id=\"Working-in-a-branch-making-amp-pushing-changes\"><a href=\"#Working-in-a-branch-making-amp-pushing-changes\" class=\"headerlink\" title=\"Working in a branch: making &amp; pushing changes\"></a>Working in a branch: making &amp; pushing changes</h2><p>In the developer’s local copy of the forked repository they can edit code, commit changes, and create branches just like in other Git workflows:</p>\n<p> <code>git checkout -b some-feature # Edit some code git commit -a -m &quot;Add first draft of some feature&quot;</code></p>\n<p>All of their changes will be entirely private until they push it to their public repository. And, if the official project has moved forward, they can access new commits with <code>git pull</code>:</p>\n<p> <code>git pull upstream main</code></p>\n<p>Since developers should be working in a dedicated feature branch, this should generally result in a fast-forward merge.</p>\n<h2 id=\"Making-a-Pull-Request\"><a href=\"#Making-a-Pull-Request\" class=\"headerlink\" title=\"Making a Pull Request\"></a>Making a Pull Request</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:0de71551-5c08-4fc4-ab6d-dc8a51bfcc5a/05.svg?cdnVersion=116\" alt=\"Git Fork Workflow - Making a pull request\"></p>\n<p>Once a developer is ready to share their new feature, they need to do two things. First, they have to make their contribution accessible to other developers by pushing it to their public repository. Their origin remote should already be set up, so all they should have to do is the following:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git push origin feature-branch<br></code></pre></td></tr></table></figure>\n\n<p>This diverges from the other workflows in that the origin remote points to the developer’s personal server-side repository, not the main codebase.</p>\n<p>Second, they need to notify the project maintainer that they want to merge their feature into the official codebase. Bitbucket provides a “pull request” button that leads to a form asking you to specify which branch you want to merge into the official repository. Typically, you’ll want to integrate your <code>feature</code> branch into the upstream remote’s <code>main</code> branch.</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>To recap, the Forking Workflow is commonly used in public open-source projects. Forking is a <code>git clone</code> operation executed on a server copy of a projects repo. A Forking Workflow is often used in conjunction with a Git hosting service like Bitbucket. A high-level example of a Forking Workflow is:</p>\n<ol>\n<li>You want to contribute to an open source library hosted at bitbucket.org&#x2F;userA&#x2F;open-project</li>\n<li>Using Bitbucket you create a fork of the repo to bitbucket.org&#x2F;YourName&#x2F;open-project</li>\n<li>On your local system you execute <code>git clone</code> on <a href=\"https://bitbucket.org/YourName/open-project\">https://bitbucket.org/YourName/open-project</a> to get a local copy of the repo</li>\n<li>You create a new <code>feature</code> branch in your local repo</li>\n<li>Work is done to complete the new feature and <code>git commit</code>is executed to save the changes</li>\n<li>You then push the new <code>feature</code> branch to your remote forked repo</li>\n<li>Using Bitbucket you open up a pull request for the new branch against the original repo at bitbucket.org&#x2F;userA&#x2F;open-project</li>\n</ol>\n<p>The Forking Workflow helps a maintainer of a project open up the repository to contributions from any developer without having to manually manage authorization settings for each individual contributor. This gives the maintainer more of a “pull” style workflow. Most commonly used in open-source projects, the Forking Workflow can also be applied to private business workflows to give more authoritative control over what is merged into a release. This can be useful in teams that have Deploy Managers or strict release cycles.</p>\n","site":{"data":{}},"wordcount":8109,"excerpt":"","more":"<h1 id=\"Forking-Workflow\"><a href=\"#Forking-Workflow\" class=\"headerlink\" title=\"Forking Workflow\"></a>Forking Workflow</h1><p>The Forking Workflow is fundamentally different than other popular Git workflows. Instead of using a single server-side repository to act as the “central” codebase, it gives every developer their own server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. The Forking Workflow is most often seen in public open source projects.</p>\n<p>The main advantage of the Forking Workflow is that contributions can be integrated without the need for everybody to push to a single central repository. Developers push to their own server-side repositories, and only the project maintainer can push to the official repository. This allows the maintainer to accept commits from any developer without giving them write access to the official codebase.</p>\n<p>The Forking Workflow typically follows a branching model based on the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\">Gitflow Workflow</a>. This means that complete feature branches will be purposed for merge into the original project maintainer’s repository. The result is a distributed workflow that provides a flexible way for large, organic teams (including untrusted third-parties) to collaborate securely. This also makes it an ideal workflow for open source projects.  </p>\n<h2 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h2><p>As in the other <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows\">Git workflows</a>, the Forking Workflow begins with an official public repository stored on a server. But when a new developer wants to start working on the project, they do not directly clone the official repository.</p>\n<p>Instead, they fork the official repository to create a copy of it on the server. This new copy serves as their personal public repository—no other developers are allowed to push to it, but they can pull changes from it (we’ll see why this is important in a moment). After they have created their server-side copy, the developer performs a <code>[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)</code> to get a copy of it onto their local machine. This serves as their private development environment, just like in the other workflows.</p>\n<p>When they’re ready to publish a local commit, they push the commit to their own public repository—not the official one. Then, they file a pull request with the main repository, which lets the project maintainer know that an update is ready to be integrated. The pull request also serves as a convenient discussion thread if there are issues with the contributed code. The following is a step-by-step example of this workflow.</p>\n<ol>\n<li>A developer ‘forks’ an ‘official’ server-side repository. This creates their own server-side copy.</li>\n<li>The new server-side copy is cloned to their local system.</li>\n<li>A Git remote path for the ‘official’ repository is added to the local clone.</li>\n<li>A new local feature branch is created.</li>\n<li>The developer makes changes on the new branch.</li>\n<li>New commits are created for the changes.</li>\n<li>The branch gets pushed to the developer’s own server-side copy.</li>\n<li>The developer opens a pull request from the new branch to the ‘official’ repository.</li>\n<li>The pull request gets approved for merge and is merged into the original server-side repository</li>\n</ol>\n<p>To integrate the feature into the official codebase, the maintainer pulls the contributor’s changes into their local repository, checks to make sure it doesn’t break the project, merges it into their local <code>main</code> branch, then pushes the <code>main</code> branch to the official repository on the server. The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.</p>\n<p>It’s important to understand that the notion of an “official” repository in the Forking Workflow is merely a convention. In fact, the only thing that makes the official repository so official is that it’s the public repository of the project maintainer.</p>\n<h2 id=\"Forking-vs-cloning\"><a href=\"#Forking-vs-cloning\" class=\"headerlink\" title=\"Forking vs cloning\"></a>Forking vs cloning</h2><p>It’s important to note that “forked” repositories and “forking” are not special operations. Forked repositories are created using the standard <code>[git clone](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone)</code> command. Forked repositories are generally “server-side clones” and usually managed and hosted by a 3rd party Git service like <a href=\"https://bitbucket.org/product\">Bitbucket</a>. There is no unique Git command to create forked repositories. A clone operation is essentially a copy of a repository and its history. </p>\n<h2 id=\"Branching-in-the-Forking-Workflow\"><a href=\"#Branching-in-the-Forking-Workflow\" class=\"headerlink\" title=\"Branching in the Forking Workflow\"></a>Branching in the Forking Workflow</h2><p>All of these personal public repositories are really just a convenient way to share branches with other developers. Everybody should still be using branches to isolate individual features, just like in the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow\">Feature Branch Workflow</a> and the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\">Gitflow Workflow.</a> The only difference is how those branches get shared. In the Forking Workflow, they are pulled into another developer’s local repository, while in the Feature Branch and Gitflow Workflows they are pushed to the official repository.</p>\n<h2 id=\"Fork-a-repository\"><a href=\"#Fork-a-repository\" class=\"headerlink\" title=\"Fork a repository\"></a>Fork a repository</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:642c56e3-ddc6-43ff-ab86-c5cd845afd05/03.svg?cdnVersion=116\" alt=\"git fork workflow - fork a repositiory\"></p>\n<p>All new developers to a Forking Workflow project need to fork the official repository. As previously stated, forking is just a standard <code>git clone</code> operation. It’s possible to do this by SSH’ing into the server and running <code>git clone</code> to copy it to another location on the server. Popular Git hosting services like Bitbucket, offer repo forking features that automate this step.</p>\n<h2 id=\"Clone-your-fork\"><a href=\"#Clone-your-fork\" class=\"headerlink\" title=\"Clone your fork\"></a>Clone your fork</h2><p>Next each developer needs to clone their own public forked repository. They can do this with the familiar <code>git clone</code>command.</p>\n<p>Assuming the use of Bitbucket to host these repositories, developers on a project should have their own Bitbucket account and they should clone their forked copy of the repository with:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git <span class=\"hljs-built_in\">clone</span> https://user@bitbucket.org/user/repo.git<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Adding-a-remote\"><a href=\"#Adding-a-remote\" class=\"headerlink\" title=\"Adding a remote\"></a>Adding a remote</h2><p>Whereas other Git workflows use a single origin remote that points to the central repository, the Forking Workflow requires two remotes—one for the official repository, and one for the developer’s personal server-side repository. While you can call these remotes anything you want, a common convention is to use origin as the remote for your forked repository (this will be created automatically when you run <code>git clone</code>) and upstream for the official repository.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git remote add upstream https://bitbucket.org/maintainer/repo<br></code></pre></td></tr></table></figure>\n\n<p>You’ll need to create the upstream remote yourself using the above command. This will let you easily keep your local repository up-to-date as the official project progresses. Note that if your upstream repository has authentication enabled (i.e., it’s not open source), you’ll need to supply a username, like so:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git remote add upstream https://user@bitbucket.org/maintainer/repo.git<br></code></pre></td></tr></table></figure>\n\n<p>This requires users to supply a valid password before cloning or pulling from the official codebase.</p>\n<h2 id=\"Working-in-a-branch-making-amp-pushing-changes\"><a href=\"#Working-in-a-branch-making-amp-pushing-changes\" class=\"headerlink\" title=\"Working in a branch: making &amp; pushing changes\"></a>Working in a branch: making &amp; pushing changes</h2><p>In the developer’s local copy of the forked repository they can edit code, commit changes, and create branches just like in other Git workflows:</p>\n<p> <code>git checkout -b some-feature # Edit some code git commit -a -m &quot;Add first draft of some feature&quot;</code></p>\n<p>All of their changes will be entirely private until they push it to their public repository. And, if the official project has moved forward, they can access new commits with <code>git pull</code>:</p>\n<p> <code>git pull upstream main</code></p>\n<p>Since developers should be working in a dedicated feature branch, this should generally result in a fast-forward merge.</p>\n<h2 id=\"Making-a-Pull-Request\"><a href=\"#Making-a-Pull-Request\" class=\"headerlink\" title=\"Making a Pull Request\"></a>Making a Pull Request</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:0de71551-5c08-4fc4-ab6d-dc8a51bfcc5a/05.svg?cdnVersion=116\" alt=\"Git Fork Workflow - Making a pull request\"></p>\n<p>Once a developer is ready to share their new feature, they need to do two things. First, they have to make their contribution accessible to other developers by pushing it to their public repository. Their origin remote should already be set up, so all they should have to do is the following:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git push origin feature-branch<br></code></pre></td></tr></table></figure>\n\n<p>This diverges from the other workflows in that the origin remote points to the developer’s personal server-side repository, not the main codebase.</p>\n<p>Second, they need to notify the project maintainer that they want to merge their feature into the official codebase. Bitbucket provides a “pull request” button that leads to a form asking you to specify which branch you want to merge into the official repository. Typically, you’ll want to integrate your <code>feature</code> branch into the upstream remote’s <code>main</code> branch.</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>To recap, the Forking Workflow is commonly used in public open-source projects. Forking is a <code>git clone</code> operation executed on a server copy of a projects repo. A Forking Workflow is often used in conjunction with a Git hosting service like Bitbucket. A high-level example of a Forking Workflow is:</p>\n<ol>\n<li>You want to contribute to an open source library hosted at bitbucket.org&#x2F;userA&#x2F;open-project</li>\n<li>Using Bitbucket you create a fork of the repo to bitbucket.org&#x2F;YourName&#x2F;open-project</li>\n<li>On your local system you execute <code>git clone</code> on <a href=\"https://bitbucket.org/YourName/open-project\">https://bitbucket.org/YourName/open-project</a> to get a local copy of the repo</li>\n<li>You create a new <code>feature</code> branch in your local repo</li>\n<li>Work is done to complete the new feature and <code>git commit</code>is executed to save the changes</li>\n<li>You then push the new <code>feature</code> branch to your remote forked repo</li>\n<li>Using Bitbucket you open up a pull request for the new branch against the original repo at bitbucket.org&#x2F;userA&#x2F;open-project</li>\n</ol>\n<p>The Forking Workflow helps a maintainer of a project open up the repository to contributions from any developer without having to manually manage authorization settings for each individual contributor. This gives the maintainer more of a “pull” style workflow. Most commonly used in open-source projects, the Forking Workflow can also be applied to private business workflows to give more authoritative control over what is merged into a release. This can be useful in teams that have Deploy Managers or strict release cycles.</p>\n"},{"title":"切换Git账号","date":"2022-04-05T09:16:27.000Z","description":"Git相关文档","_content":"\n## 开启ssh-agent服务\n\n```shell\neval \"$(ssh-agent -s)\"\n```\n\n## 把刚刚生成的ssh key加入到ssh-agent中\n```shell\nssh-add ~/.ssh/id_rsa_zjm\n```\n\n## 测试账号更换是否成功\n```shell\nssh git@github.com\n```","source":"_posts/Git/切换Git账号.md","raw":"---\ntitle: 切换Git账号\ndate: 2022-04-05 17:16:27\ntags:\n  - [git]\ncategories:\n  - [技术]\ndescription: Git相关文档\n---\n\n## 开启ssh-agent服务\n\n```shell\neval \"$(ssh-agent -s)\"\n```\n\n## 把刚刚生成的ssh key加入到ssh-agent中\n```shell\nssh-add ~/.ssh/id_rsa_zjm\n```\n\n## 测试账号更换是否成功\n```shell\nssh git@github.com\n```","slug":"Git/切换Git账号","published":1,"updated":"2022-08-28T07:38:59.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1h000bscvm2na932oz","content":"<h2 id=\"开启ssh-agent服务\"><a href=\"#开启ssh-agent服务\" class=\"headerlink\" title=\"开启ssh-agent服务\"></a>开启ssh-agent服务</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs shell\">eval &quot;$(ssh-agent -s)&quot;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"把刚刚生成的ssh-key加入到ssh-agent中\"><a href=\"#把刚刚生成的ssh-key加入到ssh-agent中\" class=\"headerlink\" title=\"把刚刚生成的ssh key加入到ssh-agent中\"></a>把刚刚生成的ssh key加入到ssh-agent中</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ssh-add ~/.ssh/id_rsa_zjm<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试账号更换是否成功\"><a href=\"#测试账号更换是否成功\" class=\"headerlink\" title=\"测试账号更换是否成功\"></a>测试账号更换是否成功</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ssh git@github.com<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":122,"excerpt":"","more":"<h2 id=\"开启ssh-agent服务\"><a href=\"#开启ssh-agent服务\" class=\"headerlink\" title=\"开启ssh-agent服务\"></a>开启ssh-agent服务</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">eval &quot;$(ssh-agent -s)&quot;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"把刚刚生成的ssh-key加入到ssh-agent中\"><a href=\"#把刚刚生成的ssh-key加入到ssh-agent中\" class=\"headerlink\" title=\"把刚刚生成的ssh key加入到ssh-agent中\"></a>把刚刚生成的ssh key加入到ssh-agent中</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ssh-add ~/.ssh/id_rsa_zjm<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试账号更换是否成功\"><a href=\"#测试账号更换是否成功\" class=\"headerlink\" title=\"测试账号更换是否成功\"></a>测试账号更换是否成功</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ssh git@github.com<br></code></pre></td></tr></table></figure>"},{"title":"Gitflow Workflow","date":"2022-04-05T09:16:27.000Z","description":"Git相关文档","_content":"\n# Gitflow Workflow\n\nGitflow is a legacy Git workflow that was originally a disruptive and novel strategy for managing Git branches. Gitflow has fallen in popularity in favor of [trunk-based workflows](https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development), which are now considered best practices for modern continuous software development and [DevOps](https://www.atlassian.com/devops/what-is-devops) practices. Gitflow also can be challenging to use with [CI/CD](https://www.atlassian.com/continuous-delivery). This post details Gitflow for historical purposes.\n\n## What is Gitflow?\n\nGiflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. It was first published and made popular by [Vincent Driessen at nvie](http://nvie.com/posts/a-successful-git-branching-model/). Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.\n\nGitflow can be used for projects that have a scheduled release cycle and for the [DevOps best practice](https://www.atlassian.com/devops/what-is-devops/devops-best-practices) of [continuous delivery](https://www.atlassian.com/continuous-delivery). This workflow doesn’t add any new concepts or commands beyond what’s required for the [Feature Branch Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow). Instead, it assigns very specific roles to different branches and defines how and when they should interact. In addition to `feature` branches, it uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.\n\n## Getting Started\n\nGitflow is really just an abstract idea of a Git workflow. This means it dictates what kind of branches to set up and how to merge them together. We will touch on the purposes of the branches below. The git-flow toolset is an actual command line tool that has an installation process. The installation process for git-flow is straightforward. Packages for git-flow are available on multiple operating systems. On OSX systems, you can execute `brew install git-flow`. On windows you will need to [download and install git-flow](https://git-scm.com/download/win). After installing git-flow you can use it in your project by executing `git flow init`. Git-flow is a wrapper around Git. The `git flow init` command is an extension of the default `[git init](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init)` command and doesn't change anything in your repository other than creating branches for you.\n\n## How it works\n\n![Git flow workflow - Historical Branches](https://wac-cdn.atlassian.com/dam/jcr:a13c18d6-94f3-4fc4-84fb-2b8f1b2fd339/01%20How%20it%20works.svg?cdnVersion=116)\n\n### Develop and main branches\n\nInstead of a single `main` branch, this workflow uses two branches to record the history of the project. The `main` branch stores the official release history, and the `develop` branch serves as an integration branch for features. It's also convenient to tag all commits in the `main` branch with a version number.\n\nThe first step is to complement the default `main` with a `develop`branch. A simple way to do this is for one developer to create an empty `develop` branch locally and push it to the server:\n\n```shell\ngit branch develop\ngit push -u origin develop\n```\n\nThis branch will contain the complete history of the project, whereas `main` will contain an abridged version. Other developers should now clone the central repository and create a tracking branch for `develop.`\n\nWhen using the git-flow extension library, executing `git flow init` on an existing repo will create the `develop`branch:\n\n```sh\n$ git flow init\nInitialized empty Git repository in ~/project/.git/No branches exist yet. Base branches must be created now.Branch name for production releases: [main]Branch name for \"next release\" development: [develop]\nHow to name your supporting branch prefixes?\nFeature branches? [feature/]\nRelease branches? [release/]\nHotfix branches? [hotfix/]\nSupport branches? [support/]\nVersion tag prefix? []\n\n$ git branch* develop main\n```\n\n## Feature branches\n\nEach new feature should reside in its own branch, which can be [pushed to the central repository](https://www.atlassian.com/git/tutorials/syncing/git-push) for backup/collaboration. But, instead of branching off of `main`, `feature` branches use `develop`as their parent branch. When a feature is complete, it gets [merged back into develop](https://www.atlassian.com/git/tutorials/using-branches/git-merge). Features should never interact directly with `main`.\n\n![Git flow workflow - Feature Branches](https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=116)\n\nNote that `feature` branches combined with the `develop` branch is, for all intents and purposes, the Feature Branch Workflow. But, the Gitflow workflow doesn’t stop there.\n\n`Feature` branches are generally created off to the latest `develop`branch.\n\n### Creating a feature branch\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout develop\ngit checkout -b feature_branch\n```\n\nWhen using the git-flow extension:\n\n```sh\ngit flow feature start feature_branch\n```\n\nContinue your work and use Git like you normally would.\n\n### Finishing a feature branch\n\nWhen you’re done with the development work on the feature, the next step is to merge the `feature_branch` into `develop`.\n\nWithout the git-flow extensions:\n\n```shell\ngit checkout develop\ngit merge feature_branch\n```\n\nUsing the git-flow extensions:\n\n```shell\ngit flow feature finish feature_branch\n```\n\n## Release branches\n\n![Git Flow Workflow - Release Branches](https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=116)\n\nOnce `develop` has acquired enough features for a release (or a predetermined release date is approaching), you fork a `release`branch off of `develop`. Creating this branch starts the next release cycle, so no new features can be added after this point—only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. Once it's ready to ship, the `release` branch gets merged into `main` and tagged with a version number. In addition, it should be merged back into `develop`, which may have progressed since the release was initiated.\n\nUsing a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development (e.g., it's easy to say, “This week we're preparing for version 4.0,” and to actually see it in the structure of the repository).\n\nMaking `release` branches is another straightforward branching operation. Like `feature` branches, `release` branches are based on the `develop` branch. A new `release` branch can be created using the following methods.\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout develop\ngit checkout -b release/0.1.0\n```\n\nWhen using the git-flow extensions:\n\n```sh\n$ git flow release start 0.1.0\nSwitched to a new branch 'release/0.1.0'\n```\n\nOnce the release is ready to ship, it will get merged it into `main` and `develop`, then the `release` branch will be deleted. It’s important to merge back into `develop` because critical updates may have been added to the `release` branch and they need to be accessible to new features. If your organization stresses code review, this would be an ideal place for a pull request.\n\nTo finish a `release` branch, use the following methods:\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout main\ngit merge release/0.1.0\n```\n\nOr with the git-flow extension:\n\n```sh\ngit flow release finish '0.1.0'\n```\n\n## Hotfix branches\n\n![Git flow workflow - Hotfix Branches](https://wac-cdn.atlassian.com/dam/jcr:cc0b526e-adb7-4d45-874e-9bcea9898b4a/04%20Hotfix%20branches.svg?cdnVersion=116)\n\nMaintenance or `“hotfix”` branches are used to quickly patch production releases. `Hotfix` branches are a lot like `release`branches and `feature` branches except they're based on `main` instead of `develop`. This is the only branch that should fork directly off of `main`. As soon as the fix is complete, it should be merged into both `main` and `develop` (or the current `release`branch), and `main` should be tagged with an updated version number.\n\nHaving a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. You can think of maintenance branches as ad hoc `release` branches that work directly with `main`. A `hotfix` branch can be created using the following methods:\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout main\ngit checkout -b hotfix_branch\n```\n\nWhen using the git-flow extensions: \n\n```sh\n$ git flow hotfix start hotfix_branch\n```\n\nSimilar to finishing a `release` branch, a `hotfix` branch gets merged into both `main` and `develop.`\n\n```sh\ngit checkout main\ngit merge hotfix_branch\ngit checkout develop\ngit merge hotfix_branch\ngit branch -D hotfix_branch\n```\n\n```sh\n$ git flow hotfix finish hotfix_branch\n```\n\n## Example\n\nA complete example demonstrating a Feature Branch Flow is as follows. Assuming we have a repo setup with a `main` branch.\n\n```sh\ngit checkout maingit checkout -b develop\ngit checkout -b feature_branch\n# work happens on feature branch\ngit checkout develop\ngit merge feature_branch\ngit checkout main\ngit merge develop\ngit branch -d feature_branch\n```\n\nIn addition to the `feature` and `release` flow, a `hotfix` example is as follows:\n\n```sh\ngit checkout main\ngit checkout -b hotfix_branch\n# work is done commits are added to the hotfix_branchgit checkout develop\ngit merge hotfix_branch\ngit checkout main\ngit merge hotfix_branch\n```\n\n## Summary\n\nHere we discussed the Gitflow Workflow. Gitflow is one of many styles of [Git workflows](https://www.atlassian.com/git/tutorials/comparing-workflows) you and your team can utilize.\n\nSome key takeaways to know about Gitflow are:\n\n-   The workflow is great for a release-based software workflow.\n-   Gitflow offers a dedicated channel for hotfixes to production.  \n    \n\nThe overall flow of Gitflow is:\n\n1.  A `develop` branch is created from `main`\n2.  A `release` branch is created from `develop`\n3.  `Feature` branches are created from `develop`\n4.  When a `feature` is complete it is merged into the `develop` branch\n5.  When the `release` branch is done it is merged into `develop`and `main`\n6.  If an issue in `main` is detected a `hotfix` branch is created from `main`\n7.  Once the `hotfix` is complete it is merged to both `develop`and `main`","source":"_posts/Git/gitflow workflow.md","raw":"---\ntitle: Gitflow Workflow\ndate: 2022-04-05 17:16:27\ntags:\n  - [git]\ncategories:\n  - [技术]\ndescription: Git相关文档\n---\n\n# Gitflow Workflow\n\nGitflow is a legacy Git workflow that was originally a disruptive and novel strategy for managing Git branches. Gitflow has fallen in popularity in favor of [trunk-based workflows](https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development), which are now considered best practices for modern continuous software development and [DevOps](https://www.atlassian.com/devops/what-is-devops) practices. Gitflow also can be challenging to use with [CI/CD](https://www.atlassian.com/continuous-delivery). This post details Gitflow for historical purposes.\n\n## What is Gitflow?\n\nGiflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. It was first published and made popular by [Vincent Driessen at nvie](http://nvie.com/posts/a-successful-git-branching-model/). Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.\n\nGitflow can be used for projects that have a scheduled release cycle and for the [DevOps best practice](https://www.atlassian.com/devops/what-is-devops/devops-best-practices) of [continuous delivery](https://www.atlassian.com/continuous-delivery). This workflow doesn’t add any new concepts or commands beyond what’s required for the [Feature Branch Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow). Instead, it assigns very specific roles to different branches and defines how and when they should interact. In addition to `feature` branches, it uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.\n\n## Getting Started\n\nGitflow is really just an abstract idea of a Git workflow. This means it dictates what kind of branches to set up and how to merge them together. We will touch on the purposes of the branches below. The git-flow toolset is an actual command line tool that has an installation process. The installation process for git-flow is straightforward. Packages for git-flow are available on multiple operating systems. On OSX systems, you can execute `brew install git-flow`. On windows you will need to [download and install git-flow](https://git-scm.com/download/win). After installing git-flow you can use it in your project by executing `git flow init`. Git-flow is a wrapper around Git. The `git flow init` command is an extension of the default `[git init](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init)` command and doesn't change anything in your repository other than creating branches for you.\n\n## How it works\n\n![Git flow workflow - Historical Branches](https://wac-cdn.atlassian.com/dam/jcr:a13c18d6-94f3-4fc4-84fb-2b8f1b2fd339/01%20How%20it%20works.svg?cdnVersion=116)\n\n### Develop and main branches\n\nInstead of a single `main` branch, this workflow uses two branches to record the history of the project. The `main` branch stores the official release history, and the `develop` branch serves as an integration branch for features. It's also convenient to tag all commits in the `main` branch with a version number.\n\nThe first step is to complement the default `main` with a `develop`branch. A simple way to do this is for one developer to create an empty `develop` branch locally and push it to the server:\n\n```shell\ngit branch develop\ngit push -u origin develop\n```\n\nThis branch will contain the complete history of the project, whereas `main` will contain an abridged version. Other developers should now clone the central repository and create a tracking branch for `develop.`\n\nWhen using the git-flow extension library, executing `git flow init` on an existing repo will create the `develop`branch:\n\n```sh\n$ git flow init\nInitialized empty Git repository in ~/project/.git/No branches exist yet. Base branches must be created now.Branch name for production releases: [main]Branch name for \"next release\" development: [develop]\nHow to name your supporting branch prefixes?\nFeature branches? [feature/]\nRelease branches? [release/]\nHotfix branches? [hotfix/]\nSupport branches? [support/]\nVersion tag prefix? []\n\n$ git branch* develop main\n```\n\n## Feature branches\n\nEach new feature should reside in its own branch, which can be [pushed to the central repository](https://www.atlassian.com/git/tutorials/syncing/git-push) for backup/collaboration. But, instead of branching off of `main`, `feature` branches use `develop`as their parent branch. When a feature is complete, it gets [merged back into develop](https://www.atlassian.com/git/tutorials/using-branches/git-merge). Features should never interact directly with `main`.\n\n![Git flow workflow - Feature Branches](https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=116)\n\nNote that `feature` branches combined with the `develop` branch is, for all intents and purposes, the Feature Branch Workflow. But, the Gitflow workflow doesn’t stop there.\n\n`Feature` branches are generally created off to the latest `develop`branch.\n\n### Creating a feature branch\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout develop\ngit checkout -b feature_branch\n```\n\nWhen using the git-flow extension:\n\n```sh\ngit flow feature start feature_branch\n```\n\nContinue your work and use Git like you normally would.\n\n### Finishing a feature branch\n\nWhen you’re done with the development work on the feature, the next step is to merge the `feature_branch` into `develop`.\n\nWithout the git-flow extensions:\n\n```shell\ngit checkout develop\ngit merge feature_branch\n```\n\nUsing the git-flow extensions:\n\n```shell\ngit flow feature finish feature_branch\n```\n\n## Release branches\n\n![Git Flow Workflow - Release Branches](https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=116)\n\nOnce `develop` has acquired enough features for a release (or a predetermined release date is approaching), you fork a `release`branch off of `develop`. Creating this branch starts the next release cycle, so no new features can be added after this point—only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. Once it's ready to ship, the `release` branch gets merged into `main` and tagged with a version number. In addition, it should be merged back into `develop`, which may have progressed since the release was initiated.\n\nUsing a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development (e.g., it's easy to say, “This week we're preparing for version 4.0,” and to actually see it in the structure of the repository).\n\nMaking `release` branches is another straightforward branching operation. Like `feature` branches, `release` branches are based on the `develop` branch. A new `release` branch can be created using the following methods.\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout develop\ngit checkout -b release/0.1.0\n```\n\nWhen using the git-flow extensions:\n\n```sh\n$ git flow release start 0.1.0\nSwitched to a new branch 'release/0.1.0'\n```\n\nOnce the release is ready to ship, it will get merged it into `main` and `develop`, then the `release` branch will be deleted. It’s important to merge back into `develop` because critical updates may have been added to the `release` branch and they need to be accessible to new features. If your organization stresses code review, this would be an ideal place for a pull request.\n\nTo finish a `release` branch, use the following methods:\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout main\ngit merge release/0.1.0\n```\n\nOr with the git-flow extension:\n\n```sh\ngit flow release finish '0.1.0'\n```\n\n## Hotfix branches\n\n![Git flow workflow - Hotfix Branches](https://wac-cdn.atlassian.com/dam/jcr:cc0b526e-adb7-4d45-874e-9bcea9898b4a/04%20Hotfix%20branches.svg?cdnVersion=116)\n\nMaintenance or `“hotfix”` branches are used to quickly patch production releases. `Hotfix` branches are a lot like `release`branches and `feature` branches except they're based on `main` instead of `develop`. This is the only branch that should fork directly off of `main`. As soon as the fix is complete, it should be merged into both `main` and `develop` (or the current `release`branch), and `main` should be tagged with an updated version number.\n\nHaving a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. You can think of maintenance branches as ad hoc `release` branches that work directly with `main`. A `hotfix` branch can be created using the following methods:\n\nWithout the git-flow extensions:\n\n```sh\ngit checkout main\ngit checkout -b hotfix_branch\n```\n\nWhen using the git-flow extensions: \n\n```sh\n$ git flow hotfix start hotfix_branch\n```\n\nSimilar to finishing a `release` branch, a `hotfix` branch gets merged into both `main` and `develop.`\n\n```sh\ngit checkout main\ngit merge hotfix_branch\ngit checkout develop\ngit merge hotfix_branch\ngit branch -D hotfix_branch\n```\n\n```sh\n$ git flow hotfix finish hotfix_branch\n```\n\n## Example\n\nA complete example demonstrating a Feature Branch Flow is as follows. Assuming we have a repo setup with a `main` branch.\n\n```sh\ngit checkout maingit checkout -b develop\ngit checkout -b feature_branch\n# work happens on feature branch\ngit checkout develop\ngit merge feature_branch\ngit checkout main\ngit merge develop\ngit branch -d feature_branch\n```\n\nIn addition to the `feature` and `release` flow, a `hotfix` example is as follows:\n\n```sh\ngit checkout main\ngit checkout -b hotfix_branch\n# work is done commits are added to the hotfix_branchgit checkout develop\ngit merge hotfix_branch\ngit checkout main\ngit merge hotfix_branch\n```\n\n## Summary\n\nHere we discussed the Gitflow Workflow. Gitflow is one of many styles of [Git workflows](https://www.atlassian.com/git/tutorials/comparing-workflows) you and your team can utilize.\n\nSome key takeaways to know about Gitflow are:\n\n-   The workflow is great for a release-based software workflow.\n-   Gitflow offers a dedicated channel for hotfixes to production.  \n    \n\nThe overall flow of Gitflow is:\n\n1.  A `develop` branch is created from `main`\n2.  A `release` branch is created from `develop`\n3.  `Feature` branches are created from `develop`\n4.  When a `feature` is complete it is merged into the `develop` branch\n5.  When the `release` branch is done it is merged into `develop`and `main`\n6.  If an issue in `main` is detected a `hotfix` branch is created from `main`\n7.  Once the `hotfix` is complete it is merged to both `develop`and `main`","slug":"Git/gitflow workflow","published":1,"updated":"2022-08-28T07:38:59.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1i000dscvm91lnf30f","content":"<h1 id=\"Gitflow-Workflow\"><a href=\"#Gitflow-Workflow\" class=\"headerlink\" title=\"Gitflow Workflow\"></a>Gitflow Workflow</h1><p>Gitflow is a legacy Git workflow that was originally a disruptive and novel strategy for managing Git branches. Gitflow has fallen in popularity in favor of <a href=\"https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development\">trunk-based workflows</a>, which are now considered best practices for modern continuous software development and <a href=\"https://www.atlassian.com/devops/what-is-devops\">DevOps</a> practices. Gitflow also can be challenging to use with <a href=\"https://www.atlassian.com/continuous-delivery\">CI&#x2F;CD</a>. This post details Gitflow for historical purposes.</p>\n<h2 id=\"What-is-Gitflow\"><a href=\"#What-is-Gitflow\" class=\"headerlink\" title=\"What is Gitflow?\"></a>What is Gitflow?</h2><p>Giflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. It was first published and made popular by <a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">Vincent Driessen at nvie</a>. Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.</p>\n<p>Gitflow can be used for projects that have a scheduled release cycle and for the <a href=\"https://www.atlassian.com/devops/what-is-devops/devops-best-practices\">DevOps best practice</a> of <a href=\"https://www.atlassian.com/continuous-delivery\">continuous delivery</a>. This workflow doesn’t add any new concepts or commands beyond what’s required for the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow\">Feature Branch Workflow</a>. Instead, it assigns very specific roles to different branches and defines how and when they should interact. In addition to <code>feature</code> branches, it uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.</p>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p>Gitflow is really just an abstract idea of a Git workflow. This means it dictates what kind of branches to set up and how to merge them together. We will touch on the purposes of the branches below. The git-flow toolset is an actual command line tool that has an installation process. The installation process for git-flow is straightforward. Packages for git-flow are available on multiple operating systems. On OSX systems, you can execute <code>brew install git-flow</code>. On windows you will need to <a href=\"https://git-scm.com/download/win\">download and install git-flow</a>. After installing git-flow you can use it in your project by executing <code>git flow init</code>. Git-flow is a wrapper around Git. The <code>git flow init</code> command is an extension of the default <code>[git init](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init)</code> command and doesn’t change anything in your repository other than creating branches for you.</p>\n<h2 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:a13c18d6-94f3-4fc4-84fb-2b8f1b2fd339/01%20How%20it%20works.svg?cdnVersion=116\" alt=\"Git flow workflow - Historical Branches\"></p>\n<h3 id=\"Develop-and-main-branches\"><a href=\"#Develop-and-main-branches\" class=\"headerlink\" title=\"Develop and main branches\"></a>Develop and main branches</h3><p>Instead of a single <code>main</code> branch, this workflow uses two branches to record the history of the project. The <code>main</code> branch stores the official release history, and the <code>develop</code> branch serves as an integration branch for features. It’s also convenient to tag all commits in the <code>main</code> branch with a version number.</p>\n<p>The first step is to complement the default <code>main</code> with a <code>develop</code>branch. A simple way to do this is for one developer to create an empty <code>develop</code> branch locally and push it to the server:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs shell\">git branch develop<br>git push -u origin develop<br></code></pre></td></tr></table></figure>\n\n<p>This branch will contain the complete history of the project, whereas <code>main</code> will contain an abridged version. Other developers should now clone the central repository and create a tracking branch for <code>develop.</code></p>\n<p>When using the git-flow extension library, executing <code>git flow init</code> on an existing repo will create the <code>develop</code>branch:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow init<br>Initialized empty Git repository <span class=\"hljs-keyword\">in</span> ~/project/.git/No branches exist yet. Base branches must be created now.Branch name <span class=\"hljs-keyword\">for</span> production releases: [main]Branch name <span class=\"hljs-keyword\">for</span> <span class=\"hljs-string\">&quot;next release&quot;</span> development: [develop]<br>How to name your supporting branch prefixes?<br>Feature branches? [feature/]<br>Release branches? [release/]<br>Hotfix branches? [hotfix/]<br>Support branches? [support/]<br>Version tag prefix? []<br><br>$ git branch* develop main<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Feature-branches\"><a href=\"#Feature-branches\" class=\"headerlink\" title=\"Feature branches\"></a>Feature branches</h2><p>Each new feature should reside in its own branch, which can be <a href=\"https://www.atlassian.com/git/tutorials/syncing/git-push\">pushed to the central repository</a> for backup&#x2F;collaboration. But, instead of branching off of <code>main</code>, <code>feature</code> branches use <code>develop</code>as their parent branch. When a feature is complete, it gets <a href=\"https://www.atlassian.com/git/tutorials/using-branches/git-merge\">merged back into develop</a>. Features should never interact directly with <code>main</code>.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=116\" alt=\"Git flow workflow - Feature Branches\"></p>\n<p>Note that <code>feature</code> branches combined with the <code>develop</code> branch is, for all intents and purposes, the Feature Branch Workflow. But, the Gitflow workflow doesn’t stop there.</p>\n<p><code>Feature</code> branches are generally created off to the latest <code>develop</code>branch.</p>\n<h3 id=\"Creating-a-feature-branch\"><a href=\"#Creating-a-feature-branch\" class=\"headerlink\" title=\"Creating a feature branch\"></a>Creating a feature branch</h3><p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout develop<br>git checkout -b feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>When using the git-flow extension:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git flow feature start feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>Continue your work and use Git like you normally would.</p>\n<h3 id=\"Finishing-a-feature-branch\"><a href=\"#Finishing-a-feature-branch\" class=\"headerlink\" title=\"Finishing a feature branch\"></a>Finishing a feature branch</h3><p>When you’re done with the development work on the feature, the next step is to merge the <code>feature_branch</code> into <code>develop</code>.</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git checkout develop<br>git merge feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>Using the git-flow extensions:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git flow feature finish feature_branch<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Release-branches\"><a href=\"#Release-branches\" class=\"headerlink\" title=\"Release branches\"></a>Release branches</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=116\" alt=\"Git Flow Workflow - Release Branches\"></p>\n<p>Once <code>develop</code> has acquired enough features for a release (or a predetermined release date is approaching), you fork a <code>release</code>branch off of <code>develop</code>. Creating this branch starts the next release cycle, so no new features can be added after this point—only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. Once it’s ready to ship, the <code>release</code> branch gets merged into <code>main</code> and tagged with a version number. In addition, it should be merged back into <code>develop</code>, which may have progressed since the release was initiated.</p>\n<p>Using a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development (e.g., it’s easy to say, “This week we’re preparing for version 4.0,” and to actually see it in the structure of the repository).</p>\n<p>Making <code>release</code> branches is another straightforward branching operation. Like <code>feature</code> branches, <code>release</code> branches are based on the <code>develop</code> branch. A new <code>release</code> branch can be created using the following methods.</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout develop<br>git checkout -b release/0.1.0<br></code></pre></td></tr></table></figure>\n\n<p>When using the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow release start 0.1.0<br>Switched to a new branch <span class=\"hljs-string\">&#x27;release/0.1.0&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>Once the release is ready to ship, it will get merged it into <code>main</code> and <code>develop</code>, then the <code>release</code> branch will be deleted. It’s important to merge back into <code>develop</code> because critical updates may have been added to the <code>release</code> branch and they need to be accessible to new features. If your organization stresses code review, this would be an ideal place for a pull request.</p>\n<p>To finish a <code>release</code> branch, use the following methods:</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git merge release/0.1.0<br></code></pre></td></tr></table></figure>\n\n<p>Or with the git-flow extension:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git flow release finish <span class=\"hljs-string\">&#x27;0.1.0&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Hotfix-branches\"><a href=\"#Hotfix-branches\" class=\"headerlink\" title=\"Hotfix branches\"></a>Hotfix branches</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:cc0b526e-adb7-4d45-874e-9bcea9898b4a/04%20Hotfix%20branches.svg?cdnVersion=116\" alt=\"Git flow workflow - Hotfix Branches\"></p>\n<p>Maintenance or <code>“hotfix”</code> branches are used to quickly patch production releases. <code>Hotfix</code> branches are a lot like <code>release</code>branches and <code>feature</code> branches except they’re based on <code>main</code> instead of <code>develop</code>. This is the only branch that should fork directly off of <code>main</code>. As soon as the fix is complete, it should be merged into both <code>main</code> and <code>develop</code> (or the current <code>release</code>branch), and <code>main</code> should be tagged with an updated version number.</p>\n<p>Having a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. You can think of maintenance branches as ad hoc <code>release</code> branches that work directly with <code>main</code>. A <code>hotfix</code> branch can be created using the following methods:</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git checkout -b hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<p>When using the git-flow extensions: </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow hotfix start hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<p>Similar to finishing a <code>release</code> branch, a <code>hotfix</code> branch gets merged into both <code>main</code> and <code>develop.</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git merge hotfix_branch<br>git checkout develop<br>git merge hotfix_branch<br>git branch -D hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow hotfix finish hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>A complete example demonstrating a Feature Branch Flow is as follows. Assuming we have a repo setup with a <code>main</code> branch.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout maingit checkout -b develop<br>git checkout -b feature_branch<br><span class=\"hljs-comment\"># work happens on feature branch</span><br>git checkout develop<br>git merge feature_branch<br>git checkout main<br>git merge develop<br>git branch -d feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>In addition to the <code>feature</code> and <code>release</code> flow, a <code>hotfix</code> example is as follows:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git checkout -b hotfix_branch<br><span class=\"hljs-comment\"># work is done commits are added to the hotfix_branchgit checkout develop</span><br>git merge hotfix_branch<br>git checkout main<br>git merge hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>Here we discussed the Gitflow Workflow. Gitflow is one of many styles of <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows\">Git workflows</a> you and your team can utilize.</p>\n<p>Some key takeaways to know about Gitflow are:</p>\n<ul>\n<li>The workflow is great for a release-based software workflow.</li>\n<li>Gitflow offers a dedicated channel for hotfixes to production.</li>\n</ul>\n<p>The overall flow of Gitflow is:</p>\n<ol>\n<li>A <code>develop</code> branch is created from <code>main</code></li>\n<li>A <code>release</code> branch is created from <code>develop</code></li>\n<li><code>Feature</code> branches are created from <code>develop</code></li>\n<li>When a <code>feature</code> is complete it is merged into the <code>develop</code> branch</li>\n<li>When the <code>release</code> branch is done it is merged into <code>develop</code>and <code>main</code></li>\n<li>If an issue in <code>main</code> is detected a <code>hotfix</code> branch is created from <code>main</code></li>\n<li>Once the <code>hotfix</code> is complete it is merged to both <code>develop</code>and <code>main</code></li>\n</ol>\n","site":{"data":{}},"wordcount":7985,"excerpt":"","more":"<h1 id=\"Gitflow-Workflow\"><a href=\"#Gitflow-Workflow\" class=\"headerlink\" title=\"Gitflow Workflow\"></a>Gitflow Workflow</h1><p>Gitflow is a legacy Git workflow that was originally a disruptive and novel strategy for managing Git branches. Gitflow has fallen in popularity in favor of <a href=\"https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development\">trunk-based workflows</a>, which are now considered best practices for modern continuous software development and <a href=\"https://www.atlassian.com/devops/what-is-devops\">DevOps</a> practices. Gitflow also can be challenging to use with <a href=\"https://www.atlassian.com/continuous-delivery\">CI&#x2F;CD</a>. This post details Gitflow for historical purposes.</p>\n<h2 id=\"What-is-Gitflow\"><a href=\"#What-is-Gitflow\" class=\"headerlink\" title=\"What is Gitflow?\"></a>What is Gitflow?</h2><p>Giflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. It was first published and made popular by <a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">Vincent Driessen at nvie</a>. Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.</p>\n<p>Gitflow can be used for projects that have a scheduled release cycle and for the <a href=\"https://www.atlassian.com/devops/what-is-devops/devops-best-practices\">DevOps best practice</a> of <a href=\"https://www.atlassian.com/continuous-delivery\">continuous delivery</a>. This workflow doesn’t add any new concepts or commands beyond what’s required for the <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow\">Feature Branch Workflow</a>. Instead, it assigns very specific roles to different branches and defines how and when they should interact. In addition to <code>feature</code> branches, it uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.</p>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p>Gitflow is really just an abstract idea of a Git workflow. This means it dictates what kind of branches to set up and how to merge them together. We will touch on the purposes of the branches below. The git-flow toolset is an actual command line tool that has an installation process. The installation process for git-flow is straightforward. Packages for git-flow are available on multiple operating systems. On OSX systems, you can execute <code>brew install git-flow</code>. On windows you will need to <a href=\"https://git-scm.com/download/win\">download and install git-flow</a>. After installing git-flow you can use it in your project by executing <code>git flow init</code>. Git-flow is a wrapper around Git. The <code>git flow init</code> command is an extension of the default <code>[git init](https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init)</code> command and doesn’t change anything in your repository other than creating branches for you.</p>\n<h2 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:a13c18d6-94f3-4fc4-84fb-2b8f1b2fd339/01%20How%20it%20works.svg?cdnVersion=116\" alt=\"Git flow workflow - Historical Branches\"></p>\n<h3 id=\"Develop-and-main-branches\"><a href=\"#Develop-and-main-branches\" class=\"headerlink\" title=\"Develop and main branches\"></a>Develop and main branches</h3><p>Instead of a single <code>main</code> branch, this workflow uses two branches to record the history of the project. The <code>main</code> branch stores the official release history, and the <code>develop</code> branch serves as an integration branch for features. It’s also convenient to tag all commits in the <code>main</code> branch with a version number.</p>\n<p>The first step is to complement the default <code>main</code> with a <code>develop</code>branch. A simple way to do this is for one developer to create an empty <code>develop</code> branch locally and push it to the server:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git branch develop<br>git push -u origin develop<br></code></pre></td></tr></table></figure>\n\n<p>This branch will contain the complete history of the project, whereas <code>main</code> will contain an abridged version. Other developers should now clone the central repository and create a tracking branch for <code>develop.</code></p>\n<p>When using the git-flow extension library, executing <code>git flow init</code> on an existing repo will create the <code>develop</code>branch:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow init<br>Initialized empty Git repository <span class=\"hljs-keyword\">in</span> ~/project/.git/No branches exist yet. Base branches must be created now.Branch name <span class=\"hljs-keyword\">for</span> production releases: [main]Branch name <span class=\"hljs-keyword\">for</span> <span class=\"hljs-string\">&quot;next release&quot;</span> development: [develop]<br>How to name your supporting branch prefixes?<br>Feature branches? [feature/]<br>Release branches? [release/]<br>Hotfix branches? [hotfix/]<br>Support branches? [support/]<br>Version tag prefix? []<br><br>$ git branch* develop main<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Feature-branches\"><a href=\"#Feature-branches\" class=\"headerlink\" title=\"Feature branches\"></a>Feature branches</h2><p>Each new feature should reside in its own branch, which can be <a href=\"https://www.atlassian.com/git/tutorials/syncing/git-push\">pushed to the central repository</a> for backup&#x2F;collaboration. But, instead of branching off of <code>main</code>, <code>feature</code> branches use <code>develop</code>as their parent branch. When a feature is complete, it gets <a href=\"https://www.atlassian.com/git/tutorials/using-branches/git-merge\">merged back into develop</a>. Features should never interact directly with <code>main</code>.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=116\" alt=\"Git flow workflow - Feature Branches\"></p>\n<p>Note that <code>feature</code> branches combined with the <code>develop</code> branch is, for all intents and purposes, the Feature Branch Workflow. But, the Gitflow workflow doesn’t stop there.</p>\n<p><code>Feature</code> branches are generally created off to the latest <code>develop</code>branch.</p>\n<h3 id=\"Creating-a-feature-branch\"><a href=\"#Creating-a-feature-branch\" class=\"headerlink\" title=\"Creating a feature branch\"></a>Creating a feature branch</h3><p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout develop<br>git checkout -b feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>When using the git-flow extension:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git flow feature start feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>Continue your work and use Git like you normally would.</p>\n<h3 id=\"Finishing-a-feature-branch\"><a href=\"#Finishing-a-feature-branch\" class=\"headerlink\" title=\"Finishing a feature branch\"></a>Finishing a feature branch</h3><p>When you’re done with the development work on the feature, the next step is to merge the <code>feature_branch</code> into <code>develop</code>.</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git checkout develop<br>git merge feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>Using the git-flow extensions:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">git flow feature finish feature_branch<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Release-branches\"><a href=\"#Release-branches\" class=\"headerlink\" title=\"Release branches\"></a>Release branches</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=116\" alt=\"Git Flow Workflow - Release Branches\"></p>\n<p>Once <code>develop</code> has acquired enough features for a release (or a predetermined release date is approaching), you fork a <code>release</code>branch off of <code>develop</code>. Creating this branch starts the next release cycle, so no new features can be added after this point—only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. Once it’s ready to ship, the <code>release</code> branch gets merged into <code>main</code> and tagged with a version number. In addition, it should be merged back into <code>develop</code>, which may have progressed since the release was initiated.</p>\n<p>Using a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development (e.g., it’s easy to say, “This week we’re preparing for version 4.0,” and to actually see it in the structure of the repository).</p>\n<p>Making <code>release</code> branches is another straightforward branching operation. Like <code>feature</code> branches, <code>release</code> branches are based on the <code>develop</code> branch. A new <code>release</code> branch can be created using the following methods.</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout develop<br>git checkout -b release/0.1.0<br></code></pre></td></tr></table></figure>\n\n<p>When using the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow release start 0.1.0<br>Switched to a new branch <span class=\"hljs-string\">&#x27;release/0.1.0&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>Once the release is ready to ship, it will get merged it into <code>main</code> and <code>develop</code>, then the <code>release</code> branch will be deleted. It’s important to merge back into <code>develop</code> because critical updates may have been added to the <code>release</code> branch and they need to be accessible to new features. If your organization stresses code review, this would be an ideal place for a pull request.</p>\n<p>To finish a <code>release</code> branch, use the following methods:</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git merge release/0.1.0<br></code></pre></td></tr></table></figure>\n\n<p>Or with the git-flow extension:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git flow release finish <span class=\"hljs-string\">&#x27;0.1.0&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Hotfix-branches\"><a href=\"#Hotfix-branches\" class=\"headerlink\" title=\"Hotfix branches\"></a>Hotfix branches</h2><p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:cc0b526e-adb7-4d45-874e-9bcea9898b4a/04%20Hotfix%20branches.svg?cdnVersion=116\" alt=\"Git flow workflow - Hotfix Branches\"></p>\n<p>Maintenance or <code>“hotfix”</code> branches are used to quickly patch production releases. <code>Hotfix</code> branches are a lot like <code>release</code>branches and <code>feature</code> branches except they’re based on <code>main</code> instead of <code>develop</code>. This is the only branch that should fork directly off of <code>main</code>. As soon as the fix is complete, it should be merged into both <code>main</code> and <code>develop</code> (or the current <code>release</code>branch), and <code>main</code> should be tagged with an updated version number.</p>\n<p>Having a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. You can think of maintenance branches as ad hoc <code>release</code> branches that work directly with <code>main</code>. A <code>hotfix</code> branch can be created using the following methods:</p>\n<p>Without the git-flow extensions:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git checkout -b hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<p>When using the git-flow extensions: </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow hotfix start hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<p>Similar to finishing a <code>release</code> branch, a <code>hotfix</code> branch gets merged into both <code>main</code> and <code>develop.</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git merge hotfix_branch<br>git checkout develop<br>git merge hotfix_branch<br>git branch -D hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ git flow hotfix finish hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>A complete example demonstrating a Feature Branch Flow is as follows. Assuming we have a repo setup with a <code>main</code> branch.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout maingit checkout -b develop<br>git checkout -b feature_branch<br><span class=\"hljs-comment\"># work happens on feature branch</span><br>git checkout develop<br>git merge feature_branch<br>git checkout main<br>git merge develop<br>git branch -d feature_branch<br></code></pre></td></tr></table></figure>\n\n<p>In addition to the <code>feature</code> and <code>release</code> flow, a <code>hotfix</code> example is as follows:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">git checkout main<br>git checkout -b hotfix_branch<br><span class=\"hljs-comment\"># work is done commits are added to the hotfix_branchgit checkout develop</span><br>git merge hotfix_branch<br>git checkout main<br>git merge hotfix_branch<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>Here we discussed the Gitflow Workflow. Gitflow is one of many styles of <a href=\"https://www.atlassian.com/git/tutorials/comparing-workflows\">Git workflows</a> you and your team can utilize.</p>\n<p>Some key takeaways to know about Gitflow are:</p>\n<ul>\n<li>The workflow is great for a release-based software workflow.</li>\n<li>Gitflow offers a dedicated channel for hotfixes to production.</li>\n</ul>\n<p>The overall flow of Gitflow is:</p>\n<ol>\n<li>A <code>develop</code> branch is created from <code>main</code></li>\n<li>A <code>release</code> branch is created from <code>develop</code></li>\n<li><code>Feature</code> branches are created from <code>develop</code></li>\n<li>When a <code>feature</code> is complete it is merged into the <code>develop</code> branch</li>\n<li>When the <code>release</code> branch is done it is merged into <code>develop</code>and <code>main</code></li>\n<li>If an issue in <code>main</code> is detected a <code>hotfix</code> branch is created from <code>main</code></li>\n<li>Once the <code>hotfix</code> is complete it is merged to both <code>develop</code>and <code>main</code></li>\n</ol>\n"},{"title":"Pip基本操作","date":"2022-04-05T09:20:27.000Z","description":"Python Pip自己的包上传","_content":"\n[PyPI · The Python Package Index](https://pypi.org/)\n\n# 查看本地环境\n\n## 查看镜像源\n\n```bash\npip config list\n```\n\n## pip国内的一些镜像\n\n-   阿里云 [](https://mirrors.aliyun.com/pypi/simple/)[https://mirrors.aliyun.com/pypi/simple/](https://mirrors.aliyun.com/pypi/simple/)\n-   中国科技大学 [](https://pypi.mirrors.ustc.edu.cn/simple/)[https://pypi.mirrors.ustc.edu.cn/simple/](https://pypi.mirrors.ustc.edu.cn/simple/)\n-   豆瓣(douban) [](http://pypi.douban.com/simple/)[http://pypi.douban.com/simple/](http://pypi.douban.com/simple/)\n-   清华大学 [](https://pypi.tuna.tsinghua.edu.cn/simple/)[https://pypi.tuna.tsinghua.edu.cn/simple/](https://pypi.tuna.tsinghua.edu.cn/simple/)\n-   中国科学技术大学 [](http://pypi.mirrors.ustc.edu.cn/simple/)[http://pypi.mirrors.ustc.edu.cn/simple/](http://pypi.mirrors.ustc.edu.cn/simple/)\n\n## 修改源方法：\n\n### 临时使用：\n\n可以在使用pip的时候在后面加上-i参数，指定pip源\n\n```\npip install scrapy -i <https://pypi.tuna.tsinghua.edu.cn/simple>\n```\n\n### 永久修改：\n\n**linux** 修改 `~/.pip/pip.conf` (没有就创建一个)， 内容如下：\n\n```\n[global]\nindex-url = <https://pypi.tuna.tsinghua.edu.cn/simple>\n```\n\n**windows** 直接在`user`目录中创建一个`pip`目录，如：`C:\\\\Users\\\\xx\\\\pip`，新建文件`pip.ini`，内容如下\n\n```\n[global]\nindex-url = <https://pypi.tuna.tsinghua.edu.cn/simple>\n```\n\n# 第一步：注册一个PyPi帐号\n\n在上边的注册网站上注册一个自已的帐号，注册好后在邮箱激活，一般注册流程都是这么操作了，这里就不多说了。\n\n# 第二步：在github上创建一个项目\n\n如果你还没有使用过github源码托管网站，可以先注册一个github的帐户再创建项目，我一般创建项目用的是官网提供的桌面工具Github Desktop.\n\nGithub Desktop的下载地址：[](https://desktop.github.com/)[https://desktop.github.com](https://desktop.github.com/)\n\ngithub注册和创建新项目，这里也不说了，程序员的基本功。\n\n# 第三步：编写自已的python项目\n\n我这里只有一个`timetool.py`和`pathtool.py`两个文件\n\n先建一个目录，比如`magetool`，这个里边放的是你的项目代码\n\n在这个`magetool`目录里,新建一个`__init__.py`，这个文件里可以什么都不用写，然后就是你要发布的`.py`文件\n\n# 第四步：编写setup.py文件\n\n这里重点说明一下这个`setup.py`文件，因为整个`pip`项目的发布和上传都是基于这个`setup.py`文件完成的。\n\n大家可以看一下我示例项目的`setup.py`是怎么写的，其实我也是从网上下载别人写好的。\n\n```bash\n#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nfrom setuptools import setup, find_packages\n\nsetup(\n\tname = \"magetool\",\n\tversion = \"0.1.0\",\n\tkeywords = (\"pip\", \"pathtool\",\"timetool\", \"magetool\", \"mage\"),\n\tdescription = \"time and path tool\",\n\tlong_description = \"time and path tool\",\n\tlicense = \"MIT Licence\",\n\turl = \"<https://github.com/fengmm521/pipProject>\",\n\tauthor = \"mage\",\n\tauthor_email = \"mage@woodcol.com\",\n\tpackages = find_packages(),\n\tinclude_package_data = True,\n\tplatforms = \"any\",\n\tinstall_requires = []\n)\n```\n\n## setup.py中重要的参数有5个：\n\n### name\n\n`name = “magetool”`，这个`name`参数后边的就是你的项目代码所在目录，也是你`pip`要上传的项目名称，其他人用`pip install xxx`来安装时，后边的`xxx`就是你的这个`magetool`\n\n### version\n\n`version = “0.1.0”`，你工具的版本号，后期你工具更新了，要用pip来更新包的时候，会更新比当前版本号高的新版本。\n\n下边是pip 更新包的命令\n\n```bash\npip install --upgrade <包的名字>\npip install -U <包的名字>\n```\n\n### packages\n\n`packages = find_packages()`，这个参数是导入目录下的所有`__init__.py`包\n\n### install_requires\n\n`install_requires = []`，这是一个数组，里边包含的是咱的pip项目引用到的第三方库，如果你的项目有用到第三方库，要在这里添上第三方库的包名，如果用的第三方版本不是最新版本，还要有版本号。\n\n# 第五步：打包自已的项目\n\n在代码编写完成，自已测试后没有问题了，就可以打包了。 打包使用下边两个命令：\n\n我使用的是第二个\n\n```bash\npython setup.py bdist_egg     # 生成类似 edssdk-0.0.1-py2.7.egg，支持 easy_install\npython setup.py sdist         # 生成类似 edssdk-0.0.1.tar.gz，支持 pip\n```\n\n两个命令打包好之后都会生成`build`和`dist`两个目录，打包的文件会放在`dist`目录下，供后边上传到`PyPi`服务器\n\n# 第六步：上传到PyPi服务器\n\n在上传前，要建一个文件，`$HOME/.pypirc`，`$HOME`目录在`linux`或者`mac`系统下就是~/目录。在这里建一个`.pypirc`文件。里边的内容如下：\n\n```bash\n[distutils]\nindex-servers = pypi\n[pypi]\nusername:你的PyPi用户名\npassword:你的PyPi密码\n```\n\n因为不能使用`python setup.py register`进行上传，使用这个上传会报一个410的错误。所以要使用`.pypirc`文件保存你的PyPi用户信息，这时使用下载的`twine`就可以直接上传了。\n\n在别的地方找到的有说上传用`python setup.py sdist upload`命令，但在我这里用这个命令也会一直失败，所以我用下边的命令上传打包好的pip项目，我上传的是用第五步的，`python setup.py sdist`命令打包好的项目，\n\n上传好打包的`pip`安装包:\n\n```bash\ntwine upload dist/magetool-0.1.0.tar.gz\n```\n\n# 第七步：使用pip安装刚刚上传的包\n\npip安装包我这里就不多说了，这个一般用python的都会的\n\n用pip安装上传的包:\n\n```bash\npip install magetool --user\n–user参数的意思是安装给当电脑的当前用户，要不然会要求系统管理员权限才能安装。加了–user之后就不用sudo的管理员权限了。\n```","source":"_posts/Anaconda/Pip.md","raw":"---\ntitle: Pip基本操作\ndate: 2022-04-05 17:20:27\ntags:\n  - [python]\n  - [pip]\ncategories:\n  - [技术]\ndescription: Python Pip自己的包上传\n---\n\n[PyPI · The Python Package Index](https://pypi.org/)\n\n# 查看本地环境\n\n## 查看镜像源\n\n```bash\npip config list\n```\n\n## pip国内的一些镜像\n\n-   阿里云 [](https://mirrors.aliyun.com/pypi/simple/)[https://mirrors.aliyun.com/pypi/simple/](https://mirrors.aliyun.com/pypi/simple/)\n-   中国科技大学 [](https://pypi.mirrors.ustc.edu.cn/simple/)[https://pypi.mirrors.ustc.edu.cn/simple/](https://pypi.mirrors.ustc.edu.cn/simple/)\n-   豆瓣(douban) [](http://pypi.douban.com/simple/)[http://pypi.douban.com/simple/](http://pypi.douban.com/simple/)\n-   清华大学 [](https://pypi.tuna.tsinghua.edu.cn/simple/)[https://pypi.tuna.tsinghua.edu.cn/simple/](https://pypi.tuna.tsinghua.edu.cn/simple/)\n-   中国科学技术大学 [](http://pypi.mirrors.ustc.edu.cn/simple/)[http://pypi.mirrors.ustc.edu.cn/simple/](http://pypi.mirrors.ustc.edu.cn/simple/)\n\n## 修改源方法：\n\n### 临时使用：\n\n可以在使用pip的时候在后面加上-i参数，指定pip源\n\n```\npip install scrapy -i <https://pypi.tuna.tsinghua.edu.cn/simple>\n```\n\n### 永久修改：\n\n**linux** 修改 `~/.pip/pip.conf` (没有就创建一个)， 内容如下：\n\n```\n[global]\nindex-url = <https://pypi.tuna.tsinghua.edu.cn/simple>\n```\n\n**windows** 直接在`user`目录中创建一个`pip`目录，如：`C:\\\\Users\\\\xx\\\\pip`，新建文件`pip.ini`，内容如下\n\n```\n[global]\nindex-url = <https://pypi.tuna.tsinghua.edu.cn/simple>\n```\n\n# 第一步：注册一个PyPi帐号\n\n在上边的注册网站上注册一个自已的帐号，注册好后在邮箱激活，一般注册流程都是这么操作了，这里就不多说了。\n\n# 第二步：在github上创建一个项目\n\n如果你还没有使用过github源码托管网站，可以先注册一个github的帐户再创建项目，我一般创建项目用的是官网提供的桌面工具Github Desktop.\n\nGithub Desktop的下载地址：[](https://desktop.github.com/)[https://desktop.github.com](https://desktop.github.com/)\n\ngithub注册和创建新项目，这里也不说了，程序员的基本功。\n\n# 第三步：编写自已的python项目\n\n我这里只有一个`timetool.py`和`pathtool.py`两个文件\n\n先建一个目录，比如`magetool`，这个里边放的是你的项目代码\n\n在这个`magetool`目录里,新建一个`__init__.py`，这个文件里可以什么都不用写，然后就是你要发布的`.py`文件\n\n# 第四步：编写setup.py文件\n\n这里重点说明一下这个`setup.py`文件，因为整个`pip`项目的发布和上传都是基于这个`setup.py`文件完成的。\n\n大家可以看一下我示例项目的`setup.py`是怎么写的，其实我也是从网上下载别人写好的。\n\n```bash\n#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nfrom setuptools import setup, find_packages\n\nsetup(\n\tname = \"magetool\",\n\tversion = \"0.1.0\",\n\tkeywords = (\"pip\", \"pathtool\",\"timetool\", \"magetool\", \"mage\"),\n\tdescription = \"time and path tool\",\n\tlong_description = \"time and path tool\",\n\tlicense = \"MIT Licence\",\n\turl = \"<https://github.com/fengmm521/pipProject>\",\n\tauthor = \"mage\",\n\tauthor_email = \"mage@woodcol.com\",\n\tpackages = find_packages(),\n\tinclude_package_data = True,\n\tplatforms = \"any\",\n\tinstall_requires = []\n)\n```\n\n## setup.py中重要的参数有5个：\n\n### name\n\n`name = “magetool”`，这个`name`参数后边的就是你的项目代码所在目录，也是你`pip`要上传的项目名称，其他人用`pip install xxx`来安装时，后边的`xxx`就是你的这个`magetool`\n\n### version\n\n`version = “0.1.0”`，你工具的版本号，后期你工具更新了，要用pip来更新包的时候，会更新比当前版本号高的新版本。\n\n下边是pip 更新包的命令\n\n```bash\npip install --upgrade <包的名字>\npip install -U <包的名字>\n```\n\n### packages\n\n`packages = find_packages()`，这个参数是导入目录下的所有`__init__.py`包\n\n### install_requires\n\n`install_requires = []`，这是一个数组，里边包含的是咱的pip项目引用到的第三方库，如果你的项目有用到第三方库，要在这里添上第三方库的包名，如果用的第三方版本不是最新版本，还要有版本号。\n\n# 第五步：打包自已的项目\n\n在代码编写完成，自已测试后没有问题了，就可以打包了。 打包使用下边两个命令：\n\n我使用的是第二个\n\n```bash\npython setup.py bdist_egg     # 生成类似 edssdk-0.0.1-py2.7.egg，支持 easy_install\npython setup.py sdist         # 生成类似 edssdk-0.0.1.tar.gz，支持 pip\n```\n\n两个命令打包好之后都会生成`build`和`dist`两个目录，打包的文件会放在`dist`目录下，供后边上传到`PyPi`服务器\n\n# 第六步：上传到PyPi服务器\n\n在上传前，要建一个文件，`$HOME/.pypirc`，`$HOME`目录在`linux`或者`mac`系统下就是~/目录。在这里建一个`.pypirc`文件。里边的内容如下：\n\n```bash\n[distutils]\nindex-servers = pypi\n[pypi]\nusername:你的PyPi用户名\npassword:你的PyPi密码\n```\n\n因为不能使用`python setup.py register`进行上传，使用这个上传会报一个410的错误。所以要使用`.pypirc`文件保存你的PyPi用户信息，这时使用下载的`twine`就可以直接上传了。\n\n在别的地方找到的有说上传用`python setup.py sdist upload`命令，但在我这里用这个命令也会一直失败，所以我用下边的命令上传打包好的pip项目，我上传的是用第五步的，`python setup.py sdist`命令打包好的项目，\n\n上传好打包的`pip`安装包:\n\n```bash\ntwine upload dist/magetool-0.1.0.tar.gz\n```\n\n# 第七步：使用pip安装刚刚上传的包\n\npip安装包我这里就不多说了，这个一般用python的都会的\n\n用pip安装上传的包:\n\n```bash\npip install magetool --user\n–user参数的意思是安装给当电脑的当前用户，要不然会要求系统管理员权限才能安装。加了–user之后就不用sudo的管理员权限了。\n```","slug":"Anaconda/Pip","published":1,"updated":"2022-08-28T07:38:59.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1k000hscvmduvm9m8n","content":"<p><a href=\"https://pypi.org/\">PyPI · The Python Package Index</a></p>\n<h1 id=\"查看本地环境\"><a href=\"#查看本地环境\" class=\"headerlink\" title=\"查看本地环境\"></a>查看本地环境</h1><h2 id=\"查看镜像源\"><a href=\"#查看镜像源\" class=\"headerlink\" title=\"查看镜像源\"></a>查看镜像源</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\">pip config list<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"pip国内的一些镜像\"><a href=\"#pip国内的一些镜像\" class=\"headerlink\" title=\"pip国内的一些镜像\"></a>pip国内的一些镜像</h2><ul>\n<li>阿里云 <a href=\"https://mirrors.aliyun.com/pypi/simple/\"></a><a href=\"https://mirrors.aliyun.com/pypi/simple/\">https://mirrors.aliyun.com/pypi/simple/</a></li>\n<li>中国科技大学 <a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\"></a><a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\">https://pypi.mirrors.ustc.edu.cn/simple/</a></li>\n<li>豆瓣(douban) <a href=\"http://pypi.douban.com/simple/\"></a><a href=\"http://pypi.douban.com/simple/\">http://pypi.douban.com/simple/</a></li>\n<li>清华大学 <a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\"></a><a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li>\n<li>中国科学技术大学 <a href=\"http://pypi.mirrors.ustc.edu.cn/simple/\"></a><a href=\"http://pypi.mirrors.ustc.edu.cn/simple/\">http://pypi.mirrors.ustc.edu.cn/simple/</a></li>\n</ul>\n<h2 id=\"修改源方法：\"><a href=\"#修改源方法：\" class=\"headerlink\" title=\"修改源方法：\"></a>修改源方法：</h2><h3 id=\"临时使用：\"><a href=\"#临时使用：\" class=\"headerlink\" title=\"临时使用：\"></a>临时使用：</h3><p>可以在使用pip的时候在后面加上-i参数，指定pip源</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">pip install scrapy -i &lt;https:<span class=\"hljs-regexp\">//</span>pypi.tuna.tsinghua.edu.cn/simple&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"永久修改：\"><a href=\"#永久修改：\" class=\"headerlink\" title=\"永久修改：\"></a>永久修改：</h3><p><strong>linux</strong> 修改 <code>~/.pip/pip.conf</code> (没有就创建一个)， 内容如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[global]</span><br><span class=\"hljs-attr\">index-url</span> = &lt;https://pypi.tuna.tsinghua.edu.cn/simple&gt;<br></code></pre></td></tr></table></figure>\n\n<p><strong>windows</strong> 直接在<code>user</code>目录中创建一个<code>pip</code>目录，如：<code>C:\\\\Users\\\\xx\\\\pip</code>，新建文件<code>pip.ini</code>，内容如下</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[global]</span><br><span class=\"hljs-attr\">index-url</span> = &lt;https://pypi.tuna.tsinghua.edu.cn/simple&gt;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第一步：注册一个PyPi帐号\"><a href=\"#第一步：注册一个PyPi帐号\" class=\"headerlink\" title=\"第一步：注册一个PyPi帐号\"></a>第一步：注册一个PyPi帐号</h1><p>在上边的注册网站上注册一个自已的帐号，注册好后在邮箱激活，一般注册流程都是这么操作了，这里就不多说了。</p>\n<h1 id=\"第二步：在github上创建一个项目\"><a href=\"#第二步：在github上创建一个项目\" class=\"headerlink\" title=\"第二步：在github上创建一个项目\"></a>第二步：在github上创建一个项目</h1><p>如果你还没有使用过github源码托管网站，可以先注册一个github的帐户再创建项目，我一般创建项目用的是官网提供的桌面工具Github Desktop.</p>\n<p>Github Desktop的下载地址：<a href=\"https://desktop.github.com/\"></a><a href=\"https://desktop.github.com/\">https://desktop.github.com</a></p>\n<p>github注册和创建新项目，这里也不说了，程序员的基本功。</p>\n<h1 id=\"第三步：编写自已的python项目\"><a href=\"#第三步：编写自已的python项目\" class=\"headerlink\" title=\"第三步：编写自已的python项目\"></a>第三步：编写自已的python项目</h1><p>我这里只有一个<code>timetool.py</code>和<code>pathtool.py</code>两个文件</p>\n<p>先建一个目录，比如<code>magetool</code>，这个里边放的是你的项目代码</p>\n<p>在这个<code>magetool</code>目录里,新建一个<code>__init__.py</code>，这个文件里可以什么都不用写，然后就是你要发布的<code>.py</code>文件</p>\n<h1 id=\"第四步：编写setup-py文件\"><a href=\"#第四步：编写setup-py文件\" class=\"headerlink\" title=\"第四步：编写setup.py文件\"></a>第四步：编写setup.py文件</h1><p>这里重点说明一下这个<code>setup.py</code>文件，因为整个<code>pip</code>项目的发布和上传都是基于这个<code>setup.py</code>文件完成的。</p>\n<p>大家可以看一下我示例项目的<code>setup.py</code>是怎么写的，其实我也是从网上下载别人写好的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/usr/bin/env python</span><br><span class=\"hljs-comment\">#-*- coding:utf-8 -*-</span><br>from setuptools import setup, find_packages<br><br>setup(<br>\tname = <span class=\"hljs-string\">&quot;magetool&quot;</span>,<br>\tversion = <span class=\"hljs-string\">&quot;0.1.0&quot;</span>,<br>\tkeywords = (<span class=\"hljs-string\">&quot;pip&quot;</span>, <span class=\"hljs-string\">&quot;pathtool&quot;</span>,<span class=\"hljs-string\">&quot;timetool&quot;</span>, <span class=\"hljs-string\">&quot;magetool&quot;</span>, <span class=\"hljs-string\">&quot;mage&quot;</span>),<br>\tdescription = <span class=\"hljs-string\">&quot;time and path tool&quot;</span>,<br>\tlong_description = <span class=\"hljs-string\">&quot;time and path tool&quot;</span>,<br>\tlicense = <span class=\"hljs-string\">&quot;MIT Licence&quot;</span>,<br>\turl = <span class=\"hljs-string\">&quot;&lt;https://github.com/fengmm521/pipProject&gt;&quot;</span>,<br>\tauthor = <span class=\"hljs-string\">&quot;mage&quot;</span>,<br>\tauthor_email = <span class=\"hljs-string\">&quot;mage@woodcol.com&quot;</span>,<br>\tpackages = find_packages(),<br>\tinclude_package_data = True,<br>\tplatforms = <span class=\"hljs-string\">&quot;any&quot;</span>,<br>\tinstall_requires = []<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"setup-py中重要的参数有5个：\"><a href=\"#setup-py中重要的参数有5个：\" class=\"headerlink\" title=\"setup.py中重要的参数有5个：\"></a>setup.py中重要的参数有5个：</h2><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p><code>name = “magetool”</code>，这个<code>name</code>参数后边的就是你的项目代码所在目录，也是你<code>pip</code>要上传的项目名称，其他人用<code>pip install xxx</code>来安装时，后边的<code>xxx</code>就是你的这个<code>magetool</code></p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p><code>version = “0.1.0”</code>，你工具的版本号，后期你工具更新了，要用pip来更新包的时候，会更新比当前版本号高的新版本。</p>\n<p>下边是pip 更新包的命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install --upgrade &lt;包的名字&gt;<br>pip install -U &lt;包的名字&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"packages\"><a href=\"#packages\" class=\"headerlink\" title=\"packages\"></a>packages</h3><p><code>packages = find_packages()</code>，这个参数是导入目录下的所有<code>__init__.py</code>包</p>\n<h3 id=\"install-requires\"><a href=\"#install-requires\" class=\"headerlink\" title=\"install_requires\"></a>install_requires</h3><p><code>install_requires = []</code>，这是一个数组，里边包含的是咱的pip项目引用到的第三方库，如果你的项目有用到第三方库，要在这里添上第三方库的包名，如果用的第三方版本不是最新版本，还要有版本号。</p>\n<h1 id=\"第五步：打包自已的项目\"><a href=\"#第五步：打包自已的项目\" class=\"headerlink\" title=\"第五步：打包自已的项目\"></a>第五步：打包自已的项目</h1><p>在代码编写完成，自已测试后没有问题了，就可以打包了。 打包使用下边两个命令：</p>\n<p>我使用的是第二个</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python setup.py bdist_egg     <span class=\"hljs-comment\"># 生成类似 edssdk-0.0.1-py2.7.egg，支持 easy_install</span><br>python setup.py sdist         <span class=\"hljs-comment\"># 生成类似 edssdk-0.0.1.tar.gz，支持 pip</span><br></code></pre></td></tr></table></figure>\n\n<p>两个命令打包好之后都会生成<code>build</code>和<code>dist</code>两个目录，打包的文件会放在<code>dist</code>目录下，供后边上传到<code>PyPi</code>服务器</p>\n<h1 id=\"第六步：上传到PyPi服务器\"><a href=\"#第六步：上传到PyPi服务器\" class=\"headerlink\" title=\"第六步：上传到PyPi服务器\"></a>第六步：上传到PyPi服务器</h1><p>在上传前，要建一个文件，<code>$HOME/.pypirc</code>，<code>$HOME</code>目录在<code>linux</code>或者<code>mac</code>系统下就是~&#x2F;目录。在这里建一个<code>.pypirc</code>文件。里边的内容如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">[distutils]<br>index-servers = pypi<br>[pypi]<br>username:你的PyPi用户名<br>password:你的PyPi密码<br></code></pre></td></tr></table></figure>\n\n<p>因为不能使用<code>python setup.py register</code>进行上传，使用这个上传会报一个410的错误。所以要使用<code>.pypirc</code>文件保存你的PyPi用户信息，这时使用下载的<code>twine</code>就可以直接上传了。</p>\n<p>在别的地方找到的有说上传用<code>python setup.py sdist upload</code>命令，但在我这里用这个命令也会一直失败，所以我用下边的命令上传打包好的pip项目，我上传的是用第五步的，<code>python setup.py sdist</code>命令打包好的项目，</p>\n<p>上传好打包的<code>pip</code>安装包:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">twine upload dist/magetool-0.1.0.tar.gz<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第七步：使用pip安装刚刚上传的包\"><a href=\"#第七步：使用pip安装刚刚上传的包\" class=\"headerlink\" title=\"第七步：使用pip安装刚刚上传的包\"></a>第七步：使用pip安装刚刚上传的包</h1><p>pip安装包我这里就不多说了，这个一般用python的都会的</p>\n<p>用pip安装上传的包:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install magetool --user<br>–user参数的意思是安装给当电脑的当前用户，要不然会要求系统管理员权限才能安装。加了–user之后就不用sudo的管理员权限了。<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":2981,"excerpt":"","more":"<p><a href=\"https://pypi.org/\">PyPI · The Python Package Index</a></p>\n<h1 id=\"查看本地环境\"><a href=\"#查看本地环境\" class=\"headerlink\" title=\"查看本地环境\"></a>查看本地环境</h1><h2 id=\"查看镜像源\"><a href=\"#查看镜像源\" class=\"headerlink\" title=\"查看镜像源\"></a>查看镜像源</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip config list<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"pip国内的一些镜像\"><a href=\"#pip国内的一些镜像\" class=\"headerlink\" title=\"pip国内的一些镜像\"></a>pip国内的一些镜像</h2><ul>\n<li>阿里云 <a href=\"https://mirrors.aliyun.com/pypi/simple/\"></a><a href=\"https://mirrors.aliyun.com/pypi/simple/\">https://mirrors.aliyun.com/pypi/simple/</a></li>\n<li>中国科技大学 <a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\"></a><a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\">https://pypi.mirrors.ustc.edu.cn/simple/</a></li>\n<li>豆瓣(douban) <a href=\"http://pypi.douban.com/simple/\"></a><a href=\"http://pypi.douban.com/simple/\">http://pypi.douban.com/simple/</a></li>\n<li>清华大学 <a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\"></a><a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li>\n<li>中国科学技术大学 <a href=\"http://pypi.mirrors.ustc.edu.cn/simple/\"></a><a href=\"http://pypi.mirrors.ustc.edu.cn/simple/\">http://pypi.mirrors.ustc.edu.cn/simple/</a></li>\n</ul>\n<h2 id=\"修改源方法：\"><a href=\"#修改源方法：\" class=\"headerlink\" title=\"修改源方法：\"></a>修改源方法：</h2><h3 id=\"临时使用：\"><a href=\"#临时使用：\" class=\"headerlink\" title=\"临时使用：\"></a>临时使用：</h3><p>可以在使用pip的时候在后面加上-i参数，指定pip源</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">pip install scrapy -i &lt;https:<span class=\"hljs-regexp\">//</span>pypi.tuna.tsinghua.edu.cn/simple&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"永久修改：\"><a href=\"#永久修改：\" class=\"headerlink\" title=\"永久修改：\"></a>永久修改：</h3><p><strong>linux</strong> 修改 <code>~/.pip/pip.conf</code> (没有就创建一个)， 内容如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[global]</span><br><span class=\"hljs-attr\">index-url</span> = &lt;https://pypi.tuna.tsinghua.edu.cn/simple&gt;<br></code></pre></td></tr></table></figure>\n\n<p><strong>windows</strong> 直接在<code>user</code>目录中创建一个<code>pip</code>目录，如：<code>C:\\\\Users\\\\xx\\\\pip</code>，新建文件<code>pip.ini</code>，内容如下</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[global]</span><br><span class=\"hljs-attr\">index-url</span> = &lt;https://pypi.tuna.tsinghua.edu.cn/simple&gt;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第一步：注册一个PyPi帐号\"><a href=\"#第一步：注册一个PyPi帐号\" class=\"headerlink\" title=\"第一步：注册一个PyPi帐号\"></a>第一步：注册一个PyPi帐号</h1><p>在上边的注册网站上注册一个自已的帐号，注册好后在邮箱激活，一般注册流程都是这么操作了，这里就不多说了。</p>\n<h1 id=\"第二步：在github上创建一个项目\"><a href=\"#第二步：在github上创建一个项目\" class=\"headerlink\" title=\"第二步：在github上创建一个项目\"></a>第二步：在github上创建一个项目</h1><p>如果你还没有使用过github源码托管网站，可以先注册一个github的帐户再创建项目，我一般创建项目用的是官网提供的桌面工具Github Desktop.</p>\n<p>Github Desktop的下载地址：<a href=\"https://desktop.github.com/\"></a><a href=\"https://desktop.github.com/\">https://desktop.github.com</a></p>\n<p>github注册和创建新项目，这里也不说了，程序员的基本功。</p>\n<h1 id=\"第三步：编写自已的python项目\"><a href=\"#第三步：编写自已的python项目\" class=\"headerlink\" title=\"第三步：编写自已的python项目\"></a>第三步：编写自已的python项目</h1><p>我这里只有一个<code>timetool.py</code>和<code>pathtool.py</code>两个文件</p>\n<p>先建一个目录，比如<code>magetool</code>，这个里边放的是你的项目代码</p>\n<p>在这个<code>magetool</code>目录里,新建一个<code>__init__.py</code>，这个文件里可以什么都不用写，然后就是你要发布的<code>.py</code>文件</p>\n<h1 id=\"第四步：编写setup-py文件\"><a href=\"#第四步：编写setup-py文件\" class=\"headerlink\" title=\"第四步：编写setup.py文件\"></a>第四步：编写setup.py文件</h1><p>这里重点说明一下这个<code>setup.py</code>文件，因为整个<code>pip</code>项目的发布和上传都是基于这个<code>setup.py</code>文件完成的。</p>\n<p>大家可以看一下我示例项目的<code>setup.py</code>是怎么写的，其实我也是从网上下载别人写好的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/usr/bin/env python</span><br><span class=\"hljs-comment\">#-*- coding:utf-8 -*-</span><br>from setuptools import setup, find_packages<br><br>setup(<br>\tname = <span class=\"hljs-string\">&quot;magetool&quot;</span>,<br>\tversion = <span class=\"hljs-string\">&quot;0.1.0&quot;</span>,<br>\tkeywords = (<span class=\"hljs-string\">&quot;pip&quot;</span>, <span class=\"hljs-string\">&quot;pathtool&quot;</span>,<span class=\"hljs-string\">&quot;timetool&quot;</span>, <span class=\"hljs-string\">&quot;magetool&quot;</span>, <span class=\"hljs-string\">&quot;mage&quot;</span>),<br>\tdescription = <span class=\"hljs-string\">&quot;time and path tool&quot;</span>,<br>\tlong_description = <span class=\"hljs-string\">&quot;time and path tool&quot;</span>,<br>\tlicense = <span class=\"hljs-string\">&quot;MIT Licence&quot;</span>,<br>\turl = <span class=\"hljs-string\">&quot;&lt;https://github.com/fengmm521/pipProject&gt;&quot;</span>,<br>\tauthor = <span class=\"hljs-string\">&quot;mage&quot;</span>,<br>\tauthor_email = <span class=\"hljs-string\">&quot;mage@woodcol.com&quot;</span>,<br>\tpackages = find_packages(),<br>\tinclude_package_data = True,<br>\tplatforms = <span class=\"hljs-string\">&quot;any&quot;</span>,<br>\tinstall_requires = []<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"setup-py中重要的参数有5个：\"><a href=\"#setup-py中重要的参数有5个：\" class=\"headerlink\" title=\"setup.py中重要的参数有5个：\"></a>setup.py中重要的参数有5个：</h2><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p><code>name = “magetool”</code>，这个<code>name</code>参数后边的就是你的项目代码所在目录，也是你<code>pip</code>要上传的项目名称，其他人用<code>pip install xxx</code>来安装时，后边的<code>xxx</code>就是你的这个<code>magetool</code></p>\n<h3 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h3><p><code>version = “0.1.0”</code>，你工具的版本号，后期你工具更新了，要用pip来更新包的时候，会更新比当前版本号高的新版本。</p>\n<p>下边是pip 更新包的命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install --upgrade &lt;包的名字&gt;<br>pip install -U &lt;包的名字&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"packages\"><a href=\"#packages\" class=\"headerlink\" title=\"packages\"></a>packages</h3><p><code>packages = find_packages()</code>，这个参数是导入目录下的所有<code>__init__.py</code>包</p>\n<h3 id=\"install-requires\"><a href=\"#install-requires\" class=\"headerlink\" title=\"install_requires\"></a>install_requires</h3><p><code>install_requires = []</code>，这是一个数组，里边包含的是咱的pip项目引用到的第三方库，如果你的项目有用到第三方库，要在这里添上第三方库的包名，如果用的第三方版本不是最新版本，还要有版本号。</p>\n<h1 id=\"第五步：打包自已的项目\"><a href=\"#第五步：打包自已的项目\" class=\"headerlink\" title=\"第五步：打包自已的项目\"></a>第五步：打包自已的项目</h1><p>在代码编写完成，自已测试后没有问题了，就可以打包了。 打包使用下边两个命令：</p>\n<p>我使用的是第二个</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python setup.py bdist_egg     <span class=\"hljs-comment\"># 生成类似 edssdk-0.0.1-py2.7.egg，支持 easy_install</span><br>python setup.py sdist         <span class=\"hljs-comment\"># 生成类似 edssdk-0.0.1.tar.gz，支持 pip</span><br></code></pre></td></tr></table></figure>\n\n<p>两个命令打包好之后都会生成<code>build</code>和<code>dist</code>两个目录，打包的文件会放在<code>dist</code>目录下，供后边上传到<code>PyPi</code>服务器</p>\n<h1 id=\"第六步：上传到PyPi服务器\"><a href=\"#第六步：上传到PyPi服务器\" class=\"headerlink\" title=\"第六步：上传到PyPi服务器\"></a>第六步：上传到PyPi服务器</h1><p>在上传前，要建一个文件，<code>$HOME/.pypirc</code>，<code>$HOME</code>目录在<code>linux</code>或者<code>mac</code>系统下就是~&#x2F;目录。在这里建一个<code>.pypirc</code>文件。里边的内容如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">[distutils]<br>index-servers = pypi<br>[pypi]<br>username:你的PyPi用户名<br>password:你的PyPi密码<br></code></pre></td></tr></table></figure>\n\n<p>因为不能使用<code>python setup.py register</code>进行上传，使用这个上传会报一个410的错误。所以要使用<code>.pypirc</code>文件保存你的PyPi用户信息，这时使用下载的<code>twine</code>就可以直接上传了。</p>\n<p>在别的地方找到的有说上传用<code>python setup.py sdist upload</code>命令，但在我这里用这个命令也会一直失败，所以我用下边的命令上传打包好的pip项目，我上传的是用第五步的，<code>python setup.py sdist</code>命令打包好的项目，</p>\n<p>上传好打包的<code>pip</code>安装包:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">twine upload dist/magetool-0.1.0.tar.gz<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第七步：使用pip安装刚刚上传的包\"><a href=\"#第七步：使用pip安装刚刚上传的包\" class=\"headerlink\" title=\"第七步：使用pip安装刚刚上传的包\"></a>第七步：使用pip安装刚刚上传的包</h1><p>pip安装包我这里就不多说了，这个一般用python的都会的</p>\n<p>用pip安装上传的包:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install magetool --user<br>–user参数的意思是安装给当电脑的当前用户，要不然会要求系统管理员权限才能安装。加了–user之后就不用sudo的管理员权限了。<br></code></pre></td></tr></table></figure>"},{"title":"NPM基本操作","date":"2022-04-05T09:21:27.000Z","description":"NPM的一些基本操作","_content":"\n# 自己的包的上传\n\n1.  先把下载包的服务器地址切换为NPM官方服务器，注意这一步很重要！\n2.  输入`npm login` 回车，根据提示输入账号、密码、邮箱，输入密码的时候不会显示出来，直接输就可以了。\n3.  创建一个要打包的文件夹，进入到文件夹。\n4.  运行`npm init`初始化一个`package.json`文件，根据提示输入包名，入口。这里没写的或者要修改也可以到`package.json`文件进行修改。\n5.  在你创建的文件夹里新建两个文件: `index.js`和`README.md`，`index.js`文件就是你要导出的内容。\n6.  `README.md`就是一个包的介绍,可以写怎么下载,怎么使用\n7.  包写好后,运行`npm publish 文件夹名称`发布，注意`npm publish`后面这个是你的包文件夹名称不是`package.json`里的`name`，为了统一，文件夹名称和包名最好还是写一样的。\n8.  发布成功后,到[NPM官网](https://www.npmjs.com/)搜索就可以搜到了。\n\n# 查看本地NPM镜像\n\n1.查看镜像源\n\n`npm get registry`\n\n2.切换官方源\n\n`npm config set registry <http://registry.npmjs.org`>\n\n3.切换淘宝源（最新版）\n\n`npm config set registry <https://registry.npmmirror.com`>\n\n4.使用临时镜像源，当安装依赖不想切换源地址时，仅安装当前依赖可以使用\n\n`npm install xxx（依赖名） --registry=https://xxx（源地址）`\n\n","source":"_posts/NPM/NPM基本操作.md","raw":"---\ntitle: NPM基本操作\ndate: 2022-04-05 17:21:27\ntags:\n  - [npm]\n  - [node]\ncategories:\n  - [技术]\ndescription: NPM的一些基本操作\n---\n\n# 自己的包的上传\n\n1.  先把下载包的服务器地址切换为NPM官方服务器，注意这一步很重要！\n2.  输入`npm login` 回车，根据提示输入账号、密码、邮箱，输入密码的时候不会显示出来，直接输就可以了。\n3.  创建一个要打包的文件夹，进入到文件夹。\n4.  运行`npm init`初始化一个`package.json`文件，根据提示输入包名，入口。这里没写的或者要修改也可以到`package.json`文件进行修改。\n5.  在你创建的文件夹里新建两个文件: `index.js`和`README.md`，`index.js`文件就是你要导出的内容。\n6.  `README.md`就是一个包的介绍,可以写怎么下载,怎么使用\n7.  包写好后,运行`npm publish 文件夹名称`发布，注意`npm publish`后面这个是你的包文件夹名称不是`package.json`里的`name`，为了统一，文件夹名称和包名最好还是写一样的。\n8.  发布成功后,到[NPM官网](https://www.npmjs.com/)搜索就可以搜到了。\n\n# 查看本地NPM镜像\n\n1.查看镜像源\n\n`npm get registry`\n\n2.切换官方源\n\n`npm config set registry <http://registry.npmjs.org`>\n\n3.切换淘宝源（最新版）\n\n`npm config set registry <https://registry.npmmirror.com`>\n\n4.使用临时镜像源，当安装依赖不想切换源地址时，仅安装当前依赖可以使用\n\n`npm install xxx（依赖名） --registry=https://xxx（源地址）`\n\n","slug":"NPM/NPM基本操作","published":1,"updated":"2022-08-28T07:38:59.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1m000kscvm8klv98wc","content":"<h1 id=\"自己的包的上传\"><a href=\"#自己的包的上传\" class=\"headerlink\" title=\"自己的包的上传\"></a>自己的包的上传</h1><ol>\n<li>先把下载包的服务器地址切换为NPM官方服务器，注意这一步很重要！</li>\n<li>输入<code>npm login</code> 回车，根据提示输入账号、密码、邮箱，输入密码的时候不会显示出来，直接输就可以了。</li>\n<li>创建一个要打包的文件夹，进入到文件夹。</li>\n<li>运行<code>npm init</code>初始化一个<code>package.json</code>文件，根据提示输入包名，入口。这里没写的或者要修改也可以到<code>package.json</code>文件进行修改。</li>\n<li>在你创建的文件夹里新建两个文件: <code>index.js</code>和<code>README.md</code>，<code>index.js</code>文件就是你要导出的内容。</li>\n<li><code>README.md</code>就是一个包的介绍,可以写怎么下载,怎么使用</li>\n<li>包写好后,运行<code>npm publish 文件夹名称</code>发布，注意<code>npm publish</code>后面这个是你的包文件夹名称不是<code>package.json</code>里的<code>name</code>，为了统一，文件夹名称和包名最好还是写一样的。</li>\n<li>发布成功后,到<a href=\"https://www.npmjs.com/\">NPM官网</a>搜索就可以搜到了。</li>\n</ol>\n<h1 id=\"查看本地NPM镜像\"><a href=\"#查看本地NPM镜像\" class=\"headerlink\" title=\"查看本地NPM镜像\"></a>查看本地NPM镜像</h1><p>1.查看镜像源</p>\n<p><code>npm get registry</code></p>\n<p>2.切换官方源</p>\n<p><code>npm config set registry &lt;http://registry.npmjs.org</code>&gt;</p>\n<p>3.切换淘宝源（最新版）</p>\n<p><code>npm config set registry &lt;https://registry.npmmirror.com</code>&gt;</p>\n<p>4.使用临时镜像源，当安装依赖不想切换源地址时，仅安装当前依赖可以使用</p>\n<p><code>npm install xxx（依赖名） --registry=https://xxx（源地址）</code></p>\n","site":{"data":{}},"wordcount":621,"excerpt":"","more":"<h1 id=\"自己的包的上传\"><a href=\"#自己的包的上传\" class=\"headerlink\" title=\"自己的包的上传\"></a>自己的包的上传</h1><ol>\n<li>先把下载包的服务器地址切换为NPM官方服务器，注意这一步很重要！</li>\n<li>输入<code>npm login</code> 回车，根据提示输入账号、密码、邮箱，输入密码的时候不会显示出来，直接输就可以了。</li>\n<li>创建一个要打包的文件夹，进入到文件夹。</li>\n<li>运行<code>npm init</code>初始化一个<code>package.json</code>文件，根据提示输入包名，入口。这里没写的或者要修改也可以到<code>package.json</code>文件进行修改。</li>\n<li>在你创建的文件夹里新建两个文件: <code>index.js</code>和<code>README.md</code>，<code>index.js</code>文件就是你要导出的内容。</li>\n<li><code>README.md</code>就是一个包的介绍,可以写怎么下载,怎么使用</li>\n<li>包写好后,运行<code>npm publish 文件夹名称</code>发布，注意<code>npm publish</code>后面这个是你的包文件夹名称不是<code>package.json</code>里的<code>name</code>，为了统一，文件夹名称和包名最好还是写一样的。</li>\n<li>发布成功后,到<a href=\"https://www.npmjs.com/\">NPM官网</a>搜索就可以搜到了。</li>\n</ol>\n<h1 id=\"查看本地NPM镜像\"><a href=\"#查看本地NPM镜像\" class=\"headerlink\" title=\"查看本地NPM镜像\"></a>查看本地NPM镜像</h1><p>1.查看镜像源</p>\n<p><code>npm get registry</code></p>\n<p>2.切换官方源</p>\n<p><code>npm config set registry &lt;http://registry.npmjs.org</code>&gt;</p>\n<p>3.切换淘宝源（最新版）</p>\n<p><code>npm config set registry &lt;https://registry.npmmirror.com</code>&gt;</p>\n<p>4.使用临时镜像源，当安装依赖不想切换源地址时，仅安装当前依赖可以使用</p>\n<p><code>npm install xxx（依赖名） --registry=https://xxx（源地址）</code></p>\n"},{"title":"Ngrok使用","date":"2022-08-28T07:45:27.000Z","description":"Ngrok相关文档","_content":"\n# Ngrok\n\n","source":"_posts/Ngrok/index.md","raw":"---\ntitle: Ngrok使用\ndate: 2022-08-28 15:45:27\ntags:\n  - [ngrok]\ncategories:\n  - [技术]\ndescription: Ngrok相关文档\n---\n\n# Ngrok\n\n","slug":"Ngrok/index","published":1,"updated":"2022-08-29T02:35:41.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1n000oscvm6xey1aes","content":"<h1 id=\"Ngrok\"><a href=\"#Ngrok\" class=\"headerlink\" title=\"Ngrok\"></a>Ngrok</h1>","site":{"data":{}},"wordcount":5,"excerpt":"","more":"<h1 id=\"Ngrok\"><a href=\"#Ngrok\" class=\"headerlink\" title=\"Ngrok\"></a>Ngrok</h1>"},{"title":"matplotlib","date":"2022-04-05T07:38:27.000Z","description":"Python绘图相关文档","_content":"\n# bar绘图并且加上数字\n\n```python\ndef plotBar(name, y_label, title, file_name):\n\tdata_group = data.groupby([name, 'emd_lable2']).size().unstack(level=1)\n\tx = np.arange(len(data_group.index))  # the label locations\n\twidth = 0.35  # the width of the bars\n\n\tfig, ax = plt.subplots()\n\trects1 = ax.bar(x - width/2, data_group[0], width, label='未付费')\n\trects2 = ax.bar(x + width/2, data_group[1], width, label='付费')\n\n\t# Add some text for labels, title and custom x-axis tick labels, etc.\n  # y_label正常情况下都是“人数”\n\tax.set_ylabel(y_label)\n\tax.set_title(\"不同{}付费情况\".format(title))\n\tax.set_xticks(x, data_group.index)\n\n\tax.bar_label(rects1, padding=3)\n\tax.bar_label(rects2, padding=3)\n\n\tfig.tight_layout()\n\n\t# 显示label\n\tplt.legend()\n\n\tplt.show()\n\tfig.savefig(file_name)\n```\n\n# 获取当前图片的画布并下载到本地\n\nAxesSubplot如何保存成图片\n\n```python\nfig = AxesSubplot.get_figure()\nfig.savefig(\"output.png\")\n```\n\n# 更改图片的大小以及格式\n\n## 比较方便的方法（开头统一处理）\n\n```python\nimport numpy as np\nimport pandas as pd\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n#from matplotlib.font_manager import FontManager\n\n#fm = FontManager()\n#fonts = set(f.name for f in fm.ttflist)\nconfig = {\n    \"font.family\": 'serif',\n    \"font.serif\": ['Songti SC'],\n    \"font.size\": 18,\n    \"font.sans-serif\": [''],\n    \"figure.figsize\": (16,9),\n    \"mathtext.fontset\": 'stix',\n}\nplt.rcParams.update(config)\n```\n\n## 方法\n\n1. 初始化期间在 `figure()` 方法中设置 `figsize`\n2. 设置 `rcParams` 来更改 Matplotlib 中图形的大小\n3. `set_figheight()` [和](https://www.delftstack.com/zh/howto/matplotlib/how-to-change-the-size-and-format-of-a-figure-in-matplotlib/#set_figheight-%E5%92%8C-set_figwidth-%E4%B8%80%E8%B5%B7%E8%AE%BE%E7%BD%AE-matplotlib-%E5%9B%BE%E5%BD%A2%E5%A4%A7%E5%B0%8F) `set_figwidth()` 一起设置 Matplotlib 图形大小\n4. `set_size_inches()` 方法来更改 Matplotlib 图形大小\n5. 在 Matplotlib 中更改图形格式\n\n我们可以使用 `set_figheight()` 和 `set_figwidth()` 和 `set_size_inches()` 方法来更改 Matplotlib 中的图形大小。我们也可以通过在 `figure()` 方法和 `rcParams` 中设置 `figsize` 来改变 Matplotlib 中的图形大小。同样，要更改图形格式，我们只需在 `savefig()` 方法中更改图像文件的扩展名。\n\n## 初始化期间在 `figure()` 方法中设置 `figsize`\n\n我们可以在初始化期间通过 `figure()` 方法设置 `figsize` 参数的值，该参数以英寸为单位指定图形的宽度和高度。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10, 0.5)\nm = 1\nc = 2\ny = m*x + c\n\nplt.figure(figsize=(6,4))\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using figsize parameter.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20figsize%20parameter.png)\n\n`figsize` 参数的默认值为 `[6.4，4.8]`。\n\n## 设置 `rcParams` 来更改 `Matplotlib` 中图形的大小\n\n我们可以更改存储在 `matplotlib.rcParams` 字典中的默认 `figure.figsize` 值，以更改 Matplotlib 中的图形大小。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nplt.rcParams[\"figure.figsize\"] = (8, 6)\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using rc parameter.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20rc%20parameter.png)\n\n## `set_figheight()` 和 `set_figwidth()` 一起设置 Matplotlib 图形大小\n\n如果已经创建了图形，我们可以使用 `set_figheight()` 和 `set_figwidth()` 方法来确定图形的大小。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nfig = plt.figure()\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\nfig.set_figheight(6)\nfig.set_figwidth(8)\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_figheight and set_figwidth.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_figheight%20and%20set_figwidth.png)\n\n这里，`set_figheight()` 方法设置图形的高度，而 `set_figwidth()` 方法设置图形的宽度。\n\n## `set_size_inches()` 方法来更改 Matplotlib 图形大小\n\n创建图形后，此方法还可以设置图形大小。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nfig = plt.figure()\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\nfig.set_size_inches(5, 5)\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_size_inches.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_size_inches.png)\n\n在这里，传递给 `set_size_inches()` 方法的参数分别表示图形的宽度和高度（以英寸为单位）。\n\n## 在 Matplotlib 中更改图形格式\n\n要更改图形格式，我们可以使用 `savefig()` 方法更改图像文件的扩展名。我们可以将图保存为不同的格式，例如 png，jpg，svg，pdf 等。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nfig = plt.figure()\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\nfig.set_size_inches(5, 5)\n\nplt.savefig(\"Figure saved in jpg format.jpg\")\n```\n\n这会将图形保存为 jpg 格式。\n\n# Python编写函数检查数值型特征项异常状态\n\n## 引入包\n\n```python\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n#from matplotlib.font_manager import FontManager\n\n#fm = FontManager()\n#fonts = set(f.name for f in fm.ttflist)\nconfig = {\n    \"font.family\": 'serif',\n    \"font.serif\": ['Songti SC'],\n    \"font.size\": 15,\n    \"font.sans-serif\": [''],\n    \"figure.figsize\": (12,7),\n    \"mathtext.fontset\": 'stix',\n}\nplt.rcParams.update(config)\n```\n\n## 编写函数\n\n**此处这个data是个Dataframe**\n\n```python\ndef checkOut(column_name):\n    \n    ax1 = plt.subplot(221)\n    bp = ax1.boxplot(data[column_name])\n    ax1.set_title('删除异常值前')\n    lower_whisker = [item.get_ydata()[1] for item in bp['whiskers']][0]\n    upper_whisker = [item.get_ydata()[1] for item in bp['whiskers']][1]\n    print(\"上边缘：\", upper_whisker)\n    print(\"下边缘：\", lower_whisker)\n    print(\"非异常范围：\", [lower_whisker,upper_whisker])\n    \n    ##### 寻找异常值 #####\n    outlier = data[(data[column_name] > upper_whisker) | (data[column_name] < lower_whisker)][column_name]\n    ##### 删除异常值 ######\n    not_outlier = data[(data[column_name] <= upper_whisker) & (data[column_name] >= lower_whisker)][column_name]\n    ax2 = plt.subplot(222)\n    ##### 重新检查是否还有异常值 #####\n    ax2.boxplot(not_outlier)\n    ax2.set_title('删除异常值后')\n    \n    ax3 = plt.subplot(212)\n    ax3 = sns.distplot(not_outlier, bins=100, color='r')\n    \n    plt.savefig('{}异常值检测与处理'.format(column_name)) # 保存图片 注意一定要先运行这一行在做plt.show画布显示，否则画布会是空的\n    plt.show()\n```\n\n## 效果如下\n\n```python\ncheckOut('pax_fcny')\n```\n\n![pax_fcny异常值检测以及处理](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/pax_fcny%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86.png)","source":"_posts/Python绘图/matplotlib.md","raw":"---\ntitle: matplotlib\ndate: 2022-04-05 15:38:27\ntags:\n  - [matplotlib]\ncategories:\n  - [技术]\ndescription: Python绘图相关文档\n---\n\n# bar绘图并且加上数字\n\n```python\ndef plotBar(name, y_label, title, file_name):\n\tdata_group = data.groupby([name, 'emd_lable2']).size().unstack(level=1)\n\tx = np.arange(len(data_group.index))  # the label locations\n\twidth = 0.35  # the width of the bars\n\n\tfig, ax = plt.subplots()\n\trects1 = ax.bar(x - width/2, data_group[0], width, label='未付费')\n\trects2 = ax.bar(x + width/2, data_group[1], width, label='付费')\n\n\t# Add some text for labels, title and custom x-axis tick labels, etc.\n  # y_label正常情况下都是“人数”\n\tax.set_ylabel(y_label)\n\tax.set_title(\"不同{}付费情况\".format(title))\n\tax.set_xticks(x, data_group.index)\n\n\tax.bar_label(rects1, padding=3)\n\tax.bar_label(rects2, padding=3)\n\n\tfig.tight_layout()\n\n\t# 显示label\n\tplt.legend()\n\n\tplt.show()\n\tfig.savefig(file_name)\n```\n\n# 获取当前图片的画布并下载到本地\n\nAxesSubplot如何保存成图片\n\n```python\nfig = AxesSubplot.get_figure()\nfig.savefig(\"output.png\")\n```\n\n# 更改图片的大小以及格式\n\n## 比较方便的方法（开头统一处理）\n\n```python\nimport numpy as np\nimport pandas as pd\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n#from matplotlib.font_manager import FontManager\n\n#fm = FontManager()\n#fonts = set(f.name for f in fm.ttflist)\nconfig = {\n    \"font.family\": 'serif',\n    \"font.serif\": ['Songti SC'],\n    \"font.size\": 18,\n    \"font.sans-serif\": [''],\n    \"figure.figsize\": (16,9),\n    \"mathtext.fontset\": 'stix',\n}\nplt.rcParams.update(config)\n```\n\n## 方法\n\n1. 初始化期间在 `figure()` 方法中设置 `figsize`\n2. 设置 `rcParams` 来更改 Matplotlib 中图形的大小\n3. `set_figheight()` [和](https://www.delftstack.com/zh/howto/matplotlib/how-to-change-the-size-and-format-of-a-figure-in-matplotlib/#set_figheight-%E5%92%8C-set_figwidth-%E4%B8%80%E8%B5%B7%E8%AE%BE%E7%BD%AE-matplotlib-%E5%9B%BE%E5%BD%A2%E5%A4%A7%E5%B0%8F) `set_figwidth()` 一起设置 Matplotlib 图形大小\n4. `set_size_inches()` 方法来更改 Matplotlib 图形大小\n5. 在 Matplotlib 中更改图形格式\n\n我们可以使用 `set_figheight()` 和 `set_figwidth()` 和 `set_size_inches()` 方法来更改 Matplotlib 中的图形大小。我们也可以通过在 `figure()` 方法和 `rcParams` 中设置 `figsize` 来改变 Matplotlib 中的图形大小。同样，要更改图形格式，我们只需在 `savefig()` 方法中更改图像文件的扩展名。\n\n## 初始化期间在 `figure()` 方法中设置 `figsize`\n\n我们可以在初始化期间通过 `figure()` 方法设置 `figsize` 参数的值，该参数以英寸为单位指定图形的宽度和高度。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10, 0.5)\nm = 1\nc = 2\ny = m*x + c\n\nplt.figure(figsize=(6,4))\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using figsize parameter.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20figsize%20parameter.png)\n\n`figsize` 参数的默认值为 `[6.4，4.8]`。\n\n## 设置 `rcParams` 来更改 `Matplotlib` 中图形的大小\n\n我们可以更改存储在 `matplotlib.rcParams` 字典中的默认 `figure.figsize` 值，以更改 Matplotlib 中的图形大小。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nplt.rcParams[\"figure.figsize\"] = (8, 6)\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using rc parameter.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20rc%20parameter.png)\n\n## `set_figheight()` 和 `set_figwidth()` 一起设置 Matplotlib 图形大小\n\n如果已经创建了图形，我们可以使用 `set_figheight()` 和 `set_figwidth()` 方法来确定图形的大小。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nfig = plt.figure()\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\nfig.set_figheight(6)\nfig.set_figwidth(8)\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_figheight and set_figwidth.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_figheight%20and%20set_figwidth.png)\n\n这里，`set_figheight()` 方法设置图形的高度，而 `set_figwidth()` 方法设置图形的宽度。\n\n## `set_size_inches()` 方法来更改 Matplotlib 图形大小\n\n创建图形后，此方法还可以设置图形大小。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nfig = plt.figure()\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\nfig.set_size_inches(5, 5)\n\nplt.show()\n```\n\n输出：\n\n![https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_size_inches.png](https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_size_inches.png)\n\n在这里，传递给 `set_size_inches()` 方法的参数分别表示图形的宽度和高度（以英寸为单位）。\n\n## 在 Matplotlib 中更改图形格式\n\n要更改图形格式，我们可以使用 `savefig()` 方法更改图像文件的扩展名。我们可以将图保存为不同的格式，例如 png，jpg，svg，pdf 等。\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(0, 10,20)\nm = 1\nc = 2\ny = m*x + c\n\nfig = plt.figure()\nplt.plot(x, y)\nplt.title(\"y=mx+c\")\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\nfig.set_size_inches(5, 5)\n\nplt.savefig(\"Figure saved in jpg format.jpg\")\n```\n\n这会将图形保存为 jpg 格式。\n\n# Python编写函数检查数值型特征项异常状态\n\n## 引入包\n\n```python\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n#from matplotlib.font_manager import FontManager\n\n#fm = FontManager()\n#fonts = set(f.name for f in fm.ttflist)\nconfig = {\n    \"font.family\": 'serif',\n    \"font.serif\": ['Songti SC'],\n    \"font.size\": 15,\n    \"font.sans-serif\": [''],\n    \"figure.figsize\": (12,7),\n    \"mathtext.fontset\": 'stix',\n}\nplt.rcParams.update(config)\n```\n\n## 编写函数\n\n**此处这个data是个Dataframe**\n\n```python\ndef checkOut(column_name):\n    \n    ax1 = plt.subplot(221)\n    bp = ax1.boxplot(data[column_name])\n    ax1.set_title('删除异常值前')\n    lower_whisker = [item.get_ydata()[1] for item in bp['whiskers']][0]\n    upper_whisker = [item.get_ydata()[1] for item in bp['whiskers']][1]\n    print(\"上边缘：\", upper_whisker)\n    print(\"下边缘：\", lower_whisker)\n    print(\"非异常范围：\", [lower_whisker,upper_whisker])\n    \n    ##### 寻找异常值 #####\n    outlier = data[(data[column_name] > upper_whisker) | (data[column_name] < lower_whisker)][column_name]\n    ##### 删除异常值 ######\n    not_outlier = data[(data[column_name] <= upper_whisker) & (data[column_name] >= lower_whisker)][column_name]\n    ax2 = plt.subplot(222)\n    ##### 重新检查是否还有异常值 #####\n    ax2.boxplot(not_outlier)\n    ax2.set_title('删除异常值后')\n    \n    ax3 = plt.subplot(212)\n    ax3 = sns.distplot(not_outlier, bins=100, color='r')\n    \n    plt.savefig('{}异常值检测与处理'.format(column_name)) # 保存图片 注意一定要先运行这一行在做plt.show画布显示，否则画布会是空的\n    plt.show()\n```\n\n## 效果如下\n\n```python\ncheckOut('pax_fcny')\n```\n\n![pax_fcny异常值检测以及处理](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/pax_fcny%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86.png)","slug":"Python绘图/matplotlib","published":1,"updated":"2022-08-28T07:38:59.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1o000rscvmbvjs3zx9","content":"<h1 id=\"bar绘图并且加上数字\"><a href=\"#bar绘图并且加上数字\" class=\"headerlink\" title=\"bar绘图并且加上数字\"></a>bar绘图并且加上数字</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plotBar</span>(<span class=\"hljs-params\">name, y_label, title, file_name</span>):<br>\tdata_group = data.groupby([name, <span class=\"hljs-string\">&#x27;emd_lable2&#x27;</span>]).size().unstack(level=<span class=\"hljs-number\">1</span>)<br>\tx = np.arange(<span class=\"hljs-built_in\">len</span>(data_group.index))  <span class=\"hljs-comment\"># the label locations</span><br>\twidth = <span class=\"hljs-number\">0.35</span>  <span class=\"hljs-comment\"># the width of the bars</span><br><br>\tfig, ax = plt.subplots()<br>\trects1 = ax.bar(x - width/<span class=\"hljs-number\">2</span>, data_group[<span class=\"hljs-number\">0</span>], width, label=<span class=\"hljs-string\">&#x27;未付费&#x27;</span>)<br>\trects2 = ax.bar(x + width/<span class=\"hljs-number\">2</span>, data_group[<span class=\"hljs-number\">1</span>], width, label=<span class=\"hljs-string\">&#x27;付费&#x27;</span>)<br><br>\t<span class=\"hljs-comment\"># Add some text for labels, title and custom x-axis tick labels, etc.</span><br>  <span class=\"hljs-comment\"># y_label正常情况下都是“人数”</span><br>\tax.set_ylabel(y_label)<br>\tax.set_title(<span class=\"hljs-string\">&quot;不同&#123;&#125;付费情况&quot;</span>.<span class=\"hljs-built_in\">format</span>(title))<br>\tax.set_xticks(x, data_group.index)<br><br>\tax.bar_label(rects1, padding=<span class=\"hljs-number\">3</span>)<br>\tax.bar_label(rects2, padding=<span class=\"hljs-number\">3</span>)<br><br>\tfig.tight_layout()<br><br>\t<span class=\"hljs-comment\"># 显示label</span><br>\tplt.legend()<br><br>\tplt.show()<br>\tfig.savefig(file_name)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"获取当前图片的画布并下载到本地\"><a href=\"#获取当前图片的画布并下载到本地\" class=\"headerlink\" title=\"获取当前图片的画布并下载到本地\"></a>获取当前图片的画布并下载到本地</h1><p>AxesSubplot如何保存成图片</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fig = AxesSubplot.get_figure()<br>fig.savefig(<span class=\"hljs-string\">&quot;output.png&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"更改图片的大小以及格式\"><a href=\"#更改图片的大小以及格式\" class=\"headerlink\" title=\"更改图片的大小以及格式\"></a>更改图片的大小以及格式</h1><h2 id=\"比较方便的方法（开头统一处理）\"><a href=\"#比较方便的方法（开头统一处理）\" class=\"headerlink\" title=\"比较方便的方法（开头统一处理）\"></a>比较方便的方法（开头统一处理）</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><br><span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br>%matplotlib inline<br><span class=\"hljs-comment\">#from matplotlib.font_manager import FontManager</span><br><br><span class=\"hljs-comment\">#fm = FontManager()</span><br><span class=\"hljs-comment\">#fonts = set(f.name for f in fm.ttflist)</span><br>config = &#123;<br>    <span class=\"hljs-string\">&quot;font.family&quot;</span>: <span class=\"hljs-string\">&#x27;serif&#x27;</span>,<br>    <span class=\"hljs-string\">&quot;font.serif&quot;</span>: [<span class=\"hljs-string\">&#x27;Songti SC&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;font.size&quot;</span>: <span class=\"hljs-number\">18</span>,<br>    <span class=\"hljs-string\">&quot;font.sans-serif&quot;</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;figure.figsize&quot;</span>: (<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">9</span>),<br>    <span class=\"hljs-string\">&quot;mathtext.fontset&quot;</span>: <span class=\"hljs-string\">&#x27;stix&#x27;</span>,<br>&#125;<br>plt.rcParams.update(config)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ol>\n<li>初始化期间在 <code>figure()</code> 方法中设置 <code>figsize</code></li>\n<li>设置 <code>rcParams</code> 来更改 Matplotlib 中图形的大小</li>\n<li><code>set_figheight()</code> <a href=\"https://www.delftstack.com/zh/howto/matplotlib/how-to-change-the-size-and-format-of-a-figure-in-matplotlib/#set_figheight-%E5%92%8C-set_figwidth-%E4%B8%80%E8%B5%B7%E8%AE%BE%E7%BD%AE-matplotlib-%E5%9B%BE%E5%BD%A2%E5%A4%A7%E5%B0%8F\">和</a> <code>set_figwidth()</code> 一起设置 Matplotlib 图形大小</li>\n<li><code>set_size_inches()</code> 方法来更改 Matplotlib 图形大小</li>\n<li>在 Matplotlib 中更改图形格式</li>\n</ol>\n<p>我们可以使用 <code>set_figheight()</code> 和 <code>set_figwidth()</code> 和 <code>set_size_inches()</code> 方法来更改 Matplotlib 中的图形大小。我们也可以通过在 <code>figure()</code> 方法和 <code>rcParams</code> 中设置 <code>figsize</code> 来改变 Matplotlib 中的图形大小。同样，要更改图形格式，我们只需在 <code>savefig()</code> 方法中更改图像文件的扩展名。</p>\n<h2 id=\"初始化期间在-figure-方法中设置-figsize\"><a href=\"#初始化期间在-figure-方法中设置-figsize\" class=\"headerlink\" title=\"初始化期间在 figure() 方法中设置 figsize\"></a>初始化期间在 <code>figure()</code> 方法中设置 <code>figsize</code></h2><p>我们可以在初始化期间通过 <code>figure()</code> 方法设置 <code>figsize</code> 参数的值，该参数以英寸为单位指定图形的宽度和高度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0.5</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>plt.figure(figsize=(<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">4</span>))<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20figsize%20parameter.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using figsize parameter.png\"></p>\n<p><code>figsize</code> 参数的默认值为 <code>[6.4，4.8]</code>。</p>\n<h2 id=\"设置-rcParams-来更改-Matplotlib-中图形的大小\"><a href=\"#设置-rcParams-来更改-Matplotlib-中图形的大小\" class=\"headerlink\" title=\"设置 rcParams 来更改 Matplotlib 中图形的大小\"></a>设置 <code>rcParams</code> 来更改 <code>Matplotlib</code> 中图形的大小</h2><p>我们可以更改存储在 <code>matplotlib.rcParams</code> 字典中的默认 <code>figure.figsize</code> 值，以更改 Matplotlib 中的图形大小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>plt.rcParams[<span class=\"hljs-string\">&quot;figure.figsize&quot;</span>] = (<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>)<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20rc%20parameter.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using rc parameter.png\"></p>\n<h2 id=\"set-figheight-和-set-figwidth-一起设置-Matplotlib-图形大小\"><a href=\"#set-figheight-和-set-figwidth-一起设置-Matplotlib-图形大小\" class=\"headerlink\" title=\"set_figheight() 和 set_figwidth() 一起设置 Matplotlib 图形大小\"></a><code>set_figheight()</code> 和 <code>set_figwidth()</code> 一起设置 Matplotlib 图形大小</h2><p>如果已经创建了图形，我们可以使用 <code>set_figheight()</code> 和 <code>set_figwidth()</code> 方法来确定图形的大小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>fig = plt.figure()<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br>fig.set_figheight(<span class=\"hljs-number\">6</span>)<br>fig.set_figwidth(<span class=\"hljs-number\">8</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_figheight%20and%20set_figwidth.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_figheight and set_figwidth.png\"></p>\n<p>这里，<code>set_figheight()</code> 方法设置图形的高度，而 <code>set_figwidth()</code> 方法设置图形的宽度。</p>\n<h2 id=\"set-size-inches-方法来更改-Matplotlib-图形大小\"><a href=\"#set-size-inches-方法来更改-Matplotlib-图形大小\" class=\"headerlink\" title=\"set_size_inches() 方法来更改 Matplotlib 图形大小\"></a><code>set_size_inches()</code> 方法来更改 Matplotlib 图形大小</h2><p>创建图形后，此方法还可以设置图形大小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>fig = plt.figure()<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br>fig.set_size_inches(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_size_inches.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_size_inches.png\"></p>\n<p>在这里，传递给 <code>set_size_inches()</code> 方法的参数分别表示图形的宽度和高度（以英寸为单位）。</p>\n<h2 id=\"在-Matplotlib-中更改图形格式\"><a href=\"#在-Matplotlib-中更改图形格式\" class=\"headerlink\" title=\"在 Matplotlib 中更改图形格式\"></a>在 Matplotlib 中更改图形格式</h2><p>要更改图形格式，我们可以使用 <code>savefig()</code> 方法更改图像文件的扩展名。我们可以将图保存为不同的格式，例如 png，jpg，svg，pdf 等。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>fig = plt.figure()<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br>fig.set_size_inches(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>)<br><br>plt.savefig(<span class=\"hljs-string\">&quot;Figure saved in jpg format.jpg&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这会将图形保存为 jpg 格式。</p>\n<h1 id=\"Python编写函数检查数值型特征项异常状态\"><a href=\"#Python编写函数检查数值型特征项异常状态\" class=\"headerlink\" title=\"Python编写函数检查数值型特征项异常状态\"></a>Python编写函数检查数值型特征项异常状态</h1><h2 id=\"引入包\"><a href=\"#引入包\" class=\"headerlink\" title=\"引入包\"></a>引入包</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br>%matplotlib inline<br><span class=\"hljs-comment\">#from matplotlib.font_manager import FontManager</span><br><br><span class=\"hljs-comment\">#fm = FontManager()</span><br><span class=\"hljs-comment\">#fonts = set(f.name for f in fm.ttflist)</span><br>config = &#123;<br>    <span class=\"hljs-string\">&quot;font.family&quot;</span>: <span class=\"hljs-string\">&#x27;serif&#x27;</span>,<br>    <span class=\"hljs-string\">&quot;font.serif&quot;</span>: [<span class=\"hljs-string\">&#x27;Songti SC&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;font.size&quot;</span>: <span class=\"hljs-number\">15</span>,<br>    <span class=\"hljs-string\">&quot;font.sans-serif&quot;</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;figure.figsize&quot;</span>: (<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">7</span>),<br>    <span class=\"hljs-string\">&quot;mathtext.fontset&quot;</span>: <span class=\"hljs-string\">&#x27;stix&#x27;</span>,<br>&#125;<br>plt.rcParams.update(config)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写函数\"><a href=\"#编写函数\" class=\"headerlink\" title=\"编写函数\"></a>编写函数</h2><p><strong>此处这个data是个Dataframe</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">checkOut</span>(<span class=\"hljs-params\">column_name</span>):<br>    <br>    ax1 = plt.subplot(<span class=\"hljs-number\">221</span>)<br>    bp = ax1.boxplot(data[column_name])<br>    ax1.set_title(<span class=\"hljs-string\">&#x27;删除异常值前&#x27;</span>)<br>    lower_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">0</span>]<br>    upper_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;上边缘：&quot;</span>, upper_whisker)<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;下边缘：&quot;</span>, lower_whisker)<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;非异常范围：&quot;</span>, [lower_whisker,upper_whisker])<br>    <br>    <span class=\"hljs-comment\">##### 寻找异常值 #####</span><br>    outlier = data[(data[column_name] &gt; upper_whisker) | (data[column_name] &lt; lower_whisker)][column_name]<br>    <span class=\"hljs-comment\">##### 删除异常值 ######</span><br>    not_outlier = data[(data[column_name] &lt;= upper_whisker) &amp; (data[column_name] &gt;= lower_whisker)][column_name]<br>    ax2 = plt.subplot(<span class=\"hljs-number\">222</span>)<br>    <span class=\"hljs-comment\">##### 重新检查是否还有异常值 #####</span><br>    ax2.boxplot(not_outlier)<br>    ax2.set_title(<span class=\"hljs-string\">&#x27;删除异常值后&#x27;</span>)<br>    <br>    ax3 = plt.subplot(<span class=\"hljs-number\">212</span>)<br>    ax3 = sns.distplot(not_outlier, bins=<span class=\"hljs-number\">100</span>, color=<span class=\"hljs-string\">&#x27;r&#x27;</span>)<br>    <br>    plt.savefig(<span class=\"hljs-string\">&#x27;&#123;&#125;异常值检测与处理&#x27;</span>.<span class=\"hljs-built_in\">format</span>(column_name)) <span class=\"hljs-comment\"># 保存图片 注意一定要先运行这一行在做plt.show画布显示，否则画布会是空的</span><br>    plt.show()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"效果如下\"><a href=\"#效果如下\" class=\"headerlink\" title=\"效果如下\"></a>效果如下</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">checkOut(<span class=\"hljs-string\">&#x27;pax_fcny&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/pax_fcny%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86.png\" alt=\"pax_fcny异常值检测以及处理\"></p>\n","site":{"data":{}},"wordcount":5072,"excerpt":"","more":"<h1 id=\"bar绘图并且加上数字\"><a href=\"#bar绘图并且加上数字\" class=\"headerlink\" title=\"bar绘图并且加上数字\"></a>bar绘图并且加上数字</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plotBar</span>(<span class=\"hljs-params\">name, y_label, title, file_name</span>):<br>\tdata_group = data.groupby([name, <span class=\"hljs-string\">&#x27;emd_lable2&#x27;</span>]).size().unstack(level=<span class=\"hljs-number\">1</span>)<br>\tx = np.arange(<span class=\"hljs-built_in\">len</span>(data_group.index))  <span class=\"hljs-comment\"># the label locations</span><br>\twidth = <span class=\"hljs-number\">0.35</span>  <span class=\"hljs-comment\"># the width of the bars</span><br><br>\tfig, ax = plt.subplots()<br>\trects1 = ax.bar(x - width/<span class=\"hljs-number\">2</span>, data_group[<span class=\"hljs-number\">0</span>], width, label=<span class=\"hljs-string\">&#x27;未付费&#x27;</span>)<br>\trects2 = ax.bar(x + width/<span class=\"hljs-number\">2</span>, data_group[<span class=\"hljs-number\">1</span>], width, label=<span class=\"hljs-string\">&#x27;付费&#x27;</span>)<br><br>\t<span class=\"hljs-comment\"># Add some text for labels, title and custom x-axis tick labels, etc.</span><br>  <span class=\"hljs-comment\"># y_label正常情况下都是“人数”</span><br>\tax.set_ylabel(y_label)<br>\tax.set_title(<span class=\"hljs-string\">&quot;不同&#123;&#125;付费情况&quot;</span>.<span class=\"hljs-built_in\">format</span>(title))<br>\tax.set_xticks(x, data_group.index)<br><br>\tax.bar_label(rects1, padding=<span class=\"hljs-number\">3</span>)<br>\tax.bar_label(rects2, padding=<span class=\"hljs-number\">3</span>)<br><br>\tfig.tight_layout()<br><br>\t<span class=\"hljs-comment\"># 显示label</span><br>\tplt.legend()<br><br>\tplt.show()<br>\tfig.savefig(file_name)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"获取当前图片的画布并下载到本地\"><a href=\"#获取当前图片的画布并下载到本地\" class=\"headerlink\" title=\"获取当前图片的画布并下载到本地\"></a>获取当前图片的画布并下载到本地</h1><p>AxesSubplot如何保存成图片</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fig = AxesSubplot.get_figure()<br>fig.savefig(<span class=\"hljs-string\">&quot;output.png&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"更改图片的大小以及格式\"><a href=\"#更改图片的大小以及格式\" class=\"headerlink\" title=\"更改图片的大小以及格式\"></a>更改图片的大小以及格式</h1><h2 id=\"比较方便的方法（开头统一处理）\"><a href=\"#比较方便的方法（开头统一处理）\" class=\"headerlink\" title=\"比较方便的方法（开头统一处理）\"></a>比较方便的方法（开头统一处理）</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><br><span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br>%matplotlib inline<br><span class=\"hljs-comment\">#from matplotlib.font_manager import FontManager</span><br><br><span class=\"hljs-comment\">#fm = FontManager()</span><br><span class=\"hljs-comment\">#fonts = set(f.name for f in fm.ttflist)</span><br>config = &#123;<br>    <span class=\"hljs-string\">&quot;font.family&quot;</span>: <span class=\"hljs-string\">&#x27;serif&#x27;</span>,<br>    <span class=\"hljs-string\">&quot;font.serif&quot;</span>: [<span class=\"hljs-string\">&#x27;Songti SC&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;font.size&quot;</span>: <span class=\"hljs-number\">18</span>,<br>    <span class=\"hljs-string\">&quot;font.sans-serif&quot;</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;figure.figsize&quot;</span>: (<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">9</span>),<br>    <span class=\"hljs-string\">&quot;mathtext.fontset&quot;</span>: <span class=\"hljs-string\">&#x27;stix&#x27;</span>,<br>&#125;<br>plt.rcParams.update(config)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ol>\n<li>初始化期间在 <code>figure()</code> 方法中设置 <code>figsize</code></li>\n<li>设置 <code>rcParams</code> 来更改 Matplotlib 中图形的大小</li>\n<li><code>set_figheight()</code> <a href=\"https://www.delftstack.com/zh/howto/matplotlib/how-to-change-the-size-and-format-of-a-figure-in-matplotlib/#set_figheight-%E5%92%8C-set_figwidth-%E4%B8%80%E8%B5%B7%E8%AE%BE%E7%BD%AE-matplotlib-%E5%9B%BE%E5%BD%A2%E5%A4%A7%E5%B0%8F\">和</a> <code>set_figwidth()</code> 一起设置 Matplotlib 图形大小</li>\n<li><code>set_size_inches()</code> 方法来更改 Matplotlib 图形大小</li>\n<li>在 Matplotlib 中更改图形格式</li>\n</ol>\n<p>我们可以使用 <code>set_figheight()</code> 和 <code>set_figwidth()</code> 和 <code>set_size_inches()</code> 方法来更改 Matplotlib 中的图形大小。我们也可以通过在 <code>figure()</code> 方法和 <code>rcParams</code> 中设置 <code>figsize</code> 来改变 Matplotlib 中的图形大小。同样，要更改图形格式，我们只需在 <code>savefig()</code> 方法中更改图像文件的扩展名。</p>\n<h2 id=\"初始化期间在-figure-方法中设置-figsize\"><a href=\"#初始化期间在-figure-方法中设置-figsize\" class=\"headerlink\" title=\"初始化期间在 figure() 方法中设置 figsize\"></a>初始化期间在 <code>figure()</code> 方法中设置 <code>figsize</code></h2><p>我们可以在初始化期间通过 <code>figure()</code> 方法设置 <code>figsize</code> 参数的值，该参数以英寸为单位指定图形的宽度和高度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0.5</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>plt.figure(figsize=(<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">4</span>))<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20figsize%20parameter.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using figsize parameter.png\"></p>\n<p><code>figsize</code> 参数的默认值为 <code>[6.4，4.8]</code>。</p>\n<h2 id=\"设置-rcParams-来更改-Matplotlib-中图形的大小\"><a href=\"#设置-rcParams-来更改-Matplotlib-中图形的大小\" class=\"headerlink\" title=\"设置 rcParams 来更改 Matplotlib 中图形的大小\"></a>设置 <code>rcParams</code> 来更改 <code>Matplotlib</code> 中图形的大小</h2><p>我们可以更改存储在 <code>matplotlib.rcParams</code> 字典中的默认 <code>figure.figsize</code> 值，以更改 Matplotlib 中的图形大小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>plt.rcParams[<span class=\"hljs-string\">&quot;figure.figsize&quot;</span>] = (<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>)<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20rc%20parameter.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using rc parameter.png\"></p>\n<h2 id=\"set-figheight-和-set-figwidth-一起设置-Matplotlib-图形大小\"><a href=\"#set-figheight-和-set-figwidth-一起设置-Matplotlib-图形大小\" class=\"headerlink\" title=\"set_figheight() 和 set_figwidth() 一起设置 Matplotlib 图形大小\"></a><code>set_figheight()</code> 和 <code>set_figwidth()</code> 一起设置 Matplotlib 图形大小</h2><p>如果已经创建了图形，我们可以使用 <code>set_figheight()</code> 和 <code>set_figwidth()</code> 方法来确定图形的大小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>fig = plt.figure()<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br>fig.set_figheight(<span class=\"hljs-number\">6</span>)<br>fig.set_figwidth(<span class=\"hljs-number\">8</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_figheight%20and%20set_figwidth.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_figheight and set_figwidth.png\"></p>\n<p>这里，<code>set_figheight()</code> 方法设置图形的高度，而 <code>set_figwidth()</code> 方法设置图形的宽度。</p>\n<h2 id=\"set-size-inches-方法来更改-Matplotlib-图形大小\"><a href=\"#set-size-inches-方法来更改-Matplotlib-图形大小\" class=\"headerlink\" title=\"set_size_inches() 方法来更改 Matplotlib 图形大小\"></a><code>set_size_inches()</code> 方法来更改 Matplotlib 图形大小</h2><p>创建图形后，此方法还可以设置图形大小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>fig = plt.figure()<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br>fig.set_size_inches(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://www.delftstack.com/img/Matplotlib/set%20figsize%20using%20set%20figsize%20using%20set_size_inches.png\" alt=\"https://www.delftstack.com/img/Matplotlib/set figsize using set figsize using set_size_inches.png\"></p>\n<p>在这里，传递给 <code>set_size_inches()</code> 方法的参数分别表示图形的宽度和高度（以英寸为单位）。</p>\n<h2 id=\"在-Matplotlib-中更改图形格式\"><a href=\"#在-Matplotlib-中更改图形格式\" class=\"headerlink\" title=\"在 Matplotlib 中更改图形格式\"></a>在 Matplotlib 中更改图形格式</h2><p>要更改图形格式，我们可以使用 <code>savefig()</code> 方法更改图像文件的扩展名。我们可以将图保存为不同的格式，例如 png，jpg，svg，pdf 等。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><br>x = np.linspace(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>)<br>m = <span class=\"hljs-number\">1</span><br>c = <span class=\"hljs-number\">2</span><br>y = m*x + c<br><br>fig = plt.figure()<br>plt.plot(x, y)<br>plt.title(<span class=\"hljs-string\">&quot;y=mx+c&quot;</span>)<br>plt.xlabel(<span class=\"hljs-string\">&#x27;x-axis&#x27;</span>)<br>plt.ylabel(<span class=\"hljs-string\">&#x27;y-axis&#x27;</span>)<br>fig.set_size_inches(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>)<br><br>plt.savefig(<span class=\"hljs-string\">&quot;Figure saved in jpg format.jpg&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>这会将图形保存为 jpg 格式。</p>\n<h1 id=\"Python编写函数检查数值型特征项异常状态\"><a href=\"#Python编写函数检查数值型特征项异常状态\" class=\"headerlink\" title=\"Python编写函数检查数值型特征项异常状态\"></a>Python编写函数检查数值型特征项异常状态</h1><h2 id=\"引入包\"><a href=\"#引入包\" class=\"headerlink\" title=\"引入包\"></a>引入包</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br>%matplotlib inline<br><span class=\"hljs-comment\">#from matplotlib.font_manager import FontManager</span><br><br><span class=\"hljs-comment\">#fm = FontManager()</span><br><span class=\"hljs-comment\">#fonts = set(f.name for f in fm.ttflist)</span><br>config = &#123;<br>    <span class=\"hljs-string\">&quot;font.family&quot;</span>: <span class=\"hljs-string\">&#x27;serif&#x27;</span>,<br>    <span class=\"hljs-string\">&quot;font.serif&quot;</span>: [<span class=\"hljs-string\">&#x27;Songti SC&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;font.size&quot;</span>: <span class=\"hljs-number\">15</span>,<br>    <span class=\"hljs-string\">&quot;font.sans-serif&quot;</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],<br>    <span class=\"hljs-string\">&quot;figure.figsize&quot;</span>: (<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">7</span>),<br>    <span class=\"hljs-string\">&quot;mathtext.fontset&quot;</span>: <span class=\"hljs-string\">&#x27;stix&#x27;</span>,<br>&#125;<br>plt.rcParams.update(config)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写函数\"><a href=\"#编写函数\" class=\"headerlink\" title=\"编写函数\"></a>编写函数</h2><p><strong>此处这个data是个Dataframe</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">checkOut</span>(<span class=\"hljs-params\">column_name</span>):<br>    <br>    ax1 = plt.subplot(<span class=\"hljs-number\">221</span>)<br>    bp = ax1.boxplot(data[column_name])<br>    ax1.set_title(<span class=\"hljs-string\">&#x27;删除异常值前&#x27;</span>)<br>    lower_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">0</span>]<br>    upper_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;上边缘：&quot;</span>, upper_whisker)<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;下边缘：&quot;</span>, lower_whisker)<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;非异常范围：&quot;</span>, [lower_whisker,upper_whisker])<br>    <br>    <span class=\"hljs-comment\">##### 寻找异常值 #####</span><br>    outlier = data[(data[column_name] &gt; upper_whisker) | (data[column_name] &lt; lower_whisker)][column_name]<br>    <span class=\"hljs-comment\">##### 删除异常值 ######</span><br>    not_outlier = data[(data[column_name] &lt;= upper_whisker) &amp; (data[column_name] &gt;= lower_whisker)][column_name]<br>    ax2 = plt.subplot(<span class=\"hljs-number\">222</span>)<br>    <span class=\"hljs-comment\">##### 重新检查是否还有异常值 #####</span><br>    ax2.boxplot(not_outlier)<br>    ax2.set_title(<span class=\"hljs-string\">&#x27;删除异常值后&#x27;</span>)<br>    <br>    ax3 = plt.subplot(<span class=\"hljs-number\">212</span>)<br>    ax3 = sns.distplot(not_outlier, bins=<span class=\"hljs-number\">100</span>, color=<span class=\"hljs-string\">&#x27;r&#x27;</span>)<br>    <br>    plt.savefig(<span class=\"hljs-string\">&#x27;&#123;&#125;异常值检测与处理&#x27;</span>.<span class=\"hljs-built_in\">format</span>(column_name)) <span class=\"hljs-comment\"># 保存图片 注意一定要先运行这一行在做plt.show画布显示，否则画布会是空的</span><br>    plt.show()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"效果如下\"><a href=\"#效果如下\" class=\"headerlink\" title=\"效果如下\"></a>效果如下</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">checkOut(<span class=\"hljs-string\">&#x27;pax_fcny&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/pax_fcny%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86.png\" alt=\"pax_fcny异常值检测以及处理\"></p>\n"},{"title":"VIM-中文翻译","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","hide":true,"_content":"\n# Learn-Vim(the Smart Way) 中文翻译\n\n[英文版本仓库地址](https://github.com/iggredible/Learn-Vim)\n\n本中文版基于2021-10-15英文版进行翻译和更新，基础英文版本保存在 `./The_original_En_version` 下，如果后续英文版有更新，可以将最新版本与该版本比对后，再进行差分翻译。\n\n## 这是什么?\n\n_学习 Vim（智能方式）_ 是一本学习Vim中优秀部分知识的书。\n\n有很多种方法可以去学习Vim：`vimtutor`就是一个很棒的教程，另外还有`help`拥有您所想的所有参考信息。但是在日常使用中，对于绝大部分用户的需求而言，`vimtutor`讲得太浅不能满足需要，而`:help`所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。\n\n本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。\n\n## 目录（进行中）\n\n### 序言\n\n- [Ch 0 - 请先阅读](./ch00_read_this_first.md)\n\n### 第一部分：聪明地学习Vim\n\n- [Ch 1 - 起步](./ch01_starting_vim.md)\n- [Ch 2 - 缓冲区，窗口和选项卡](./ch02_buffers_windows_tabs.md)\n- [Ch 3 - 打开和搜索文件](./ch03_searching_files.md)\n- [Ch 4 - Vim 语法](./ch04_vim_grammar.md)\n- [Ch 5 - 移动文件](./ch05_moving_in_file.md)\n- [Ch 6 - 插入模式](./ch06_insert_mode.md)\n- [Ch 7 - 点命令](./ch07_the_dot_command.md)\n- [Ch 8 - 寄存器](./ch08_registers.md)\n- [Ch 9 - 宏](./ch09_macros.md)\n- [Ch 10 - 撤消](./ch10_undo.md)\n- [Ch 11 - 可视模式](./ch11_visual_mode.md)\n- [Ch 12 - 搜索和替换](./ch12_search_and_substitute.md)\n- [Ch 13 - 全局命令](./ch13_the_global_command.md)\n- [Ch 14 - 外部命令](./ch14_external_commands.md)\n- [Ch 15 - 命令行模式](./ch15_command-line_mode.md)\n- [Ch 16 - 标签](./ch16_tags.md)\n- [Ch 17 - 折叠](./ch17_fold.md)\n- [Ch 18 - Git](./ch18_git.md)\n- [Ch 19 - 编译](./ch19_compile.md)\n- [Ch 20 - 视图、会话和 Viminfo](./ch20_views_sessions_viminfo.md)\n- [Ch 21 - 多文件操作](./ch21_multiple_file_operations.md)\n\n### 第二部分：聪明地定制Vim\n\n- [Ch 22 - Vimrc](./ch22_vimrc.md)\n- [Ch 23 - Vim软件包](./ch23_vim_packages.md)\n- [Ch 24 - Vim Runtime](./ch24_vim_runtime.md)\n\n# 许可和版权\n\n这些材料全部归 ©2020 Igor Irianto 所有。\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png\" /></a><br />\n\n这项作品已获得<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><<知识共享署名-非商业性-相同方式共享 4.0 版>></a>的许可。\n","source":"_posts/Vim/README.md","raw":"---\ntitle: VIM-中文翻译\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\ncategories:\n  - [编辑器]\n  - [技术]\ndescription: VIM相关文档\nhide: true\n---\n\n# Learn-Vim(the Smart Way) 中文翻译\n\n[英文版本仓库地址](https://github.com/iggredible/Learn-Vim)\n\n本中文版基于2021-10-15英文版进行翻译和更新，基础英文版本保存在 `./The_original_En_version` 下，如果后续英文版有更新，可以将最新版本与该版本比对后，再进行差分翻译。\n\n## 这是什么?\n\n_学习 Vim（智能方式）_ 是一本学习Vim中优秀部分知识的书。\n\n有很多种方法可以去学习Vim：`vimtutor`就是一个很棒的教程，另外还有`help`拥有您所想的所有参考信息。但是在日常使用中，对于绝大部分用户的需求而言，`vimtutor`讲得太浅不能满足需要，而`:help`所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。\n\n本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。\n\n## 目录（进行中）\n\n### 序言\n\n- [Ch 0 - 请先阅读](./ch00_read_this_first.md)\n\n### 第一部分：聪明地学习Vim\n\n- [Ch 1 - 起步](./ch01_starting_vim.md)\n- [Ch 2 - 缓冲区，窗口和选项卡](./ch02_buffers_windows_tabs.md)\n- [Ch 3 - 打开和搜索文件](./ch03_searching_files.md)\n- [Ch 4 - Vim 语法](./ch04_vim_grammar.md)\n- [Ch 5 - 移动文件](./ch05_moving_in_file.md)\n- [Ch 6 - 插入模式](./ch06_insert_mode.md)\n- [Ch 7 - 点命令](./ch07_the_dot_command.md)\n- [Ch 8 - 寄存器](./ch08_registers.md)\n- [Ch 9 - 宏](./ch09_macros.md)\n- [Ch 10 - 撤消](./ch10_undo.md)\n- [Ch 11 - 可视模式](./ch11_visual_mode.md)\n- [Ch 12 - 搜索和替换](./ch12_search_and_substitute.md)\n- [Ch 13 - 全局命令](./ch13_the_global_command.md)\n- [Ch 14 - 外部命令](./ch14_external_commands.md)\n- [Ch 15 - 命令行模式](./ch15_command-line_mode.md)\n- [Ch 16 - 标签](./ch16_tags.md)\n- [Ch 17 - 折叠](./ch17_fold.md)\n- [Ch 18 - Git](./ch18_git.md)\n- [Ch 19 - 编译](./ch19_compile.md)\n- [Ch 20 - 视图、会话和 Viminfo](./ch20_views_sessions_viminfo.md)\n- [Ch 21 - 多文件操作](./ch21_multiple_file_operations.md)\n\n### 第二部分：聪明地定制Vim\n\n- [Ch 22 - Vimrc](./ch22_vimrc.md)\n- [Ch 23 - Vim软件包](./ch23_vim_packages.md)\n- [Ch 24 - Vim Runtime](./ch24_vim_runtime.md)\n\n# 许可和版权\n\n这些材料全部归 ©2020 Igor Irianto 所有。\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png\" /></a><br />\n\n这项作品已获得<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><<知识共享署名-非商业性-相同方式共享 4.0 版>></a>的许可。\n","slug":"Vim/README","published":1,"updated":"2022-08-28T07:38:59.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1p000uscvm66fs3g38","content":"<h1 id=\"Learn-Vim-the-Smart-Way-中文翻译\"><a href=\"#Learn-Vim-the-Smart-Way-中文翻译\" class=\"headerlink\" title=\"Learn-Vim(the Smart Way) 中文翻译\"></a>Learn-Vim(the Smart Way) 中文翻译</h1><p><a href=\"https://github.com/iggredible/Learn-Vim\">英文版本仓库地址</a></p>\n<p>本中文版基于2021-10-15英文版进行翻译和更新，基础英文版本保存在 <code>./The_original_En_version</code> 下，如果后续英文版有更新，可以将最新版本与该版本比对后，再进行差分翻译。</p>\n<h2 id=\"这是什么\"><a href=\"#这是什么\" class=\"headerlink\" title=\"这是什么?\"></a>这是什么?</h2><p><em>学习 Vim（智能方式）</em> 是一本学习Vim中优秀部分知识的书。</p>\n<p>有很多种方法可以去学习Vim：<code>vimtutor</code>就是一个很棒的教程，另外还有<code>help</code>拥有您所想的所有参考信息。但是在日常使用中，对于绝大部分用户的需求而言，<code>vimtutor</code>讲得太浅不能满足需要，而<code>:help</code>所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。</p>\n<p>本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。</p>\n<h2 id=\"目录（进行中）\"><a href=\"#目录（进行中）\" class=\"headerlink\" title=\"目录（进行中）\"></a>目录（进行中）</h2><h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><ul>\n<li><a href=\"./ch00_read_this_first.md\">Ch 0 - 请先阅读</a></li>\n</ul>\n<h3 id=\"第一部分：聪明地学习Vim\"><a href=\"#第一部分：聪明地学习Vim\" class=\"headerlink\" title=\"第一部分：聪明地学习Vim\"></a>第一部分：聪明地学习Vim</h3><ul>\n<li><a href=\"./ch01_starting_vim.md\">Ch 1 - 起步</a></li>\n<li><a href=\"./ch02_buffers_windows_tabs.md\">Ch 2 - 缓冲区，窗口和选项卡</a></li>\n<li><a href=\"./ch03_searching_files.md\">Ch 3 - 打开和搜索文件</a></li>\n<li><a href=\"./ch04_vim_grammar.md\">Ch 4 - Vim 语法</a></li>\n<li><a href=\"./ch05_moving_in_file.md\">Ch 5 - 移动文件</a></li>\n<li><a href=\"./ch06_insert_mode.md\">Ch 6 - 插入模式</a></li>\n<li><a href=\"./ch07_the_dot_command.md\">Ch 7 - 点命令</a></li>\n<li><a href=\"./ch08_registers.md\">Ch 8 - 寄存器</a></li>\n<li><a href=\"./ch09_macros.md\">Ch 9 - 宏</a></li>\n<li><a href=\"./ch10_undo.md\">Ch 10 - 撤消</a></li>\n<li><a href=\"./ch11_visual_mode.md\">Ch 11 - 可视模式</a></li>\n<li><a href=\"./ch12_search_and_substitute.md\">Ch 12 - 搜索和替换</a></li>\n<li><a href=\"./ch13_the_global_command.md\">Ch 13 - 全局命令</a></li>\n<li><a href=\"./ch14_external_commands.md\">Ch 14 - 外部命令</a></li>\n<li><a href=\"./ch15_command-line_mode.md\">Ch 15 - 命令行模式</a></li>\n<li><a href=\"./ch16_tags.md\">Ch 16 - 标签</a></li>\n<li><a href=\"./ch17_fold.md\">Ch 17 - 折叠</a></li>\n<li><a href=\"./ch18_git.md\">Ch 18 - Git</a></li>\n<li><a href=\"./ch19_compile.md\">Ch 19 - 编译</a></li>\n<li><a href=\"./ch20_views_sessions_viminfo.md\">Ch 20 - 视图、会话和 Viminfo</a></li>\n<li><a href=\"./ch21_multiple_file_operations.md\">Ch 21 - 多文件操作</a></li>\n</ul>\n<h3 id=\"第二部分：聪明地定制Vim\"><a href=\"#第二部分：聪明地定制Vim\" class=\"headerlink\" title=\"第二部分：聪明地定制Vim\"></a>第二部分：聪明地定制Vim</h3><ul>\n<li><a href=\"./ch22_vimrc.md\">Ch 22 - Vimrc</a></li>\n<li><a href=\"./ch23_vim_packages.md\">Ch 23 - Vim软件包</a></li>\n<li><a href=\"./ch24_vim_runtime.md\">Ch 24 - Vim Runtime</a></li>\n</ul>\n<h1 id=\"许可和版权\"><a href=\"#许可和版权\" class=\"headerlink\" title=\"许可和版权\"></a>许可和版权</h1><p>这些材料全部归 ©2020 Igor Irianto 所有。</p>\n<p><a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png\" /></a><br /></p>\n<p>这项作品已获得<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">&lt;&lt;知识共享署名-非商业性-相同方式共享 4.0 版&gt;&gt;</a>的许可。</p>\n","site":{"data":{}},"wordcount":770,"excerpt":"","more":"<h1 id=\"Learn-Vim-the-Smart-Way-中文翻译\"><a href=\"#Learn-Vim-the-Smart-Way-中文翻译\" class=\"headerlink\" title=\"Learn-Vim(the Smart Way) 中文翻译\"></a>Learn-Vim(the Smart Way) 中文翻译</h1><p><a href=\"https://github.com/iggredible/Learn-Vim\">英文版本仓库地址</a></p>\n<p>本中文版基于2021-10-15英文版进行翻译和更新，基础英文版本保存在 <code>./The_original_En_version</code> 下，如果后续英文版有更新，可以将最新版本与该版本比对后，再进行差分翻译。</p>\n<h2 id=\"这是什么\"><a href=\"#这是什么\" class=\"headerlink\" title=\"这是什么?\"></a>这是什么?</h2><p><em>学习 Vim（智能方式）</em> 是一本学习Vim中优秀部分知识的书。</p>\n<p>有很多种方法可以去学习Vim：<code>vimtutor</code>就是一个很棒的教程，另外还有<code>help</code>拥有您所想的所有参考信息。但是在日常使用中，对于绝大部分用户的需求而言，<code>vimtutor</code>讲得太浅不能满足需要，而<code>:help</code>所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。</p>\n<p>本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。</p>\n<h2 id=\"目录（进行中）\"><a href=\"#目录（进行中）\" class=\"headerlink\" title=\"目录（进行中）\"></a>目录（进行中）</h2><h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><ul>\n<li><a href=\"./ch00_read_this_first.md\">Ch 0 - 请先阅读</a></li>\n</ul>\n<h3 id=\"第一部分：聪明地学习Vim\"><a href=\"#第一部分：聪明地学习Vim\" class=\"headerlink\" title=\"第一部分：聪明地学习Vim\"></a>第一部分：聪明地学习Vim</h3><ul>\n<li><a href=\"./ch01_starting_vim.md\">Ch 1 - 起步</a></li>\n<li><a href=\"./ch02_buffers_windows_tabs.md\">Ch 2 - 缓冲区，窗口和选项卡</a></li>\n<li><a href=\"./ch03_searching_files.md\">Ch 3 - 打开和搜索文件</a></li>\n<li><a href=\"./ch04_vim_grammar.md\">Ch 4 - Vim 语法</a></li>\n<li><a href=\"./ch05_moving_in_file.md\">Ch 5 - 移动文件</a></li>\n<li><a href=\"./ch06_insert_mode.md\">Ch 6 - 插入模式</a></li>\n<li><a href=\"./ch07_the_dot_command.md\">Ch 7 - 点命令</a></li>\n<li><a href=\"./ch08_registers.md\">Ch 8 - 寄存器</a></li>\n<li><a href=\"./ch09_macros.md\">Ch 9 - 宏</a></li>\n<li><a href=\"./ch10_undo.md\">Ch 10 - 撤消</a></li>\n<li><a href=\"./ch11_visual_mode.md\">Ch 11 - 可视模式</a></li>\n<li><a href=\"./ch12_search_and_substitute.md\">Ch 12 - 搜索和替换</a></li>\n<li><a href=\"./ch13_the_global_command.md\">Ch 13 - 全局命令</a></li>\n<li><a href=\"./ch14_external_commands.md\">Ch 14 - 外部命令</a></li>\n<li><a href=\"./ch15_command-line_mode.md\">Ch 15 - 命令行模式</a></li>\n<li><a href=\"./ch16_tags.md\">Ch 16 - 标签</a></li>\n<li><a href=\"./ch17_fold.md\">Ch 17 - 折叠</a></li>\n<li><a href=\"./ch18_git.md\">Ch 18 - Git</a></li>\n<li><a href=\"./ch19_compile.md\">Ch 19 - 编译</a></li>\n<li><a href=\"./ch20_views_sessions_viminfo.md\">Ch 20 - 视图、会话和 Viminfo</a></li>\n<li><a href=\"./ch21_multiple_file_operations.md\">Ch 21 - 多文件操作</a></li>\n</ul>\n<h3 id=\"第二部分：聪明地定制Vim\"><a href=\"#第二部分：聪明地定制Vim\" class=\"headerlink\" title=\"第二部分：聪明地定制Vim\"></a>第二部分：聪明地定制Vim</h3><ul>\n<li><a href=\"./ch22_vimrc.md\">Ch 22 - Vimrc</a></li>\n<li><a href=\"./ch23_vim_packages.md\">Ch 23 - Vim软件包</a></li>\n<li><a href=\"./ch24_vim_runtime.md\">Ch 24 - Vim Runtime</a></li>\n</ul>\n<h1 id=\"许可和版权\"><a href=\"#许可和版权\" class=\"headerlink\" title=\"许可和版权\"></a>许可和版权</h1><p>这些材料全部归 ©2020 Igor Irianto 所有。</p>\n<p><a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png\" /></a><br /></p>\n<p>这项作品已获得<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">&lt;&lt;知识共享署名-非商业性-相同方式共享 4.0 版&gt;&gt;</a>的许可。</p>\n"},{"title":"VIM-请先阅读","date":"2022-04-04T16:25:14.000Z","description":"VIM相关文档","hide":true,"_content":"\n# 第0章 请先阅读\n\n## 为什么写这本教程\n\n有很多途径可以学习Vim:`vimtutor`就是一个很好的途径，另外还有Vim自带的帮助手册（`:help`查看）包含了所有需要的参考信息。\n\n但是在日常使用中，对于绝大部分用户的需求而言，`vimtutor`讲得太浅不能满足需要，而`:help`所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。\n\n绝大部分情况下，您并不会使用到Vim100%的功能。您可能仅仅需要掌握其中20%就可以成为一名娴熟的Vim用户。本指南将为您展示Vim中最有用的功能。\n\n本指南带有作者强烈的个人观点。它涵盖了作者在使用Vim的过程中经常用到的技巧。章节按照作者认为的，最适合初学者最符合逻辑的顺序排列。\n\n本指南包含大量示例。当学习一个新技能时，示例是不可缺少的，大量的示例可以更有效的巩固所学概念。\n\n部分读者可能好奇为什么要学习Vimscript？我刚使用Vim时，仅仅满足于知道如何使用Vim。随着时间推移，我越来越需要使用Vimscript去写一些自定义命令，以满足特殊的编辑需要。在您使用Vim的过程中，您早晚会接触Vimscript。所以为什么不早点学呢？Vimscript是一门小巧的脚本语言，仅需要本指南的四个章节，您就可以学到它的基础知识。\n\n您当然可以继续使用Vim而不了解任何Vimscript知识，但了解它可以使您更加擅长Vim。\n\n本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。\n\n## 如何从其他编辑器过渡到Vim\n\n学习Vim的过程虽然很困难,但很具有成就感。有两种方法去学习Vim：\n\n1. 强制转换地使用Vim\n2. 循序渐进地使用Vim\n\n强制转换为Vim意味着从现在开始只使用Vim，停止使用您以前使用的任何编辑器/IDE。本方法的缺点是在前一周或两周，您将面临编辑效率的严重下降。如果您是一名专职程序员，本方法可能不太行得通。这也是为什么对于大部分读者而言，我认为过渡到Vim最好是循序渐进地使用Vim。\n\n想要循序渐进地使用Vim，应该在最开始的两个星期，每天花1个小时使用Vim作为您的编辑器，而剩下的时间您可以继续使用其他编辑器。许多现代编辑器都带有Vim插件。我刚开始时，每天花1个小时使用VSCode的Vim插件。逐渐地，我增加使用Vim插件的时间，直到最终完全使用Vim插件。记住，这些插件仅仅模拟了Vim中的一小部分功能。要想体验Vim中比如Vimscript、命令行命令（Ex模式）、以及外部集成命令的强大功能，您必须使用Vim自身。\n\n有两个关键节点驱使我开始100%地使用Vim：一是当我理解到Vim命令的语法结构（看第4章）时。二是学会[fzf.vim](https://github.com/junegunn/fzf.vim)插件时（看第3章）。\n\n第一个，当我了解了Vim命令的语法结构时。这是一个决定性时间节点，我终于理解了Vim用户以前讨论的是什么。我并不需要去学习上百个命令，而仅需要学习一小部分命令，然后就可以凭直觉将它们串起来去做很多事情。\n\n第二个，fzf插件我经常使用，该插件具有类似IDE的模糊文件查找功能。当我学会在Vim中如何使用该功能时，我的编辑效率极大提升，从此再也回不去了。\n\n尽管每一个程序都是不同的。但仔细一想，您会发现您所偏爱的编辑器/IDE总有1个或2个功能是您频繁使用的。也许是模糊查找，也许是跳转至定义，或是快速编译，但不管是什么，快速确认这些功能，然后学会如何在Vim中实现它们（一般情况下Vim都能办到）。您的编辑速度将会获得一个巨大的提高。\n\n当您使用Vim可以达到您原来50%的效率时，就是时候完全使用Vim了。\n\n## 如何阅读本指南\n\n本指南注重实效性。为了更好地在Vim中工作，您需要锻炼您的肌肉记忆，而不是大脑理解。\n\n想学会骑自行车，您并不需要首先阅读一本骑车教程。您需要做的是骑上一辆真正的自行车，然后在实践中探索。\n\n您需要输入每一条本指南中提到的命令。不仅如此，您还需要不断地重复，然后尝试命令的不同联合方式。想了解您刚学到命令具有什么功能，`:help`命令和搜索引擎是您最好的帮手。但您的目标并不是去掌握关于一条命令的全部信息，而是能够本能地、自然地使用该命令。\n\n我本想尽可能地使本指南的知识点呈线性化展示，但有些概念还是不得不违反顺序。比如在第1章，我就提到了替换命令（`:s`），这个知识点要到第12章才讲。作为补救，不管是什么概念，如果被提前讲到了，我将为它提供一个简短的说明，原谅我吧。\n\n## 更多帮助\n\n关于Vim帮助手册有一个额外的小技巧：假设您想了解关于`Ctrl-p`在插入模式时的功能。如果您仅仅查找`:h CTRL-P`，您将被导航到普通模式下关于`Ctrl-P`的介绍页面，这并不是您想要的信息。在这种情况下，改为查找`:h i_CTRL-P`。添加的`i_`表示插入模式。注意它属于哪个模式。\n\n## 语法\n\n大部分命令或涉及的代码片段都使用代码样式（`like this`）。\n\n字符串使用双引号包括（\"like this\"）。\n\nVim命令可以使用简写。比如，`:join`可以简写为`:j`。本指南全文中，我将混合使用简写和全称。对于本指南不经常使用的命令，我将使用全称。而对于经常使用的命令，我将使用简写。我为这不一致性道歉。总之，不管什么时候当您看到一个新命令，记得使用`:help`查看它的简写。\n\n## Vimrc\n\n在本指南的很多地方，我将提到vimrc选项。如果您是初学者，可以把vimrc看做一个配置文件。\n\nVimrc直到第21章才讲。为了保持清晰，我将在这里简要的介绍如何配置Vimrc。\n\n假设您需要设置number选项，即显示行号(`set number`)。如果您还没有vimrc文件，就创建一个。它通常位于根目录，名字为`.vimrc`。根据您的操作系统，该位置可能不同。在macOS，我将它放在`~/.vimrc`。要查看您的vimrc文件应该放在哪里，查看`:h vimrc`。\n\n在vimrc文件内，添加一行`set number`。保存(`:w`)，然后激活这一配置(`:source %`)。您将会在每一行的的左侧看到行号。\n\n另外，如果您不想永久配置一个选项，您可以在Vim命令行使用`set`命令，输入`:set number`。这种方法的缺点是设置是临时的。当您关闭Vim，该配置选项将消失。\n\n因为我们学的是Vim而不是Vi，有一个设置您必须启用，这就是`nocompatible`选项。在您的vimrc文件中添加`set nocompatible`。如果启用`compatible`选项，许多Vim特有的功能将会被禁止。\n\n一般而言，不管什么时候只要有一段内容涉及vimrc选项，只需要将该选项添加到vimrc中就好了，然后保存并激活相关选项。\n\n## 未来计划，错误，问题\n\n期待未来有更多的更新。如果您发现任何错误或有什么疑问，请随意提交。\n\n我计划近期再发布一些更新章节，敬请关注。\n\n## 更多关于Vim的技巧\n\n要了解Vim更多的信息，请关注我的推特（需墙）。[@learnvim](https://twitter.com/learnvim).\n\n## 感谢\n\n感谢Bram Moleenar编写了Vim，没有Vim就不会有本指南。感谢我的妻子当我编写本指南时表现的耐心和支持。感谢所有的贡献者[contributors](https://github.com/iggredible/Learn-Vim/graphs/contributors)，感谢Vim社区，还有很多其他没有提及的人们。\n\n谢谢，您们使得这件工作更加有趣。:)\n\n","source":"_posts/Vim/ch00_read_this_first.md","raw":"---\ntitle: VIM-请先阅读\ndate: 2022-04-05 00:25:14\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n    - [技术]\ndescription: VIM相关文档\nhide: true\n---\n\n# 第0章 请先阅读\n\n## 为什么写这本教程\n\n有很多途径可以学习Vim:`vimtutor`就是一个很好的途径，另外还有Vim自带的帮助手册（`:help`查看）包含了所有需要的参考信息。\n\n但是在日常使用中，对于绝大部分用户的需求而言，`vimtutor`讲得太浅不能满足需要，而`:help`所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。\n\n绝大部分情况下，您并不会使用到Vim100%的功能。您可能仅仅需要掌握其中20%就可以成为一名娴熟的Vim用户。本指南将为您展示Vim中最有用的功能。\n\n本指南带有作者强烈的个人观点。它涵盖了作者在使用Vim的过程中经常用到的技巧。章节按照作者认为的，最适合初学者最符合逻辑的顺序排列。\n\n本指南包含大量示例。当学习一个新技能时，示例是不可缺少的，大量的示例可以更有效的巩固所学概念。\n\n部分读者可能好奇为什么要学习Vimscript？我刚使用Vim时，仅仅满足于知道如何使用Vim。随着时间推移，我越来越需要使用Vimscript去写一些自定义命令，以满足特殊的编辑需要。在您使用Vim的过程中，您早晚会接触Vimscript。所以为什么不早点学呢？Vimscript是一门小巧的脚本语言，仅需要本指南的四个章节，您就可以学到它的基础知识。\n\n您当然可以继续使用Vim而不了解任何Vimscript知识，但了解它可以使您更加擅长Vim。\n\n本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。\n\n## 如何从其他编辑器过渡到Vim\n\n学习Vim的过程虽然很困难,但很具有成就感。有两种方法去学习Vim：\n\n1. 强制转换地使用Vim\n2. 循序渐进地使用Vim\n\n强制转换为Vim意味着从现在开始只使用Vim，停止使用您以前使用的任何编辑器/IDE。本方法的缺点是在前一周或两周，您将面临编辑效率的严重下降。如果您是一名专职程序员，本方法可能不太行得通。这也是为什么对于大部分读者而言，我认为过渡到Vim最好是循序渐进地使用Vim。\n\n想要循序渐进地使用Vim，应该在最开始的两个星期，每天花1个小时使用Vim作为您的编辑器，而剩下的时间您可以继续使用其他编辑器。许多现代编辑器都带有Vim插件。我刚开始时，每天花1个小时使用VSCode的Vim插件。逐渐地，我增加使用Vim插件的时间，直到最终完全使用Vim插件。记住，这些插件仅仅模拟了Vim中的一小部分功能。要想体验Vim中比如Vimscript、命令行命令（Ex模式）、以及外部集成命令的强大功能，您必须使用Vim自身。\n\n有两个关键节点驱使我开始100%地使用Vim：一是当我理解到Vim命令的语法结构（看第4章）时。二是学会[fzf.vim](https://github.com/junegunn/fzf.vim)插件时（看第3章）。\n\n第一个，当我了解了Vim命令的语法结构时。这是一个决定性时间节点，我终于理解了Vim用户以前讨论的是什么。我并不需要去学习上百个命令，而仅需要学习一小部分命令，然后就可以凭直觉将它们串起来去做很多事情。\n\n第二个，fzf插件我经常使用，该插件具有类似IDE的模糊文件查找功能。当我学会在Vim中如何使用该功能时，我的编辑效率极大提升，从此再也回不去了。\n\n尽管每一个程序都是不同的。但仔细一想，您会发现您所偏爱的编辑器/IDE总有1个或2个功能是您频繁使用的。也许是模糊查找，也许是跳转至定义，或是快速编译，但不管是什么，快速确认这些功能，然后学会如何在Vim中实现它们（一般情况下Vim都能办到）。您的编辑速度将会获得一个巨大的提高。\n\n当您使用Vim可以达到您原来50%的效率时，就是时候完全使用Vim了。\n\n## 如何阅读本指南\n\n本指南注重实效性。为了更好地在Vim中工作，您需要锻炼您的肌肉记忆，而不是大脑理解。\n\n想学会骑自行车，您并不需要首先阅读一本骑车教程。您需要做的是骑上一辆真正的自行车，然后在实践中探索。\n\n您需要输入每一条本指南中提到的命令。不仅如此，您还需要不断地重复，然后尝试命令的不同联合方式。想了解您刚学到命令具有什么功能，`:help`命令和搜索引擎是您最好的帮手。但您的目标并不是去掌握关于一条命令的全部信息，而是能够本能地、自然地使用该命令。\n\n我本想尽可能地使本指南的知识点呈线性化展示，但有些概念还是不得不违反顺序。比如在第1章，我就提到了替换命令（`:s`），这个知识点要到第12章才讲。作为补救，不管是什么概念，如果被提前讲到了，我将为它提供一个简短的说明，原谅我吧。\n\n## 更多帮助\n\n关于Vim帮助手册有一个额外的小技巧：假设您想了解关于`Ctrl-p`在插入模式时的功能。如果您仅仅查找`:h CTRL-P`，您将被导航到普通模式下关于`Ctrl-P`的介绍页面，这并不是您想要的信息。在这种情况下，改为查找`:h i_CTRL-P`。添加的`i_`表示插入模式。注意它属于哪个模式。\n\n## 语法\n\n大部分命令或涉及的代码片段都使用代码样式（`like this`）。\n\n字符串使用双引号包括（\"like this\"）。\n\nVim命令可以使用简写。比如，`:join`可以简写为`:j`。本指南全文中，我将混合使用简写和全称。对于本指南不经常使用的命令，我将使用全称。而对于经常使用的命令，我将使用简写。我为这不一致性道歉。总之，不管什么时候当您看到一个新命令，记得使用`:help`查看它的简写。\n\n## Vimrc\n\n在本指南的很多地方，我将提到vimrc选项。如果您是初学者，可以把vimrc看做一个配置文件。\n\nVimrc直到第21章才讲。为了保持清晰，我将在这里简要的介绍如何配置Vimrc。\n\n假设您需要设置number选项，即显示行号(`set number`)。如果您还没有vimrc文件，就创建一个。它通常位于根目录，名字为`.vimrc`。根据您的操作系统，该位置可能不同。在macOS，我将它放在`~/.vimrc`。要查看您的vimrc文件应该放在哪里，查看`:h vimrc`。\n\n在vimrc文件内，添加一行`set number`。保存(`:w`)，然后激活这一配置(`:source %`)。您将会在每一行的的左侧看到行号。\n\n另外，如果您不想永久配置一个选项，您可以在Vim命令行使用`set`命令，输入`:set number`。这种方法的缺点是设置是临时的。当您关闭Vim，该配置选项将消失。\n\n因为我们学的是Vim而不是Vi，有一个设置您必须启用，这就是`nocompatible`选项。在您的vimrc文件中添加`set nocompatible`。如果启用`compatible`选项，许多Vim特有的功能将会被禁止。\n\n一般而言，不管什么时候只要有一段内容涉及vimrc选项，只需要将该选项添加到vimrc中就好了，然后保存并激活相关选项。\n\n## 未来计划，错误，问题\n\n期待未来有更多的更新。如果您发现任何错误或有什么疑问，请随意提交。\n\n我计划近期再发布一些更新章节，敬请关注。\n\n## 更多关于Vim的技巧\n\n要了解Vim更多的信息，请关注我的推特（需墙）。[@learnvim](https://twitter.com/learnvim).\n\n## 感谢\n\n感谢Bram Moleenar编写了Vim，没有Vim就不会有本指南。感谢我的妻子当我编写本指南时表现的耐心和支持。感谢所有的贡献者[contributors](https://github.com/iggredible/Learn-Vim/graphs/contributors)，感谢Vim社区，还有很多其他没有提及的人们。\n\n谢谢，您们使得这件工作更加有趣。:)\n\n","slug":"Vim/ch00_read_this_first","published":1,"updated":"2022-08-28T07:38:59.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1q000wscvm9t3wdp97","content":"<h1 id=\"第0章-请先阅读\"><a href=\"#第0章-请先阅读\" class=\"headerlink\" title=\"第0章 请先阅读\"></a>第0章 请先阅读</h1><h2 id=\"为什么写这本教程\"><a href=\"#为什么写这本教程\" class=\"headerlink\" title=\"为什么写这本教程\"></a>为什么写这本教程</h2><p>有很多途径可以学习Vim:<code>vimtutor</code>就是一个很好的途径，另外还有Vim自带的帮助手册（<code>:help</code>查看）包含了所有需要的参考信息。</p>\n<p>但是在日常使用中，对于绝大部分用户的需求而言，<code>vimtutor</code>讲得太浅不能满足需要，而<code>:help</code>所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。</p>\n<p>绝大部分情况下，您并不会使用到Vim100%的功能。您可能仅仅需要掌握其中20%就可以成为一名娴熟的Vim用户。本指南将为您展示Vim中最有用的功能。</p>\n<p>本指南带有作者强烈的个人观点。它涵盖了作者在使用Vim的过程中经常用到的技巧。章节按照作者认为的，最适合初学者最符合逻辑的顺序排列。</p>\n<p>本指南包含大量示例。当学习一个新技能时，示例是不可缺少的，大量的示例可以更有效的巩固所学概念。</p>\n<p>部分读者可能好奇为什么要学习Vimscript？我刚使用Vim时，仅仅满足于知道如何使用Vim。随着时间推移，我越来越需要使用Vimscript去写一些自定义命令，以满足特殊的编辑需要。在您使用Vim的过程中，您早晚会接触Vimscript。所以为什么不早点学呢？Vimscript是一门小巧的脚本语言，仅需要本指南的四个章节，您就可以学到它的基础知识。</p>\n<p>您当然可以继续使用Vim而不了解任何Vimscript知识，但了解它可以使您更加擅长Vim。</p>\n<p>本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。</p>\n<h2 id=\"如何从其他编辑器过渡到Vim\"><a href=\"#如何从其他编辑器过渡到Vim\" class=\"headerlink\" title=\"如何从其他编辑器过渡到Vim\"></a>如何从其他编辑器过渡到Vim</h2><p>学习Vim的过程虽然很困难,但很具有成就感。有两种方法去学习Vim：</p>\n<ol>\n<li>强制转换地使用Vim</li>\n<li>循序渐进地使用Vim</li>\n</ol>\n<p>强制转换为Vim意味着从现在开始只使用Vim，停止使用您以前使用的任何编辑器&#x2F;IDE。本方法的缺点是在前一周或两周，您将面临编辑效率的严重下降。如果您是一名专职程序员，本方法可能不太行得通。这也是为什么对于大部分读者而言，我认为过渡到Vim最好是循序渐进地使用Vim。</p>\n<p>想要循序渐进地使用Vim，应该在最开始的两个星期，每天花1个小时使用Vim作为您的编辑器，而剩下的时间您可以继续使用其他编辑器。许多现代编辑器都带有Vim插件。我刚开始时，每天花1个小时使用VSCode的Vim插件。逐渐地，我增加使用Vim插件的时间，直到最终完全使用Vim插件。记住，这些插件仅仅模拟了Vim中的一小部分功能。要想体验Vim中比如Vimscript、命令行命令（Ex模式）、以及外部集成命令的强大功能，您必须使用Vim自身。</p>\n<p>有两个关键节点驱使我开始100%地使用Vim：一是当我理解到Vim命令的语法结构（看第4章）时。二是学会<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>插件时（看第3章）。</p>\n<p>第一个，当我了解了Vim命令的语法结构时。这是一个决定性时间节点，我终于理解了Vim用户以前讨论的是什么。我并不需要去学习上百个命令，而仅需要学习一小部分命令，然后就可以凭直觉将它们串起来去做很多事情。</p>\n<p>第二个，fzf插件我经常使用，该插件具有类似IDE的模糊文件查找功能。当我学会在Vim中如何使用该功能时，我的编辑效率极大提升，从此再也回不去了。</p>\n<p>尽管每一个程序都是不同的。但仔细一想，您会发现您所偏爱的编辑器&#x2F;IDE总有1个或2个功能是您频繁使用的。也许是模糊查找，也许是跳转至定义，或是快速编译，但不管是什么，快速确认这些功能，然后学会如何在Vim中实现它们（一般情况下Vim都能办到）。您的编辑速度将会获得一个巨大的提高。</p>\n<p>当您使用Vim可以达到您原来50%的效率时，就是时候完全使用Vim了。</p>\n<h2 id=\"如何阅读本指南\"><a href=\"#如何阅读本指南\" class=\"headerlink\" title=\"如何阅读本指南\"></a>如何阅读本指南</h2><p>本指南注重实效性。为了更好地在Vim中工作，您需要锻炼您的肌肉记忆，而不是大脑理解。</p>\n<p>想学会骑自行车，您并不需要首先阅读一本骑车教程。您需要做的是骑上一辆真正的自行车，然后在实践中探索。</p>\n<p>您需要输入每一条本指南中提到的命令。不仅如此，您还需要不断地重复，然后尝试命令的不同联合方式。想了解您刚学到命令具有什么功能，<code>:help</code>命令和搜索引擎是您最好的帮手。但您的目标并不是去掌握关于一条命令的全部信息，而是能够本能地、自然地使用该命令。</p>\n<p>我本想尽可能地使本指南的知识点呈线性化展示，但有些概念还是不得不违反顺序。比如在第1章，我就提到了替换命令（<code>:s</code>），这个知识点要到第12章才讲。作为补救，不管是什么概念，如果被提前讲到了，我将为它提供一个简短的说明，原谅我吧。</p>\n<h2 id=\"更多帮助\"><a href=\"#更多帮助\" class=\"headerlink\" title=\"更多帮助\"></a>更多帮助</h2><p>关于Vim帮助手册有一个额外的小技巧：假设您想了解关于<code>Ctrl-p</code>在插入模式时的功能。如果您仅仅查找<code>:h CTRL-P</code>，您将被导航到普通模式下关于<code>Ctrl-P</code>的介绍页面，这并不是您想要的信息。在这种情况下，改为查找<code>:h i_CTRL-P</code>。添加的<code>i_</code>表示插入模式。注意它属于哪个模式。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>大部分命令或涉及的代码片段都使用代码样式（<code>like this</code>）。</p>\n<p>字符串使用双引号包括（”like this”）。</p>\n<p>Vim命令可以使用简写。比如，<code>:join</code>可以简写为<code>:j</code>。本指南全文中，我将混合使用简写和全称。对于本指南不经常使用的命令，我将使用全称。而对于经常使用的命令，我将使用简写。我为这不一致性道歉。总之，不管什么时候当您看到一个新命令，记得使用<code>:help</code>查看它的简写。</p>\n<h2 id=\"Vimrc\"><a href=\"#Vimrc\" class=\"headerlink\" title=\"Vimrc\"></a>Vimrc</h2><p>在本指南的很多地方，我将提到vimrc选项。如果您是初学者，可以把vimrc看做一个配置文件。</p>\n<p>Vimrc直到第21章才讲。为了保持清晰，我将在这里简要的介绍如何配置Vimrc。</p>\n<p>假设您需要设置number选项，即显示行号(<code>set number</code>)。如果您还没有vimrc文件，就创建一个。它通常位于根目录，名字为<code>.vimrc</code>。根据您的操作系统，该位置可能不同。在macOS，我将它放在<code>~/.vimrc</code>。要查看您的vimrc文件应该放在哪里，查看<code>:h vimrc</code>。</p>\n<p>在vimrc文件内，添加一行<code>set number</code>。保存(<code>:w</code>)，然后激活这一配置(<code>:source %</code>)。您将会在每一行的的左侧看到行号。</p>\n<p>另外，如果您不想永久配置一个选项，您可以在Vim命令行使用<code>set</code>命令，输入<code>:set number</code>。这种方法的缺点是设置是临时的。当您关闭Vim，该配置选项将消失。</p>\n<p>因为我们学的是Vim而不是Vi，有一个设置您必须启用，这就是<code>nocompatible</code>选项。在您的vimrc文件中添加<code>set nocompatible</code>。如果启用<code>compatible</code>选项，许多Vim特有的功能将会被禁止。</p>\n<p>一般而言，不管什么时候只要有一段内容涉及vimrc选项，只需要将该选项添加到vimrc中就好了，然后保存并激活相关选项。</p>\n<h2 id=\"未来计划，错误，问题\"><a href=\"#未来计划，错误，问题\" class=\"headerlink\" title=\"未来计划，错误，问题\"></a>未来计划，错误，问题</h2><p>期待未来有更多的更新。如果您发现任何错误或有什么疑问，请随意提交。</p>\n<p>我计划近期再发布一些更新章节，敬请关注。</p>\n<h2 id=\"更多关于Vim的技巧\"><a href=\"#更多关于Vim的技巧\" class=\"headerlink\" title=\"更多关于Vim的技巧\"></a>更多关于Vim的技巧</h2><p>要了解Vim更多的信息，请关注我的推特（需墙）。<a href=\"https://twitter.com/learnvim\">@learnvim</a>.</p>\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p>感谢Bram Moleenar编写了Vim，没有Vim就不会有本指南。感谢我的妻子当我编写本指南时表现的耐心和支持。感谢所有的贡献者<a href=\"https://github.com/iggredible/Learn-Vim/graphs/contributors\">contributors</a>，感谢Vim社区，还有很多其他没有提及的人们。</p>\n<p>谢谢，您们使得这件工作更加有趣。:)</p>\n","site":{"data":{}},"wordcount":2987,"excerpt":"","more":"<h1 id=\"第0章-请先阅读\"><a href=\"#第0章-请先阅读\" class=\"headerlink\" title=\"第0章 请先阅读\"></a>第0章 请先阅读</h1><h2 id=\"为什么写这本教程\"><a href=\"#为什么写这本教程\" class=\"headerlink\" title=\"为什么写这本教程\"></a>为什么写这本教程</h2><p>有很多途径可以学习Vim:<code>vimtutor</code>就是一个很好的途径，另外还有Vim自带的帮助手册（<code>:help</code>查看）包含了所有需要的参考信息。</p>\n<p>但是在日常使用中，对于绝大部分用户的需求而言，<code>vimtutor</code>讲得太浅不能满足需要，而<code>:help</code>所提供的信息又有很多是用不上的。本指南尝试在两者之间搭一座桥，仅重点介绍关键功能，使您尽可能在最短的时间内掌握Vim中最有用的知识。</p>\n<p>绝大部分情况下，您并不会使用到Vim100%的功能。您可能仅仅需要掌握其中20%就可以成为一名娴熟的Vim用户。本指南将为您展示Vim中最有用的功能。</p>\n<p>本指南带有作者强烈的个人观点。它涵盖了作者在使用Vim的过程中经常用到的技巧。章节按照作者认为的，最适合初学者最符合逻辑的顺序排列。</p>\n<p>本指南包含大量示例。当学习一个新技能时，示例是不可缺少的，大量的示例可以更有效的巩固所学概念。</p>\n<p>部分读者可能好奇为什么要学习Vimscript？我刚使用Vim时，仅仅满足于知道如何使用Vim。随着时间推移，我越来越需要使用Vimscript去写一些自定义命令，以满足特殊的编辑需要。在您使用Vim的过程中，您早晚会接触Vimscript。所以为什么不早点学呢？Vimscript是一门小巧的脚本语言，仅需要本指南的四个章节，您就可以学到它的基础知识。</p>\n<p>您当然可以继续使用Vim而不了解任何Vimscript知识，但了解它可以使您更加擅长Vim。</p>\n<p>本指南同时为初学者和高级Vim用户撰写。它从宽泛而简单的概念开始讲，最后落在特殊的、进阶的技巧上。如果您已经是一名进阶用户，我还是鼓励您从头到尾阅读本指南，因为您将了解到一些新的东西。</p>\n<h2 id=\"如何从其他编辑器过渡到Vim\"><a href=\"#如何从其他编辑器过渡到Vim\" class=\"headerlink\" title=\"如何从其他编辑器过渡到Vim\"></a>如何从其他编辑器过渡到Vim</h2><p>学习Vim的过程虽然很困难,但很具有成就感。有两种方法去学习Vim：</p>\n<ol>\n<li>强制转换地使用Vim</li>\n<li>循序渐进地使用Vim</li>\n</ol>\n<p>强制转换为Vim意味着从现在开始只使用Vim，停止使用您以前使用的任何编辑器&#x2F;IDE。本方法的缺点是在前一周或两周，您将面临编辑效率的严重下降。如果您是一名专职程序员，本方法可能不太行得通。这也是为什么对于大部分读者而言，我认为过渡到Vim最好是循序渐进地使用Vim。</p>\n<p>想要循序渐进地使用Vim，应该在最开始的两个星期，每天花1个小时使用Vim作为您的编辑器，而剩下的时间您可以继续使用其他编辑器。许多现代编辑器都带有Vim插件。我刚开始时，每天花1个小时使用VSCode的Vim插件。逐渐地，我增加使用Vim插件的时间，直到最终完全使用Vim插件。记住，这些插件仅仅模拟了Vim中的一小部分功能。要想体验Vim中比如Vimscript、命令行命令（Ex模式）、以及外部集成命令的强大功能，您必须使用Vim自身。</p>\n<p>有两个关键节点驱使我开始100%地使用Vim：一是当我理解到Vim命令的语法结构（看第4章）时。二是学会<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>插件时（看第3章）。</p>\n<p>第一个，当我了解了Vim命令的语法结构时。这是一个决定性时间节点，我终于理解了Vim用户以前讨论的是什么。我并不需要去学习上百个命令，而仅需要学习一小部分命令，然后就可以凭直觉将它们串起来去做很多事情。</p>\n<p>第二个，fzf插件我经常使用，该插件具有类似IDE的模糊文件查找功能。当我学会在Vim中如何使用该功能时，我的编辑效率极大提升，从此再也回不去了。</p>\n<p>尽管每一个程序都是不同的。但仔细一想，您会发现您所偏爱的编辑器&#x2F;IDE总有1个或2个功能是您频繁使用的。也许是模糊查找，也许是跳转至定义，或是快速编译，但不管是什么，快速确认这些功能，然后学会如何在Vim中实现它们（一般情况下Vim都能办到）。您的编辑速度将会获得一个巨大的提高。</p>\n<p>当您使用Vim可以达到您原来50%的效率时，就是时候完全使用Vim了。</p>\n<h2 id=\"如何阅读本指南\"><a href=\"#如何阅读本指南\" class=\"headerlink\" title=\"如何阅读本指南\"></a>如何阅读本指南</h2><p>本指南注重实效性。为了更好地在Vim中工作，您需要锻炼您的肌肉记忆，而不是大脑理解。</p>\n<p>想学会骑自行车，您并不需要首先阅读一本骑车教程。您需要做的是骑上一辆真正的自行车，然后在实践中探索。</p>\n<p>您需要输入每一条本指南中提到的命令。不仅如此，您还需要不断地重复，然后尝试命令的不同联合方式。想了解您刚学到命令具有什么功能，<code>:help</code>命令和搜索引擎是您最好的帮手。但您的目标并不是去掌握关于一条命令的全部信息，而是能够本能地、自然地使用该命令。</p>\n<p>我本想尽可能地使本指南的知识点呈线性化展示，但有些概念还是不得不违反顺序。比如在第1章，我就提到了替换命令（<code>:s</code>），这个知识点要到第12章才讲。作为补救，不管是什么概念，如果被提前讲到了，我将为它提供一个简短的说明，原谅我吧。</p>\n<h2 id=\"更多帮助\"><a href=\"#更多帮助\" class=\"headerlink\" title=\"更多帮助\"></a>更多帮助</h2><p>关于Vim帮助手册有一个额外的小技巧：假设您想了解关于<code>Ctrl-p</code>在插入模式时的功能。如果您仅仅查找<code>:h CTRL-P</code>，您将被导航到普通模式下关于<code>Ctrl-P</code>的介绍页面，这并不是您想要的信息。在这种情况下，改为查找<code>:h i_CTRL-P</code>。添加的<code>i_</code>表示插入模式。注意它属于哪个模式。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>大部分命令或涉及的代码片段都使用代码样式（<code>like this</code>）。</p>\n<p>字符串使用双引号包括（”like this”）。</p>\n<p>Vim命令可以使用简写。比如，<code>:join</code>可以简写为<code>:j</code>。本指南全文中，我将混合使用简写和全称。对于本指南不经常使用的命令，我将使用全称。而对于经常使用的命令，我将使用简写。我为这不一致性道歉。总之，不管什么时候当您看到一个新命令，记得使用<code>:help</code>查看它的简写。</p>\n<h2 id=\"Vimrc\"><a href=\"#Vimrc\" class=\"headerlink\" title=\"Vimrc\"></a>Vimrc</h2><p>在本指南的很多地方，我将提到vimrc选项。如果您是初学者，可以把vimrc看做一个配置文件。</p>\n<p>Vimrc直到第21章才讲。为了保持清晰，我将在这里简要的介绍如何配置Vimrc。</p>\n<p>假设您需要设置number选项，即显示行号(<code>set number</code>)。如果您还没有vimrc文件，就创建一个。它通常位于根目录，名字为<code>.vimrc</code>。根据您的操作系统，该位置可能不同。在macOS，我将它放在<code>~/.vimrc</code>。要查看您的vimrc文件应该放在哪里，查看<code>:h vimrc</code>。</p>\n<p>在vimrc文件内，添加一行<code>set number</code>。保存(<code>:w</code>)，然后激活这一配置(<code>:source %</code>)。您将会在每一行的的左侧看到行号。</p>\n<p>另外，如果您不想永久配置一个选项，您可以在Vim命令行使用<code>set</code>命令，输入<code>:set number</code>。这种方法的缺点是设置是临时的。当您关闭Vim，该配置选项将消失。</p>\n<p>因为我们学的是Vim而不是Vi，有一个设置您必须启用，这就是<code>nocompatible</code>选项。在您的vimrc文件中添加<code>set nocompatible</code>。如果启用<code>compatible</code>选项，许多Vim特有的功能将会被禁止。</p>\n<p>一般而言，不管什么时候只要有一段内容涉及vimrc选项，只需要将该选项添加到vimrc中就好了，然后保存并激活相关选项。</p>\n<h2 id=\"未来计划，错误，问题\"><a href=\"#未来计划，错误，问题\" class=\"headerlink\" title=\"未来计划，错误，问题\"></a>未来计划，错误，问题</h2><p>期待未来有更多的更新。如果您发现任何错误或有什么疑问，请随意提交。</p>\n<p>我计划近期再发布一些更新章节，敬请关注。</p>\n<h2 id=\"更多关于Vim的技巧\"><a href=\"#更多关于Vim的技巧\" class=\"headerlink\" title=\"更多关于Vim的技巧\"></a>更多关于Vim的技巧</h2><p>要了解Vim更多的信息，请关注我的推特（需墙）。<a href=\"https://twitter.com/learnvim\">@learnvim</a>.</p>\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p>感谢Bram Moleenar编写了Vim，没有Vim就不会有本指南。感谢我的妻子当我编写本指南时表现的耐心和支持。感谢所有的贡献者<a href=\"https://github.com/iggredible/Learn-Vim/graphs/contributors\">contributors</a>，感谢Vim社区，还有很多其他没有提及的人们。</p>\n<p>谢谢，您们使得这件工作更加有趣。:)</p>\n"},{"title":"VIM-开始","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第1章 VIM起步 \n\n在本章，您将了解从终端启动Vim的几种不同方法。我写这本教程时使用的Vim版本是8.2。如果您使用Neovim或老版本的Vim，大部分情况下方法是通用的，但注意个别命令可能无效。\n\n## 安装\n\n我不会给出在某台特定机器上安装Vim的详细指令。好消息是，大部分Unix-based电脑应该预装了Vim。如果没有，大部分发行版也应该有关于如何安装Vim的指令。\n\n从Vim的官方网站或官方仓库可以获得下载链接：\n- [Vim 官网](https://www.vim.org/download.php)\n- [Vim 官方仓库](https://github.com/vim/vim)\n- [Vim 官方仓库镜像](https://hub.fastgit.org/vim/vim)\n\n## Vim命令\n\n当您安装好Vim后，在终端运行以下命令：\n\n```bash\nvim\n```\n\n您应该会看到一个介绍界面。这就是您用来处理文本的工作区。不像其它大部分文本编辑器和IDE，Vim是一个模式编辑器。如果您想输入\"hello\"，您需要使用'i'命令切换到插入模式。按下'ihello<Esc>'可以在工作区插入文本\"hello\"。\n\n## 退出Vim\n\n有好几种不同的方法都可以退出Vim。（译者注：在stackflow论坛上，有个著名的问题“如何退出Vim”，五年来，有超过100万开发者遇到相同的问题。^_^，这件事已经成为了开发者中的一个梗）。最常用的退出方法是在Vim中输入：\n\n```\n:quit\n```\n\n您可以使用简写`:q`。这是一个命令行模式的命令(command-line mode：Vim的另一种模式)。如果您在普通模式输入`:`，光标将移动到屏幕底部，在这里您可以输入命令。在后面的第15章，您会学到关于命令行模式更多信息。如果您处于插入模式，按下`:`将会在屏幕上直接显示\":\"(冒号)。因此，您需要按下`<Esc>`键切换回普通模式。顺带说一下，在命令行模式也可以通过按`<Esc>`键切换回普通模式。您将会注意到，在Vim的好几种模式下都可以通过按`<Esc>`键切回普通模式。\n\n## 保存文件\n\n若要保存您的修改，在Vim中输入：\n\n```\n:write\n```\n\n您也可以输入简写':w'。如果这是一个新建的文件，您必须给出文件名才能保存。下面的命令使文件保存为名为'file.txt'的文件，在Vim命令行运行：\n\n```\n:w file.txt\n```\n\n如果想保存并退出，可以将':w'和':q'命令联起来，在Vim命令行中输入：\n\n```\n:wq\n```\n\n如果想不保存修改而强制退出，可以在':q'命令后加'!'（叹号）,在Vim命令行中：\n\n```\n:q!\n```\n\n## 帮助\n\n在本指南全文中，我将向您提及好几种Vim的帮助页面。您可以通过输入`:help {命令}`(`:h`是简写)进入相关命令的帮助文档。可以向`:h`命令传递主题、命令名作为参数。比如，如果想查询退出Vim的方法，在vim中输入：\n\n```\n:h write-quit\n```\n\n我是怎么知道应该搜索\"write-quit\"这个关键词的呢？实际上我也不知道，我仅仅只是输入':h quit'，然后按`<Tab>`。Vim会自动显示相关联的关键词供用户选择。如果您需要查询一些信息，只需要输入`:h`后接关键词，然后按`<Tab>`。\n\n## 打开文件\n\n如果想在终端中使用Vim打开名为('hello1.txt')，在终端中运行：\n\n```bash\nvim hello1.txt\n```\n\n可以一次打开多个文件，在终端中：\n\n```bash\nvim hello1.txt hello2.txt hello3.txt\n```\n\nVim会在不同的buffers中打开'hello1.txt'，'hello2.txt'，'hello3.txt'。在下一章您将学到关于buffers的知识。\n\n## 参数\n\n您可以在终端中向`vim`命令传递参数。  \n\n如果想查看Vim的当前版本，在终端中运行：\n\n```bash\nvim --version\n```\n\n终端中将显示您当前Vim的版本和所有支持的特性，'+'表示支持的特性，'-'表示不支持的特性。本教程中的一些操作需要您的Vim支持特定的特性。比如，在后面的章节中提到可以使用`:history`查看Vim的命令行历史记录。您的Vim必须包含`+cmdline_history`这一特性，这条命令才能正常使用。一般情况下，如果您通过主流的安装源下载Vim的话，您安装的Vim是支持所有特性的，\n\n您在终端里做的很多事情都可以在Vim内部实现。比如，在Vim程序中也可以查看当前Vim版本，您可以运行下面的命令，在Vim中输入：\n\n```\n:version\n```\n\n如果您想打开`hello.txt`文件后迅速执行一条命令，您可以向`vim`传递一个`+{cmd}`选项。\n\n在Vim中，您可以使用`:s`命令（`substitue`的缩写）替换文本。如果您想打开`hello.txt`后立即将所有的\"pancake\"替换成\"bagel\"，在终端中：\n\n```bash\nvim +%s/pancake/bagel/g hello.txt\n```\n\n该命令可以被叠加，在终端中：\n\n```bash\nvim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt\n```\n\nVim会将所有\"pancake\" 实例替换为\"bagel\"，然后将所有\"bagel\"替换为\"egg\"，然后将所有\"egg\"替换为\"donut\"（在后面的章节中您将学到如何替换）。\n\n您同样可以使用`c`标志来代替`+`语法，在终端中：\n\n```bash\nvim -c %s/pancake/bagel/g hello.txt\nvim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt\n```\n\n## 打开多个窗口\n\n您可以使用`o`和`O`选项使Vim打开后分别显示为水平或垂直分割的窗口。\n\n若想将Vim打开为2个水平分割的窗口，在终端中运行：\n```bash\nvim -o2\n```\n\n若想将Vim打开为5个水平分割的窗口，在终端中运行：\n```bash\nvim -o5\n```\n\n若想将Vim打开为5个水平分割的窗口，并使前两个窗口显示`hello1.txt`和`hello2.txt`的内容，在终端中运行：\n\n```bash\nvim -o5 hello1.txt hello2.txt\n```\n\n若想将Vim打开为2个垂直分割的窗口、5个垂直分割的窗口、5个垂直分割窗口并显示2个文件，在终端中分别运行以下命令：\n\n```bash\nvim -O\nvim -O5\nvim -O5 hello1.txt hello2.txt\n```\n\n## 挂起\n\n如果您编辑时想将Vim挂起，您可以按下`Ctrl-z`。同样，您也可以使用`:stop`或`:suspend`命令达到相同的效果。若想从挂起状态返回，在终端中运行`fg`命令。\n\n## 聪明的启动Vim\n\n您可以向`vim`命令传递不同的选项(option)和标志(flag)，就像其他终端命令一样。其中一个选项是命令行命令（`+{cmd}`或`-c cmd`）。当您读完本教程学到更多命令后，看看您是否能将相应命令应用到Vim的启动中。同样，作为一个终端命令，您可以将`vim`命令和其他终端命令联合起来。比如，您可以将`ls`命令的输出重定向到Vim中编辑，命令是`ls -l | vim -`。\n\n若要了解更多Vim终端命令，查看`man vim`。若要了解更多关于Vim编辑器的知识，继续阅读本教程，多使用`:help`命令。\n","source":"_posts/Vim/ch01_starting_vim.md","raw":"---\ntitle: VIM-开始\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第1章 VIM起步 \n\n在本章，您将了解从终端启动Vim的几种不同方法。我写这本教程时使用的Vim版本是8.2。如果您使用Neovim或老版本的Vim，大部分情况下方法是通用的，但注意个别命令可能无效。\n\n## 安装\n\n我不会给出在某台特定机器上安装Vim的详细指令。好消息是，大部分Unix-based电脑应该预装了Vim。如果没有，大部分发行版也应该有关于如何安装Vim的指令。\n\n从Vim的官方网站或官方仓库可以获得下载链接：\n- [Vim 官网](https://www.vim.org/download.php)\n- [Vim 官方仓库](https://github.com/vim/vim)\n- [Vim 官方仓库镜像](https://hub.fastgit.org/vim/vim)\n\n## Vim命令\n\n当您安装好Vim后，在终端运行以下命令：\n\n```bash\nvim\n```\n\n您应该会看到一个介绍界面。这就是您用来处理文本的工作区。不像其它大部分文本编辑器和IDE，Vim是一个模式编辑器。如果您想输入\"hello\"，您需要使用'i'命令切换到插入模式。按下'ihello<Esc>'可以在工作区插入文本\"hello\"。\n\n## 退出Vim\n\n有好几种不同的方法都可以退出Vim。（译者注：在stackflow论坛上，有个著名的问题“如何退出Vim”，五年来，有超过100万开发者遇到相同的问题。^_^，这件事已经成为了开发者中的一个梗）。最常用的退出方法是在Vim中输入：\n\n```\n:quit\n```\n\n您可以使用简写`:q`。这是一个命令行模式的命令(command-line mode：Vim的另一种模式)。如果您在普通模式输入`:`，光标将移动到屏幕底部，在这里您可以输入命令。在后面的第15章，您会学到关于命令行模式更多信息。如果您处于插入模式，按下`:`将会在屏幕上直接显示\":\"(冒号)。因此，您需要按下`<Esc>`键切换回普通模式。顺带说一下，在命令行模式也可以通过按`<Esc>`键切换回普通模式。您将会注意到，在Vim的好几种模式下都可以通过按`<Esc>`键切回普通模式。\n\n## 保存文件\n\n若要保存您的修改，在Vim中输入：\n\n```\n:write\n```\n\n您也可以输入简写':w'。如果这是一个新建的文件，您必须给出文件名才能保存。下面的命令使文件保存为名为'file.txt'的文件，在Vim命令行运行：\n\n```\n:w file.txt\n```\n\n如果想保存并退出，可以将':w'和':q'命令联起来，在Vim命令行中输入：\n\n```\n:wq\n```\n\n如果想不保存修改而强制退出，可以在':q'命令后加'!'（叹号）,在Vim命令行中：\n\n```\n:q!\n```\n\n## 帮助\n\n在本指南全文中，我将向您提及好几种Vim的帮助页面。您可以通过输入`:help {命令}`(`:h`是简写)进入相关命令的帮助文档。可以向`:h`命令传递主题、命令名作为参数。比如，如果想查询退出Vim的方法，在vim中输入：\n\n```\n:h write-quit\n```\n\n我是怎么知道应该搜索\"write-quit\"这个关键词的呢？实际上我也不知道，我仅仅只是输入':h quit'，然后按`<Tab>`。Vim会自动显示相关联的关键词供用户选择。如果您需要查询一些信息，只需要输入`:h`后接关键词，然后按`<Tab>`。\n\n## 打开文件\n\n如果想在终端中使用Vim打开名为('hello1.txt')，在终端中运行：\n\n```bash\nvim hello1.txt\n```\n\n可以一次打开多个文件，在终端中：\n\n```bash\nvim hello1.txt hello2.txt hello3.txt\n```\n\nVim会在不同的buffers中打开'hello1.txt'，'hello2.txt'，'hello3.txt'。在下一章您将学到关于buffers的知识。\n\n## 参数\n\n您可以在终端中向`vim`命令传递参数。  \n\n如果想查看Vim的当前版本，在终端中运行：\n\n```bash\nvim --version\n```\n\n终端中将显示您当前Vim的版本和所有支持的特性，'+'表示支持的特性，'-'表示不支持的特性。本教程中的一些操作需要您的Vim支持特定的特性。比如，在后面的章节中提到可以使用`:history`查看Vim的命令行历史记录。您的Vim必须包含`+cmdline_history`这一特性，这条命令才能正常使用。一般情况下，如果您通过主流的安装源下载Vim的话，您安装的Vim是支持所有特性的，\n\n您在终端里做的很多事情都可以在Vim内部实现。比如，在Vim程序中也可以查看当前Vim版本，您可以运行下面的命令，在Vim中输入：\n\n```\n:version\n```\n\n如果您想打开`hello.txt`文件后迅速执行一条命令，您可以向`vim`传递一个`+{cmd}`选项。\n\n在Vim中，您可以使用`:s`命令（`substitue`的缩写）替换文本。如果您想打开`hello.txt`后立即将所有的\"pancake\"替换成\"bagel\"，在终端中：\n\n```bash\nvim +%s/pancake/bagel/g hello.txt\n```\n\n该命令可以被叠加，在终端中：\n\n```bash\nvim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt\n```\n\nVim会将所有\"pancake\" 实例替换为\"bagel\"，然后将所有\"bagel\"替换为\"egg\"，然后将所有\"egg\"替换为\"donut\"（在后面的章节中您将学到如何替换）。\n\n您同样可以使用`c`标志来代替`+`语法，在终端中：\n\n```bash\nvim -c %s/pancake/bagel/g hello.txt\nvim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt\n```\n\n## 打开多个窗口\n\n您可以使用`o`和`O`选项使Vim打开后分别显示为水平或垂直分割的窗口。\n\n若想将Vim打开为2个水平分割的窗口，在终端中运行：\n```bash\nvim -o2\n```\n\n若想将Vim打开为5个水平分割的窗口，在终端中运行：\n```bash\nvim -o5\n```\n\n若想将Vim打开为5个水平分割的窗口，并使前两个窗口显示`hello1.txt`和`hello2.txt`的内容，在终端中运行：\n\n```bash\nvim -o5 hello1.txt hello2.txt\n```\n\n若想将Vim打开为2个垂直分割的窗口、5个垂直分割的窗口、5个垂直分割窗口并显示2个文件，在终端中分别运行以下命令：\n\n```bash\nvim -O\nvim -O5\nvim -O5 hello1.txt hello2.txt\n```\n\n## 挂起\n\n如果您编辑时想将Vim挂起，您可以按下`Ctrl-z`。同样，您也可以使用`:stop`或`:suspend`命令达到相同的效果。若想从挂起状态返回，在终端中运行`fg`命令。\n\n## 聪明的启动Vim\n\n您可以向`vim`命令传递不同的选项(option)和标志(flag)，就像其他终端命令一样。其中一个选项是命令行命令（`+{cmd}`或`-c cmd`）。当您读完本教程学到更多命令后，看看您是否能将相应命令应用到Vim的启动中。同样，作为一个终端命令，您可以将`vim`命令和其他终端命令联合起来。比如，您可以将`ls`命令的输出重定向到Vim中编辑，命令是`ls -l | vim -`。\n\n若要了解更多Vim终端命令，查看`man vim`。若要了解更多关于Vim编辑器的知识，继续阅读本教程，多使用`:help`命令。\n","slug":"Vim/ch01_starting_vim","published":1,"updated":"2022-08-28T07:38:59.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1q000zscvm1vaz87ol","content":"<h1 id=\"第1章-VIM起步\"><a href=\"#第1章-VIM起步\" class=\"headerlink\" title=\"第1章 VIM起步\"></a>第1章 VIM起步</h1><p>在本章，您将了解从终端启动Vim的几种不同方法。我写这本教程时使用的Vim版本是8.2。如果您使用Neovim或老版本的Vim，大部分情况下方法是通用的，但注意个别命令可能无效。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我不会给出在某台特定机器上安装Vim的详细指令。好消息是，大部分Unix-based电脑应该预装了Vim。如果没有，大部分发行版也应该有关于如何安装Vim的指令。</p>\n<p>从Vim的官方网站或官方仓库可以获得下载链接：</p>\n<ul>\n<li><a href=\"https://www.vim.org/download.php\">Vim 官网</a></li>\n<li><a href=\"https://github.com/vim/vim\">Vim 官方仓库</a></li>\n<li><a href=\"https://hub.fastgit.org/vim/vim\">Vim 官方仓库镜像</a></li>\n</ul>\n<h2 id=\"Vim命令\"><a href=\"#Vim命令\" class=\"headerlink\" title=\"Vim命令\"></a>Vim命令</h2><p>当您安装好Vim后，在终端运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\">vim<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到一个介绍界面。这就是您用来处理文本的工作区。不像其它大部分文本编辑器和IDE，Vim是一个模式编辑器。如果您想输入”hello”，您需要使用’i’命令切换到插入模式。按下’ihello<Esc>‘可以在工作区插入文本”hello”。</p>\n<h2 id=\"退出Vim\"><a href=\"#退出Vim\" class=\"headerlink\" title=\"退出Vim\"></a>退出Vim</h2><p>有好几种不同的方法都可以退出Vim。（译者注：在stackflow论坛上，有个著名的问题“如何退出Vim”，五年来，有超过100万开发者遇到相同的问题。^_^，这件事已经成为了开发者中的一个梗）。最常用的退出方法是在Vim中输入：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:quit</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以使用简写<code>:q</code>。这是一个命令行模式的命令(command-line mode：Vim的另一种模式)。如果您在普通模式输入<code>:</code>，光标将移动到屏幕底部，在这里您可以输入命令。在后面的第15章，您会学到关于命令行模式更多信息。如果您处于插入模式，按下<code>:</code>将会在屏幕上直接显示”:”(冒号)。因此，您需要按下<code>&lt;Esc&gt;</code>键切换回普通模式。顺带说一下，在命令行模式也可以通过按<code>&lt;Esc&gt;</code>键切换回普通模式。您将会注意到，在Vim的好几种模式下都可以通过按<code>&lt;Esc&gt;</code>键切回普通模式。</p>\n<h2 id=\"保存文件\"><a href=\"#保存文件\" class=\"headerlink\" title=\"保存文件\"></a>保存文件</h2><p>若要保存您的修改，在Vim中输入：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:<span class=\"hljs-built_in\">write</span><br></code></pre></td></tr></table></figure>\n\n<p>您也可以输入简写’:w’。如果这是一个新建的文件，您必须给出文件名才能保存。下面的命令使文件保存为名为’file.txt’的文件，在Vim命令行运行：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:w <span class=\"hljs-built_in\">file</span>.txt<br></code></pre></td></tr></table></figure>\n\n<p>如果想保存并退出，可以将’:w’和’:q’命令联起来，在Vim命令行中输入：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:wq</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想不保存修改而强制退出，可以在’:q’命令后加’!’（叹号）,在Vim命令行中：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:q!</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"帮助\"><a href=\"#帮助\" class=\"headerlink\" title=\"帮助\"></a>帮助</h2><p>在本指南全文中，我将向您提及好几种Vim的帮助页面。您可以通过输入<code>:help &#123;命令&#125;</code>(<code>:h</code>是简写)进入相关命令的帮助文档。可以向<code>:h</code>命令传递主题、命令名作为参数。比如，如果想查询退出Vim的方法，在vim中输入：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">:<span class=\"hljs-keyword\">h</span> <span class=\"hljs-keyword\">write</span>-<span class=\"hljs-keyword\">quit</span><br></code></pre></td></tr></table></figure>\n\n<p>我是怎么知道应该搜索”write-quit”这个关键词的呢？实际上我也不知道，我仅仅只是输入’:h quit’，然后按<code>&lt;Tab&gt;</code>。Vim会自动显示相关联的关键词供用户选择。如果您需要查询一些信息，只需要输入<code>:h</code>后接关键词，然后按<code>&lt;Tab&gt;</code>。</p>\n<h2 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h2><p>如果想在终端中使用Vim打开名为(‘hello1.txt’)，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim hello1.txt<br></code></pre></td></tr></table></figure>\n\n<p>可以一次打开多个文件，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim hello1.txt hello2.txt hello3.txt<br></code></pre></td></tr></table></figure>\n\n<p>Vim会在不同的buffers中打开’hello1.txt’，’hello2.txt’，’hello3.txt’。在下一章您将学到关于buffers的知识。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>您可以在终端中向<code>vim</code>命令传递参数。  </p>\n<p>如果想查看Vim的当前版本，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim --version<br></code></pre></td></tr></table></figure>\n\n<p>终端中将显示您当前Vim的版本和所有支持的特性，’+’表示支持的特性，’-‘表示不支持的特性。本教程中的一些操作需要您的Vim支持特定的特性。比如，在后面的章节中提到可以使用<code>:history</code>查看Vim的命令行历史记录。您的Vim必须包含<code>+cmdline_history</code>这一特性，这条命令才能正常使用。一般情况下，如果您通过主流的安装源下载Vim的话，您安装的Vim是支持所有特性的，</p>\n<p>您在终端里做的很多事情都可以在Vim内部实现。比如，在Vim程序中也可以查看当前Vim版本，您可以运行下面的命令，在Vim中输入：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:<span class=\"hljs-built_in\">version</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您想打开<code>hello.txt</code>文件后迅速执行一条命令，您可以向<code>vim</code>传递一个<code>+&#123;cmd&#125;</code>选项。</p>\n<p>在Vim中，您可以使用<code>:s</code>命令（<code>substitue</code>的缩写）替换文本。如果您想打开<code>hello.txt</code>后立即将所有的”pancake”替换成”bagel”，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim +%s/pancake/bagel/g hello.txt<br></code></pre></td></tr></table></figure>\n\n<p>该命令可以被叠加，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt<br></code></pre></td></tr></table></figure>\n\n<p>Vim会将所有”pancake” 实例替换为”bagel”，然后将所有”bagel”替换为”egg”，然后将所有”egg”替换为”donut”（在后面的章节中您将学到如何替换）。</p>\n<p>您同样可以使用<code>c</code>标志来代替<code>+</code>语法，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -c %s/pancake/bagel/g hello.txt<br>vim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"打开多个窗口\"><a href=\"#打开多个窗口\" class=\"headerlink\" title=\"打开多个窗口\"></a>打开多个窗口</h2><p>您可以使用<code>o</code>和<code>O</code>选项使Vim打开后分别显示为水平或垂直分割的窗口。</p>\n<p>若想将Vim打开为2个水平分割的窗口，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -o2<br></code></pre></td></tr></table></figure>\n\n<p>若想将Vim打开为5个水平分割的窗口，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -o5<br></code></pre></td></tr></table></figure>\n\n<p>若想将Vim打开为5个水平分割的窗口，并使前两个窗口显示<code>hello1.txt</code>和<code>hello2.txt</code>的内容，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -o5 hello1.txt hello2.txt<br></code></pre></td></tr></table></figure>\n\n<p>若想将Vim打开为2个垂直分割的窗口、5个垂直分割的窗口、5个垂直分割窗口并显示2个文件，在终端中分别运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -O<br>vim -O5<br>vim -O5 hello1.txt hello2.txt<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"挂起\"><a href=\"#挂起\" class=\"headerlink\" title=\"挂起\"></a>挂起</h2><p>如果您编辑时想将Vim挂起，您可以按下<code>Ctrl-z</code>。同样，您也可以使用<code>:stop</code>或<code>:suspend</code>命令达到相同的效果。若想从挂起状态返回，在终端中运行<code>fg</code>命令。</p>\n<h2 id=\"聪明的启动Vim\"><a href=\"#聪明的启动Vim\" class=\"headerlink\" title=\"聪明的启动Vim\"></a>聪明的启动Vim</h2><p>您可以向<code>vim</code>命令传递不同的选项(option)和标志(flag)，就像其他终端命令一样。其中一个选项是命令行命令（<code>+&#123;cmd&#125;</code>或<code>-c cmd</code>）。当您读完本教程学到更多命令后，看看您是否能将相应命令应用到Vim的启动中。同样，作为一个终端命令，您可以将<code>vim</code>命令和其他终端命令联合起来。比如，您可以将<code>ls</code>命令的输出重定向到Vim中编辑，命令是<code>ls -l | vim -</code>。</p>\n<p>若要了解更多Vim终端命令，查看<code>man vim</code>。若要了解更多关于Vim编辑器的知识，继续阅读本教程，多使用<code>:help</code>命令。</p>\n","site":{"data":{}},"wordcount":2797,"excerpt":"","more":"<h1 id=\"第1章-VIM起步\"><a href=\"#第1章-VIM起步\" class=\"headerlink\" title=\"第1章 VIM起步\"></a>第1章 VIM起步</h1><p>在本章，您将了解从终端启动Vim的几种不同方法。我写这本教程时使用的Vim版本是8.2。如果您使用Neovim或老版本的Vim，大部分情况下方法是通用的，但注意个别命令可能无效。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我不会给出在某台特定机器上安装Vim的详细指令。好消息是，大部分Unix-based电脑应该预装了Vim。如果没有，大部分发行版也应该有关于如何安装Vim的指令。</p>\n<p>从Vim的官方网站或官方仓库可以获得下载链接：</p>\n<ul>\n<li><a href=\"https://www.vim.org/download.php\">Vim 官网</a></li>\n<li><a href=\"https://github.com/vim/vim\">Vim 官方仓库</a></li>\n<li><a href=\"https://hub.fastgit.org/vim/vim\">Vim 官方仓库镜像</a></li>\n</ul>\n<h2 id=\"Vim命令\"><a href=\"#Vim命令\" class=\"headerlink\" title=\"Vim命令\"></a>Vim命令</h2><p>当您安装好Vim后，在终端运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到一个介绍界面。这就是您用来处理文本的工作区。不像其它大部分文本编辑器和IDE，Vim是一个模式编辑器。如果您想输入”hello”，您需要使用’i’命令切换到插入模式。按下’ihello<Esc>‘可以在工作区插入文本”hello”。</p>\n<h2 id=\"退出Vim\"><a href=\"#退出Vim\" class=\"headerlink\" title=\"退出Vim\"></a>退出Vim</h2><p>有好几种不同的方法都可以退出Vim。（译者注：在stackflow论坛上，有个著名的问题“如何退出Vim”，五年来，有超过100万开发者遇到相同的问题。^_^，这件事已经成为了开发者中的一个梗）。最常用的退出方法是在Vim中输入：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:quit</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以使用简写<code>:q</code>。这是一个命令行模式的命令(command-line mode：Vim的另一种模式)。如果您在普通模式输入<code>:</code>，光标将移动到屏幕底部，在这里您可以输入命令。在后面的第15章，您会学到关于命令行模式更多信息。如果您处于插入模式，按下<code>:</code>将会在屏幕上直接显示”:”(冒号)。因此，您需要按下<code>&lt;Esc&gt;</code>键切换回普通模式。顺带说一下，在命令行模式也可以通过按<code>&lt;Esc&gt;</code>键切换回普通模式。您将会注意到，在Vim的好几种模式下都可以通过按<code>&lt;Esc&gt;</code>键切回普通模式。</p>\n<h2 id=\"保存文件\"><a href=\"#保存文件\" class=\"headerlink\" title=\"保存文件\"></a>保存文件</h2><p>若要保存您的修改，在Vim中输入：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:<span class=\"hljs-built_in\">write</span><br></code></pre></td></tr></table></figure>\n\n<p>您也可以输入简写’:w’。如果这是一个新建的文件，您必须给出文件名才能保存。下面的命令使文件保存为名为’file.txt’的文件，在Vim命令行运行：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:w <span class=\"hljs-built_in\">file</span>.txt<br></code></pre></td></tr></table></figure>\n\n<p>如果想保存并退出，可以将’:w’和’:q’命令联起来，在Vim命令行中输入：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:wq</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想不保存修改而强制退出，可以在’:q’命令后加’!’（叹号）,在Vim命令行中：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:q!</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"帮助\"><a href=\"#帮助\" class=\"headerlink\" title=\"帮助\"></a>帮助</h2><p>在本指南全文中，我将向您提及好几种Vim的帮助页面。您可以通过输入<code>:help &#123;命令&#125;</code>(<code>:h</code>是简写)进入相关命令的帮助文档。可以向<code>:h</code>命令传递主题、命令名作为参数。比如，如果想查询退出Vim的方法，在vim中输入：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">:<span class=\"hljs-keyword\">h</span> <span class=\"hljs-keyword\">write</span>-<span class=\"hljs-keyword\">quit</span><br></code></pre></td></tr></table></figure>\n\n<p>我是怎么知道应该搜索”write-quit”这个关键词的呢？实际上我也不知道，我仅仅只是输入’:h quit’，然后按<code>&lt;Tab&gt;</code>。Vim会自动显示相关联的关键词供用户选择。如果您需要查询一些信息，只需要输入<code>:h</code>后接关键词，然后按<code>&lt;Tab&gt;</code>。</p>\n<h2 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h2><p>如果想在终端中使用Vim打开名为(‘hello1.txt’)，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim hello1.txt<br></code></pre></td></tr></table></figure>\n\n<p>可以一次打开多个文件，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim hello1.txt hello2.txt hello3.txt<br></code></pre></td></tr></table></figure>\n\n<p>Vim会在不同的buffers中打开’hello1.txt’，’hello2.txt’，’hello3.txt’。在下一章您将学到关于buffers的知识。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>您可以在终端中向<code>vim</code>命令传递参数。  </p>\n<p>如果想查看Vim的当前版本，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim --version<br></code></pre></td></tr></table></figure>\n\n<p>终端中将显示您当前Vim的版本和所有支持的特性，’+’表示支持的特性，’-‘表示不支持的特性。本教程中的一些操作需要您的Vim支持特定的特性。比如，在后面的章节中提到可以使用<code>:history</code>查看Vim的命令行历史记录。您的Vim必须包含<code>+cmdline_history</code>这一特性，这条命令才能正常使用。一般情况下，如果您通过主流的安装源下载Vim的话，您安装的Vim是支持所有特性的，</p>\n<p>您在终端里做的很多事情都可以在Vim内部实现。比如，在Vim程序中也可以查看当前Vim版本，您可以运行下面的命令，在Vim中输入：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:<span class=\"hljs-built_in\">version</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您想打开<code>hello.txt</code>文件后迅速执行一条命令，您可以向<code>vim</code>传递一个<code>+&#123;cmd&#125;</code>选项。</p>\n<p>在Vim中，您可以使用<code>:s</code>命令（<code>substitue</code>的缩写）替换文本。如果您想打开<code>hello.txt</code>后立即将所有的”pancake”替换成”bagel”，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim +%s/pancake/bagel/g hello.txt<br></code></pre></td></tr></table></figure>\n\n<p>该命令可以被叠加，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt<br></code></pre></td></tr></table></figure>\n\n<p>Vim会将所有”pancake” 实例替换为”bagel”，然后将所有”bagel”替换为”egg”，然后将所有”egg”替换为”donut”（在后面的章节中您将学到如何替换）。</p>\n<p>您同样可以使用<code>c</code>标志来代替<code>+</code>语法，在终端中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -c %s/pancake/bagel/g hello.txt<br>vim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"打开多个窗口\"><a href=\"#打开多个窗口\" class=\"headerlink\" title=\"打开多个窗口\"></a>打开多个窗口</h2><p>您可以使用<code>o</code>和<code>O</code>选项使Vim打开后分别显示为水平或垂直分割的窗口。</p>\n<p>若想将Vim打开为2个水平分割的窗口，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -o2<br></code></pre></td></tr></table></figure>\n\n<p>若想将Vim打开为5个水平分割的窗口，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -o5<br></code></pre></td></tr></table></figure>\n\n<p>若想将Vim打开为5个水平分割的窗口，并使前两个窗口显示<code>hello1.txt</code>和<code>hello2.txt</code>的内容，在终端中运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -o5 hello1.txt hello2.txt<br></code></pre></td></tr></table></figure>\n\n<p>若想将Vim打开为2个垂直分割的窗口、5个垂直分割的窗口、5个垂直分割窗口并显示2个文件，在终端中分别运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -O<br>vim -O5<br>vim -O5 hello1.txt hello2.txt<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"挂起\"><a href=\"#挂起\" class=\"headerlink\" title=\"挂起\"></a>挂起</h2><p>如果您编辑时想将Vim挂起，您可以按下<code>Ctrl-z</code>。同样，您也可以使用<code>:stop</code>或<code>:suspend</code>命令达到相同的效果。若想从挂起状态返回，在终端中运行<code>fg</code>命令。</p>\n<h2 id=\"聪明的启动Vim\"><a href=\"#聪明的启动Vim\" class=\"headerlink\" title=\"聪明的启动Vim\"></a>聪明的启动Vim</h2><p>您可以向<code>vim</code>命令传递不同的选项(option)和标志(flag)，就像其他终端命令一样。其中一个选项是命令行命令（<code>+&#123;cmd&#125;</code>或<code>-c cmd</code>）。当您读完本教程学到更多命令后，看看您是否能将相应命令应用到Vim的启动中。同样，作为一个终端命令，您可以将<code>vim</code>命令和其他终端命令联合起来。比如，您可以将<code>ls</code>命令的输出重定向到Vim中编辑，命令是<code>ls -l | vim -</code>。</p>\n<p>若要了解更多Vim终端命令，查看<code>man vim</code>。若要了解更多关于Vim编辑器的知识，继续阅读本教程，多使用<code>:help</code>命令。</p>\n"},{"title":"VIM-缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第2章 缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)\n\n(译者注：在Vim中，Buffers缓冲区，Windows窗口，Tabs选项卡是专有名词。为适应不同读者的翻译习惯，确保没有歧义，本文将不对Buffers、Windows、Tabs这三个词进行翻译)。  \n\n如果您使用过现代文本编辑器，您很可能对Windows和tabs这两个概念是非常熟悉的。但Vim使用了三个关于显示方面的抽象概念：buffers, windows, 还有tabs。在本章，我将向您解释什么是buffers, windows和tabs，以及它们在Vim中如何工作。\n\n在开始之前，确保您的vimrc文件中开启了`set hidden`选项。若没有配置该选项，当您想切换buffer且当前buffer没有保存时，Vim将提示您保存文件（如果您想快速切换，您不会想要这个提示）。我目前还没有讲vimrc，如果您没有vimrc配置文件，那就创建一个。它通常位于根目录下，名字叫`.vimrc`。我的vimrc位于`~/.vimrc`。要查看您自己的vimrc文件应该放置在哪，可以在Vim命令模式中输入`:h vimrc`。在vimrc文件中，添加：\n\n```\nset hidden\n```\n\n保存好vimrc文件，然后激活它(在vimrc文件中运行`:source %`)。\n\n## Buffers\n\n*buffer*到底是什么？\n\nbuffer就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers。\n\n创建两个可使用的空文件，分别名为`file1.js`和`file2.js`（如果可能，尽量使用Vim来创建）。在终端中运行下面的命令：\n\n```bash\nvim file1.js\n```\n\n这时您看到的是`file1.js`的 *buffer* 。每当您打开一个新文件，Vim总是会创建一个新的buffer。\n\n退出Vim。这一次，打开两个新文件：\n\n```bash\nvim file1.js file2.js\n```\n\nVim当前显示的是`file1.js`的buffer，但它实际上创建了两个buffers：`file1.js`buffer和`file2.js`buffer。运行`:buffers`命令可以查看所有的buffers（另外，您也可以使用`:ls`和`:files`命令）。您应该会 *同时* 看到列出来的`file1.js`和`file2.js`。运行`vim file1 file2 file3 ... filen`创建n个buffers。每一次您打开一个新文件，Vim就为这个文件创建一个新的buffer。\n\n要遍历所有buffers，有以下几种方法：\n- `:bnext` 切换至下一个buffer（`:bprevious`切换至前一个buffer）。\n- `:buffer` + 文件名。（按下`<Tab>`键Vim会自动补全文件名）。 \n- `:buffer` + `n`, n是buffer的编号。比如，输入`:buffer 2`将使您切换到buffer #2。\n- 按下`Ctrl-O`将跳转至跳转列表中旧的位置，对应的，按下`Ctrl-I`将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转。我将在第5章详细讲述关于跳转的知识。\n- 按下`Ctrl-^`跳转至先前编辑过的buffer。\n\n一旦Vim创建了一个buffer，它将保留在您的buffers列表中。若想删除它，您可以输入`:bdelete`。这条命令也可以接收一个buffer编号（`:bdlete 3`将删除buffer #3）或一个文件名（`:bdelete`然后按`<Tab>`自动补全文件名）。\n\n我学习buffer时最困难的事情就是理解buffer如何工作，因为我当时的思维已经习惯了使用主流文本编辑器时关于窗口的概念。要理解buffer，可以打个很好的比方，就是打牌的桌面。如果您有2个buffers，就像您有一叠牌（2张）。您只能看见顶部的牌，虽然您知道在它下面还有其他的牌。如果您看见`file1.js`buffer，那么`file1.js`就是顶部的牌。虽然您看不到其他的牌`file2.js`，但它实际上就在那。如果您切换buffers到`file2.js`，那么`file2.js`这张牌就换到了顶部，而`file1.js`就换到了底部。\n\n如果您以前没有用过Vim，这是一个新的概念。花上几分钟理解一下。\n\n## 退出Vim\n\n顺带说一句，如果您已经打开了多个buffers，您可以使用quit -all来关闭所有的buffers：\n\n```\n:qall\n```\n\n如果您想关闭所有buffers但不保存，仅需要在后面加`!`（叹号）就行了：\n\n```\n:qall!\n```\n\n若要保存所有buffers然后退出，请运行：\n\n```\n:wqall\n```\n\n## Windows\n\n一个window就是在buffer上的一个视口。如果您使用过主流的编辑器，Windows这个概念应该很熟悉。大部分文本编辑器具有显示多个窗口的能力。在Vim中，您同样可以拥有多个窗口。\n\n让我们从终端再次打开`file1.js`：\n\n```bash\nvim file1.js\n```\n\n先前我说过，您看到的是`file1.js`的buffer。但这个说法并不完整，现在这句话得更正一下，您看到的是`file1.js `的buffer通过 **一个窗口** 显示出来。窗口就是您查看的buffer所使用的视口。\n\n先不忙急着退出Vim，在Vim中运行：\n\n```\n:split file2.js\n```\n\n现在您看到的是两个buffers通过 **两个窗口** 显示出来。上面的窗口显示的是`file2.js`的buffer。而下面的窗口显示的是`file1.js`的buffer。\n\n如果您想在窗口之间导航，使用这些快捷键：\n\n```\nCtrl-W H    移动光标到左边的窗口\nCtrl-W J    移动光标到下面的窗口\nCtrl-W K    移动光标到上面的窗口\nCtrl-W L    移动光标到右边的窗口\n```\n\n现在，在Vim中运行：\n\n```\n:vsplit file3.js\n```\n\n您现在看到的是三个窗口显示三个buffers。一个窗口显示`file3.js`的buffer，一个窗口显示`file2.js`的buffer，还有一个窗口显示`file1.js`的buffer。\n\n您可以使多个窗口显示同一个buffer。当光标位于左上方窗口时，输入：\n\n```\n:buffer file2.js\n```\n\n现在两个窗口显示的都是`file2.js`的buffer。如果您现在在这两个窗口中的某一个输入内容，您会看到所有显示`file2.js`buffer的窗口都在实时更新。\n\n要关闭当前的窗口，您可以按`Ctrl-W C`或输入`:quit`。当您关闭一个窗口后，buffers仍然会在列表中。（可以运行`:buffers`来确认这一点）。\n\n这里有一些普通模式下关于窗口的命令：\n\n```\nCtrl-W V    打开一个新的垂直分割的窗口\nCtrl-W S    打开一个新的水平分割的窗口\nCtrl-W C    关闭一个窗口\nCtrl-W O    除了当前窗口，关闭所有其他的窗口\n```\n\n另外，下面的列表列出了一些有用的关于windows的命令行命令\n\n```\n:vsplit filename    垂直分割当前窗口，并在新窗口中打开名为filename的文件。\n:split filename     水平分割当前窗口，并在新窗口中打开名为filename的文件。\n:new filename       创建一个新窗口并打开名为filename的文件。\n```\n\n花一点时间理解上面的知识。要了解更多信息，可以查看帮助`:h window`。\n\n## Tabs\n\nTabs就是windows的集合。它就像窗口的布局。在大部分的现代文本编辑器（还有现代互联网浏览器）中，一个tab意味着打开一个文件/页面，当您关闭标签，相应的文件/页面就消失了。但在Vim中，tab并不表示打开了一个文件。当您在Vim中关闭一个tab，您并不是关闭一个文件。您仅仅关闭了窗口布局。文件的数据依然存储在内存中的buffers中。\n\n让我们运行几个命令看看Vim中tabs的功能。打开`file1.js`：\n\n```bash\nvim file1.js\n```\n\n若要在新tab中打开`file2.js`：\n\n```\n:tabnew file2.js\n```\n\n当然您可以按`<Tab>`让Vim自动补全 *新tab* 中将要打开的文件名（啰嗦几句，请理解作者的幽默 ）。\n\n下面的列表列出了一些有用的关于tab导航的命令：\n\n```\n:tabnew file.txt    在tab中打开一个文件\n:tabclose           关闭当前tab\n:tabnext            切换至下一个tab\n:tabprevious        切换至前一个tab\n:tablast            切换至最后一个tab\n:tabfirst           切换至第一个tab\n```\n\n您可以输入`gt`切换到下一个标签页（对应的，可以用`gT`切换到前一个标签页）。您也可以传递一个数字作为参数给`gt`，这个数字是tab的编号。若想切换到第3个tab，输入`3gt`。\n\n拥有多个tabs的好处是，您可以在不同的tab中使用不同的窗口布局。也许，您想让您的第1个tab包含3个垂直分割的窗口，然后让第2个tab为水平分割和垂直分割混合的窗口布局。tab是完成这件工作的完美工具!\n\n若想让Vim启动时就包含多个tabs，您可以在终端中运行如下命令：\n\n```bash\nvim -p file1.js file2.js file3.js\n```\n\n## 三维移动\n\n在windows之间移动就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动。您可以使用`Ctrl-W H/J/K/L`移动到上面、右侧、下面、以及左侧的窗口。\n\n在buffer之间移动就像在笛卡尔坐标系的Z轴上穿梭。想象您的buffer文件在Z轴上呈线性排列，您可以使用`:bnext`和`bprevious`在Z轴上一次一个buffer地遍历。您也可以使用`:buffer 文件名/buffer编号`在Z轴上跳转到任意坐标。\n\n结合window和buffer的移动，您可以在 *三维空间* 中移动。您可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）。因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）。\n\n## 用聪明的方法使用Buffers、Windows、以及Tabs\n\n您已经学习了什么是buffers、windows、以及tabs，也学习了它们如何在Vim中工作。现在您对它们有了更好地理解，您可以把它们用在您自己的工作流程中。\n\n每个人都有不同的工作流程，以下示例是我的工作流程：\n- 首先，对于某个特定任务，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。\n- 当比对文件、读文档、或追踪代码流时，我使用多窗口来一次查看多个buffers。我尽量保持屏幕上的窗口数不超过3个，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。\n- 我使用[tmux](https://github.com/tmux/tmux/wiki)windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。 \n\n由于编辑风格不同，我的工作流程可能和您的工作流程不同，这没关系。您可以在实践中去探索适合您自己工作流程的编码风格。\n","source":"_posts/Vim/ch02_buffers_windows_tabs.md","raw":"---\ntitle: VIM-缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第2章 缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)\n\n(译者注：在Vim中，Buffers缓冲区，Windows窗口，Tabs选项卡是专有名词。为适应不同读者的翻译习惯，确保没有歧义，本文将不对Buffers、Windows、Tabs这三个词进行翻译)。  \n\n如果您使用过现代文本编辑器，您很可能对Windows和tabs这两个概念是非常熟悉的。但Vim使用了三个关于显示方面的抽象概念：buffers, windows, 还有tabs。在本章，我将向您解释什么是buffers, windows和tabs，以及它们在Vim中如何工作。\n\n在开始之前，确保您的vimrc文件中开启了`set hidden`选项。若没有配置该选项，当您想切换buffer且当前buffer没有保存时，Vim将提示您保存文件（如果您想快速切换，您不会想要这个提示）。我目前还没有讲vimrc，如果您没有vimrc配置文件，那就创建一个。它通常位于根目录下，名字叫`.vimrc`。我的vimrc位于`~/.vimrc`。要查看您自己的vimrc文件应该放置在哪，可以在Vim命令模式中输入`:h vimrc`。在vimrc文件中，添加：\n\n```\nset hidden\n```\n\n保存好vimrc文件，然后激活它(在vimrc文件中运行`:source %`)。\n\n## Buffers\n\n*buffer*到底是什么？\n\nbuffer就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers。\n\n创建两个可使用的空文件，分别名为`file1.js`和`file2.js`（如果可能，尽量使用Vim来创建）。在终端中运行下面的命令：\n\n```bash\nvim file1.js\n```\n\n这时您看到的是`file1.js`的 *buffer* 。每当您打开一个新文件，Vim总是会创建一个新的buffer。\n\n退出Vim。这一次，打开两个新文件：\n\n```bash\nvim file1.js file2.js\n```\n\nVim当前显示的是`file1.js`的buffer，但它实际上创建了两个buffers：`file1.js`buffer和`file2.js`buffer。运行`:buffers`命令可以查看所有的buffers（另外，您也可以使用`:ls`和`:files`命令）。您应该会 *同时* 看到列出来的`file1.js`和`file2.js`。运行`vim file1 file2 file3 ... filen`创建n个buffers。每一次您打开一个新文件，Vim就为这个文件创建一个新的buffer。\n\n要遍历所有buffers，有以下几种方法：\n- `:bnext` 切换至下一个buffer（`:bprevious`切换至前一个buffer）。\n- `:buffer` + 文件名。（按下`<Tab>`键Vim会自动补全文件名）。 \n- `:buffer` + `n`, n是buffer的编号。比如，输入`:buffer 2`将使您切换到buffer #2。\n- 按下`Ctrl-O`将跳转至跳转列表中旧的位置，对应的，按下`Ctrl-I`将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转。我将在第5章详细讲述关于跳转的知识。\n- 按下`Ctrl-^`跳转至先前编辑过的buffer。\n\n一旦Vim创建了一个buffer，它将保留在您的buffers列表中。若想删除它，您可以输入`:bdelete`。这条命令也可以接收一个buffer编号（`:bdlete 3`将删除buffer #3）或一个文件名（`:bdelete`然后按`<Tab>`自动补全文件名）。\n\n我学习buffer时最困难的事情就是理解buffer如何工作，因为我当时的思维已经习惯了使用主流文本编辑器时关于窗口的概念。要理解buffer，可以打个很好的比方，就是打牌的桌面。如果您有2个buffers，就像您有一叠牌（2张）。您只能看见顶部的牌，虽然您知道在它下面还有其他的牌。如果您看见`file1.js`buffer，那么`file1.js`就是顶部的牌。虽然您看不到其他的牌`file2.js`，但它实际上就在那。如果您切换buffers到`file2.js`，那么`file2.js`这张牌就换到了顶部，而`file1.js`就换到了底部。\n\n如果您以前没有用过Vim，这是一个新的概念。花上几分钟理解一下。\n\n## 退出Vim\n\n顺带说一句，如果您已经打开了多个buffers，您可以使用quit -all来关闭所有的buffers：\n\n```\n:qall\n```\n\n如果您想关闭所有buffers但不保存，仅需要在后面加`!`（叹号）就行了：\n\n```\n:qall!\n```\n\n若要保存所有buffers然后退出，请运行：\n\n```\n:wqall\n```\n\n## Windows\n\n一个window就是在buffer上的一个视口。如果您使用过主流的编辑器，Windows这个概念应该很熟悉。大部分文本编辑器具有显示多个窗口的能力。在Vim中，您同样可以拥有多个窗口。\n\n让我们从终端再次打开`file1.js`：\n\n```bash\nvim file1.js\n```\n\n先前我说过，您看到的是`file1.js`的buffer。但这个说法并不完整，现在这句话得更正一下，您看到的是`file1.js `的buffer通过 **一个窗口** 显示出来。窗口就是您查看的buffer所使用的视口。\n\n先不忙急着退出Vim，在Vim中运行：\n\n```\n:split file2.js\n```\n\n现在您看到的是两个buffers通过 **两个窗口** 显示出来。上面的窗口显示的是`file2.js`的buffer。而下面的窗口显示的是`file1.js`的buffer。\n\n如果您想在窗口之间导航，使用这些快捷键：\n\n```\nCtrl-W H    移动光标到左边的窗口\nCtrl-W J    移动光标到下面的窗口\nCtrl-W K    移动光标到上面的窗口\nCtrl-W L    移动光标到右边的窗口\n```\n\n现在，在Vim中运行：\n\n```\n:vsplit file3.js\n```\n\n您现在看到的是三个窗口显示三个buffers。一个窗口显示`file3.js`的buffer，一个窗口显示`file2.js`的buffer，还有一个窗口显示`file1.js`的buffer。\n\n您可以使多个窗口显示同一个buffer。当光标位于左上方窗口时，输入：\n\n```\n:buffer file2.js\n```\n\n现在两个窗口显示的都是`file2.js`的buffer。如果您现在在这两个窗口中的某一个输入内容，您会看到所有显示`file2.js`buffer的窗口都在实时更新。\n\n要关闭当前的窗口，您可以按`Ctrl-W C`或输入`:quit`。当您关闭一个窗口后，buffers仍然会在列表中。（可以运行`:buffers`来确认这一点）。\n\n这里有一些普通模式下关于窗口的命令：\n\n```\nCtrl-W V    打开一个新的垂直分割的窗口\nCtrl-W S    打开一个新的水平分割的窗口\nCtrl-W C    关闭一个窗口\nCtrl-W O    除了当前窗口，关闭所有其他的窗口\n```\n\n另外，下面的列表列出了一些有用的关于windows的命令行命令\n\n```\n:vsplit filename    垂直分割当前窗口，并在新窗口中打开名为filename的文件。\n:split filename     水平分割当前窗口，并在新窗口中打开名为filename的文件。\n:new filename       创建一个新窗口并打开名为filename的文件。\n```\n\n花一点时间理解上面的知识。要了解更多信息，可以查看帮助`:h window`。\n\n## Tabs\n\nTabs就是windows的集合。它就像窗口的布局。在大部分的现代文本编辑器（还有现代互联网浏览器）中，一个tab意味着打开一个文件/页面，当您关闭标签，相应的文件/页面就消失了。但在Vim中，tab并不表示打开了一个文件。当您在Vim中关闭一个tab，您并不是关闭一个文件。您仅仅关闭了窗口布局。文件的数据依然存储在内存中的buffers中。\n\n让我们运行几个命令看看Vim中tabs的功能。打开`file1.js`：\n\n```bash\nvim file1.js\n```\n\n若要在新tab中打开`file2.js`：\n\n```\n:tabnew file2.js\n```\n\n当然您可以按`<Tab>`让Vim自动补全 *新tab* 中将要打开的文件名（啰嗦几句，请理解作者的幽默 ）。\n\n下面的列表列出了一些有用的关于tab导航的命令：\n\n```\n:tabnew file.txt    在tab中打开一个文件\n:tabclose           关闭当前tab\n:tabnext            切换至下一个tab\n:tabprevious        切换至前一个tab\n:tablast            切换至最后一个tab\n:tabfirst           切换至第一个tab\n```\n\n您可以输入`gt`切换到下一个标签页（对应的，可以用`gT`切换到前一个标签页）。您也可以传递一个数字作为参数给`gt`，这个数字是tab的编号。若想切换到第3个tab，输入`3gt`。\n\n拥有多个tabs的好处是，您可以在不同的tab中使用不同的窗口布局。也许，您想让您的第1个tab包含3个垂直分割的窗口，然后让第2个tab为水平分割和垂直分割混合的窗口布局。tab是完成这件工作的完美工具!\n\n若想让Vim启动时就包含多个tabs，您可以在终端中运行如下命令：\n\n```bash\nvim -p file1.js file2.js file3.js\n```\n\n## 三维移动\n\n在windows之间移动就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动。您可以使用`Ctrl-W H/J/K/L`移动到上面、右侧、下面、以及左侧的窗口。\n\n在buffer之间移动就像在笛卡尔坐标系的Z轴上穿梭。想象您的buffer文件在Z轴上呈线性排列，您可以使用`:bnext`和`bprevious`在Z轴上一次一个buffer地遍历。您也可以使用`:buffer 文件名/buffer编号`在Z轴上跳转到任意坐标。\n\n结合window和buffer的移动，您可以在 *三维空间* 中移动。您可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）。因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）。\n\n## 用聪明的方法使用Buffers、Windows、以及Tabs\n\n您已经学习了什么是buffers、windows、以及tabs，也学习了它们如何在Vim中工作。现在您对它们有了更好地理解，您可以把它们用在您自己的工作流程中。\n\n每个人都有不同的工作流程，以下示例是我的工作流程：\n- 首先，对于某个特定任务，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。\n- 当比对文件、读文档、或追踪代码流时，我使用多窗口来一次查看多个buffers。我尽量保持屏幕上的窗口数不超过3个，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。\n- 我使用[tmux](https://github.com/tmux/tmux/wiki)windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。 \n\n由于编辑风格不同，我的工作流程可能和您的工作流程不同，这没关系。您可以在实践中去探索适合您自己工作流程的编码风格。\n","slug":"Vim/ch02_buffers_windows_tabs","published":1,"updated":"2022-08-28T07:38:59.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1r0013scvmgqg6amdz","content":"<h1 id=\"第2章-缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs\"><a href=\"#第2章-缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs\" class=\"headerlink\" title=\"第2章 缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)\"></a>第2章 缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)</h1><p>(译者注：在Vim中，Buffers缓冲区，Windows窗口，Tabs选项卡是专有名词。为适应不同读者的翻译习惯，确保没有歧义，本文将不对Buffers、Windows、Tabs这三个词进行翻译)。  </p>\n<p>如果您使用过现代文本编辑器，您很可能对Windows和tabs这两个概念是非常熟悉的。但Vim使用了三个关于显示方面的抽象概念：buffers, windows, 还有tabs。在本章，我将向您解释什么是buffers, windows和tabs，以及它们在Vim中如何工作。</p>\n<p>在开始之前，确保您的vimrc文件中开启了<code>set hidden</code>选项。若没有配置该选项，当您想切换buffer且当前buffer没有保存时，Vim将提示您保存文件（如果您想快速切换，您不会想要这个提示）。我目前还没有讲vimrc，如果您没有vimrc配置文件，那就创建一个。它通常位于根目录下，名字叫<code>.vimrc</code>。我的vimrc位于<code>~/.vimrc</code>。要查看您自己的vimrc文件应该放置在哪，可以在Vim命令模式中输入<code>:h vimrc</code>。在vimrc文件中，添加：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-keyword\">hidden</span><br></code></pre></td></tr></table></figure>\n\n<p>保存好vimrc文件，然后激活它(在vimrc文件中运行<code>:source %</code>)。</p>\n<h2 id=\"Buffers\"><a href=\"#Buffers\" class=\"headerlink\" title=\"Buffers\"></a>Buffers</h2><p><em>buffer</em>到底是什么？</p>\n<p>buffer就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers。</p>\n<p>创建两个可使用的空文件，分别名为<code>file1.js</code>和<code>file2.js</code>（如果可能，尽量使用Vim来创建）。在终端中运行下面的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js<br></code></pre></td></tr></table></figure>\n\n<p>这时您看到的是<code>file1.js</code>的 <em>buffer</em> 。每当您打开一个新文件，Vim总是会创建一个新的buffer。</p>\n<p>退出Vim。这一次，打开两个新文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js file2.js<br></code></pre></td></tr></table></figure>\n\n<p>Vim当前显示的是<code>file1.js</code>的buffer，但它实际上创建了两个buffers：<code>file1.js</code>buffer和<code>file2.js</code>buffer。运行<code>:buffers</code>命令可以查看所有的buffers（另外，您也可以使用<code>:ls</code>和<code>:files</code>命令）。您应该会 <em>同时</em> 看到列出来的<code>file1.js</code>和<code>file2.js</code>。运行<code>vim file1 file2 file3 ... filen</code>创建n个buffers。每一次您打开一个新文件，Vim就为这个文件创建一个新的buffer。</p>\n<p>要遍历所有buffers，有以下几种方法：</p>\n<ul>\n<li><code>:bnext</code> 切换至下一个buffer（<code>:bprevious</code>切换至前一个buffer）。</li>\n<li><code>:buffer</code> + 文件名。（按下<code>&lt;Tab&gt;</code>键Vim会自动补全文件名）。 </li>\n<li><code>:buffer</code> + <code>n</code>, n是buffer的编号。比如，输入<code>:buffer 2</code>将使您切换到buffer #2。</li>\n<li>按下<code>Ctrl-O</code>将跳转至跳转列表中旧的位置，对应的，按下<code>Ctrl-I</code>将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转。我将在第5章详细讲述关于跳转的知识。</li>\n<li>按下<code>Ctrl-^</code>跳转至先前编辑过的buffer。</li>\n</ul>\n<p>一旦Vim创建了一个buffer，它将保留在您的buffers列表中。若想删除它，您可以输入<code>:bdelete</code>。这条命令也可以接收一个buffer编号（<code>:bdlete 3</code>将删除buffer #3）或一个文件名（<code>:bdelete</code>然后按<code>&lt;Tab&gt;</code>自动补全文件名）。</p>\n<p>我学习buffer时最困难的事情就是理解buffer如何工作，因为我当时的思维已经习惯了使用主流文本编辑器时关于窗口的概念。要理解buffer，可以打个很好的比方，就是打牌的桌面。如果您有2个buffers，就像您有一叠牌（2张）。您只能看见顶部的牌，虽然您知道在它下面还有其他的牌。如果您看见<code>file1.js</code>buffer，那么<code>file1.js</code>就是顶部的牌。虽然您看不到其他的牌<code>file2.js</code>，但它实际上就在那。如果您切换buffers到<code>file2.js</code>，那么<code>file2.js</code>这张牌就换到了顶部，而<code>file1.js</code>就换到了底部。</p>\n<p>如果您以前没有用过Vim，这是一个新的概念。花上几分钟理解一下。</p>\n<h2 id=\"退出Vim\"><a href=\"#退出Vim\" class=\"headerlink\" title=\"退出Vim\"></a>退出Vim</h2><p>顺带说一句，如果您已经打开了多个buffers，您可以使用quit -all来关闭所有的buffers：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:qall</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您想关闭所有buffers但不保存，仅需要在后面加<code>!</code>（叹号）就行了：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:qall!</span><br></code></pre></td></tr></table></figure>\n\n<p>若要保存所有buffers然后退出，请运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:wqall</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h2><p>一个window就是在buffer上的一个视口。如果您使用过主流的编辑器，Windows这个概念应该很熟悉。大部分文本编辑器具有显示多个窗口的能力。在Vim中，您同样可以拥有多个窗口。</p>\n<p>让我们从终端再次打开<code>file1.js</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js<br></code></pre></td></tr></table></figure>\n\n<p>先前我说过，您看到的是<code>file1.js</code>的buffer。但这个说法并不完整，现在这句话得更正一下，您看到的是<code>file1.js </code>的buffer通过 <strong>一个窗口</strong> 显示出来。窗口就是您查看的buffer所使用的视口。</p>\n<p>先不忙急着退出Vim，在Vim中运行：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">:<span class=\"hljs-built_in\">split</span> file2.js<br></code></pre></td></tr></table></figure>\n\n<p>现在您看到的是两个buffers通过 <strong>两个窗口</strong> 显示出来。上面的窗口显示的是<code>file2.js</code>的buffer。而下面的窗口显示的是<code>file1.js</code>的buffer。</p>\n<p>如果您想在窗口之间导航，使用这些快捷键：</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">Ctrl-<span class=\"hljs-keyword\">W</span> H    移动光标到左边的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> J    移动光标到下面的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> K    移动光标到上面的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> L    移动光标到右边的窗口<br></code></pre></td></tr></table></figure>\n\n<p>现在，在Vim中运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:vsplit</span> file3.js<br></code></pre></td></tr></table></figure>\n\n<p>您现在看到的是三个窗口显示三个buffers。一个窗口显示<code>file3.js</code>的buffer，一个窗口显示<code>file2.js</code>的buffer，还有一个窗口显示<code>file1.js</code>的buffer。</p>\n<p>您可以使多个窗口显示同一个buffer。当光标位于左上方窗口时，输入：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">:<span class=\"hljs-built_in\">buffer</span> file2.js<br></code></pre></td></tr></table></figure>\n\n<p>现在两个窗口显示的都是<code>file2.js</code>的buffer。如果您现在在这两个窗口中的某一个输入内容，您会看到所有显示<code>file2.js</code>buffer的窗口都在实时更新。</p>\n<p>要关闭当前的窗口，您可以按<code>Ctrl-W C</code>或输入<code>:quit</code>。当您关闭一个窗口后，buffers仍然会在列表中。（可以运行<code>:buffers</code>来确认这一点）。</p>\n<p>这里有一些普通模式下关于窗口的命令：</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">Ctrl-<span class=\"hljs-keyword\">W</span> V    打开一个新的垂直分割的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> S    打开一个新的水平分割的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> C    关闭一个窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> O    除了当前窗口，关闭所有其他的窗口<br></code></pre></td></tr></table></figure>\n\n<p>另外，下面的列表列出了一些有用的关于windows的命令行命令</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tcl\">:vsplit <span class=\"hljs-keyword\">filename</span>    垂直分割当前窗口，并在新窗口中打开名为<span class=\"hljs-keyword\">filename</span>的文件。<br>:<span class=\"hljs-keyword\">split</span> <span class=\"hljs-keyword\">filename</span>     水平分割当前窗口，并在新窗口中打开名为<span class=\"hljs-keyword\">filename</span>的文件。<br>:new <span class=\"hljs-keyword\">filename</span>       创建一个新窗口并打开名为<span class=\"hljs-keyword\">filename</span>的文件。<br></code></pre></td></tr></table></figure>\n\n<p>花一点时间理解上面的知识。要了解更多信息，可以查看帮助<code>:h window</code>。</p>\n<h2 id=\"Tabs\"><a href=\"#Tabs\" class=\"headerlink\" title=\"Tabs\"></a>Tabs</h2><p>Tabs就是windows的集合。它就像窗口的布局。在大部分的现代文本编辑器（还有现代互联网浏览器）中，一个tab意味着打开一个文件&#x2F;页面，当您关闭标签，相应的文件&#x2F;页面就消失了。但在Vim中，tab并不表示打开了一个文件。当您在Vim中关闭一个tab，您并不是关闭一个文件。您仅仅关闭了窗口布局。文件的数据依然存储在内存中的buffers中。</p>\n<p>让我们运行几个命令看看Vim中tabs的功能。打开<code>file1.js</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js<br></code></pre></td></tr></table></figure>\n\n<p>若要在新tab中打开<code>file2.js</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tabnew</span> file2.js<br></code></pre></td></tr></table></figure>\n\n<p>当然您可以按<code>&lt;Tab&gt;</code>让Vim自动补全 <em>新tab</em> 中将要打开的文件名（啰嗦几句，请理解作者的幽默 ）。</p>\n<p>下面的列表列出了一些有用的关于tab导航的命令：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">tabnew</span> <span class=\"hljs-keyword\">file</span>.txt    在<span class=\"hljs-keyword\">tab</span>中打开一个文件<br>:<span class=\"hljs-keyword\">tabclose</span>           关闭当前<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tabnext</span>            切换至下一个<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tabprevious</span>        切换至前一个<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tablast</span>            切换至最后一个<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tabfirst</span>           切换至第一个<span class=\"hljs-keyword\">tab</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以输入<code>gt</code>切换到下一个标签页（对应的，可以用<code>gT</code>切换到前一个标签页）。您也可以传递一个数字作为参数给<code>gt</code>，这个数字是tab的编号。若想切换到第3个tab，输入<code>3gt</code>。</p>\n<p>拥有多个tabs的好处是，您可以在不同的tab中使用不同的窗口布局。也许，您想让您的第1个tab包含3个垂直分割的窗口，然后让第2个tab为水平分割和垂直分割混合的窗口布局。tab是完成这件工作的完美工具!</p>\n<p>若想让Vim启动时就包含多个tabs，您可以在终端中运行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -p file1.js file2.js file3.js<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三维移动\"><a href=\"#三维移动\" class=\"headerlink\" title=\"三维移动\"></a>三维移动</h2><p>在windows之间移动就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动。您可以使用<code>Ctrl-W H/J/K/L</code>移动到上面、右侧、下面、以及左侧的窗口。</p>\n<p>在buffer之间移动就像在笛卡尔坐标系的Z轴上穿梭。想象您的buffer文件在Z轴上呈线性排列，您可以使用<code>:bnext</code>和<code>bprevious</code>在Z轴上一次一个buffer地遍历。您也可以使用<code>:buffer 文件名/buffer编号</code>在Z轴上跳转到任意坐标。</p>\n<p>结合window和buffer的移动，您可以在 <em>三维空间</em> 中移动。您可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）。因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）。</p>\n<h2 id=\"用聪明的方法使用Buffers、Windows、以及Tabs\"><a href=\"#用聪明的方法使用Buffers、Windows、以及Tabs\" class=\"headerlink\" title=\"用聪明的方法使用Buffers、Windows、以及Tabs\"></a>用聪明的方法使用Buffers、Windows、以及Tabs</h2><p>您已经学习了什么是buffers、windows、以及tabs，也学习了它们如何在Vim中工作。现在您对它们有了更好地理解，您可以把它们用在您自己的工作流程中。</p>\n<p>每个人都有不同的工作流程，以下示例是我的工作流程：</p>\n<ul>\n<li>首先，对于某个特定任务，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。</li>\n<li>当比对文件、读文档、或追踪代码流时，我使用多窗口来一次查看多个buffers。我尽量保持屏幕上的窗口数不超过3个，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。</li>\n<li>我使用<a href=\"https://github.com/tmux/tmux/wiki\">tmux</a>windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。</li>\n</ul>\n<p>由于编辑风格不同，我的工作流程可能和您的工作流程不同，这没关系。您可以在实践中去探索适合您自己工作流程的编码风格。</p>\n","site":{"data":{}},"wordcount":4540,"excerpt":"","more":"<h1 id=\"第2章-缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs\"><a href=\"#第2章-缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs\" class=\"headerlink\" title=\"第2章 缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)\"></a>第2章 缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)</h1><p>(译者注：在Vim中，Buffers缓冲区，Windows窗口，Tabs选项卡是专有名词。为适应不同读者的翻译习惯，确保没有歧义，本文将不对Buffers、Windows、Tabs这三个词进行翻译)。  </p>\n<p>如果您使用过现代文本编辑器，您很可能对Windows和tabs这两个概念是非常熟悉的。但Vim使用了三个关于显示方面的抽象概念：buffers, windows, 还有tabs。在本章，我将向您解释什么是buffers, windows和tabs，以及它们在Vim中如何工作。</p>\n<p>在开始之前，确保您的vimrc文件中开启了<code>set hidden</code>选项。若没有配置该选项，当您想切换buffer且当前buffer没有保存时，Vim将提示您保存文件（如果您想快速切换，您不会想要这个提示）。我目前还没有讲vimrc，如果您没有vimrc配置文件，那就创建一个。它通常位于根目录下，名字叫<code>.vimrc</code>。我的vimrc位于<code>~/.vimrc</code>。要查看您自己的vimrc文件应该放置在哪，可以在Vim命令模式中输入<code>:h vimrc</code>。在vimrc文件中，添加：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-keyword\">hidden</span><br></code></pre></td></tr></table></figure>\n\n<p>保存好vimrc文件，然后激活它(在vimrc文件中运行<code>:source %</code>)。</p>\n<h2 id=\"Buffers\"><a href=\"#Buffers\" class=\"headerlink\" title=\"Buffers\"></a>Buffers</h2><p><em>buffer</em>到底是什么？</p>\n<p>buffer就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers。</p>\n<p>创建两个可使用的空文件，分别名为<code>file1.js</code>和<code>file2.js</code>（如果可能，尽量使用Vim来创建）。在终端中运行下面的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js<br></code></pre></td></tr></table></figure>\n\n<p>这时您看到的是<code>file1.js</code>的 <em>buffer</em> 。每当您打开一个新文件，Vim总是会创建一个新的buffer。</p>\n<p>退出Vim。这一次，打开两个新文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js file2.js<br></code></pre></td></tr></table></figure>\n\n<p>Vim当前显示的是<code>file1.js</code>的buffer，但它实际上创建了两个buffers：<code>file1.js</code>buffer和<code>file2.js</code>buffer。运行<code>:buffers</code>命令可以查看所有的buffers（另外，您也可以使用<code>:ls</code>和<code>:files</code>命令）。您应该会 <em>同时</em> 看到列出来的<code>file1.js</code>和<code>file2.js</code>。运行<code>vim file1 file2 file3 ... filen</code>创建n个buffers。每一次您打开一个新文件，Vim就为这个文件创建一个新的buffer。</p>\n<p>要遍历所有buffers，有以下几种方法：</p>\n<ul>\n<li><code>:bnext</code> 切换至下一个buffer（<code>:bprevious</code>切换至前一个buffer）。</li>\n<li><code>:buffer</code> + 文件名。（按下<code>&lt;Tab&gt;</code>键Vim会自动补全文件名）。 </li>\n<li><code>:buffer</code> + <code>n</code>, n是buffer的编号。比如，输入<code>:buffer 2</code>将使您切换到buffer #2。</li>\n<li>按下<code>Ctrl-O</code>将跳转至跳转列表中旧的位置，对应的，按下<code>Ctrl-I</code>将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转。我将在第5章详细讲述关于跳转的知识。</li>\n<li>按下<code>Ctrl-^</code>跳转至先前编辑过的buffer。</li>\n</ul>\n<p>一旦Vim创建了一个buffer，它将保留在您的buffers列表中。若想删除它，您可以输入<code>:bdelete</code>。这条命令也可以接收一个buffer编号（<code>:bdlete 3</code>将删除buffer #3）或一个文件名（<code>:bdelete</code>然后按<code>&lt;Tab&gt;</code>自动补全文件名）。</p>\n<p>我学习buffer时最困难的事情就是理解buffer如何工作，因为我当时的思维已经习惯了使用主流文本编辑器时关于窗口的概念。要理解buffer，可以打个很好的比方，就是打牌的桌面。如果您有2个buffers，就像您有一叠牌（2张）。您只能看见顶部的牌，虽然您知道在它下面还有其他的牌。如果您看见<code>file1.js</code>buffer，那么<code>file1.js</code>就是顶部的牌。虽然您看不到其他的牌<code>file2.js</code>，但它实际上就在那。如果您切换buffers到<code>file2.js</code>，那么<code>file2.js</code>这张牌就换到了顶部，而<code>file1.js</code>就换到了底部。</p>\n<p>如果您以前没有用过Vim，这是一个新的概念。花上几分钟理解一下。</p>\n<h2 id=\"退出Vim\"><a href=\"#退出Vim\" class=\"headerlink\" title=\"退出Vim\"></a>退出Vim</h2><p>顺带说一句，如果您已经打开了多个buffers，您可以使用quit -all来关闭所有的buffers：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:qall</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您想关闭所有buffers但不保存，仅需要在后面加<code>!</code>（叹号）就行了：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:qall!</span><br></code></pre></td></tr></table></figure>\n\n<p>若要保存所有buffers然后退出，请运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:wqall</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h2><p>一个window就是在buffer上的一个视口。如果您使用过主流的编辑器，Windows这个概念应该很熟悉。大部分文本编辑器具有显示多个窗口的能力。在Vim中，您同样可以拥有多个窗口。</p>\n<p>让我们从终端再次打开<code>file1.js</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js<br></code></pre></td></tr></table></figure>\n\n<p>先前我说过，您看到的是<code>file1.js</code>的buffer。但这个说法并不完整，现在这句话得更正一下，您看到的是<code>file1.js </code>的buffer通过 <strong>一个窗口</strong> 显示出来。窗口就是您查看的buffer所使用的视口。</p>\n<p>先不忙急着退出Vim，在Vim中运行：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">:<span class=\"hljs-built_in\">split</span> file2.js<br></code></pre></td></tr></table></figure>\n\n<p>现在您看到的是两个buffers通过 <strong>两个窗口</strong> 显示出来。上面的窗口显示的是<code>file2.js</code>的buffer。而下面的窗口显示的是<code>file1.js</code>的buffer。</p>\n<p>如果您想在窗口之间导航，使用这些快捷键：</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">Ctrl-<span class=\"hljs-keyword\">W</span> H    移动光标到左边的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> J    移动光标到下面的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> K    移动光标到上面的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> L    移动光标到右边的窗口<br></code></pre></td></tr></table></figure>\n\n<p>现在，在Vim中运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:vsplit</span> file3.js<br></code></pre></td></tr></table></figure>\n\n<p>您现在看到的是三个窗口显示三个buffers。一个窗口显示<code>file3.js</code>的buffer，一个窗口显示<code>file2.js</code>的buffer，还有一个窗口显示<code>file1.js</code>的buffer。</p>\n<p>您可以使多个窗口显示同一个buffer。当光标位于左上方窗口时，输入：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">:<span class=\"hljs-built_in\">buffer</span> file2.js<br></code></pre></td></tr></table></figure>\n\n<p>现在两个窗口显示的都是<code>file2.js</code>的buffer。如果您现在在这两个窗口中的某一个输入内容，您会看到所有显示<code>file2.js</code>buffer的窗口都在实时更新。</p>\n<p>要关闭当前的窗口，您可以按<code>Ctrl-W C</code>或输入<code>:quit</code>。当您关闭一个窗口后，buffers仍然会在列表中。（可以运行<code>:buffers</code>来确认这一点）。</p>\n<p>这里有一些普通模式下关于窗口的命令：</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">Ctrl-<span class=\"hljs-keyword\">W</span> V    打开一个新的垂直分割的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> S    打开一个新的水平分割的窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> C    关闭一个窗口<br>Ctrl-<span class=\"hljs-keyword\">W</span> O    除了当前窗口，关闭所有其他的窗口<br></code></pre></td></tr></table></figure>\n\n<p>另外，下面的列表列出了一些有用的关于windows的命令行命令</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tcl\">:vsplit <span class=\"hljs-keyword\">filename</span>    垂直分割当前窗口，并在新窗口中打开名为<span class=\"hljs-keyword\">filename</span>的文件。<br>:<span class=\"hljs-keyword\">split</span> <span class=\"hljs-keyword\">filename</span>     水平分割当前窗口，并在新窗口中打开名为<span class=\"hljs-keyword\">filename</span>的文件。<br>:new <span class=\"hljs-keyword\">filename</span>       创建一个新窗口并打开名为<span class=\"hljs-keyword\">filename</span>的文件。<br></code></pre></td></tr></table></figure>\n\n<p>花一点时间理解上面的知识。要了解更多信息，可以查看帮助<code>:h window</code>。</p>\n<h2 id=\"Tabs\"><a href=\"#Tabs\" class=\"headerlink\" title=\"Tabs\"></a>Tabs</h2><p>Tabs就是windows的集合。它就像窗口的布局。在大部分的现代文本编辑器（还有现代互联网浏览器）中，一个tab意味着打开一个文件&#x2F;页面，当您关闭标签，相应的文件&#x2F;页面就消失了。但在Vim中，tab并不表示打开了一个文件。当您在Vim中关闭一个tab，您并不是关闭一个文件。您仅仅关闭了窗口布局。文件的数据依然存储在内存中的buffers中。</p>\n<p>让我们运行几个命令看看Vim中tabs的功能。打开<code>file1.js</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim file1.js<br></code></pre></td></tr></table></figure>\n\n<p>若要在新tab中打开<code>file2.js</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tabnew</span> file2.js<br></code></pre></td></tr></table></figure>\n\n<p>当然您可以按<code>&lt;Tab&gt;</code>让Vim自动补全 <em>新tab</em> 中将要打开的文件名（啰嗦几句，请理解作者的幽默 ）。</p>\n<p>下面的列表列出了一些有用的关于tab导航的命令：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">tabnew</span> <span class=\"hljs-keyword\">file</span>.txt    在<span class=\"hljs-keyword\">tab</span>中打开一个文件<br>:<span class=\"hljs-keyword\">tabclose</span>           关闭当前<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tabnext</span>            切换至下一个<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tabprevious</span>        切换至前一个<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tablast</span>            切换至最后一个<span class=\"hljs-keyword\">tab</span><br>:<span class=\"hljs-keyword\">tabfirst</span>           切换至第一个<span class=\"hljs-keyword\">tab</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以输入<code>gt</code>切换到下一个标签页（对应的，可以用<code>gT</code>切换到前一个标签页）。您也可以传递一个数字作为参数给<code>gt</code>，这个数字是tab的编号。若想切换到第3个tab，输入<code>3gt</code>。</p>\n<p>拥有多个tabs的好处是，您可以在不同的tab中使用不同的窗口布局。也许，您想让您的第1个tab包含3个垂直分割的窗口，然后让第2个tab为水平分割和垂直分割混合的窗口布局。tab是完成这件工作的完美工具!</p>\n<p>若想让Vim启动时就包含多个tabs，您可以在终端中运行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -p file1.js file2.js file3.js<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三维移动\"><a href=\"#三维移动\" class=\"headerlink\" title=\"三维移动\"></a>三维移动</h2><p>在windows之间移动就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动。您可以使用<code>Ctrl-W H/J/K/L</code>移动到上面、右侧、下面、以及左侧的窗口。</p>\n<p>在buffer之间移动就像在笛卡尔坐标系的Z轴上穿梭。想象您的buffer文件在Z轴上呈线性排列，您可以使用<code>:bnext</code>和<code>bprevious</code>在Z轴上一次一个buffer地遍历。您也可以使用<code>:buffer 文件名/buffer编号</code>在Z轴上跳转到任意坐标。</p>\n<p>结合window和buffer的移动，您可以在 <em>三维空间</em> 中移动。您可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）。因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）。</p>\n<h2 id=\"用聪明的方法使用Buffers、Windows、以及Tabs\"><a href=\"#用聪明的方法使用Buffers、Windows、以及Tabs\" class=\"headerlink\" title=\"用聪明的方法使用Buffers、Windows、以及Tabs\"></a>用聪明的方法使用Buffers、Windows、以及Tabs</h2><p>您已经学习了什么是buffers、windows、以及tabs，也学习了它们如何在Vim中工作。现在您对它们有了更好地理解，您可以把它们用在您自己的工作流程中。</p>\n<p>每个人都有不同的工作流程，以下示例是我的工作流程：</p>\n<ul>\n<li>首先，对于某个特定任务，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。</li>\n<li>当比对文件、读文档、或追踪代码流时，我使用多窗口来一次查看多个buffers。我尽量保持屏幕上的窗口数不超过3个，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。</li>\n<li>我使用<a href=\"https://github.com/tmux/tmux/wiki\">tmux</a>windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。</li>\n</ul>\n<p>由于编辑风格不同，我的工作流程可能和您的工作流程不同，这没关系。您可以在实践中去探索适合您自己工作流程的编码风格。</p>\n"},{"title":"VIM-打开和搜索文件","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第3章 打开和搜索文件\n\n本章的目的是向您介绍如何在Vim中快速搜索，能够快速搜索是提高您的Vim工作效率的重要途径。当我解决了如何快速搜索文件这个问题后，我就决定改为完全使用Vim来工作。\n\n本章划分为两个部分：一是如何不依赖插件搜索；二是使用[fzf插件](https://github.com/junegunn/fzf.vim)搜索。让我们开始吧！\n\n## 打开和编辑文件\n\n要在Vim中打开一个文件，您可以使用`:edit`。\n\n```\n:edit file.txt\n```\n\n如果`file.txt`已经存在，就会打开`file.txt`buffer。如果`file.txt`不存在，会创建一个新buffer名为`file.txt`。\n\n`:edit`命令支持使用`<Tab>`进行自动补全。比如，如果您的文件位于[Rails](https://rubyonrails.org/)应用控制器的用户控制器目录`./app/controllers/users_controllers.rb`内，您可以使用`<Tab>`对文件路径名进行快速扩展。\n\n```\n:edit a<Tab>c<Tab>u<Tab>\n```\n\n`:edit`可以接收通配符参数。`*`匹配当前目录下的任意文件。如果您只想查找当前目录下后缀名为`.yml`的文件：\n\n```\n:edit *.yml<Tab>\n```\n\nVim将列出当前目录下所有`.yml`文件供您选择。\n\n您可以使用`**`进行递归的搜索。如果您想查找当前项目文件夹下所有`*.md`文件，但您不知道在哪个目录，您可以这样做：\n\n```\n:edit **/*.md<Tab>\n```\n\n`:edit`可以用于运行`netrw`（Vim的内置文件浏览器）。使用方法是，给`:edit`一个目录参数而不是文件名就行了：\n\n```\n:edit .\n:edit test/unit/\n```\n\n## 使用find命令搜索文件\n\n您可以使用`:find`命令搜索文件。比如：\n\n```\n:find package.json\n:find app/controllers/users_controller.rb\n```\n\n`:find`命令同样支持自动补全：\n\n```\n:find p<Tab>                \" to find package.json\n:find a<Tab>c<Tab>u<Tab>    \" to find app/controllers/users_controller.rb\n```\n\n您可能注意到`:find`和`:edit`看起来很像。它们的区别是什么呢？\n\n## Find 和 Path\n\n两者的区别在于，`:find`命令根据`path`选项配置的路径查找文件，而`:edit`不会。让我们了解一点关于`path`选项的知识。一旦您学会如何修改您的路径，`:find`命令能变成一个功能强大的搜索工具。先查看一下您的`path`是什么：\n\n```\n:set path?\n```\n\n默认情况下，您的`path`内容很可能是这样的：\n\n```\npath=.,/usr/include,,\n```\n\n- `.` 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 **当前所打开的文件** 所在的目录)\n- `,` means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号`,`应该是表示路径之间的分割符。连续的两个`,,`（两个逗号之间为空）才表示当前目录)\n- `/usr/include` 表示在C编译器头文件目录下搜索。\n\n前两个配置非常重要，第3个现在可以被忽略。您这里应该记住的是：您可以修改您自己的路径。让我们假设您的项目结构是这样的：\n\n```\napp/\n  assets/\n  controllers/\n    application_controller.rb\n    comments_controller.rb\n    users_controller.rb\n    ...\n```\n\n如果您想从根目录跳到`users_controller.rb`，您将不得不经过好几层目录（按好几次`<Tab>`）。一般说来，当您处理一个framework时，90%的时间您都在某个特定的目录下。在这种情况下，您只关心如何用最少的按键跳到`controllers/`目录。那么`path`设置可以减少这个途程。\n\n您只需要将`app/controllers/`添加到当前`path`选项。以下是操作步骤：\n\n```\n:set path+=app/controllers/\n```\n\n现在您的路径已经更新，当您输入`:find u<Tab>`时，Vim将会在`app/controllers/`目录内搜索所有以\"u\"开头的文件。\n\n如果您有一个嵌套的目录`controllers/`，比如`app/controllers/account/users_controller.rb`，Vim就找不到`users_controllers`了。您必须改为添加`:set path+=app/controllers/**`，这样自动补全才会找到`users_controller.rb`。这太棒了！您现在可以只需要按1次键就可找到users controller。\n\n您可能会想将整个项目文件夹添加到`path`中，这样当您按`<Tab>`，Vim将在所有文件夹内搜索您要找的文件，就像这样：\n\n```\n:set path+=$PWD/**\n```\n\n`$PWD` 表示的是当前工作目录。如果您尝试将整个项目路径加到`path`中，并希望让所有文件名可以用`<Tab>`补全，虽然对于小项目没问题，但如果您的项目中包含大量文件时，这会显著降低您的搜索速度。我建议仅仅将您最常访问的文件/目录添加到`path`。（译者注：不知道是不是因为系统环境不一样的原因，译者使用的是windows下的Vim8.2，\\$PWD 这个环境变量在译者的vim中不起作用，必须在vimrc文件中添加一句`let $PWD=getcwd()`才行）。\n\n您可以将`set path+={您需要添加的目录}`添加到您的vimrc文件中。更新`path`仅花费几秒钟，但可以为您的工作节省很多时间。\n\n## 使用Grep命令在文件中搜索\n\n如果您想在文件内部查找（搜索文件中的词句），您可以使用grep。Vim有两个方法可以完成这个工作：\n\n- 内置grep （`:vim`。没错，就是`:vim`，它是`:vimgrep`的简写）。\n- 外部grep (`:grep`)。\n\n让我们首先仔细看看内置grep。`:vim`有以下语法：\n\n```\n:vim /pattern/ file\n```\n\n- `/pattern/` 是您要搜索的内容的正则表达式。\n- `file` 是文件参数。您可以传入多个参数。Vim将在文件中搜索所有匹配正则表达式的内容。类似于`:find`，您可以传入*和**通配符。\n\n比如，要在`app/controllers/`目录下所有ruby文件(`.rb`)中，查找所有的\"breakfast\"字符串:\n\n```\n:vim /breakfast/ app/controllers/**/*.rb\n```\n\n输入上面的命令后，您将会被导航到第一个结果。Vim的`vim`搜索命令使用`quickfix`进行处理。要查看所有搜索结果，运行`:copen`会打开一个`quickfix`窗口。下面有一些有用的quickfix命令，可以让您提高效率：\n\n```\n:copen        打开quickfix窗口\n:cclose       关闭quickfix窗口\n:cnext        跳到下一个错误\n:cprevious    跳到前一个错误\n:colder       跳到旧的错误列表\n:cnewer       跳到新的错误列表\n```\n\n要了解更多关于quickfix的信息，使用`:h quickfix`查看帮助信息。\n\n您可能注意到运行内置grep(`:vim`)命令时，如果匹配结果数量较多时系统速度会变慢。这是因为Vim将每一个搜索结果读入内存。Vim加载每一个匹配的文件就像它们被编辑一样。如果Vim查到大量文件，它将消耗很多内存。\n\n让我们谈谈外置grep。默认情况下，它使用终端命令`grep`。要想在`app/controllers/`目录中搜索字符串\"lunch\"，您可以这样做：\n\n```\n:grep -R \"lunch\" app/controllers/\n```\n\n注意这里不是使用`/pattern/`，它遵循的是终端grep的语法`\"pattern\"`，它同样使用'quickfix'来显示所有的匹配结果。\n\nVim使用`grepprg`变量来决定运行`:grep`时，应该使用哪个外部程序。所以您并不是非得使用终端的`grep`命令。稍后我将为您演示如何改变外部grep程序的默认值。\n\n## 用Netrw浏览文件\n\n`netrw`是Vim的内置文件浏览器，当查看项目的目录结构时很有用。要运行`netrw`，您需要在您的`.vimrc`中做以下设置：\n\n```\nset nocp\nfiletype plugin on\n```\n\n由于`netrw`是一个很宽泛的话题，我将紧紧介绍它的基本用法，这应该已经足够了。您可以在启动Vim时运行`netrw`，只需要传给Vim一个目录参数（而不是文件参数）就行了。比如：\n\n```\nvim .\nvim src/client/\nvim app/controllers/\n```\n\n要想从Vim内部运行`netrw`，您可以使用`:edit`命令，传给他一个目录而不是文件名：\n\n```\n:edit .\n:edit src/client/\n:edit app/controllers/\n```\n\n也有其他方法，不需要传递目录参数就运行`netrw`窗口：\n\n```\n:Explore     从当前文件启动netrw。\n:Sexplore    Sex_Plore?不是开玩笑:)，在顶部水平分割的窗口打开netrw。\n:Vexplore    在左侧垂直分割的窗口打开netrw。\n```\n\n您可以使用Vim动作(motions，在后面的章节中将详细讲述)在`netrw`中导航。如果您要创建、删除、重命名文件或文件夹，下面有一些关于`netrw`的有用命令：\n\n```\n%    创建新文件\nd    创建新目录\nR    重命名文件/目录\nD    删除文件/目录\n```\n\n`:h netrw` 的信息非常复杂，如果您有时间可以看看。\n\n如果您觉得 `netrw` 过于单调乏味，[vim-vinegar](https://github.com/tpope/vim-vinegar)是netrw的一个改进插件。如果您想找一个不同的文件浏览器，[NERDTree](https://github.com/preservim/nerdtree) 是一个很好的选择。去看看吧。\n\n## Fzf插件\n\n您现在已经学会了如何使用Vim的内置工具去搜索文件，那么让我们学习一下如何用插件实现这些功能吧。\n\n现代文本编辑器相比Vim，有一个功能设计得很好，那就是文件搜索和模糊搜索的简化。在本章的下半部分，我将向您演示如何使用[fzf.vim](https://github.com/junegunn/fzf.vim)插件，在Vim中轻松实现功能强大的搜索功能。\n\n## 安装\n\n首先，确保您下载了[fzf](https://github.com/junegunn/fzf)和[ripgrep](https://github.com/BurntSushi/ripgrep)。按照它们在github仓库上的指令一步步做。成功安装后，命令`fzf`和`rg`应该就可以用了。\n\nRipgrep是一个类似grep（从名字上就看得出）的搜索工具。一般说来，它比grep要快，而且还有很多有用的特性。Fzf是一个多用途的命令行模糊搜索工具，您可以讲它与其他命令联合起来使用，包括ripgrep。联合起来后，它们成为一个功能强大的搜索工具。\n\nFzf默认并不使用ripgrep，所以我们需要设置`FZF_DEFAULT_COMMAND`变量告诉fzf使用ripgrep命令。在我的`.zshrc`（如果您用bash，应该是`.bashrc`）文件内，我有以下设置：\n\n```\nif type rg &> /dev/null; then\n  export FZF_DEFAULT_COMMAND='rg --files'\n  export FZF_DEFAULT_OPTS='-m'\nfi\n```\n\n注意`FZF_DEFAULT_OPTS`变量中的`-m`。这个设置允许我们按下`<Tab`或`<Shift-Tab>`后进行多重选择。如果仅想让fzf在Vim中能够工作，这个设置不是必须的，但我认为这是一个有用的设置。当您想在多个文件中执行搜索和替换，进行少量修改时，它会很方便。fzf命令可以接收很多标志，但我不会再这里讲。要想了解更多信息，可以查看[fzf's 仓库](https://github.com/junegunn/fzf#usage)，或者使用`man fzf`。要想让fzf使用ripgrep，您至少得有这个设置`export FZF_DEFAULT_COMMAND='rg'`。\n\n安装好了fzf和ripgrep后，让我们再安装fzf的插件。在这个例子中，我使用的是[vim-plug](https://github.com/junegunn/vim-plug)插件管理器，当然您可以使用其他插件管理器。\n\n将下列配置添加到您的`.vimrc`中。因为您需要使用[fzf.vim](https://github.com/junegunn/fzf.vim)插件。（同样是由fzf的作者在维护）\n\n```\nPlug 'junegunn/fzf.vim'\nPlug 'junegunn/fzf', { 'do': { -> fzf#install() } }\n```\n\n添加后，您需要打开vim，运行`:PlugInstall`。这条命令将会安装所有您在`vimrc`文件中定义了但尚未安装的插件。 在我的例子中，将会安装`fzf.vim`和`fzf`。\n\n要了解更多关于此插件的信息，您可以查看[fzf.vim 的仓库](https://github.com/junegunn/fzf/blob/master/README-VIM.md)。\n\n## Fzf的语法\n\n要想高效的使用fzf，您首先得了解一些fzf的基础语法。幸运的是，这个列表比较短：\n\n- `^` 表示前缀精确匹配。要搜索一个以\"welcome\"开头的短语：`^welcom`。\n- `$` 表示后缀精确匹配。要搜索一个以\"my friends\"结尾的短语：`friends$`。\n- `'` 表示精确匹配。要搜索短语\"welcom my friends\"：`'welcom my friends`。\n- `|` 表示\"或者\"匹配。要搜索\"friends\"或\"foes\"：`friends | foes`。\n- `!` 表示反向匹配。要搜索一个包含\"welcome\"但不包含\"friends\"的短语：`welcome !friends`。\n\n您可以混合起来使用。比如，`^hello | ^welcome friends$`将搜索以\"welcome\"或\"hello\"开头，并且以\"friends\"结束的短语。\n\n## 查找文件\n\n要想在Vim内使用fzf.vim插件搜索文件，您可以使用`:Files`方法。在Vim中运行`:Files`，您将看到fzf搜索提示符。\n\n因为您将频繁地使用这个命令，最好建立一个键盘映射，我把它映射到`Ctrl-f`。在我的vimrc配置中，有这个设置：\n\n```\nnnoremap <silent> <C-f> :Files<CR>\n```\n\n## 在文件中查找\n\n要想在文件内部搜索，您可以使用`:Rg`命令。\n\n同样，因为您可能将频繁的使用这个命令，让我们给它一个键盘映射。我的映射在`<Leader>f`。\n\n```\nnnoremap <silent> <Leader>f :Rg<CR>\n```\n\n## 其他搜索\n\nFzf.vim提供了许多其他命令。这里我不会一个个仔细讲，您可以去[这里](https://github.com/junegunn/fzf.vim#commands)查看更多信息。\n\n这是我的fzf键盘映射：\n\n```\nnnoremap <silent> <Leader>b :Buffers<CR>\nnnoremap <silent> <C-f> :Files<CR>\nnnoremap <silent> <Leader>f :Rg<CR>\nnnoremap <silent> <Leader>/ :BLines<CR>\nnnoremap <silent> <Leader>' :Marks<CR>\nnnoremap <silent> <Leader>g :Commits<CR>\nnnoremap <silent> <Leader>H :Helptags<CR>\nnnoremap <silent> <Leader>hh :History<CR>\nnnoremap <silent> <Leader>h: :History:<CR>\nnnoremap <silent> <Leader>h/ :History/<CR>\n```\n\n## 将Grep替换为Rg\n\n正如前面提到的，Vim有两种方法在文件内搜索：`:vim`和`:grep`。您可以使用`grepprg`这个关键字重新指定`:grep`使用的外部搜索工具。我将向您演示如何设置Vim，使得当运行`:grep`命令时，使用ripgrep代替终端的grep。\n\n现在，让我们设置`grepprg`来使`:grep`使用ripgrep。将下列设置添加到您的vimrc：\n\n```\nset grepprg=rg\\ --vimgrep\\ --smart-case\\ --follow\n```\n\n上面的一些选项可以随意修改！要想了解更多关于这些选项的含义，请使用`man rg`了解详情。\n\n当您更新`grepprg`选项后，现在当您运行`:grep`，它将实际运行`rg --vimgrep --smart-case --follow`而不是`grep`。如果您想使用ripgrep搜索\"donut\"，您可以运行一条更简洁的命令`:grep \"donut\"`，而不是`:grep \"donut\" . -R`\n\n就像老的`:grep`一样，新的`:grep`同样使用quickfix窗口来显示结果。\n\n您可能好奇，“很好，但我从没在Vim中使用过`:grep`，为什么我不能直接使用`:Rg`命令在文件中搜索呢？究竟什么时候我必须使用`:grep`？”。\n\n这个问题问得很好。在Vim中，当您需要在多个文件中执行搜索和替换时，您可能必须使用`:grep`这个命令。我马上就会讲这个问题。\n\n## 在多文件中搜索和替换\n\n现代文本编辑器，比如VSCode中，在多个文件中搜索和替换一个字符串是很简单的事情。在这一节，我将向您演示如何在Vim中轻松实现这个。\n\n第一个方法是在您的项目中替换 **所有** 的匹配短句。您得使用`:grep`命令。如果您想将所有\"pizza\"替换为\"donut\"，下面是操作方法：\n\n```\n:grep \"pizza\"\n:cfdo %s/pizza/donut/g | update\n```\n\n让我们来分析一下这条命令：\n\n1. `:grep pizza`使用ripgrep去搜索所有\"pizza\"（顺带说一句，就算您不给`grepprg`重新赋值让它使用ripgrep，这条命令依然有效，但您可能不得不使用`:grep \"pizza\" . -R`命令，而不是`:grep \"pizza\"`）。\n2. `:cfdo`会在您的quickfix列表中所有文件里，执行您传递给它的命令。在这个例子中，您的命令是一条替换命令`%s/pizza/donut/g`。管道符号(`|`)是一个链接操作符。命令`update`在每个文件被替换后，立刻保存。在后面的章节中，我将深入介绍替换命令。\n\n第二个方法是在您选择文件中执行搜索和替换。用这个方法，您可以手动选择您想执行搜索和替换的文件。下面是操作方法：\n\n1. 首先清空您的buffer。让您的buffer列表仅包含您所需要的文件，这一点很有必要。您可以重启Vim，也可以运行`:%bd | e#`命令（`%bd`关闭所有buffer，而`e#`打开您当前所在的文件）。\n2. 运行`:Files`。\n3. 选择好您想搜索-替换的文件。要选择多个文件，使用`<Tab>`或`<Shift-Tab>`。当然，您必须使多文件标志(`-m`)位于`FZF_DEFAULT_OPTS`中。\n4. 运行`:bufdo %s/pizza/donut/g | update`。命令`:bufdo %s/pizza/donut/g | update`看起来和前面的`:cfdo %s/pizza/donut/g | update`很像，区别在于，(`:cfdo`)替换所有quickfix中的实体，而(`:bufdo`)替换所有buffer中的实体。\n\n## 用聪明的方法学习搜索\n\n在文本编辑时，搜索是一个很实用的技巧。学会在Vim中如何搜索，将显著提高您的文本编辑工作流程效率。\n\nFzf.vim插件就像一个游戏规则改变者。我无法想象使用Vim没有它的情景。当最开始使用Vim时，如果有一个好的搜索工具，我想是非常重要的。我看见很多人过渡到Vim时的艰难历程，就是因为Vim缺少了现代编辑器所拥有的一些关键功能特性，比如简单快捷且功能强大的搜索功能。我希望本章将帮助您更轻松地向Vim过渡。\n\n您同时也看到了Vim的扩展性，即使用插件或外部程序扩展搜索功能的能力。将来，记住您想在Vim中拓展的功能。很有可能已经有人写好了相关插件，已经有现成的程序了。下一章，您将学习Vim中非常重要的主题：Vim语法。\n","source":"_posts/Vim/ch03_searching_files.md","raw":"---\ntitle: VIM-打开和搜索文件\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第3章 打开和搜索文件\n\n本章的目的是向您介绍如何在Vim中快速搜索，能够快速搜索是提高您的Vim工作效率的重要途径。当我解决了如何快速搜索文件这个问题后，我就决定改为完全使用Vim来工作。\n\n本章划分为两个部分：一是如何不依赖插件搜索；二是使用[fzf插件](https://github.com/junegunn/fzf.vim)搜索。让我们开始吧！\n\n## 打开和编辑文件\n\n要在Vim中打开一个文件，您可以使用`:edit`。\n\n```\n:edit file.txt\n```\n\n如果`file.txt`已经存在，就会打开`file.txt`buffer。如果`file.txt`不存在，会创建一个新buffer名为`file.txt`。\n\n`:edit`命令支持使用`<Tab>`进行自动补全。比如，如果您的文件位于[Rails](https://rubyonrails.org/)应用控制器的用户控制器目录`./app/controllers/users_controllers.rb`内，您可以使用`<Tab>`对文件路径名进行快速扩展。\n\n```\n:edit a<Tab>c<Tab>u<Tab>\n```\n\n`:edit`可以接收通配符参数。`*`匹配当前目录下的任意文件。如果您只想查找当前目录下后缀名为`.yml`的文件：\n\n```\n:edit *.yml<Tab>\n```\n\nVim将列出当前目录下所有`.yml`文件供您选择。\n\n您可以使用`**`进行递归的搜索。如果您想查找当前项目文件夹下所有`*.md`文件，但您不知道在哪个目录，您可以这样做：\n\n```\n:edit **/*.md<Tab>\n```\n\n`:edit`可以用于运行`netrw`（Vim的内置文件浏览器）。使用方法是，给`:edit`一个目录参数而不是文件名就行了：\n\n```\n:edit .\n:edit test/unit/\n```\n\n## 使用find命令搜索文件\n\n您可以使用`:find`命令搜索文件。比如：\n\n```\n:find package.json\n:find app/controllers/users_controller.rb\n```\n\n`:find`命令同样支持自动补全：\n\n```\n:find p<Tab>                \" to find package.json\n:find a<Tab>c<Tab>u<Tab>    \" to find app/controllers/users_controller.rb\n```\n\n您可能注意到`:find`和`:edit`看起来很像。它们的区别是什么呢？\n\n## Find 和 Path\n\n两者的区别在于，`:find`命令根据`path`选项配置的路径查找文件，而`:edit`不会。让我们了解一点关于`path`选项的知识。一旦您学会如何修改您的路径，`:find`命令能变成一个功能强大的搜索工具。先查看一下您的`path`是什么：\n\n```\n:set path?\n```\n\n默认情况下，您的`path`内容很可能是这样的：\n\n```\npath=.,/usr/include,,\n```\n\n- `.` 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 **当前所打开的文件** 所在的目录)\n- `,` means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号`,`应该是表示路径之间的分割符。连续的两个`,,`（两个逗号之间为空）才表示当前目录)\n- `/usr/include` 表示在C编译器头文件目录下搜索。\n\n前两个配置非常重要，第3个现在可以被忽略。您这里应该记住的是：您可以修改您自己的路径。让我们假设您的项目结构是这样的：\n\n```\napp/\n  assets/\n  controllers/\n    application_controller.rb\n    comments_controller.rb\n    users_controller.rb\n    ...\n```\n\n如果您想从根目录跳到`users_controller.rb`，您将不得不经过好几层目录（按好几次`<Tab>`）。一般说来，当您处理一个framework时，90%的时间您都在某个特定的目录下。在这种情况下，您只关心如何用最少的按键跳到`controllers/`目录。那么`path`设置可以减少这个途程。\n\n您只需要将`app/controllers/`添加到当前`path`选项。以下是操作步骤：\n\n```\n:set path+=app/controllers/\n```\n\n现在您的路径已经更新，当您输入`:find u<Tab>`时，Vim将会在`app/controllers/`目录内搜索所有以\"u\"开头的文件。\n\n如果您有一个嵌套的目录`controllers/`，比如`app/controllers/account/users_controller.rb`，Vim就找不到`users_controllers`了。您必须改为添加`:set path+=app/controllers/**`，这样自动补全才会找到`users_controller.rb`。这太棒了！您现在可以只需要按1次键就可找到users controller。\n\n您可能会想将整个项目文件夹添加到`path`中，这样当您按`<Tab>`，Vim将在所有文件夹内搜索您要找的文件，就像这样：\n\n```\n:set path+=$PWD/**\n```\n\n`$PWD` 表示的是当前工作目录。如果您尝试将整个项目路径加到`path`中，并希望让所有文件名可以用`<Tab>`补全，虽然对于小项目没问题，但如果您的项目中包含大量文件时，这会显著降低您的搜索速度。我建议仅仅将您最常访问的文件/目录添加到`path`。（译者注：不知道是不是因为系统环境不一样的原因，译者使用的是windows下的Vim8.2，\\$PWD 这个环境变量在译者的vim中不起作用，必须在vimrc文件中添加一句`let $PWD=getcwd()`才行）。\n\n您可以将`set path+={您需要添加的目录}`添加到您的vimrc文件中。更新`path`仅花费几秒钟，但可以为您的工作节省很多时间。\n\n## 使用Grep命令在文件中搜索\n\n如果您想在文件内部查找（搜索文件中的词句），您可以使用grep。Vim有两个方法可以完成这个工作：\n\n- 内置grep （`:vim`。没错，就是`:vim`，它是`:vimgrep`的简写）。\n- 外部grep (`:grep`)。\n\n让我们首先仔细看看内置grep。`:vim`有以下语法：\n\n```\n:vim /pattern/ file\n```\n\n- `/pattern/` 是您要搜索的内容的正则表达式。\n- `file` 是文件参数。您可以传入多个参数。Vim将在文件中搜索所有匹配正则表达式的内容。类似于`:find`，您可以传入*和**通配符。\n\n比如，要在`app/controllers/`目录下所有ruby文件(`.rb`)中，查找所有的\"breakfast\"字符串:\n\n```\n:vim /breakfast/ app/controllers/**/*.rb\n```\n\n输入上面的命令后，您将会被导航到第一个结果。Vim的`vim`搜索命令使用`quickfix`进行处理。要查看所有搜索结果，运行`:copen`会打开一个`quickfix`窗口。下面有一些有用的quickfix命令，可以让您提高效率：\n\n```\n:copen        打开quickfix窗口\n:cclose       关闭quickfix窗口\n:cnext        跳到下一个错误\n:cprevious    跳到前一个错误\n:colder       跳到旧的错误列表\n:cnewer       跳到新的错误列表\n```\n\n要了解更多关于quickfix的信息，使用`:h quickfix`查看帮助信息。\n\n您可能注意到运行内置grep(`:vim`)命令时，如果匹配结果数量较多时系统速度会变慢。这是因为Vim将每一个搜索结果读入内存。Vim加载每一个匹配的文件就像它们被编辑一样。如果Vim查到大量文件，它将消耗很多内存。\n\n让我们谈谈外置grep。默认情况下，它使用终端命令`grep`。要想在`app/controllers/`目录中搜索字符串\"lunch\"，您可以这样做：\n\n```\n:grep -R \"lunch\" app/controllers/\n```\n\n注意这里不是使用`/pattern/`，它遵循的是终端grep的语法`\"pattern\"`，它同样使用'quickfix'来显示所有的匹配结果。\n\nVim使用`grepprg`变量来决定运行`:grep`时，应该使用哪个外部程序。所以您并不是非得使用终端的`grep`命令。稍后我将为您演示如何改变外部grep程序的默认值。\n\n## 用Netrw浏览文件\n\n`netrw`是Vim的内置文件浏览器，当查看项目的目录结构时很有用。要运行`netrw`，您需要在您的`.vimrc`中做以下设置：\n\n```\nset nocp\nfiletype plugin on\n```\n\n由于`netrw`是一个很宽泛的话题，我将紧紧介绍它的基本用法，这应该已经足够了。您可以在启动Vim时运行`netrw`，只需要传给Vim一个目录参数（而不是文件参数）就行了。比如：\n\n```\nvim .\nvim src/client/\nvim app/controllers/\n```\n\n要想从Vim内部运行`netrw`，您可以使用`:edit`命令，传给他一个目录而不是文件名：\n\n```\n:edit .\n:edit src/client/\n:edit app/controllers/\n```\n\n也有其他方法，不需要传递目录参数就运行`netrw`窗口：\n\n```\n:Explore     从当前文件启动netrw。\n:Sexplore    Sex_Plore?不是开玩笑:)，在顶部水平分割的窗口打开netrw。\n:Vexplore    在左侧垂直分割的窗口打开netrw。\n```\n\n您可以使用Vim动作(motions，在后面的章节中将详细讲述)在`netrw`中导航。如果您要创建、删除、重命名文件或文件夹，下面有一些关于`netrw`的有用命令：\n\n```\n%    创建新文件\nd    创建新目录\nR    重命名文件/目录\nD    删除文件/目录\n```\n\n`:h netrw` 的信息非常复杂，如果您有时间可以看看。\n\n如果您觉得 `netrw` 过于单调乏味，[vim-vinegar](https://github.com/tpope/vim-vinegar)是netrw的一个改进插件。如果您想找一个不同的文件浏览器，[NERDTree](https://github.com/preservim/nerdtree) 是一个很好的选择。去看看吧。\n\n## Fzf插件\n\n您现在已经学会了如何使用Vim的内置工具去搜索文件，那么让我们学习一下如何用插件实现这些功能吧。\n\n现代文本编辑器相比Vim，有一个功能设计得很好，那就是文件搜索和模糊搜索的简化。在本章的下半部分，我将向您演示如何使用[fzf.vim](https://github.com/junegunn/fzf.vim)插件，在Vim中轻松实现功能强大的搜索功能。\n\n## 安装\n\n首先，确保您下载了[fzf](https://github.com/junegunn/fzf)和[ripgrep](https://github.com/BurntSushi/ripgrep)。按照它们在github仓库上的指令一步步做。成功安装后，命令`fzf`和`rg`应该就可以用了。\n\nRipgrep是一个类似grep（从名字上就看得出）的搜索工具。一般说来，它比grep要快，而且还有很多有用的特性。Fzf是一个多用途的命令行模糊搜索工具，您可以讲它与其他命令联合起来使用，包括ripgrep。联合起来后，它们成为一个功能强大的搜索工具。\n\nFzf默认并不使用ripgrep，所以我们需要设置`FZF_DEFAULT_COMMAND`变量告诉fzf使用ripgrep命令。在我的`.zshrc`（如果您用bash，应该是`.bashrc`）文件内，我有以下设置：\n\n```\nif type rg &> /dev/null; then\n  export FZF_DEFAULT_COMMAND='rg --files'\n  export FZF_DEFAULT_OPTS='-m'\nfi\n```\n\n注意`FZF_DEFAULT_OPTS`变量中的`-m`。这个设置允许我们按下`<Tab`或`<Shift-Tab>`后进行多重选择。如果仅想让fzf在Vim中能够工作，这个设置不是必须的，但我认为这是一个有用的设置。当您想在多个文件中执行搜索和替换，进行少量修改时，它会很方便。fzf命令可以接收很多标志，但我不会再这里讲。要想了解更多信息，可以查看[fzf's 仓库](https://github.com/junegunn/fzf#usage)，或者使用`man fzf`。要想让fzf使用ripgrep，您至少得有这个设置`export FZF_DEFAULT_COMMAND='rg'`。\n\n安装好了fzf和ripgrep后，让我们再安装fzf的插件。在这个例子中，我使用的是[vim-plug](https://github.com/junegunn/vim-plug)插件管理器，当然您可以使用其他插件管理器。\n\n将下列配置添加到您的`.vimrc`中。因为您需要使用[fzf.vim](https://github.com/junegunn/fzf.vim)插件。（同样是由fzf的作者在维护）\n\n```\nPlug 'junegunn/fzf.vim'\nPlug 'junegunn/fzf', { 'do': { -> fzf#install() } }\n```\n\n添加后，您需要打开vim，运行`:PlugInstall`。这条命令将会安装所有您在`vimrc`文件中定义了但尚未安装的插件。 在我的例子中，将会安装`fzf.vim`和`fzf`。\n\n要了解更多关于此插件的信息，您可以查看[fzf.vim 的仓库](https://github.com/junegunn/fzf/blob/master/README-VIM.md)。\n\n## Fzf的语法\n\n要想高效的使用fzf，您首先得了解一些fzf的基础语法。幸运的是，这个列表比较短：\n\n- `^` 表示前缀精确匹配。要搜索一个以\"welcome\"开头的短语：`^welcom`。\n- `$` 表示后缀精确匹配。要搜索一个以\"my friends\"结尾的短语：`friends$`。\n- `'` 表示精确匹配。要搜索短语\"welcom my friends\"：`'welcom my friends`。\n- `|` 表示\"或者\"匹配。要搜索\"friends\"或\"foes\"：`friends | foes`。\n- `!` 表示反向匹配。要搜索一个包含\"welcome\"但不包含\"friends\"的短语：`welcome !friends`。\n\n您可以混合起来使用。比如，`^hello | ^welcome friends$`将搜索以\"welcome\"或\"hello\"开头，并且以\"friends\"结束的短语。\n\n## 查找文件\n\n要想在Vim内使用fzf.vim插件搜索文件，您可以使用`:Files`方法。在Vim中运行`:Files`，您将看到fzf搜索提示符。\n\n因为您将频繁地使用这个命令，最好建立一个键盘映射，我把它映射到`Ctrl-f`。在我的vimrc配置中，有这个设置：\n\n```\nnnoremap <silent> <C-f> :Files<CR>\n```\n\n## 在文件中查找\n\n要想在文件内部搜索，您可以使用`:Rg`命令。\n\n同样，因为您可能将频繁的使用这个命令，让我们给它一个键盘映射。我的映射在`<Leader>f`。\n\n```\nnnoremap <silent> <Leader>f :Rg<CR>\n```\n\n## 其他搜索\n\nFzf.vim提供了许多其他命令。这里我不会一个个仔细讲，您可以去[这里](https://github.com/junegunn/fzf.vim#commands)查看更多信息。\n\n这是我的fzf键盘映射：\n\n```\nnnoremap <silent> <Leader>b :Buffers<CR>\nnnoremap <silent> <C-f> :Files<CR>\nnnoremap <silent> <Leader>f :Rg<CR>\nnnoremap <silent> <Leader>/ :BLines<CR>\nnnoremap <silent> <Leader>' :Marks<CR>\nnnoremap <silent> <Leader>g :Commits<CR>\nnnoremap <silent> <Leader>H :Helptags<CR>\nnnoremap <silent> <Leader>hh :History<CR>\nnnoremap <silent> <Leader>h: :History:<CR>\nnnoremap <silent> <Leader>h/ :History/<CR>\n```\n\n## 将Grep替换为Rg\n\n正如前面提到的，Vim有两种方法在文件内搜索：`:vim`和`:grep`。您可以使用`grepprg`这个关键字重新指定`:grep`使用的外部搜索工具。我将向您演示如何设置Vim，使得当运行`:grep`命令时，使用ripgrep代替终端的grep。\n\n现在，让我们设置`grepprg`来使`:grep`使用ripgrep。将下列设置添加到您的vimrc：\n\n```\nset grepprg=rg\\ --vimgrep\\ --smart-case\\ --follow\n```\n\n上面的一些选项可以随意修改！要想了解更多关于这些选项的含义，请使用`man rg`了解详情。\n\n当您更新`grepprg`选项后，现在当您运行`:grep`，它将实际运行`rg --vimgrep --smart-case --follow`而不是`grep`。如果您想使用ripgrep搜索\"donut\"，您可以运行一条更简洁的命令`:grep \"donut\"`，而不是`:grep \"donut\" . -R`\n\n就像老的`:grep`一样，新的`:grep`同样使用quickfix窗口来显示结果。\n\n您可能好奇，“很好，但我从没在Vim中使用过`:grep`，为什么我不能直接使用`:Rg`命令在文件中搜索呢？究竟什么时候我必须使用`:grep`？”。\n\n这个问题问得很好。在Vim中，当您需要在多个文件中执行搜索和替换时，您可能必须使用`:grep`这个命令。我马上就会讲这个问题。\n\n## 在多文件中搜索和替换\n\n现代文本编辑器，比如VSCode中，在多个文件中搜索和替换一个字符串是很简单的事情。在这一节，我将向您演示如何在Vim中轻松实现这个。\n\n第一个方法是在您的项目中替换 **所有** 的匹配短句。您得使用`:grep`命令。如果您想将所有\"pizza\"替换为\"donut\"，下面是操作方法：\n\n```\n:grep \"pizza\"\n:cfdo %s/pizza/donut/g | update\n```\n\n让我们来分析一下这条命令：\n\n1. `:grep pizza`使用ripgrep去搜索所有\"pizza\"（顺带说一句，就算您不给`grepprg`重新赋值让它使用ripgrep，这条命令依然有效，但您可能不得不使用`:grep \"pizza\" . -R`命令，而不是`:grep \"pizza\"`）。\n2. `:cfdo`会在您的quickfix列表中所有文件里，执行您传递给它的命令。在这个例子中，您的命令是一条替换命令`%s/pizza/donut/g`。管道符号(`|`)是一个链接操作符。命令`update`在每个文件被替换后，立刻保存。在后面的章节中，我将深入介绍替换命令。\n\n第二个方法是在您选择文件中执行搜索和替换。用这个方法，您可以手动选择您想执行搜索和替换的文件。下面是操作方法：\n\n1. 首先清空您的buffer。让您的buffer列表仅包含您所需要的文件，这一点很有必要。您可以重启Vim，也可以运行`:%bd | e#`命令（`%bd`关闭所有buffer，而`e#`打开您当前所在的文件）。\n2. 运行`:Files`。\n3. 选择好您想搜索-替换的文件。要选择多个文件，使用`<Tab>`或`<Shift-Tab>`。当然，您必须使多文件标志(`-m`)位于`FZF_DEFAULT_OPTS`中。\n4. 运行`:bufdo %s/pizza/donut/g | update`。命令`:bufdo %s/pizza/donut/g | update`看起来和前面的`:cfdo %s/pizza/donut/g | update`很像，区别在于，(`:cfdo`)替换所有quickfix中的实体，而(`:bufdo`)替换所有buffer中的实体。\n\n## 用聪明的方法学习搜索\n\n在文本编辑时，搜索是一个很实用的技巧。学会在Vim中如何搜索，将显著提高您的文本编辑工作流程效率。\n\nFzf.vim插件就像一个游戏规则改变者。我无法想象使用Vim没有它的情景。当最开始使用Vim时，如果有一个好的搜索工具，我想是非常重要的。我看见很多人过渡到Vim时的艰难历程，就是因为Vim缺少了现代编辑器所拥有的一些关键功能特性，比如简单快捷且功能强大的搜索功能。我希望本章将帮助您更轻松地向Vim过渡。\n\n您同时也看到了Vim的扩展性，即使用插件或外部程序扩展搜索功能的能力。将来，记住您想在Vim中拓展的功能。很有可能已经有人写好了相关插件，已经有现成的程序了。下一章，您将学习Vim中非常重要的主题：Vim语法。\n","slug":"Vim/ch03_searching_files","published":1,"updated":"2022-08-28T07:38:59.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1s0017scvmfq9t8aff","content":"<h1 id=\"第3章-打开和搜索文件\"><a href=\"#第3章-打开和搜索文件\" class=\"headerlink\" title=\"第3章 打开和搜索文件\"></a>第3章 打开和搜索文件</h1><p>本章的目的是向您介绍如何在Vim中快速搜索，能够快速搜索是提高您的Vim工作效率的重要途径。当我解决了如何快速搜索文件这个问题后，我就决定改为完全使用Vim来工作。</p>\n<p>本章划分为两个部分：一是如何不依赖插件搜索；二是使用<a href=\"https://github.com/junegunn/fzf.vim\">fzf插件</a>搜索。让我们开始吧！</p>\n<h2 id=\"打开和编辑文件\"><a href=\"#打开和编辑文件\" class=\"headerlink\" title=\"打开和编辑文件\"></a>打开和编辑文件</h2><p>要在Vim中打开一个文件，您可以使用<code>:edit</code>。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">edit</span> file.txt<br></code></pre></td></tr></table></figure>\n\n<p>如果<code>file.txt</code>已经存在，就会打开<code>file.txt</code>buffer。如果<code>file.txt</code>不存在，会创建一个新buffer名为<code>file.txt</code>。</p>\n<p><code>:edit</code>命令支持使用<code>&lt;Tab&gt;</code>进行自动补全。比如，如果您的文件位于<a href=\"https://rubyonrails.org/\">Rails</a>应用控制器的用户控制器目录<code>./app/controllers/users_controllers.rb</code>内，您可以使用<code>&lt;Tab&gt;</code>对文件路径名进行快速扩展。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">:<span class=\"hljs-keyword\">edit</span> a&lt;<span class=\"hljs-built_in\">Tab</span>&gt;c&lt;<span class=\"hljs-built_in\">Tab</span>&gt;u&lt;<span class=\"hljs-built_in\">Tab</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>:edit</code>可以接收通配符参数。<code>*</code>匹配当前目录下的任意文件。如果您只想查找当前目录下后缀名为<code>.yml</code>的文件：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">:<span class=\"hljs-keyword\">edit</span> *.yml&lt;<span class=\"hljs-built_in\">Tab</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>Vim将列出当前目录下所有<code>.yml</code>文件供您选择。</p>\n<p>您可以使用<code>**</code>进行递归的搜索。如果您想查找当前项目文件夹下所有<code>*.md</code>文件，但您不知道在哪个目录，您可以这样做：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">edit</span> **/*.md<span class=\"hljs-symbol\">&lt;Tab&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>:edit</code>可以用于运行<code>netrw</code>（Vim的内置文件浏览器）。使用方法是，给<code>:edit</code>一个目录参数而不是文件名就行了：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">edit</span> .<br>:<span class=\"hljs-built_in\">edit</span> test/unit/<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用find命令搜索文件\"><a href=\"#使用find命令搜索文件\" class=\"headerlink\" title=\"使用find命令搜索文件\"></a>使用find命令搜索文件</h2><p>您可以使用<code>:find</code>命令搜索文件。比如：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:<span class=\"hljs-keyword\">find</span> <span class=\"hljs-keyword\">package</span>.json<br>:<span class=\"hljs-keyword\">find</span> app<span class=\"hljs-regexp\">/controllers/u</span>sers_controller.rb<br></code></pre></td></tr></table></figure>\n\n<p><code>:find</code>命令同样支持自动补全：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">find</span> <span class=\"hljs-keyword\">p</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span>                <span class=\"hljs-comment\">&quot; to find package.json</span><br>:<span class=\"hljs-keyword\">find</span> <span class=\"hljs-keyword\">a</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span><span class=\"hljs-keyword\">c</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span><span class=\"hljs-keyword\">u</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span>    <span class=\"hljs-comment\">&quot; to find app/controllers/users_controller.rb</span><br></code></pre></td></tr></table></figure>\n\n<p>您可能注意到<code>:find</code>和<code>:edit</code>看起来很像。它们的区别是什么呢？</p>\n<h2 id=\"Find-和-Path\"><a href=\"#Find-和-Path\" class=\"headerlink\" title=\"Find 和 Path\"></a>Find 和 Path</h2><p>两者的区别在于，<code>:find</code>命令根据<code>path</code>选项配置的路径查找文件，而<code>:edit</code>不会。让我们了解一点关于<code>path</code>选项的知识。一旦您学会如何修改您的路径，<code>:find</code>命令能变成一个功能强大的搜索工具。先查看一下您的<code>path</code>是什么：</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dos\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">path</span>?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下，您的<code>path</code>内容很可能是这样的：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">path=.,<span class=\"hljs-regexp\">/usr/i</span>nclude,,<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>.</code> 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 <strong>当前所打开的文件</strong> 所在的目录)</li>\n<li><code>,</code> means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号<code>,</code>应该是表示路径之间的分割符。连续的两个<code>,,</code>（两个逗号之间为空）才表示当前目录)</li>\n<li><code>/usr/include</code> 表示在C编译器头文件目录下搜索。</li>\n</ul>\n<p>前两个配置非常重要，第3个现在可以被忽略。您这里应该记住的是：您可以修改您自己的路径。让我们假设您的项目结构是这样的：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">app/<br>  assets/<br>  controllers/<br>    application_controller<span class=\"hljs-selector-class\">.rb</span><br>    comments_controller<span class=\"hljs-selector-class\">.rb</span><br>    users_controller<span class=\"hljs-selector-class\">.rb</span><br>    ...<br></code></pre></td></tr></table></figure>\n\n<p>如果您想从根目录跳到<code>users_controller.rb</code>，您将不得不经过好几层目录（按好几次<code>&lt;Tab&gt;</code>）。一般说来，当您处理一个framework时，90%的时间您都在某个特定的目录下。在这种情况下，您只关心如何用最少的按键跳到<code>controllers/</code>目录。那么<code>path</code>设置可以减少这个途程。</p>\n<p>您只需要将<code>app/controllers/</code>添加到当前<code>path</code>选项。以下是操作步骤：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:set path+=app<span class=\"hljs-regexp\">/controllers/</span><br></code></pre></td></tr></table></figure>\n\n<p>现在您的路径已经更新，当您输入<code>:find u&lt;Tab&gt;</code>时，Vim将会在<code>app/controllers/</code>目录内搜索所有以”u”开头的文件。</p>\n<p>如果您有一个嵌套的目录<code>controllers/</code>，比如<code>app/controllers/account/users_controller.rb</code>，Vim就找不到<code>users_controllers</code>了。您必须改为添加<code>:set path+=app/controllers/**</code>，这样自动补全才会找到<code>users_controller.rb</code>。这太棒了！您现在可以只需要按1次键就可找到users controller。</p>\n<p>您可能会想将整个项目文件夹添加到<code>path</code>中，这样当您按<code>&lt;Tab&gt;</code>，Vim将在所有文件夹内搜索您要找的文件，就像这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:<span class=\"hljs-built_in\">set</span> path+=<span class=\"hljs-variable\">$PWD</span>/**<br></code></pre></td></tr></table></figure>\n\n<p><code>$PWD</code> 表示的是当前工作目录。如果您尝试将整个项目路径加到<code>path</code>中，并希望让所有文件名可以用<code>&lt;Tab&gt;</code>补全，虽然对于小项目没问题，但如果您的项目中包含大量文件时，这会显著降低您的搜索速度。我建议仅仅将您最常访问的文件&#x2F;目录添加到<code>path</code>。（译者注：不知道是不是因为系统环境不一样的原因，译者使用的是windows下的Vim8.2，$PWD 这个环境变量在译者的vim中不起作用，必须在vimrc文件中添加一句<code>let $PWD=getcwd()</code>才行）。</p>\n<p>您可以将<code>set path+=&#123;您需要添加的目录&#125;</code>添加到您的vimrc文件中。更新<code>path</code>仅花费几秒钟，但可以为您的工作节省很多时间。</p>\n<h2 id=\"使用Grep命令在文件中搜索\"><a href=\"#使用Grep命令在文件中搜索\" class=\"headerlink\" title=\"使用Grep命令在文件中搜索\"></a>使用Grep命令在文件中搜索</h2><p>如果您想在文件内部查找（搜索文件中的词句），您可以使用grep。Vim有两个方法可以完成这个工作：</p>\n<ul>\n<li>内置grep （<code>:vim</code>。没错，就是<code>:vim</code>，它是<code>:vimgrep</code>的简写）。</li>\n<li>外部grep (<code>:grep</code>)。</li>\n</ul>\n<p>让我们首先仔细看看内置grep。<code>:vim</code>有以下语法：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:vim <span class=\"hljs-regexp\">/pattern/</span> <span class=\"hljs-keyword\">file</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>/pattern/</code> 是您要搜索的内容的正则表达式。</li>\n<li><code>file</code> 是文件参数。您可以传入多个参数。Vim将在文件中搜索所有匹配正则表达式的内容。类似于<code>:find</code>，您可以传入*和**通配符。</li>\n</ul>\n<p>比如，要在<code>app/controllers/</code>目录下所有ruby文件(<code>.rb</code>)中，查找所有的”breakfast”字符串:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:vim <span class=\"hljs-regexp\">/breakfast/</span> app<span class=\"hljs-regexp\">/controllers/</span>**/*.rb<br></code></pre></td></tr></table></figure>\n\n<p>输入上面的命令后，您将会被导航到第一个结果。Vim的<code>vim</code>搜索命令使用<code>quickfix</code>进行处理。要查看所有搜索结果，运行<code>:copen</code>会打开一个<code>quickfix</code>窗口。下面有一些有用的quickfix命令，可以让您提高效率：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:copen</span>        打开quickfix窗口<br><span class=\"hljs-symbol\">:cclose</span>       关闭quickfix窗口<br><span class=\"hljs-symbol\">:cnext</span>        跳到下一个错误<br><span class=\"hljs-symbol\">:cprevious</span>    跳到前一个错误<br><span class=\"hljs-symbol\">:colder</span>       跳到旧的错误列表<br><span class=\"hljs-symbol\">:cnewer</span>       跳到新的错误列表<br></code></pre></td></tr></table></figure>\n\n<p>要了解更多关于quickfix的信息，使用<code>:h quickfix</code>查看帮助信息。</p>\n<p>您可能注意到运行内置grep(<code>:vim</code>)命令时，如果匹配结果数量较多时系统速度会变慢。这是因为Vim将每一个搜索结果读入内存。Vim加载每一个匹配的文件就像它们被编辑一样。如果Vim查到大量文件，它将消耗很多内存。</p>\n<p>让我们谈谈外置grep。默认情况下，它使用终端命令<code>grep</code>。要想在<code>app/controllers/</code>目录中搜索字符串”lunch”，您可以这样做：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:<span class=\"hljs-keyword\">grep</span> -R <span class=\"hljs-string\">&quot;lunch&quot;</span> app<span class=\"hljs-regexp\">/controllers/</span><br></code></pre></td></tr></table></figure>\n\n<p>注意这里不是使用<code>/pattern/</code>，它遵循的是终端grep的语法<code>&quot;pattern&quot;</code>，它同样使用’quickfix’来显示所有的匹配结果。</p>\n<p>Vim使用<code>grepprg</code>变量来决定运行<code>:grep</code>时，应该使用哪个外部程序。所以您并不是非得使用终端的<code>grep</code>命令。稍后我将为您演示如何改变外部grep程序的默认值。</p>\n<h2 id=\"用Netrw浏览文件\"><a href=\"#用Netrw浏览文件\" class=\"headerlink\" title=\"用Netrw浏览文件\"></a>用Netrw浏览文件</h2><p><code>netrw</code>是Vim的内置文件浏览器，当查看项目的目录结构时很有用。要运行<code>netrw</code>，您需要在您的<code>.vimrc</code>中做以下设置：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">set</span> nocp<br>filetype <span class=\"hljs-keyword\">plugin</span> <span class=\"hljs-keyword\">on</span><br></code></pre></td></tr></table></figure>\n\n<p>由于<code>netrw</code>是一个很宽泛的话题，我将紧紧介绍它的基本用法，这应该已经足够了。您可以在启动Vim时运行<code>netrw</code>，只需要传给Vim一个目录参数（而不是文件参数）就行了。比如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">vim .<br>vim src<span class=\"hljs-regexp\">/client/</span><br>vim app<span class=\"hljs-regexp\">/controllers/</span><br></code></pre></td></tr></table></figure>\n\n<p>要想从Vim内部运行<code>netrw</code>，您可以使用<code>:edit</code>命令，传给他一个目录而不是文件名：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">edit</span> .<br>:<span class=\"hljs-built_in\">edit</span> src/client/<br>:<span class=\"hljs-built_in\">edit</span> app/controllers/<br></code></pre></td></tr></table></figure>\n\n<p>也有其他方法，不需要传递目录参数就运行<code>netrw</code>窗口：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">:Explore     从当前文件启动netrw。<br><span class=\"hljs-meta\">:Sexplore    Sex_Plore?不是开玩笑:)，在顶部水平分割的窗口打开netrw。</span><br>:Vexplore    在左侧垂直分割的窗口打开netrw。<br></code></pre></td></tr></table></figure>\n\n<p>您可以使用Vim动作(motions，在后面的章节中将详细讲述)在<code>netrw</code>中导航。如果您要创建、删除、重命名文件或文件夹，下面有一些关于<code>netrw</code>的有用命令：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\"><span class=\"hljs-comment\">%    创建新文件</span><br>d    创建新目录<br>R    重命名文件/目录<br>D    删除文件/目录<br></code></pre></td></tr></table></figure>\n\n<p><code>:h netrw</code> 的信息非常复杂，如果您有时间可以看看。</p>\n<p>如果您觉得 <code>netrw</code> 过于单调乏味，<a href=\"https://github.com/tpope/vim-vinegar\">vim-vinegar</a>是netrw的一个改进插件。如果您想找一个不同的文件浏览器，<a href=\"https://github.com/preservim/nerdtree\">NERDTree</a> 是一个很好的选择。去看看吧。</p>\n<h2 id=\"Fzf插件\"><a href=\"#Fzf插件\" class=\"headerlink\" title=\"Fzf插件\"></a>Fzf插件</h2><p>您现在已经学会了如何使用Vim的内置工具去搜索文件，那么让我们学习一下如何用插件实现这些功能吧。</p>\n<p>现代文本编辑器相比Vim，有一个功能设计得很好，那就是文件搜索和模糊搜索的简化。在本章的下半部分，我将向您演示如何使用<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>插件，在Vim中轻松实现功能强大的搜索功能。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>首先，确保您下载了<a href=\"https://github.com/junegunn/fzf\">fzf</a>和<a href=\"https://github.com/BurntSushi/ripgrep\">ripgrep</a>。按照它们在github仓库上的指令一步步做。成功安装后，命令<code>fzf</code>和<code>rg</code>应该就可以用了。</p>\n<p>Ripgrep是一个类似grep（从名字上就看得出）的搜索工具。一般说来，它比grep要快，而且还有很多有用的特性。Fzf是一个多用途的命令行模糊搜索工具，您可以讲它与其他命令联合起来使用，包括ripgrep。联合起来后，它们成为一个功能强大的搜索工具。</p>\n<p>Fzf默认并不使用ripgrep，所以我们需要设置<code>FZF_DEFAULT_COMMAND</code>变量告诉fzf使用ripgrep命令。在我的<code>.zshrc</code>（如果您用bash，应该是<code>.bashrc</code>）文件内，我有以下设置：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-keyword\">if</span><span class=\"hljs-built_in\"> type </span>rg &amp;&gt; /dev/<span class=\"hljs-literal\">null</span>; then<br>  <span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">FZF_DEFAULT_COMMAND</span>=<span class=\"hljs-string\">&#x27;rg --files&#x27;</span><br>  <span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">FZF_DEFAULT_OPTS</span>=<span class=\"hljs-string\">&#x27;-m&#x27;</span><br>fi<br></code></pre></td></tr></table></figure>\n\n<p>注意<code>FZF_DEFAULT_OPTS</code>变量中的<code>-m</code>。这个设置允许我们按下<code>&lt;Tab</code>或<code>&lt;Shift-Tab&gt;</code>后进行多重选择。如果仅想让fzf在Vim中能够工作，这个设置不是必须的，但我认为这是一个有用的设置。当您想在多个文件中执行搜索和替换，进行少量修改时，它会很方便。fzf命令可以接收很多标志，但我不会再这里讲。要想了解更多信息，可以查看<a href=\"https://github.com/junegunn/fzf#usage\">fzf’s 仓库</a>，或者使用<code>man fzf</code>。要想让fzf使用ripgrep，您至少得有这个设置<code>export FZF_DEFAULT_COMMAND=&#39;rg&#39;</code>。</p>\n<p>安装好了fzf和ripgrep后，让我们再安装fzf的插件。在这个例子中，我使用的是<a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a>插件管理器，当然您可以使用其他插件管理器。</p>\n<p>将下列配置添加到您的<code>.vimrc</code>中。因为您需要使用<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>插件。（同样是由fzf的作者在维护）</p>\n<figure class=\"highlight sml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sml\"><span class=\"hljs-type\">Plug</span> <span class=\"hljs-symbol\">&#x27;junegunn</span>/fzf.vim&#x27;<br><span class=\"hljs-type\">Plug</span> <span class=\"hljs-symbol\">&#x27;junegunn</span>/fzf&#x27;, &#123; <span class=\"hljs-symbol\">&#x27;do&#x27;</span>: &#123; -&gt; fzf#install<span class=\"hljs-literal\">()</span> &#125; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>添加后，您需要打开vim，运行<code>:PlugInstall</code>。这条命令将会安装所有您在<code>vimrc</code>文件中定义了但尚未安装的插件。 在我的例子中，将会安装<code>fzf.vim</code>和<code>fzf</code>。</p>\n<p>要了解更多关于此插件的信息，您可以查看<a href=\"https://github.com/junegunn/fzf/blob/master/README-VIM.md\">fzf.vim 的仓库</a>。</p>\n<h2 id=\"Fzf的语法\"><a href=\"#Fzf的语法\" class=\"headerlink\" title=\"Fzf的语法\"></a>Fzf的语法</h2><p>要想高效的使用fzf，您首先得了解一些fzf的基础语法。幸运的是，这个列表比较短：</p>\n<ul>\n<li><code>^</code> 表示前缀精确匹配。要搜索一个以”welcome”开头的短语：<code>^welcom</code>。</li>\n<li><code>$</code> 表示后缀精确匹配。要搜索一个以”my friends”结尾的短语：<code>friends$</code>。</li>\n<li><code>&#39;</code> 表示精确匹配。要搜索短语”welcom my friends”：<code>&#39;welcom my friends</code>。</li>\n<li><code>|</code> 表示”或者”匹配。要搜索”friends”或”foes”：<code>friends | foes</code>。</li>\n<li><code>!</code> 表示反向匹配。要搜索一个包含”welcome”但不包含”friends”的短语：<code>welcome !friends</code>。</li>\n</ul>\n<p>您可以混合起来使用。比如，<code>^hello | ^welcome friends$</code>将搜索以”welcome”或”hello”开头，并且以”friends”结束的短语。</p>\n<h2 id=\"查找文件\"><a href=\"#查找文件\" class=\"headerlink\" title=\"查找文件\"></a>查找文件</h2><p>要想在Vim内使用fzf.vim插件搜索文件，您可以使用<code>:Files</code>方法。在Vim中运行<code>:Files</code>，您将看到fzf搜索提示符。</p>\n<p>因为您将频繁地使用这个命令，最好建立一个键盘映射，我把它映射到<code>Ctrl-f</code>。在我的vimrc配置中，有这个设置：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">nnoremap &lt;silent&gt; &lt;C-f&gt; <span class=\"hljs-symbol\">:Files&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"在文件中查找\"><a href=\"#在文件中查找\" class=\"headerlink\" title=\"在文件中查找\"></a>在文件中查找</h2><p>要想在文件内部搜索，您可以使用<code>:Rg</code>命令。</p>\n<p>同样，因为您可能将频繁的使用这个命令，让我们给它一个键盘映射。我的映射在<code>&lt;Leader&gt;f</code>。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">nnoremap &lt;silent&gt; &lt;<span class=\"hljs-title class_\">Leader</span>&gt;f <span class=\"hljs-symbol\">:Rg&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"其他搜索\"><a href=\"#其他搜索\" class=\"headerlink\" title=\"其他搜索\"></a>其他搜索</h2><p>Fzf.vim提供了许多其他命令。这里我不会一个个仔细讲，您可以去<a href=\"https://github.com/junegunn/fzf.vim#commands\">这里</a>查看更多信息。</p>\n<p>这是我的fzf键盘映射：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>b :Buffers<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">C-f</span>&gt;</span> :Files<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>f :Rg<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>/ :BLines<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>&#x27; :Marks<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>g :Commits<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>H :Helptags<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>hh :History<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>h: :History:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>h/ :History/<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"将Grep替换为Rg\"><a href=\"#将Grep替换为Rg\" class=\"headerlink\" title=\"将Grep替换为Rg\"></a>将Grep替换为Rg</h2><p>正如前面提到的，Vim有两种方法在文件内搜索：<code>:vim</code>和<code>:grep</code>。您可以使用<code>grepprg</code>这个关键字重新指定<code>:grep</code>使用的外部搜索工具。我将向您演示如何设置Vim，使得当运行<code>:grep</code>命令时，使用ripgrep代替终端的grep。</p>\n<p>现在，让我们设置<code>grepprg</code>来使<code>:grep</code>使用ripgrep。将下列设置添加到您的vimrc：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-keyword\">set</span> grepprg=rg\\ <span class=\"hljs-params\">--vimgrep</span>\\ <span class=\"hljs-params\">--smart-case</span>\\ <span class=\"hljs-params\">--follow</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的一些选项可以随意修改！要想了解更多关于这些选项的含义，请使用<code>man rg</code>了解详情。</p>\n<p>当您更新<code>grepprg</code>选项后，现在当您运行<code>:grep</code>，它将实际运行<code>rg --vimgrep --smart-case --follow</code>而不是<code>grep</code>。如果您想使用ripgrep搜索”donut”，您可以运行一条更简洁的命令<code>:grep &quot;donut&quot;</code>，而不是<code>:grep &quot;donut&quot; . -R</code></p>\n<p>就像老的<code>:grep</code>一样，新的<code>:grep</code>同样使用quickfix窗口来显示结果。</p>\n<p>您可能好奇，“很好，但我从没在Vim中使用过<code>:grep</code>，为什么我不能直接使用<code>:Rg</code>命令在文件中搜索呢？究竟什么时候我必须使用<code>:grep</code>？”。</p>\n<p>这个问题问得很好。在Vim中，当您需要在多个文件中执行搜索和替换时，您可能必须使用<code>:grep</code>这个命令。我马上就会讲这个问题。</p>\n<h2 id=\"在多文件中搜索和替换\"><a href=\"#在多文件中搜索和替换\" class=\"headerlink\" title=\"在多文件中搜索和替换\"></a>在多文件中搜索和替换</h2><p>现代文本编辑器，比如VSCode中，在多个文件中搜索和替换一个字符串是很简单的事情。在这一节，我将向您演示如何在Vim中轻松实现这个。</p>\n<p>第一个方法是在您的项目中替换 <strong>所有</strong> 的匹配短句。您得使用<code>:grep</code>命令。如果您想将所有”pizza”替换为”donut”，下面是操作方法：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:<span class=\"hljs-keyword\">grep</span> <span class=\"hljs-string\">&quot;pizza&quot;</span><br>:cfdo %s<span class=\"hljs-regexp\">/pizza/</span>donut/g | update<br></code></pre></td></tr></table></figure>\n\n<p>让我们来分析一下这条命令：</p>\n<ol>\n<li><code>:grep pizza</code>使用ripgrep去搜索所有”pizza”（顺带说一句，就算您不给<code>grepprg</code>重新赋值让它使用ripgrep，这条命令依然有效，但您可能不得不使用<code>:grep &quot;pizza&quot; . -R</code>命令，而不是<code>:grep &quot;pizza&quot;</code>）。</li>\n<li><code>:cfdo</code>会在您的quickfix列表中所有文件里，执行您传递给它的命令。在这个例子中，您的命令是一条替换命令<code>%s/pizza/donut/g</code>。管道符号(<code>|</code>)是一个链接操作符。命令<code>update</code>在每个文件被替换后，立刻保存。在后面的章节中，我将深入介绍替换命令。</li>\n</ol>\n<p>第二个方法是在您选择文件中执行搜索和替换。用这个方法，您可以手动选择您想执行搜索和替换的文件。下面是操作方法：</p>\n<ol>\n<li>首先清空您的buffer。让您的buffer列表仅包含您所需要的文件，这一点很有必要。您可以重启Vim，也可以运行<code>:%bd | e#</code>命令（<code>%bd</code>关闭所有buffer，而<code>e#</code>打开您当前所在的文件）。</li>\n<li>运行<code>:Files</code>。</li>\n<li>选择好您想搜索-替换的文件。要选择多个文件，使用<code>&lt;Tab&gt;</code>或<code>&lt;Shift-Tab&gt;</code>。当然，您必须使多文件标志(<code>-m</code>)位于<code>FZF_DEFAULT_OPTS</code>中。</li>\n<li>运行<code>:bufdo %s/pizza/donut/g | update</code>。命令<code>:bufdo %s/pizza/donut/g | update</code>看起来和前面的<code>:cfdo %s/pizza/donut/g | update</code>很像，区别在于，(<code>:cfdo</code>)替换所有quickfix中的实体，而(<code>:bufdo</code>)替换所有buffer中的实体。</li>\n</ol>\n<h2 id=\"用聪明的方法学习搜索\"><a href=\"#用聪明的方法学习搜索\" class=\"headerlink\" title=\"用聪明的方法学习搜索\"></a>用聪明的方法学习搜索</h2><p>在文本编辑时，搜索是一个很实用的技巧。学会在Vim中如何搜索，将显著提高您的文本编辑工作流程效率。</p>\n<p>Fzf.vim插件就像一个游戏规则改变者。我无法想象使用Vim没有它的情景。当最开始使用Vim时，如果有一个好的搜索工具，我想是非常重要的。我看见很多人过渡到Vim时的艰难历程，就是因为Vim缺少了现代编辑器所拥有的一些关键功能特性，比如简单快捷且功能强大的搜索功能。我希望本章将帮助您更轻松地向Vim过渡。</p>\n<p>您同时也看到了Vim的扩展性，即使用插件或外部程序扩展搜索功能的能力。将来，记住您想在Vim中拓展的功能。很有可能已经有人写好了相关插件，已经有现成的程序了。下一章，您将学习Vim中非常重要的主题：Vim语法。</p>\n","site":{"data":{}},"wordcount":8228,"excerpt":"","more":"<h1 id=\"第3章-打开和搜索文件\"><a href=\"#第3章-打开和搜索文件\" class=\"headerlink\" title=\"第3章 打开和搜索文件\"></a>第3章 打开和搜索文件</h1><p>本章的目的是向您介绍如何在Vim中快速搜索，能够快速搜索是提高您的Vim工作效率的重要途径。当我解决了如何快速搜索文件这个问题后，我就决定改为完全使用Vim来工作。</p>\n<p>本章划分为两个部分：一是如何不依赖插件搜索；二是使用<a href=\"https://github.com/junegunn/fzf.vim\">fzf插件</a>搜索。让我们开始吧！</p>\n<h2 id=\"打开和编辑文件\"><a href=\"#打开和编辑文件\" class=\"headerlink\" title=\"打开和编辑文件\"></a>打开和编辑文件</h2><p>要在Vim中打开一个文件，您可以使用<code>:edit</code>。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">edit</span> file.txt<br></code></pre></td></tr></table></figure>\n\n<p>如果<code>file.txt</code>已经存在，就会打开<code>file.txt</code>buffer。如果<code>file.txt</code>不存在，会创建一个新buffer名为<code>file.txt</code>。</p>\n<p><code>:edit</code>命令支持使用<code>&lt;Tab&gt;</code>进行自动补全。比如，如果您的文件位于<a href=\"https://rubyonrails.org/\">Rails</a>应用控制器的用户控制器目录<code>./app/controllers/users_controllers.rb</code>内，您可以使用<code>&lt;Tab&gt;</code>对文件路径名进行快速扩展。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">:<span class=\"hljs-keyword\">edit</span> a&lt;<span class=\"hljs-built_in\">Tab</span>&gt;c&lt;<span class=\"hljs-built_in\">Tab</span>&gt;u&lt;<span class=\"hljs-built_in\">Tab</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>:edit</code>可以接收通配符参数。<code>*</code>匹配当前目录下的任意文件。如果您只想查找当前目录下后缀名为<code>.yml</code>的文件：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">:<span class=\"hljs-keyword\">edit</span> *.yml&lt;<span class=\"hljs-built_in\">Tab</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>Vim将列出当前目录下所有<code>.yml</code>文件供您选择。</p>\n<p>您可以使用<code>**</code>进行递归的搜索。如果您想查找当前项目文件夹下所有<code>*.md</code>文件，但您不知道在哪个目录，您可以这样做：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">edit</span> **/*.md<span class=\"hljs-symbol\">&lt;Tab&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>:edit</code>可以用于运行<code>netrw</code>（Vim的内置文件浏览器）。使用方法是，给<code>:edit</code>一个目录参数而不是文件名就行了：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">edit</span> .<br>:<span class=\"hljs-built_in\">edit</span> test/unit/<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用find命令搜索文件\"><a href=\"#使用find命令搜索文件\" class=\"headerlink\" title=\"使用find命令搜索文件\"></a>使用find命令搜索文件</h2><p>您可以使用<code>:find</code>命令搜索文件。比如：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:<span class=\"hljs-keyword\">find</span> <span class=\"hljs-keyword\">package</span>.json<br>:<span class=\"hljs-keyword\">find</span> app<span class=\"hljs-regexp\">/controllers/u</span>sers_controller.rb<br></code></pre></td></tr></table></figure>\n\n<p><code>:find</code>命令同样支持自动补全：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">find</span> <span class=\"hljs-keyword\">p</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span>                <span class=\"hljs-comment\">&quot; to find package.json</span><br>:<span class=\"hljs-keyword\">find</span> <span class=\"hljs-keyword\">a</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span><span class=\"hljs-keyword\">c</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span><span class=\"hljs-keyword\">u</span><span class=\"hljs-symbol\">&lt;Tab&gt;</span>    <span class=\"hljs-comment\">&quot; to find app/controllers/users_controller.rb</span><br></code></pre></td></tr></table></figure>\n\n<p>您可能注意到<code>:find</code>和<code>:edit</code>看起来很像。它们的区别是什么呢？</p>\n<h2 id=\"Find-和-Path\"><a href=\"#Find-和-Path\" class=\"headerlink\" title=\"Find 和 Path\"></a>Find 和 Path</h2><p>两者的区别在于，<code>:find</code>命令根据<code>path</code>选项配置的路径查找文件，而<code>:edit</code>不会。让我们了解一点关于<code>path</code>选项的知识。一旦您学会如何修改您的路径，<code>:find</code>命令能变成一个功能强大的搜索工具。先查看一下您的<code>path</code>是什么：</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dos\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-built_in\">path</span>?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下，您的<code>path</code>内容很可能是这样的：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">path=.,<span class=\"hljs-regexp\">/usr/i</span>nclude,,<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>.</code> 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 <strong>当前所打开的文件</strong> 所在的目录)</li>\n<li><code>,</code> means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号<code>,</code>应该是表示路径之间的分割符。连续的两个<code>,,</code>（两个逗号之间为空）才表示当前目录)</li>\n<li><code>/usr/include</code> 表示在C编译器头文件目录下搜索。</li>\n</ul>\n<p>前两个配置非常重要，第3个现在可以被忽略。您这里应该记住的是：您可以修改您自己的路径。让我们假设您的项目结构是这样的：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">app/<br>  assets/<br>  controllers/<br>    application_controller<span class=\"hljs-selector-class\">.rb</span><br>    comments_controller<span class=\"hljs-selector-class\">.rb</span><br>    users_controller<span class=\"hljs-selector-class\">.rb</span><br>    ...<br></code></pre></td></tr></table></figure>\n\n<p>如果您想从根目录跳到<code>users_controller.rb</code>，您将不得不经过好几层目录（按好几次<code>&lt;Tab&gt;</code>）。一般说来，当您处理一个framework时，90%的时间您都在某个特定的目录下。在这种情况下，您只关心如何用最少的按键跳到<code>controllers/</code>目录。那么<code>path</code>设置可以减少这个途程。</p>\n<p>您只需要将<code>app/controllers/</code>添加到当前<code>path</code>选项。以下是操作步骤：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:set path+=app<span class=\"hljs-regexp\">/controllers/</span><br></code></pre></td></tr></table></figure>\n\n<p>现在您的路径已经更新，当您输入<code>:find u&lt;Tab&gt;</code>时，Vim将会在<code>app/controllers/</code>目录内搜索所有以”u”开头的文件。</p>\n<p>如果您有一个嵌套的目录<code>controllers/</code>，比如<code>app/controllers/account/users_controller.rb</code>，Vim就找不到<code>users_controllers</code>了。您必须改为添加<code>:set path+=app/controllers/**</code>，这样自动补全才会找到<code>users_controller.rb</code>。这太棒了！您现在可以只需要按1次键就可找到users controller。</p>\n<p>您可能会想将整个项目文件夹添加到<code>path</code>中，这样当您按<code>&lt;Tab&gt;</code>，Vim将在所有文件夹内搜索您要找的文件，就像这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:<span class=\"hljs-built_in\">set</span> path+=<span class=\"hljs-variable\">$PWD</span>/**<br></code></pre></td></tr></table></figure>\n\n<p><code>$PWD</code> 表示的是当前工作目录。如果您尝试将整个项目路径加到<code>path</code>中，并希望让所有文件名可以用<code>&lt;Tab&gt;</code>补全，虽然对于小项目没问题，但如果您的项目中包含大量文件时，这会显著降低您的搜索速度。我建议仅仅将您最常访问的文件&#x2F;目录添加到<code>path</code>。（译者注：不知道是不是因为系统环境不一样的原因，译者使用的是windows下的Vim8.2，$PWD 这个环境变量在译者的vim中不起作用，必须在vimrc文件中添加一句<code>let $PWD=getcwd()</code>才行）。</p>\n<p>您可以将<code>set path+=&#123;您需要添加的目录&#125;</code>添加到您的vimrc文件中。更新<code>path</code>仅花费几秒钟，但可以为您的工作节省很多时间。</p>\n<h2 id=\"使用Grep命令在文件中搜索\"><a href=\"#使用Grep命令在文件中搜索\" class=\"headerlink\" title=\"使用Grep命令在文件中搜索\"></a>使用Grep命令在文件中搜索</h2><p>如果您想在文件内部查找（搜索文件中的词句），您可以使用grep。Vim有两个方法可以完成这个工作：</p>\n<ul>\n<li>内置grep （<code>:vim</code>。没错，就是<code>:vim</code>，它是<code>:vimgrep</code>的简写）。</li>\n<li>外部grep (<code>:grep</code>)。</li>\n</ul>\n<p>让我们首先仔细看看内置grep。<code>:vim</code>有以下语法：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:vim <span class=\"hljs-regexp\">/pattern/</span> <span class=\"hljs-keyword\">file</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>/pattern/</code> 是您要搜索的内容的正则表达式。</li>\n<li><code>file</code> 是文件参数。您可以传入多个参数。Vim将在文件中搜索所有匹配正则表达式的内容。类似于<code>:find</code>，您可以传入*和**通配符。</li>\n</ul>\n<p>比如，要在<code>app/controllers/</code>目录下所有ruby文件(<code>.rb</code>)中，查找所有的”breakfast”字符串:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:vim <span class=\"hljs-regexp\">/breakfast/</span> app<span class=\"hljs-regexp\">/controllers/</span>**/*.rb<br></code></pre></td></tr></table></figure>\n\n<p>输入上面的命令后，您将会被导航到第一个结果。Vim的<code>vim</code>搜索命令使用<code>quickfix</code>进行处理。要查看所有搜索结果，运行<code>:copen</code>会打开一个<code>quickfix</code>窗口。下面有一些有用的quickfix命令，可以让您提高效率：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:copen</span>        打开quickfix窗口<br><span class=\"hljs-symbol\">:cclose</span>       关闭quickfix窗口<br><span class=\"hljs-symbol\">:cnext</span>        跳到下一个错误<br><span class=\"hljs-symbol\">:cprevious</span>    跳到前一个错误<br><span class=\"hljs-symbol\">:colder</span>       跳到旧的错误列表<br><span class=\"hljs-symbol\">:cnewer</span>       跳到新的错误列表<br></code></pre></td></tr></table></figure>\n\n<p>要了解更多关于quickfix的信息，使用<code>:h quickfix</code>查看帮助信息。</p>\n<p>您可能注意到运行内置grep(<code>:vim</code>)命令时，如果匹配结果数量较多时系统速度会变慢。这是因为Vim将每一个搜索结果读入内存。Vim加载每一个匹配的文件就像它们被编辑一样。如果Vim查到大量文件，它将消耗很多内存。</p>\n<p>让我们谈谈外置grep。默认情况下，它使用终端命令<code>grep</code>。要想在<code>app/controllers/</code>目录中搜索字符串”lunch”，您可以这样做：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:<span class=\"hljs-keyword\">grep</span> -R <span class=\"hljs-string\">&quot;lunch&quot;</span> app<span class=\"hljs-regexp\">/controllers/</span><br></code></pre></td></tr></table></figure>\n\n<p>注意这里不是使用<code>/pattern/</code>，它遵循的是终端grep的语法<code>&quot;pattern&quot;</code>，它同样使用’quickfix’来显示所有的匹配结果。</p>\n<p>Vim使用<code>grepprg</code>变量来决定运行<code>:grep</code>时，应该使用哪个外部程序。所以您并不是非得使用终端的<code>grep</code>命令。稍后我将为您演示如何改变外部grep程序的默认值。</p>\n<h2 id=\"用Netrw浏览文件\"><a href=\"#用Netrw浏览文件\" class=\"headerlink\" title=\"用Netrw浏览文件\"></a>用Netrw浏览文件</h2><p><code>netrw</code>是Vim的内置文件浏览器，当查看项目的目录结构时很有用。要运行<code>netrw</code>，您需要在您的<code>.vimrc</code>中做以下设置：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">set</span> nocp<br>filetype <span class=\"hljs-keyword\">plugin</span> <span class=\"hljs-keyword\">on</span><br></code></pre></td></tr></table></figure>\n\n<p>由于<code>netrw</code>是一个很宽泛的话题，我将紧紧介绍它的基本用法，这应该已经足够了。您可以在启动Vim时运行<code>netrw</code>，只需要传给Vim一个目录参数（而不是文件参数）就行了。比如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">vim .<br>vim src<span class=\"hljs-regexp\">/client/</span><br>vim app<span class=\"hljs-regexp\">/controllers/</span><br></code></pre></td></tr></table></figure>\n\n<p>要想从Vim内部运行<code>netrw</code>，您可以使用<code>:edit</code>命令，传给他一个目录而不是文件名：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">edit</span> .<br>:<span class=\"hljs-built_in\">edit</span> src/client/<br>:<span class=\"hljs-built_in\">edit</span> app/controllers/<br></code></pre></td></tr></table></figure>\n\n<p>也有其他方法，不需要传递目录参数就运行<code>netrw</code>窗口：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">:Explore     从当前文件启动netrw。<br><span class=\"hljs-meta\">:Sexplore    Sex_Plore?不是开玩笑:)，在顶部水平分割的窗口打开netrw。</span><br>:Vexplore    在左侧垂直分割的窗口打开netrw。<br></code></pre></td></tr></table></figure>\n\n<p>您可以使用Vim动作(motions，在后面的章节中将详细讲述)在<code>netrw</code>中导航。如果您要创建、删除、重命名文件或文件夹，下面有一些关于<code>netrw</code>的有用命令：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\"><span class=\"hljs-comment\">%    创建新文件</span><br>d    创建新目录<br>R    重命名文件/目录<br>D    删除文件/目录<br></code></pre></td></tr></table></figure>\n\n<p><code>:h netrw</code> 的信息非常复杂，如果您有时间可以看看。</p>\n<p>如果您觉得 <code>netrw</code> 过于单调乏味，<a href=\"https://github.com/tpope/vim-vinegar\">vim-vinegar</a>是netrw的一个改进插件。如果您想找一个不同的文件浏览器，<a href=\"https://github.com/preservim/nerdtree\">NERDTree</a> 是一个很好的选择。去看看吧。</p>\n<h2 id=\"Fzf插件\"><a href=\"#Fzf插件\" class=\"headerlink\" title=\"Fzf插件\"></a>Fzf插件</h2><p>您现在已经学会了如何使用Vim的内置工具去搜索文件，那么让我们学习一下如何用插件实现这些功能吧。</p>\n<p>现代文本编辑器相比Vim，有一个功能设计得很好，那就是文件搜索和模糊搜索的简化。在本章的下半部分，我将向您演示如何使用<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>插件，在Vim中轻松实现功能强大的搜索功能。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>首先，确保您下载了<a href=\"https://github.com/junegunn/fzf\">fzf</a>和<a href=\"https://github.com/BurntSushi/ripgrep\">ripgrep</a>。按照它们在github仓库上的指令一步步做。成功安装后，命令<code>fzf</code>和<code>rg</code>应该就可以用了。</p>\n<p>Ripgrep是一个类似grep（从名字上就看得出）的搜索工具。一般说来，它比grep要快，而且还有很多有用的特性。Fzf是一个多用途的命令行模糊搜索工具，您可以讲它与其他命令联合起来使用，包括ripgrep。联合起来后，它们成为一个功能强大的搜索工具。</p>\n<p>Fzf默认并不使用ripgrep，所以我们需要设置<code>FZF_DEFAULT_COMMAND</code>变量告诉fzf使用ripgrep命令。在我的<code>.zshrc</code>（如果您用bash，应该是<code>.bashrc</code>）文件内，我有以下设置：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-keyword\">if</span><span class=\"hljs-built_in\"> type </span>rg &amp;&gt; /dev/<span class=\"hljs-literal\">null</span>; then<br>  <span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">FZF_DEFAULT_COMMAND</span>=<span class=\"hljs-string\">&#x27;rg --files&#x27;</span><br>  <span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">FZF_DEFAULT_OPTS</span>=<span class=\"hljs-string\">&#x27;-m&#x27;</span><br>fi<br></code></pre></td></tr></table></figure>\n\n<p>注意<code>FZF_DEFAULT_OPTS</code>变量中的<code>-m</code>。这个设置允许我们按下<code>&lt;Tab</code>或<code>&lt;Shift-Tab&gt;</code>后进行多重选择。如果仅想让fzf在Vim中能够工作，这个设置不是必须的，但我认为这是一个有用的设置。当您想在多个文件中执行搜索和替换，进行少量修改时，它会很方便。fzf命令可以接收很多标志，但我不会再这里讲。要想了解更多信息，可以查看<a href=\"https://github.com/junegunn/fzf#usage\">fzf’s 仓库</a>，或者使用<code>man fzf</code>。要想让fzf使用ripgrep，您至少得有这个设置<code>export FZF_DEFAULT_COMMAND=&#39;rg&#39;</code>。</p>\n<p>安装好了fzf和ripgrep后，让我们再安装fzf的插件。在这个例子中，我使用的是<a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a>插件管理器，当然您可以使用其他插件管理器。</p>\n<p>将下列配置添加到您的<code>.vimrc</code>中。因为您需要使用<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>插件。（同样是由fzf的作者在维护）</p>\n<figure class=\"highlight sml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sml\"><span class=\"hljs-type\">Plug</span> <span class=\"hljs-symbol\">&#x27;junegunn</span>/fzf.vim&#x27;<br><span class=\"hljs-type\">Plug</span> <span class=\"hljs-symbol\">&#x27;junegunn</span>/fzf&#x27;, &#123; <span class=\"hljs-symbol\">&#x27;do&#x27;</span>: &#123; -&gt; fzf#install<span class=\"hljs-literal\">()</span> &#125; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>添加后，您需要打开vim，运行<code>:PlugInstall</code>。这条命令将会安装所有您在<code>vimrc</code>文件中定义了但尚未安装的插件。 在我的例子中，将会安装<code>fzf.vim</code>和<code>fzf</code>。</p>\n<p>要了解更多关于此插件的信息，您可以查看<a href=\"https://github.com/junegunn/fzf/blob/master/README-VIM.md\">fzf.vim 的仓库</a>。</p>\n<h2 id=\"Fzf的语法\"><a href=\"#Fzf的语法\" class=\"headerlink\" title=\"Fzf的语法\"></a>Fzf的语法</h2><p>要想高效的使用fzf，您首先得了解一些fzf的基础语法。幸运的是，这个列表比较短：</p>\n<ul>\n<li><code>^</code> 表示前缀精确匹配。要搜索一个以”welcome”开头的短语：<code>^welcom</code>。</li>\n<li><code>$</code> 表示后缀精确匹配。要搜索一个以”my friends”结尾的短语：<code>friends$</code>。</li>\n<li><code>&#39;</code> 表示精确匹配。要搜索短语”welcom my friends”：<code>&#39;welcom my friends</code>。</li>\n<li><code>|</code> 表示”或者”匹配。要搜索”friends”或”foes”：<code>friends | foes</code>。</li>\n<li><code>!</code> 表示反向匹配。要搜索一个包含”welcome”但不包含”friends”的短语：<code>welcome !friends</code>。</li>\n</ul>\n<p>您可以混合起来使用。比如，<code>^hello | ^welcome friends$</code>将搜索以”welcome”或”hello”开头，并且以”friends”结束的短语。</p>\n<h2 id=\"查找文件\"><a href=\"#查找文件\" class=\"headerlink\" title=\"查找文件\"></a>查找文件</h2><p>要想在Vim内使用fzf.vim插件搜索文件，您可以使用<code>:Files</code>方法。在Vim中运行<code>:Files</code>，您将看到fzf搜索提示符。</p>\n<p>因为您将频繁地使用这个命令，最好建立一个键盘映射，我把它映射到<code>Ctrl-f</code>。在我的vimrc配置中，有这个设置：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">nnoremap &lt;silent&gt; &lt;C-f&gt; <span class=\"hljs-symbol\">:Files&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"在文件中查找\"><a href=\"#在文件中查找\" class=\"headerlink\" title=\"在文件中查找\"></a>在文件中查找</h2><p>要想在文件内部搜索，您可以使用<code>:Rg</code>命令。</p>\n<p>同样，因为您可能将频繁的使用这个命令，让我们给它一个键盘映射。我的映射在<code>&lt;Leader&gt;f</code>。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">nnoremap &lt;silent&gt; &lt;<span class=\"hljs-title class_\">Leader</span>&gt;f <span class=\"hljs-symbol\">:Rg&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"其他搜索\"><a href=\"#其他搜索\" class=\"headerlink\" title=\"其他搜索\"></a>其他搜索</h2><p>Fzf.vim提供了许多其他命令。这里我不会一个个仔细讲，您可以去<a href=\"https://github.com/junegunn/fzf.vim#commands\">这里</a>查看更多信息。</p>\n<p>这是我的fzf键盘映射：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>b :Buffers<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">C-f</span>&gt;</span> :Files<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>f :Rg<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>/ :BLines<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>&#x27; :Marks<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>g :Commits<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>H :Helptags<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>hh :History<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>h: :History:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br>nnoremap <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">silent</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Leader</span>&gt;</span>h/ :History/<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">CR</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"将Grep替换为Rg\"><a href=\"#将Grep替换为Rg\" class=\"headerlink\" title=\"将Grep替换为Rg\"></a>将Grep替换为Rg</h2><p>正如前面提到的，Vim有两种方法在文件内搜索：<code>:vim</code>和<code>:grep</code>。您可以使用<code>grepprg</code>这个关键字重新指定<code>:grep</code>使用的外部搜索工具。我将向您演示如何设置Vim，使得当运行<code>:grep</code>命令时，使用ripgrep代替终端的grep。</p>\n<p>现在，让我们设置<code>grepprg</code>来使<code>:grep</code>使用ripgrep。将下列设置添加到您的vimrc：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-keyword\">set</span> grepprg=rg\\ <span class=\"hljs-params\">--vimgrep</span>\\ <span class=\"hljs-params\">--smart-case</span>\\ <span class=\"hljs-params\">--follow</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的一些选项可以随意修改！要想了解更多关于这些选项的含义，请使用<code>man rg</code>了解详情。</p>\n<p>当您更新<code>grepprg</code>选项后，现在当您运行<code>:grep</code>，它将实际运行<code>rg --vimgrep --smart-case --follow</code>而不是<code>grep</code>。如果您想使用ripgrep搜索”donut”，您可以运行一条更简洁的命令<code>:grep &quot;donut&quot;</code>，而不是<code>:grep &quot;donut&quot; . -R</code></p>\n<p>就像老的<code>:grep</code>一样，新的<code>:grep</code>同样使用quickfix窗口来显示结果。</p>\n<p>您可能好奇，“很好，但我从没在Vim中使用过<code>:grep</code>，为什么我不能直接使用<code>:Rg</code>命令在文件中搜索呢？究竟什么时候我必须使用<code>:grep</code>？”。</p>\n<p>这个问题问得很好。在Vim中，当您需要在多个文件中执行搜索和替换时，您可能必须使用<code>:grep</code>这个命令。我马上就会讲这个问题。</p>\n<h2 id=\"在多文件中搜索和替换\"><a href=\"#在多文件中搜索和替换\" class=\"headerlink\" title=\"在多文件中搜索和替换\"></a>在多文件中搜索和替换</h2><p>现代文本编辑器，比如VSCode中，在多个文件中搜索和替换一个字符串是很简单的事情。在这一节，我将向您演示如何在Vim中轻松实现这个。</p>\n<p>第一个方法是在您的项目中替换 <strong>所有</strong> 的匹配短句。您得使用<code>:grep</code>命令。如果您想将所有”pizza”替换为”donut”，下面是操作方法：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:<span class=\"hljs-keyword\">grep</span> <span class=\"hljs-string\">&quot;pizza&quot;</span><br>:cfdo %s<span class=\"hljs-regexp\">/pizza/</span>donut/g | update<br></code></pre></td></tr></table></figure>\n\n<p>让我们来分析一下这条命令：</p>\n<ol>\n<li><code>:grep pizza</code>使用ripgrep去搜索所有”pizza”（顺带说一句，就算您不给<code>grepprg</code>重新赋值让它使用ripgrep，这条命令依然有效，但您可能不得不使用<code>:grep &quot;pizza&quot; . -R</code>命令，而不是<code>:grep &quot;pizza&quot;</code>）。</li>\n<li><code>:cfdo</code>会在您的quickfix列表中所有文件里，执行您传递给它的命令。在这个例子中，您的命令是一条替换命令<code>%s/pizza/donut/g</code>。管道符号(<code>|</code>)是一个链接操作符。命令<code>update</code>在每个文件被替换后，立刻保存。在后面的章节中，我将深入介绍替换命令。</li>\n</ol>\n<p>第二个方法是在您选择文件中执行搜索和替换。用这个方法，您可以手动选择您想执行搜索和替换的文件。下面是操作方法：</p>\n<ol>\n<li>首先清空您的buffer。让您的buffer列表仅包含您所需要的文件，这一点很有必要。您可以重启Vim，也可以运行<code>:%bd | e#</code>命令（<code>%bd</code>关闭所有buffer，而<code>e#</code>打开您当前所在的文件）。</li>\n<li>运行<code>:Files</code>。</li>\n<li>选择好您想搜索-替换的文件。要选择多个文件，使用<code>&lt;Tab&gt;</code>或<code>&lt;Shift-Tab&gt;</code>。当然，您必须使多文件标志(<code>-m</code>)位于<code>FZF_DEFAULT_OPTS</code>中。</li>\n<li>运行<code>:bufdo %s/pizza/donut/g | update</code>。命令<code>:bufdo %s/pizza/donut/g | update</code>看起来和前面的<code>:cfdo %s/pizza/donut/g | update</code>很像，区别在于，(<code>:cfdo</code>)替换所有quickfix中的实体，而(<code>:bufdo</code>)替换所有buffer中的实体。</li>\n</ol>\n<h2 id=\"用聪明的方法学习搜索\"><a href=\"#用聪明的方法学习搜索\" class=\"headerlink\" title=\"用聪明的方法学习搜索\"></a>用聪明的方法学习搜索</h2><p>在文本编辑时，搜索是一个很实用的技巧。学会在Vim中如何搜索，将显著提高您的文本编辑工作流程效率。</p>\n<p>Fzf.vim插件就像一个游戏规则改变者。我无法想象使用Vim没有它的情景。当最开始使用Vim时，如果有一个好的搜索工具，我想是非常重要的。我看见很多人过渡到Vim时的艰难历程，就是因为Vim缺少了现代编辑器所拥有的一些关键功能特性，比如简单快捷且功能强大的搜索功能。我希望本章将帮助您更轻松地向Vim过渡。</p>\n<p>您同时也看到了Vim的扩展性，即使用插件或外部程序扩展搜索功能的能力。将来，记住您想在Vim中拓展的功能。很有可能已经有人写好了相关插件，已经有现成的程序了。下一章，您将学习Vim中非常重要的主题：Vim语法。</p>\n"},{"title":"VIM-语法","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第04章 Vim 语法\n\n刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用`gUfV`或`1GdG`，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。\n\n这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim\"说话\"。注意，在这一章中当我讨论Vim语言时，我讨论并不是\nVimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。\n\n## 如何学习一门语言\n\n我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：\n1. 学习语法规则\n2. 扩展我的词汇量\n3. 练习，练习，练习\n\n同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。\n\n## 语法规则\n\n你只需要知道一个Vim语言的语法规则：\n\n```\nverb + noun # 动词 + 名词\n```\n\n这就类似与在英语中的祈使句：\n- \"Eat(verb) a donut(noun)\"\n- \"Kick(verb) a ball(noun)\"\n- \"Learn(verb) the Vim Editor(noun)\"\n\n现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表\n\n## 名词(动作 Motion)\n\n我们这里将 **动作 Motion** 作为名词， **动作Motion**用来在Vim中到处移动。下面列出了一些常见的**动作**的例子：\n\n```\nh\t左\nj\t下\nk\t上\nl\t右\nw\t向前移动到下一个单词的开头\n}\t跳转到下一个段落\n$\t跳转到当前行的末尾\n```\n\n在之后的章节你将学习更多的关于**动作**的内容，所以如果你不理解上面这些**动作**也不必担心。\n\n## 动词(操作符 Operator)\n根据`:h operator`，Vim共有16个**操作符**，然而根据我的经验，学习这3个**操作符**在80%的情况下就已经够用了\n```\ny\tyank(复制)\nd\tdelete(删除)\nc\tchange 删除文本，将删除的文本存到寄存器中，进入插入模式\n```\n\n顺带说一句，当你yank一段文本后，您可以使用`p`将它粘贴到光标后，或使用`P`粘贴到光标前。\n\n## 动词（操作符 Operator）和名词（动作 motions）的结合\n\n现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则，动词和名词的结合！假设你有下面这段文本：\n\n```javascript\nconst learn = \"Vim\";\n```\n\n- 复制当前位置到行尾的所有内容：`y$`\n- 删除当前位置到下一个单词的开头：`dw`\n- 修改当前位置到这个段落的结尾：`c}`\n\n**动作 motions**也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用`3k`代替按3次`k`，数字可应用在Vim语法中。\n\n- 向左拷贝2个字符：`y2h`\n- 删除后两个单词：`d2w`\n- 修改后面两行：`c2j`\n\n目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。唯一途径就是重复、重复再重复。\n\n作为补充，行级的 **操作符 operations** (作用在整行中的操作符)在文本编辑中和其他的 **操作符** 一样，Vim允许你通过按两次 **操作符**使它执行行级的操作，例如`dd`，`yy`，`cc`来执行删除，复制或修改整个行。您可以使用其他operations试一下（比如`gUgU`）。\n\n666!从这可以看出Vim命令的一种执行模式。但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)\n\n## 更多名词(文本对象 Text Objects)\n\n想象一下你现在正在某个被括号包围的文本中例如`(hello Vim)`，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？\n\n答案是有的。文本通常是结构化的，特别是代码中，文本经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。\n\n文本对象可以被 **操作符 operations** 使用，这里有两类文本对象：\n\n```\ni + object  内部文本对象\na + object  外部文本对象\n```\n\n**内部文本对象**选中的部分不包含包围文本对象的空白或括号等，**外部文本对象**则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多。如果你的光标位于一对括号内部，例如`(hello Vim)`中：\n- 删除括号内部的内容但保留括号：`di(`\n- 删除括号以及内部的内容：`da(`\n\n让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在\"Hello\"中的\"H\"上：\n\n```javascript\nconst hello = function() {\n    console.log(\"Hello Vim\");\n    return true;\n}\n```\n\n- 删除整个\"Hello Vim\"：`di(`\n- 删除整个函数(被{}包含)：`di{`\n- 删除\"Hello\"这个词：`diw`\n\n文本对象很强大因为你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到`di(`，`di{`和`diw`时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词。\n\n让我们来看最后一个例子。假设你有这样一些html的标签的文本：\n\n```html\n<div>\n  <h1>Header1</h1>\n  <p>Paragraph1</p>\n  <p>Paragraph2</p>\n</div>\n```\n\n如果你的光标位于\"Header1\"文本上：\n- 删除\"Header1\"：`dit`\n- 删除`<h1>Header1</h1>`：`dat`\n\n如果你的光标在\"div\"文本上：\n- 删除`h1`和所有`p`标签的行：`dit`\n- 删除所有文本：`dat`\n- 删除\"div\"：`di<`\n\n下面列举的一些通常见到的文本对象：\n```\nw     一个单词\np     一个段落\ns     一个句子\n(或)  一对()\n{或}  一对{}\n[或]  一对[]\n<或>  一对<>\nt     XML标签\n\"     一对\"\"\n'     一对''\n`     一对``\n```\n\n你可以通过`:h text-objects`了解更多\n\n## 结合性和语法\n\n在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。\n\n结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。\n\nVim的结合性最强大之处体现在它和外部程序结合时，Vim有一个 **过滤操作符**`!`可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：\n\n```\nId|Name|Cuteness\n01|Puppy|Very\n02|Kitten|Ok\n03|Bunny|Ok\n```\n\n这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令`column`很快的完成它，当你的光标位于\"Id\"上时，运行`!}column -t -s \"|\"`，你的文本就变得整齐了许多：\n\n```\nId  Name    Cuteness\n01  Puppy   Very\n02  Kitten  Ok\n03  Bunny   Ok\n```\n\n让我们分解一下上面那条命令，动词是`!`(**过滤操作符**)，名词是`}`(到下一个段落)。**过滤操作符**`!`接受终端命令作为另一个参数，因此我把`column -t -s \"|\"`传给它。我不想详细描述`column`是如何工作的，但是总之它格式化了文本。\n\n假设你不止想格式化你的文本，还想只展示`Ok`结尾的行，你知道`awk`命令可以做这件事情，那么你可以这样做：\n```\n!}column -t -s \"|\" | awk 'NR > 1 && /Ok/{print $0}'\n```\n\n结果如下：\n```\n02  Kitten  Ok\n03  Bunny   Ok\n```\n666！管道竟然在Vim中也能起作用。\n\n这就是Vim的结合性的强大之处。你知道的动词 **操作符**，名词 **动作**，终端命令越多，你组建复杂操作的能力成倍增长。\n\n换句话说，假设你只知道四个**动作**：`w, $, }, G`和删除操作符(`d`)，你可以做8件事：按四种方式移动(`w, $, }, G`)和删除4种文本对象(`dw, d$, d}, dG`)。如果有一天你学习了小写变大写的**操作符**(`gU`)，你的Vim工具箱中多的不是1种工具，而是4种：`gUw, gU$, gU}, gUG`。现在你的Vim工具箱中就有12种工具了。如果你知道10个**动作**和5个**操作符**，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(`nG`)给你了`n`种**动作**，其中`n`是你文件中的行数(例如前往第5行，`5G`)。搜索动作(`/`)实际上给你带来无限数量的**动作**因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(`!`)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。\n\n这种具有结合性的行为也正符合Unix的哲学：*一个命令做好一件事*。**动作**只需要做一件事：前往X。**操作符**只需要做一件事：完成Y。通过结合一个**操作符**和一个**动作**，你就获得了YX：在X上完成Y。\n\n甚至，**动作**和**操作符**都是可拓展的，你可以自己创造**动作**和**操作符**去丰富你的Vim工具箱，[`Vim-textobj-user`](https://github.com/kana/vim-textobj-user)插件允许你创建自己的文本对象，同时包含有[一系列定义好的文本对象](https://github.com/kana/vim-textobj-user/wiki)。\n\n另外，如果你不知道我刚才使用的`column`和`awk`命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。\n\n## 聪明地学习语法\n\n你刚刚学完Vim唯一的语法规则：\n```\nverb + noun\n```\n我学Vim中最大的\"AHA moment\"之一是当我刚学完大写命令(`gU`)时，想要把一个单词变成大写，我本能的运行了`gUiW`，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的\"AHA moment\"，如果之前没有的话。\n\n这一章的目标是向你展现Vim中的`verb+noun`模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。\n\n学习这种模式并且理解其中的含义，这是聪明的学习方式。\n","source":"_posts/Vim/ch04_vim_grammar.md","raw":"---\ntitle: VIM-语法\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第04章 Vim 语法\n\n刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用`gUfV`或`1GdG`，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。\n\n这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim\"说话\"。注意，在这一章中当我讨论Vim语言时，我讨论并不是\nVimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。\n\n## 如何学习一门语言\n\n我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：\n1. 学习语法规则\n2. 扩展我的词汇量\n3. 练习，练习，练习\n\n同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。\n\n## 语法规则\n\n你只需要知道一个Vim语言的语法规则：\n\n```\nverb + noun # 动词 + 名词\n```\n\n这就类似与在英语中的祈使句：\n- \"Eat(verb) a donut(noun)\"\n- \"Kick(verb) a ball(noun)\"\n- \"Learn(verb) the Vim Editor(noun)\"\n\n现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表\n\n## 名词(动作 Motion)\n\n我们这里将 **动作 Motion** 作为名词， **动作Motion**用来在Vim中到处移动。下面列出了一些常见的**动作**的例子：\n\n```\nh\t左\nj\t下\nk\t上\nl\t右\nw\t向前移动到下一个单词的开头\n}\t跳转到下一个段落\n$\t跳转到当前行的末尾\n```\n\n在之后的章节你将学习更多的关于**动作**的内容，所以如果你不理解上面这些**动作**也不必担心。\n\n## 动词(操作符 Operator)\n根据`:h operator`，Vim共有16个**操作符**，然而根据我的经验，学习这3个**操作符**在80%的情况下就已经够用了\n```\ny\tyank(复制)\nd\tdelete(删除)\nc\tchange 删除文本，将删除的文本存到寄存器中，进入插入模式\n```\n\n顺带说一句，当你yank一段文本后，您可以使用`p`将它粘贴到光标后，或使用`P`粘贴到光标前。\n\n## 动词（操作符 Operator）和名词（动作 motions）的结合\n\n现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则，动词和名词的结合！假设你有下面这段文本：\n\n```javascript\nconst learn = \"Vim\";\n```\n\n- 复制当前位置到行尾的所有内容：`y$`\n- 删除当前位置到下一个单词的开头：`dw`\n- 修改当前位置到这个段落的结尾：`c}`\n\n**动作 motions**也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用`3k`代替按3次`k`，数字可应用在Vim语法中。\n\n- 向左拷贝2个字符：`y2h`\n- 删除后两个单词：`d2w`\n- 修改后面两行：`c2j`\n\n目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。唯一途径就是重复、重复再重复。\n\n作为补充，行级的 **操作符 operations** (作用在整行中的操作符)在文本编辑中和其他的 **操作符** 一样，Vim允许你通过按两次 **操作符**使它执行行级的操作，例如`dd`，`yy`，`cc`来执行删除，复制或修改整个行。您可以使用其他operations试一下（比如`gUgU`）。\n\n666!从这可以看出Vim命令的一种执行模式。但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)\n\n## 更多名词(文本对象 Text Objects)\n\n想象一下你现在正在某个被括号包围的文本中例如`(hello Vim)`，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？\n\n答案是有的。文本通常是结构化的，特别是代码中，文本经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。\n\n文本对象可以被 **操作符 operations** 使用，这里有两类文本对象：\n\n```\ni + object  内部文本对象\na + object  外部文本对象\n```\n\n**内部文本对象**选中的部分不包含包围文本对象的空白或括号等，**外部文本对象**则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多。如果你的光标位于一对括号内部，例如`(hello Vim)`中：\n- 删除括号内部的内容但保留括号：`di(`\n- 删除括号以及内部的内容：`da(`\n\n让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在\"Hello\"中的\"H\"上：\n\n```javascript\nconst hello = function() {\n    console.log(\"Hello Vim\");\n    return true;\n}\n```\n\n- 删除整个\"Hello Vim\"：`di(`\n- 删除整个函数(被{}包含)：`di{`\n- 删除\"Hello\"这个词：`diw`\n\n文本对象很强大因为你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到`di(`，`di{`和`diw`时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词。\n\n让我们来看最后一个例子。假设你有这样一些html的标签的文本：\n\n```html\n<div>\n  <h1>Header1</h1>\n  <p>Paragraph1</p>\n  <p>Paragraph2</p>\n</div>\n```\n\n如果你的光标位于\"Header1\"文本上：\n- 删除\"Header1\"：`dit`\n- 删除`<h1>Header1</h1>`：`dat`\n\n如果你的光标在\"div\"文本上：\n- 删除`h1`和所有`p`标签的行：`dit`\n- 删除所有文本：`dat`\n- 删除\"div\"：`di<`\n\n下面列举的一些通常见到的文本对象：\n```\nw     一个单词\np     一个段落\ns     一个句子\n(或)  一对()\n{或}  一对{}\n[或]  一对[]\n<或>  一对<>\nt     XML标签\n\"     一对\"\"\n'     一对''\n`     一对``\n```\n\n你可以通过`:h text-objects`了解更多\n\n## 结合性和语法\n\n在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。\n\n结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。\n\nVim的结合性最强大之处体现在它和外部程序结合时，Vim有一个 **过滤操作符**`!`可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：\n\n```\nId|Name|Cuteness\n01|Puppy|Very\n02|Kitten|Ok\n03|Bunny|Ok\n```\n\n这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令`column`很快的完成它，当你的光标位于\"Id\"上时，运行`!}column -t -s \"|\"`，你的文本就变得整齐了许多：\n\n```\nId  Name    Cuteness\n01  Puppy   Very\n02  Kitten  Ok\n03  Bunny   Ok\n```\n\n让我们分解一下上面那条命令，动词是`!`(**过滤操作符**)，名词是`}`(到下一个段落)。**过滤操作符**`!`接受终端命令作为另一个参数，因此我把`column -t -s \"|\"`传给它。我不想详细描述`column`是如何工作的，但是总之它格式化了文本。\n\n假设你不止想格式化你的文本，还想只展示`Ok`结尾的行，你知道`awk`命令可以做这件事情，那么你可以这样做：\n```\n!}column -t -s \"|\" | awk 'NR > 1 && /Ok/{print $0}'\n```\n\n结果如下：\n```\n02  Kitten  Ok\n03  Bunny   Ok\n```\n666！管道竟然在Vim中也能起作用。\n\n这就是Vim的结合性的强大之处。你知道的动词 **操作符**，名词 **动作**，终端命令越多，你组建复杂操作的能力成倍增长。\n\n换句话说，假设你只知道四个**动作**：`w, $, }, G`和删除操作符(`d`)，你可以做8件事：按四种方式移动(`w, $, }, G`)和删除4种文本对象(`dw, d$, d}, dG`)。如果有一天你学习了小写变大写的**操作符**(`gU`)，你的Vim工具箱中多的不是1种工具，而是4种：`gUw, gU$, gU}, gUG`。现在你的Vim工具箱中就有12种工具了。如果你知道10个**动作**和5个**操作符**，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(`nG`)给你了`n`种**动作**，其中`n`是你文件中的行数(例如前往第5行，`5G`)。搜索动作(`/`)实际上给你带来无限数量的**动作**因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(`!`)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。\n\n这种具有结合性的行为也正符合Unix的哲学：*一个命令做好一件事*。**动作**只需要做一件事：前往X。**操作符**只需要做一件事：完成Y。通过结合一个**操作符**和一个**动作**，你就获得了YX：在X上完成Y。\n\n甚至，**动作**和**操作符**都是可拓展的，你可以自己创造**动作**和**操作符**去丰富你的Vim工具箱，[`Vim-textobj-user`](https://github.com/kana/vim-textobj-user)插件允许你创建自己的文本对象，同时包含有[一系列定义好的文本对象](https://github.com/kana/vim-textobj-user/wiki)。\n\n另外，如果你不知道我刚才使用的`column`和`awk`命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。\n\n## 聪明地学习语法\n\n你刚刚学完Vim唯一的语法规则：\n```\nverb + noun\n```\n我学Vim中最大的\"AHA moment\"之一是当我刚学完大写命令(`gU`)时，想要把一个单词变成大写，我本能的运行了`gUiW`，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的\"AHA moment\"，如果之前没有的话。\n\n这一章的目标是向你展现Vim中的`verb+noun`模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。\n\n学习这种模式并且理解其中的含义，这是聪明的学习方式。\n","slug":"Vim/ch04_vim_grammar","published":1,"updated":"2022-08-28T07:38:59.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1t0019scvmgg60ejuz","content":"<h1 id=\"第04章-Vim-语法\"><a href=\"#第04章-Vim-语法\" class=\"headerlink\" title=\"第04章 Vim 语法\"></a>第04章 Vim 语法</h1><p>刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用<code>gUfV</code>或<code>1GdG</code>，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。</p>\n<p>这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vim语言时，我讨论并不是<br>Vimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。</p>\n<h2 id=\"如何学习一门语言\"><a href=\"#如何学习一门语言\" class=\"headerlink\" title=\"如何学习一门语言\"></a>如何学习一门语言</h2><p>我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：</p>\n<ol>\n<li>学习语法规则</li>\n<li>扩展我的词汇量</li>\n<li>练习，练习，练习</li>\n</ol>\n<p>同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。</p>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">verb</span> + noun <span class=\"hljs-comment\"># 动词 + 名词</span><br></code></pre></td></tr></table></figure>\n\n<p>这就类似与在英语中的祈使句：</p>\n<ul>\n<li>“Eat(verb) a donut(noun)”</li>\n<li>“Kick(verb) a ball(noun)”</li>\n<li>“Learn(verb) the Vim Editor(noun)”</li>\n</ul>\n<p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p>\n<h2 id=\"名词-动作-Motion\"><a href=\"#名词-动作-Motion\" class=\"headerlink\" title=\"名词(动作 Motion)\"></a>名词(动作 Motion)</h2><p>我们这里将 <strong>动作 Motion</strong> 作为名词， <strong>动作Motion</strong>用来在Vim中到处移动。下面列出了一些常见的<strong>动作</strong>的例子：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-built_in\">h</span>\t左<br>j\t下<br>k\t上<br>l\t右<br>w\t向前移动到下一个单词的开头<br>&#125;\t跳转到下一个段落<br><span class=\"hljs-variable\">$</span>\t跳转到当前行的末尾<br></code></pre></td></tr></table></figure>\n\n<p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些<strong>动作</strong>也不必担心。</p>\n<h2 id=\"动词-操作符-Operator\"><a href=\"#动词-操作符-Operator\" class=\"headerlink\" title=\"动词(操作符 Operator)\"></a>动词(操作符 Operator)</h2><p>根据<code>:h operator</code>，Vim共有16个<strong>操作符</strong>，然而根据我的经验，学习这3个<strong>操作符</strong>在80%的情况下就已经够用了</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">y</span>\t<span class=\"hljs-function\"><span class=\"hljs-title\">yank</span>(复制)</span><br><span class=\"hljs-variable\">d</span>\t<span class=\"hljs-function\"><span class=\"hljs-title\">delete</span>(删除)</span><br><span class=\"hljs-variable\">c</span>\t<span class=\"hljs-variable\">change</span> 删除文本，将删除的文本存到寄存器中，进入插入模式<br></code></pre></td></tr></table></figure>\n\n<p>顺带说一句，当你yank一段文本后，您可以使用<code>p</code>将它粘贴到光标后，或使用<code>P</code>粘贴到光标前。</p>\n<h2 id=\"动词（操作符-Operator）和名词（动作-motions）的结合\"><a href=\"#动词（操作符-Operator）和名词（动作-motions）的结合\" class=\"headerlink\" title=\"动词（操作符 Operator）和名词（动作 motions）的结合\"></a>动词（操作符 Operator）和名词（动作 motions）的结合</h2><p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则，动词和名词的结合！假设你有下面这段文本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> learn = <span class=\"hljs-string\">&quot;Vim&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>复制当前位置到行尾的所有内容：<code>y$</code></li>\n<li>删除当前位置到下一个单词的开头：<code>dw</code></li>\n<li>修改当前位置到这个段落的结尾：<code>c&#125;</code></li>\n</ul>\n<p><strong>动作 motions</strong>也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用<code>3k</code>代替按3次<code>k</code>，数字可应用在Vim语法中。</p>\n<ul>\n<li>向左拷贝2个字符：<code>y2h</code></li>\n<li>删除后两个单词：<code>d2w</code></li>\n<li>修改后面两行：<code>c2j</code></li>\n</ul>\n<p>目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。唯一途径就是重复、重复再重复。</p>\n<p>作为补充，行级的 <strong>操作符 operations</strong> (作用在整行中的操作符)在文本编辑中和其他的 <strong>操作符</strong> 一样，Vim允许你通过按两次 <strong>操作符</strong>使它执行行级的操作，例如<code>dd</code>，<code>yy</code>，<code>cc</code>来执行删除，复制或修改整个行。您可以使用其他operations试一下（比如<code>gUgU</code>）。</p>\n<p>666!从这可以看出Vim命令的一种执行模式。但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)</p>\n<h2 id=\"更多名词-文本对象-Text-Objects\"><a href=\"#更多名词-文本对象-Text-Objects\" class=\"headerlink\" title=\"更多名词(文本对象 Text Objects)\"></a>更多名词(文本对象 Text Objects)</h2><p>想象一下你现在正在某个被括号包围的文本中例如<code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？</p>\n<p>答案是有的。文本通常是结构化的，特别是代码中，文本经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。</p>\n<p>文本对象可以被 <strong>操作符 operations</strong> 使用，这里有两类文本对象：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">i</span> + <span class=\"hljs-selector-tag\">object</span>  内部文本对象<br><span class=\"hljs-selector-tag\">a</span> + <span class=\"hljs-selector-tag\">object</span>  外部文本对象<br></code></pre></td></tr></table></figure>\n\n<p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多。如果你的光标位于一对括号内部，例如<code>(hello Vim)</code>中：</p>\n<ul>\n<li>删除括号内部的内容但保留括号：<code>di(</code></li>\n<li>删除括号以及内部的内容：<code>da(</code></li>\n</ul>\n<p>让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在”Hello”中的”H”上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> hello = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello Vim&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>删除整个”Hello Vim”：<code>di(</code></li>\n<li>删除整个函数(被{}包含)：<code>di&#123;</code></li>\n<li>删除”Hello”这个词：<code>diw</code></li>\n</ul>\n<p>文本对象很强大因为你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到<code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词。</p>\n<p>让我们来看最后一个例子。假设你有这样一些html的标签的文本：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Header1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你的光标位于”Header1”文本上：</p>\n<ul>\n<li>删除”Header1”：<code>dit</code></li>\n<li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：<code>dat</code></li>\n</ul>\n<p>如果你的光标在”div”文本上：</p>\n<ul>\n<li>删除<code>h1</code>和所有<code>p</code>标签的行：<code>dit</code></li>\n<li>删除所有文本：<code>dat</code></li>\n<li>删除”div”：<code>di&lt;</code></li>\n</ul>\n<p>下面列举的一些通常见到的文本对象：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">w     一个单词<br>p     一个段落<br>s     一个句子<br>(或)  一对()<br>&#123;或&#125;  一对&#123;&#125;<br>[或]  一对[]<br>&lt;或&gt;  一对&lt;&gt;<br>t     XML标签<br><span class=\"hljs-string\">&quot;     一对&quot;&quot;</span><br>&#x27;     一对&#x27;&#x27;<br>`     一对``<br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>:h text-objects</code>了解更多</p>\n<h2 id=\"结合性和语法\"><a href=\"#结合性和语法\" class=\"headerlink\" title=\"结合性和语法\"></a>结合性和语法</h2><p>在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。</p>\n<p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。</p>\n<p>Vim的结合性最强大之处体现在它和外部程序结合时，Vim有一个 <strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coq\">Id|<span class=\"hljs-type\">Name</span>|<span class=\"hljs-type\">Cuteness</span><br><span class=\"hljs-number\">01</span>|<span class=\"hljs-type\">Puppy</span>|<span class=\"hljs-type\">Very</span><br><span class=\"hljs-number\">02</span>|<span class=\"hljs-type\">Kitten</span>|<span class=\"hljs-type\">Ok</span><br><span class=\"hljs-number\">03</span>|<span class=\"hljs-type\">Bunny</span>|<span class=\"hljs-type\">Ok</span><br></code></pre></td></tr></table></figure>\n\n<p>这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令<code>column</code>很快的完成它，当你的光标位于”Id”上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多：</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\">Id  Name    Cuteness<br><span class=\"hljs-number\">01</span>  Puppy   Very<br><span class=\"hljs-number\">02</span>  Kitten  <span class=\"hljs-literal\">Ok</span><br><span class=\"hljs-number\">03</span>  Bunny   <span class=\"hljs-literal\">Ok</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下上面那条命令，动词是<code>!</code>(<strong>过滤操作符</strong>)，名词是<code>&#125;</code>(到下一个段落)。<strong>过滤操作符</strong><code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本。</p>\n<p>假设你不止想格式化你的文本，还想只展示<code>Ok</code>结尾的行，你知道<code>awk</code>命令可以做这件事情，那么你可以这样做：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">!&#125;column -t -s <span class=\"hljs-string\">&quot;|&quot;</span> | awk <span class=\"hljs-string\">&#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print <span class=\"hljs-subst\">$0</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">02 </span> Kitten  Ok<br><span class=\"hljs-symbol\">03 </span> Bunny   Ok<br></code></pre></td></tr></table></figure>\n<p>666！管道竟然在Vim中也能起作用。</p>\n<p>这就是Vim的结合性的强大之处。你知道的动词 <strong>操作符</strong>，名词 <strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长。</p>\n<p>换句话说，假设你只知道四个<strong>动作</strong>：<code>w, $, &#125;, G</code>和删除操作符(<code>d</code>)，你可以做8件事：按四种方式移动(<code>w, $, &#125;, G</code>)和删除4种文本对象(<code>dw, d$, d&#125;, dG</code>)。如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的Vim工具箱中多的不是1种工具，而是4种：<code>gUw, gU$, gU&#125;, gUG</code>。现在你的Vim工具箱中就有12种工具了。如果你知道10个<strong>动作</strong>和5个<strong>操作符</strong>，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(<code>nG</code>)给你了<code>n</code>种<strong>动作</strong>，其中<code>n</code>是你文件中的行数(例如前往第5行，<code>5G</code>)。搜索动作(<code>/</code>)实际上给你带来无限数量的<strong>动作</strong>因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(<code>!</code>)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。</p>\n<p>这种具有结合性的行为也正符合Unix的哲学：<em>一个命令做好一件事</em>。<strong>动作</strong>只需要做一件事：前往X。<strong>操作符</strong>只需要做一件事：完成Y。通过结合一个<strong>操作符</strong>和一个<strong>动作</strong>，你就获得了YX：在X上完成Y。</p>\n<p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造<strong>动作</strong>和<strong>操作符</strong>去丰富你的Vim工具箱，<a href=\"https://github.com/kana/vim-textobj-user\"><code>Vim-textobj-user</code></a>插件允许你创建自己的文本对象，同时包含有<a href=\"https://github.com/kana/vim-textobj-user/wiki\">一系列定义好的文本对象</a>。</p>\n<p>另外，如果你不知道我刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。</p>\n<h2 id=\"聪明地学习语法\"><a href=\"#聪明地学习语法\" class=\"headerlink\" title=\"聪明地学习语法\"></a>聪明地学习语法</h2><p>你刚刚学完Vim唯一的语法规则：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">verb + <span class=\"hljs-built_in\">noun</span><br></code></pre></td></tr></table></figure>\n<p>我学Vim中最大的”AHA moment”之一是当我刚学完大写命令(<code>gU</code>)时，想要把一个单词变成大写，我本能的运行了<code>gUiW</code>，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的”AHA moment”，如果之前没有的话。</p>\n<p>这一章的目标是向你展现Vim中的<code>verb+noun</code>模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。</p>\n<p>学习这种模式并且理解其中的含义，这是聪明的学习方式。</p>\n","site":{"data":{}},"wordcount":4245,"excerpt":"","more":"<h1 id=\"第04章-Vim-语法\"><a href=\"#第04章-Vim-语法\" class=\"headerlink\" title=\"第04章 Vim 语法\"></a>第04章 Vim 语法</h1><p>刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用<code>gUfV</code>或<code>1GdG</code>，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。</p>\n<p>这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vim语言时，我讨论并不是<br>Vimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。</p>\n<h2 id=\"如何学习一门语言\"><a href=\"#如何学习一门语言\" class=\"headerlink\" title=\"如何学习一门语言\"></a>如何学习一门语言</h2><p>我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：</p>\n<ol>\n<li>学习语法规则</li>\n<li>扩展我的词汇量</li>\n<li>练习，练习，练习</li>\n</ol>\n<p>同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。</p>\n<h2 id=\"语法规则\"><a href=\"#语法规则\" class=\"headerlink\" title=\"语法规则\"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">verb</span> + noun <span class=\"hljs-comment\"># 动词 + 名词</span><br></code></pre></td></tr></table></figure>\n\n<p>这就类似与在英语中的祈使句：</p>\n<ul>\n<li>“Eat(verb) a donut(noun)”</li>\n<li>“Kick(verb) a ball(noun)”</li>\n<li>“Learn(verb) the Vim Editor(noun)”</li>\n</ul>\n<p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p>\n<h2 id=\"名词-动作-Motion\"><a href=\"#名词-动作-Motion\" class=\"headerlink\" title=\"名词(动作 Motion)\"></a>名词(动作 Motion)</h2><p>我们这里将 <strong>动作 Motion</strong> 作为名词， <strong>动作Motion</strong>用来在Vim中到处移动。下面列出了一些常见的<strong>动作</strong>的例子：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-built_in\">h</span>\t左<br>j\t下<br>k\t上<br>l\t右<br>w\t向前移动到下一个单词的开头<br>&#125;\t跳转到下一个段落<br><span class=\"hljs-variable\">$</span>\t跳转到当前行的末尾<br></code></pre></td></tr></table></figure>\n\n<p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些<strong>动作</strong>也不必担心。</p>\n<h2 id=\"动词-操作符-Operator\"><a href=\"#动词-操作符-Operator\" class=\"headerlink\" title=\"动词(操作符 Operator)\"></a>动词(操作符 Operator)</h2><p>根据<code>:h operator</code>，Vim共有16个<strong>操作符</strong>，然而根据我的经验，学习这3个<strong>操作符</strong>在80%的情况下就已经够用了</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">y</span>\t<span class=\"hljs-function\"><span class=\"hljs-title\">yank</span>(复制)</span><br><span class=\"hljs-variable\">d</span>\t<span class=\"hljs-function\"><span class=\"hljs-title\">delete</span>(删除)</span><br><span class=\"hljs-variable\">c</span>\t<span class=\"hljs-variable\">change</span> 删除文本，将删除的文本存到寄存器中，进入插入模式<br></code></pre></td></tr></table></figure>\n\n<p>顺带说一句，当你yank一段文本后，您可以使用<code>p</code>将它粘贴到光标后，或使用<code>P</code>粘贴到光标前。</p>\n<h2 id=\"动词（操作符-Operator）和名词（动作-motions）的结合\"><a href=\"#动词（操作符-Operator）和名词（动作-motions）的结合\" class=\"headerlink\" title=\"动词（操作符 Operator）和名词（动作 motions）的结合\"></a>动词（操作符 Operator）和名词（动作 motions）的结合</h2><p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则，动词和名词的结合！假设你有下面这段文本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> learn = <span class=\"hljs-string\">&quot;Vim&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>复制当前位置到行尾的所有内容：<code>y$</code></li>\n<li>删除当前位置到下一个单词的开头：<code>dw</code></li>\n<li>修改当前位置到这个段落的结尾：<code>c&#125;</code></li>\n</ul>\n<p><strong>动作 motions</strong>也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用<code>3k</code>代替按3次<code>k</code>，数字可应用在Vim语法中。</p>\n<ul>\n<li>向左拷贝2个字符：<code>y2h</code></li>\n<li>删除后两个单词：<code>d2w</code></li>\n<li>修改后面两行：<code>c2j</code></li>\n</ul>\n<p>目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。唯一途径就是重复、重复再重复。</p>\n<p>作为补充，行级的 <strong>操作符 operations</strong> (作用在整行中的操作符)在文本编辑中和其他的 <strong>操作符</strong> 一样，Vim允许你通过按两次 <strong>操作符</strong>使它执行行级的操作，例如<code>dd</code>，<code>yy</code>，<code>cc</code>来执行删除，复制或修改整个行。您可以使用其他operations试一下（比如<code>gUgU</code>）。</p>\n<p>666!从这可以看出Vim命令的一种执行模式。但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)</p>\n<h2 id=\"更多名词-文本对象-Text-Objects\"><a href=\"#更多名词-文本对象-Text-Objects\" class=\"headerlink\" title=\"更多名词(文本对象 Text Objects)\"></a>更多名词(文本对象 Text Objects)</h2><p>想象一下你现在正在某个被括号包围的文本中例如<code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？</p>\n<p>答案是有的。文本通常是结构化的，特别是代码中，文本经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。</p>\n<p>文本对象可以被 <strong>操作符 operations</strong> 使用，这里有两类文本对象：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">i</span> + <span class=\"hljs-selector-tag\">object</span>  内部文本对象<br><span class=\"hljs-selector-tag\">a</span> + <span class=\"hljs-selector-tag\">object</span>  外部文本对象<br></code></pre></td></tr></table></figure>\n\n<p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多。如果你的光标位于一对括号内部，例如<code>(hello Vim)</code>中：</p>\n<ul>\n<li>删除括号内部的内容但保留括号：<code>di(</code></li>\n<li>删除括号以及内部的内容：<code>da(</code></li>\n</ul>\n<p>让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在”Hello”中的”H”上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> hello = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello Vim&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>删除整个”Hello Vim”：<code>di(</code></li>\n<li>删除整个函数(被{}包含)：<code>di&#123;</code></li>\n<li>删除”Hello”这个词：<code>diw</code></li>\n</ul>\n<p>文本对象很强大因为你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到<code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词。</p>\n<p>让我们来看最后一个例子。假设你有这样一些html的标签的文本：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Header1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你的光标位于”Header1”文本上：</p>\n<ul>\n<li>删除”Header1”：<code>dit</code></li>\n<li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：<code>dat</code></li>\n</ul>\n<p>如果你的光标在”div”文本上：</p>\n<ul>\n<li>删除<code>h1</code>和所有<code>p</code>标签的行：<code>dit</code></li>\n<li>删除所有文本：<code>dat</code></li>\n<li>删除”div”：<code>di&lt;</code></li>\n</ul>\n<p>下面列举的一些通常见到的文本对象：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">w     一个单词<br>p     一个段落<br>s     一个句子<br>(或)  一对()<br>&#123;或&#125;  一对&#123;&#125;<br>[或]  一对[]<br>&lt;或&gt;  一对&lt;&gt;<br>t     XML标签<br><span class=\"hljs-string\">&quot;     一对&quot;&quot;</span><br>&#x27;     一对&#x27;&#x27;<br>`     一对``<br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>:h text-objects</code>了解更多</p>\n<h2 id=\"结合性和语法\"><a href=\"#结合性和语法\" class=\"headerlink\" title=\"结合性和语法\"></a>结合性和语法</h2><p>在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。</p>\n<p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。</p>\n<p>Vim的结合性最强大之处体现在它和外部程序结合时，Vim有一个 <strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coq\">Id|<span class=\"hljs-type\">Name</span>|<span class=\"hljs-type\">Cuteness</span><br><span class=\"hljs-number\">01</span>|<span class=\"hljs-type\">Puppy</span>|<span class=\"hljs-type\">Very</span><br><span class=\"hljs-number\">02</span>|<span class=\"hljs-type\">Kitten</span>|<span class=\"hljs-type\">Ok</span><br><span class=\"hljs-number\">03</span>|<span class=\"hljs-type\">Bunny</span>|<span class=\"hljs-type\">Ok</span><br></code></pre></td></tr></table></figure>\n\n<p>这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令<code>column</code>很快的完成它，当你的光标位于”Id”上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多：</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\">Id  Name    Cuteness<br><span class=\"hljs-number\">01</span>  Puppy   Very<br><span class=\"hljs-number\">02</span>  Kitten  <span class=\"hljs-literal\">Ok</span><br><span class=\"hljs-number\">03</span>  Bunny   <span class=\"hljs-literal\">Ok</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下上面那条命令，动词是<code>!</code>(<strong>过滤操作符</strong>)，名词是<code>&#125;</code>(到下一个段落)。<strong>过滤操作符</strong><code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本。</p>\n<p>假设你不止想格式化你的文本，还想只展示<code>Ok</code>结尾的行，你知道<code>awk</code>命令可以做这件事情，那么你可以这样做：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">!&#125;column -t -s <span class=\"hljs-string\">&quot;|&quot;</span> | awk <span class=\"hljs-string\">&#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print <span class=\"hljs-subst\">$0</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">02 </span> Kitten  Ok<br><span class=\"hljs-symbol\">03 </span> Bunny   Ok<br></code></pre></td></tr></table></figure>\n<p>666！管道竟然在Vim中也能起作用。</p>\n<p>这就是Vim的结合性的强大之处。你知道的动词 <strong>操作符</strong>，名词 <strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长。</p>\n<p>换句话说，假设你只知道四个<strong>动作</strong>：<code>w, $, &#125;, G</code>和删除操作符(<code>d</code>)，你可以做8件事：按四种方式移动(<code>w, $, &#125;, G</code>)和删除4种文本对象(<code>dw, d$, d&#125;, dG</code>)。如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的Vim工具箱中多的不是1种工具，而是4种：<code>gUw, gU$, gU&#125;, gUG</code>。现在你的Vim工具箱中就有12种工具了。如果你知道10个<strong>动作</strong>和5个<strong>操作符</strong>，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(<code>nG</code>)给你了<code>n</code>种<strong>动作</strong>，其中<code>n</code>是你文件中的行数(例如前往第5行，<code>5G</code>)。搜索动作(<code>/</code>)实际上给你带来无限数量的<strong>动作</strong>因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(<code>!</code>)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。</p>\n<p>这种具有结合性的行为也正符合Unix的哲学：<em>一个命令做好一件事</em>。<strong>动作</strong>只需要做一件事：前往X。<strong>操作符</strong>只需要做一件事：完成Y。通过结合一个<strong>操作符</strong>和一个<strong>动作</strong>，你就获得了YX：在X上完成Y。</p>\n<p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造<strong>动作</strong>和<strong>操作符</strong>去丰富你的Vim工具箱，<a href=\"https://github.com/kana/vim-textobj-user\"><code>Vim-textobj-user</code></a>插件允许你创建自己的文本对象，同时包含有<a href=\"https://github.com/kana/vim-textobj-user/wiki\">一系列定义好的文本对象</a>。</p>\n<p>另外，如果你不知道我刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。</p>\n<h2 id=\"聪明地学习语法\"><a href=\"#聪明地学习语法\" class=\"headerlink\" title=\"聪明地学习语法\"></a>聪明地学习语法</h2><p>你刚刚学完Vim唯一的语法规则：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">verb + <span class=\"hljs-built_in\">noun</span><br></code></pre></td></tr></table></figure>\n<p>我学Vim中最大的”AHA moment”之一是当我刚学完大写命令(<code>gU</code>)时，想要把一个单词变成大写，我本能的运行了<code>gUiW</code>，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的”AHA moment”，如果之前没有的话。</p>\n<p>这一章的目标是向你展现Vim中的<code>verb+noun</code>模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。</p>\n<p>学习这种模式并且理解其中的含义，这是聪明的学习方式。</p>\n"},{"title":"VIM-在文件中移动","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第05章 在文件中移动\n\n一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。\n\n这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令(motions)，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看`:h motion.txt`。\n\n## 字符导航\n\n最基本的移动单元是上下左右移动一个字符。\n\n```\nh   左\nj   下\nk   上\nl   右\n```\n\n你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。\n\n我更喜欢`hjkl`因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过`~/.vimrc`关闭了方向键：\n\n```\nnoremap <Up> <NOP>\nnoremap <Down> <NOP>\nnoremap <Left> <NOP>\nnoremap <Right> <NOP>\n```\n\n也有一些插件可以帮助改掉这个坏习惯，其中有一个叫[vim-hardtime](https://github.com/takac/vim-hardtime)。 让我感到惊讶的是，我只用了几天就习惯了使用`hjkl`。\n\n另外，如果你想知道为什么Vim使用`hjkl`进行移动，*这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把`hjkl`当做方向键*。\n\n如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用`h`和`l`。 如果我需要在可见的范围内上下移动几行，我会使用`j`和`k`。 如果我想去更远的地方，我倾向于使用其他移动命令。\n\n## 相对行号\n\n我觉得设置`number`和`relativenumber`非常有用，你可以在`~/.vimrc`中设置:\n\n```\nset relativenumber number\n```\n\n这将会展示当前行号和其他行相对当前行的行号。\n\n为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用`12j`去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69=12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。\n\n这是一个100%的个人偏好，你可以尝试`relativenumber`/`norelativenumber`，`number`/`nonumber` 然后选择自己觉得最有用的。\n\n## 对移动计数\n\n在继续之前，让我们讨论一下\"计数\"参数。 一个移动(motion)可以接受一个数字前缀作为参数，上面我提到的你可以通过`12j`向下移动12行，其中`12j`中的`12`就是计数数字。\n\n你使用带计数的移动的语法如下：\n\n```\n[计数] + 移动\n```\n\n你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用`9l`来代替按9次`l`。 当你学到了更多的动作时，你都可以试试给定计数参数。\n\n## 单词导航\n\n我们现在移动一个更长的单元：单词(word)。 你可以通过`w`移动到下一个单词的开始，通过`e`移动到下一个单词的结尾，通过`b`移动到上一个单词的开始，通过`ge`移动到前一个单词的结尾。\n\n另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过`W`移动到下一个词组的开始，通过`E`移动到下一个词组的结尾，通过`B`移动到前一个词组的开头，通过`gE`移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。\n\n```\nw\t\t移动到下一个单词的开头\nW\t\t移动到下一个词组的开头\ne\t\t移动到下一个单词的结尾\nE\t\t移动到下一个词组的结尾\nb\t\t移动到前一个单词的开头\nB\t\t移动到前一个词组的开头\nge\t移动到前一个单词的结尾\ngE\t移动到前一个词组的结尾\n```\n\n词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含`a-zA-Z0-9`字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过`:h word`和`:h WORD`了解更多。\n\n例如，假如你有下面这段内容：\n\n```\nconst hello = \"world\";\n```\n\n当你光标位于这行的开头时，你可以通过`l`走到行尾，但是你需要按21下，使用`w`，你需要6下，使用`W`只需要4下。 单词和词组都是短距离移动的很好的选择。\n\n然而，之后你可以通过当前行导航只按一次从`c`移动到`;`。\n\n## 当前行导航\n\n当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过`0`跳到本行第一个字符，通过`$`跳到本行最后一个字符。 另外，你可以使用`^`跳到本行第一个非空字符，通过`g_`跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用`n|`。\n\n```\n0\t\t跳到本行第一个字符\n^\t\t跳到本行第一个非空字符\ng_      跳到本行最后一个非空字符\n$\t\t跳到本行最后一个字符\nn|      跳到本行第n列\n```\n\n你也可以在本行通过`f`和`t`进行行内搜索，`f`和`t`的区别在于`f`会停在第一个匹配的字母上，`t`会停在第一个匹配的字母前。 因此如果你想要搜索并停留在\"h\"上，使用`fh`。 如果你想搜索第一个\"h\"并停留在它的前一个字母上，可以使用`th`。 如果你想去下一个行内匹配的位置，使用`;`，如果你想去前一个行内匹配的位置，使用`,`。\n\n`F`和`T`是`f`和`t`对应的向后搜索版本。如果想向前搜索\"h\"，可以使用`Fh`，使用`;`，保持相同的搜索方向搜索下一个匹配的字母。 注意，`;`不是总是向后搜索，`;`表示的是上一次搜索的方向，因此如果你使用的`F`，那么使用`;`时将会向前搜索使用`,`时向后搜索。\n\n```\nf   在同一行向后搜索第一个匹配\nF   在同一行向前搜索第一个匹配\nt   在同一行向后搜索第一个匹配，并停在匹配前\nT   在同一行向前搜索第一个匹配，并停在匹配前\n;   在同一行重复最近一次搜索\n,   在同一行向相反方向重复最近一次搜索\n```\n\n回到上一个例子：\n\n```\nconst hello = \"world\";\n```\n\n当你的光标位于行的开头时，你可以通过按一次键`$`去往行尾的最后一个字符\";\"。 如果想去往\"world\"中的\"w\"，你可以使用`fw`。 一个建议是，在行内目标附近通过寻找重复出现最少的字母例如\"j\"，\"x\"，\"z\"来前往行中的该位置更快。\n\n## 句子和段落导航\n\n接下来两个移动的单元是句子和段落。\n\n首先我们来聊聊句子。 一个句子的定义是以`.!?`和跟着的一个换行符或空格，tab结尾的。 你可以通过`)`和`(`跳到下一个和上一个句子。\n\n```\n(   跳到前一个句子\n)   跳到下一个句子\n```\n\n让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用`(`和`)`感受一下。\n\n```\nI am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :\n\nThere is an empty line above me.\n\n```\n\n另外，如果你的Vim中遇到了无法将一个以`.`结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于`compatible`的模式。 运行`:set nocompatible`可以修复。 在Vi中，一个句子是以**两个**空格结尾的，你应该总是保持的`nocompatible`的设置。\n\n接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项(`paragraphs`)中\"字符对\"所指定的段落宏的每个集合开始。\n\n```\n{   跳转到上一个段落\n}   跳转到下一个段落\n```\n\n如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。\n\n我们来看这个例子。 你可以尝试着使用`}`和`{`进行导航，也可以试一试`()`这样的句子导航。\n\n```\nHello. How are you? I am great, thanks!\nVim is awesome.\nIt may not easy to learn it at first...- but we are in this together. Good luck!\n\nHello again.\n\nTry to move around with ), (, }, and {. Feel how they work.\nYou got this.\n```\n\n你可以通过`:h setence`和`:h paragraph`了解更多。\n\n## 匹配导航\n\n程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过`%`跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。\n\n```\n%    Navigate to another match, usually works for (), [], {}\n```\n\n我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用`%`移动\n\n```\n(define (fib n)\n  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        (else\n          (+ (fib (- n 1)) (fib (- n 2)))\n        )))\n```\n\n我个人喜欢使用类似[vim-rainbow](https://github.com/frazrepo/vim-rainbow)这样的可视化指示插件来作为`%`的补充。 通过`:h %`了解更多。\n\n## 行号导航\n\n你可以通过`nG`调到行号为`n`的行，例如如果你想跳到第7行，你可以使用`7G`，跳到第一行使用`gg`或`1G`，跳到最后一行使用`G`。\n\n有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用`70%`跳过去，可以使用`50%`跳到文件的中间。\n\n```\ngg      跳转到第一行\nG       跳转到最后一行\nnG      跳转到第n行\nn%      跳到文件的n%\n```\n\n另外，如果你想看文件总行数，可以用`CTRL-g`查看。\n\n## 窗格导航\n\n为了移动到当前窗格的顶部，中间，底部，你可以使用`H`，`M`和`L`。\n\n你也可以给`H`和`L`传一个数字前缀。 如果你输入`10H`你会跳转到窗格顶部往下数10行的位置，如果你输入`3L`，你会跳转到距离当前窗格的底部一行向上数3行的位置。\n\n```\nH   跳转到屏幕的顶部\nM   跳转到屏幕的中间\nL   跳转到屏幕的底部\nnH  跳转到距离顶部n行的位置\nnL  跳转到距离底部n行的位置\n```\n\n## 滚动\n\n在文件中滚动，你有三种速度可以选择： 滚动一整页(`CTRL-F`/`CTRL-B`)，滚动半页(`CTRL-D`/`CTRL-U`)，滚动一行`CTRL-E`/`CTRL-Y`)。\n\n```\nCtrl-e    向下滚动一行\nCtrl-d    向下滚动半屏\nCtrl-f    向下滚动一屏\nCtrl-y    向上滚动一行\nCtrl-u    向上滚动半屏\nCtrl-b    向上滚动一屏\n```\n\n你也可以相对当前行进行滚动\n\n```\nzt    将当前行置于屏幕顶部附近\nzz    将当前行置于屏幕中央\nzb    将当前行置于屏幕底部\n```\n\n## 搜索导航\n\n通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过`/`向下搜索，也可以通过`?`向上搜索一个字段。 你可以通过`n`重复最近一次搜索，`N`向反方向重复最近一次搜索。\n\n```\n/   向后搜索一个匹配\n?   向前搜素一个匹配\nn   重复上一次搜索(和上一次方向相同)\nN   重复上一次搜索(和上一次方向相反)\n```\n\n假设你有一下文本：\n\n```\nlet one = 1;\nlet two = 2;\none = \"01\";\none = \"one\";\nlet onetwo = 12;\n```\n\n你可以通过`/let`搜索\"let\"，然后通过`n`快速的重复搜索下一个\"let\"，如果需要向相反方向搜索，可以使用`N`。 如果你用`?let`搜索，会得到一个向前的搜索，这时你使用`n`，它会继续向前搜索，就和`?`的方向一致。(`N`将会向后搜索\"let\")。\n\n你可以通过`:set hlsearch`设置搜索高亮。 这样，当你搜索`/let`，它将高亮文件中所有匹配的字段。 另外，如果你通过`:set incsearch`设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用`:nohlsearch`。 因为我经常使用这个功能，所以我会设置一个映射：\n\n```\nnnoremap <esc><esc> :noh<return><esc>\n```\n\n你可以通过`*`快速的向前搜索光标下的文本，通过`#`快速向后搜索光标下的文本。 如果你的光标位于一个字符串\"one\"上，按下`*`相当于`/\\<one\\>`。\n`/\\<one\\>`中的`\\<`和`\\>`表示整词匹配，使得一个更长的包含\"one\"的单词不会被匹配上，也就是说它会匹配\"one\"，但不会匹配\"onetwo\"。 如果你的光标在\"one\"上并且你想向后搜索完全或部分匹配的单词，例如\"one\"和\"onetwo\"，你可以用`g*`替代`*`。\n\n```\n*   向后查找光标所在的完整单词\n#   向前查找光标所在的完整单词\ng*  向后搜索光标所在的单词\ng#  向前搜索光标所在的单词\n```\n\n## 位置标记\n\n你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过`mx`设置一个标记，其中`x`可以是`a-zA-Z`。 有两种办法能回到标记的位置： 用`` `x``精确回到(行和列)，或者用`'x`回到行级位置。\n\n```\nma    用a标签标记一个位置\n`a    精确回到a标签的位置(行和列)\n'a    跳转到a标签的行\n```\n\n`a-z`的标签和`A-Z`的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。\n\n我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记\"a\"(`ma`)，然后在另一个文件中设置另一个标记\"a\"(`ma`)。\n\n不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在`myFile.txt`中设置了标签`mA`，下一次你在另一个文件中设置`mA`时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。\n\n使用`:marks`查看所有标签，你也许会注意到除了`a-zA-Z`以外还有别的标签，其中有一些例如：\n\n```\n''   在当前buffer中跳转回到上一次跳转前的最后一行\n``  在当前buffer中跳转回到上一次跳转前的最后一个位置\n`[  跳转到上一次修改或拷贝的文本的开头\n`]  跳转到上一次修改或拷贝的文本的结尾\n`<  跳转到最近一次可视模式下选择的部分的开头\n`>  跳转到最近一次可视模式下选择的部分的结尾\n`0  跳转到退出Vim前编辑的最后一个文件\n```\n\n除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过`: marks`查看。\n\n## 跳转\n最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用`j`向下移动一行就不被看做一个跳转，即使你使用`10j`向下移动10行，也不是一个跳转。 但是你通过`10G`去往第10行被算作一个跳转。\n\n```\n'   跳转到标记的行\n`   跳转到标记的位置(行和列)\nG   跳转到行\n/   向后搜索\n?   向前搜索\nn   重复上一次搜索，相同方向\nN   重复上一次搜索，相反方向\n%   查找匹配\n(   跳转上一个句子\n)   跳转下一个句子\n{   跳转上一个段落\n}   跳转下一个段落\nL   跳转到当前屏幕的最后一行\nM   跳转到当前屏幕的中间\nH   跳转到当前屏幕的第一行\n[[  跳转到上一个小节\n]]  跳转到下一个小节\n:s  替换\n:tag  跳转到tag定义\n```\n我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过`:jumps`查看这个列表，如果想了解更多，可以查看`:h jump-motions`。\n\n为什么跳转有用呢? 因为你可以在跳转列表中通过`Ctrl-o`和`Ctrl-i`在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。\n\n## 聪明地学习导航\n如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。\n\n我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从`h,j,k,l,w,b,G,/,?,n`开始，不断地重复这10个移动知道形成肌肉记忆，这花不了多少时间。\n\n为了让你更擅长导航，我有两个建议：\n1. 注意重复的动作。 如果你发现你自己在重复的使用`l`，你可以去找一个方法让你前进的更快，然后你会发现你可以用`w`在单词间移动。 如果你发现你自己的重复的使用`w`，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用`$`。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。\n2. 当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。\n\n最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。\n\n慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。\n","source":"_posts/Vim/ch05_moving_in_file.md","raw":"---\ntitle: VIM-在文件中移动\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第05章 在文件中移动\n\n一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。\n\n这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令(motions)，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看`:h motion.txt`。\n\n## 字符导航\n\n最基本的移动单元是上下左右移动一个字符。\n\n```\nh   左\nj   下\nk   上\nl   右\n```\n\n你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。\n\n我更喜欢`hjkl`因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过`~/.vimrc`关闭了方向键：\n\n```\nnoremap <Up> <NOP>\nnoremap <Down> <NOP>\nnoremap <Left> <NOP>\nnoremap <Right> <NOP>\n```\n\n也有一些插件可以帮助改掉这个坏习惯，其中有一个叫[vim-hardtime](https://github.com/takac/vim-hardtime)。 让我感到惊讶的是，我只用了几天就习惯了使用`hjkl`。\n\n另外，如果你想知道为什么Vim使用`hjkl`进行移动，*这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把`hjkl`当做方向键*。\n\n如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用`h`和`l`。 如果我需要在可见的范围内上下移动几行，我会使用`j`和`k`。 如果我想去更远的地方，我倾向于使用其他移动命令。\n\n## 相对行号\n\n我觉得设置`number`和`relativenumber`非常有用，你可以在`~/.vimrc`中设置:\n\n```\nset relativenumber number\n```\n\n这将会展示当前行号和其他行相对当前行的行号。\n\n为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用`12j`去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69=12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。\n\n这是一个100%的个人偏好，你可以尝试`relativenumber`/`norelativenumber`，`number`/`nonumber` 然后选择自己觉得最有用的。\n\n## 对移动计数\n\n在继续之前，让我们讨论一下\"计数\"参数。 一个移动(motion)可以接受一个数字前缀作为参数，上面我提到的你可以通过`12j`向下移动12行，其中`12j`中的`12`就是计数数字。\n\n你使用带计数的移动的语法如下：\n\n```\n[计数] + 移动\n```\n\n你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用`9l`来代替按9次`l`。 当你学到了更多的动作时，你都可以试试给定计数参数。\n\n## 单词导航\n\n我们现在移动一个更长的单元：单词(word)。 你可以通过`w`移动到下一个单词的开始，通过`e`移动到下一个单词的结尾，通过`b`移动到上一个单词的开始，通过`ge`移动到前一个单词的结尾。\n\n另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过`W`移动到下一个词组的开始，通过`E`移动到下一个词组的结尾，通过`B`移动到前一个词组的开头，通过`gE`移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。\n\n```\nw\t\t移动到下一个单词的开头\nW\t\t移动到下一个词组的开头\ne\t\t移动到下一个单词的结尾\nE\t\t移动到下一个词组的结尾\nb\t\t移动到前一个单词的开头\nB\t\t移动到前一个词组的开头\nge\t移动到前一个单词的结尾\ngE\t移动到前一个词组的结尾\n```\n\n词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含`a-zA-Z0-9`字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过`:h word`和`:h WORD`了解更多。\n\n例如，假如你有下面这段内容：\n\n```\nconst hello = \"world\";\n```\n\n当你光标位于这行的开头时，你可以通过`l`走到行尾，但是你需要按21下，使用`w`，你需要6下，使用`W`只需要4下。 单词和词组都是短距离移动的很好的选择。\n\n然而，之后你可以通过当前行导航只按一次从`c`移动到`;`。\n\n## 当前行导航\n\n当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过`0`跳到本行第一个字符，通过`$`跳到本行最后一个字符。 另外，你可以使用`^`跳到本行第一个非空字符，通过`g_`跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用`n|`。\n\n```\n0\t\t跳到本行第一个字符\n^\t\t跳到本行第一个非空字符\ng_      跳到本行最后一个非空字符\n$\t\t跳到本行最后一个字符\nn|      跳到本行第n列\n```\n\n你也可以在本行通过`f`和`t`进行行内搜索，`f`和`t`的区别在于`f`会停在第一个匹配的字母上，`t`会停在第一个匹配的字母前。 因此如果你想要搜索并停留在\"h\"上，使用`fh`。 如果你想搜索第一个\"h\"并停留在它的前一个字母上，可以使用`th`。 如果你想去下一个行内匹配的位置，使用`;`，如果你想去前一个行内匹配的位置，使用`,`。\n\n`F`和`T`是`f`和`t`对应的向后搜索版本。如果想向前搜索\"h\"，可以使用`Fh`，使用`;`，保持相同的搜索方向搜索下一个匹配的字母。 注意，`;`不是总是向后搜索，`;`表示的是上一次搜索的方向，因此如果你使用的`F`，那么使用`;`时将会向前搜索使用`,`时向后搜索。\n\n```\nf   在同一行向后搜索第一个匹配\nF   在同一行向前搜索第一个匹配\nt   在同一行向后搜索第一个匹配，并停在匹配前\nT   在同一行向前搜索第一个匹配，并停在匹配前\n;   在同一行重复最近一次搜索\n,   在同一行向相反方向重复最近一次搜索\n```\n\n回到上一个例子：\n\n```\nconst hello = \"world\";\n```\n\n当你的光标位于行的开头时，你可以通过按一次键`$`去往行尾的最后一个字符\";\"。 如果想去往\"world\"中的\"w\"，你可以使用`fw`。 一个建议是，在行内目标附近通过寻找重复出现最少的字母例如\"j\"，\"x\"，\"z\"来前往行中的该位置更快。\n\n## 句子和段落导航\n\n接下来两个移动的单元是句子和段落。\n\n首先我们来聊聊句子。 一个句子的定义是以`.!?`和跟着的一个换行符或空格，tab结尾的。 你可以通过`)`和`(`跳到下一个和上一个句子。\n\n```\n(   跳到前一个句子\n)   跳到下一个句子\n```\n\n让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用`(`和`)`感受一下。\n\n```\nI am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :\n\nThere is an empty line above me.\n\n```\n\n另外，如果你的Vim中遇到了无法将一个以`.`结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于`compatible`的模式。 运行`:set nocompatible`可以修复。 在Vi中，一个句子是以**两个**空格结尾的，你应该总是保持的`nocompatible`的设置。\n\n接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项(`paragraphs`)中\"字符对\"所指定的段落宏的每个集合开始。\n\n```\n{   跳转到上一个段落\n}   跳转到下一个段落\n```\n\n如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。\n\n我们来看这个例子。 你可以尝试着使用`}`和`{`进行导航，也可以试一试`()`这样的句子导航。\n\n```\nHello. How are you? I am great, thanks!\nVim is awesome.\nIt may not easy to learn it at first...- but we are in this together. Good luck!\n\nHello again.\n\nTry to move around with ), (, }, and {. Feel how they work.\nYou got this.\n```\n\n你可以通过`:h setence`和`:h paragraph`了解更多。\n\n## 匹配导航\n\n程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过`%`跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。\n\n```\n%    Navigate to another match, usually works for (), [], {}\n```\n\n我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用`%`移动\n\n```\n(define (fib n)\n  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        (else\n          (+ (fib (- n 1)) (fib (- n 2)))\n        )))\n```\n\n我个人喜欢使用类似[vim-rainbow](https://github.com/frazrepo/vim-rainbow)这样的可视化指示插件来作为`%`的补充。 通过`:h %`了解更多。\n\n## 行号导航\n\n你可以通过`nG`调到行号为`n`的行，例如如果你想跳到第7行，你可以使用`7G`，跳到第一行使用`gg`或`1G`，跳到最后一行使用`G`。\n\n有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用`70%`跳过去，可以使用`50%`跳到文件的中间。\n\n```\ngg      跳转到第一行\nG       跳转到最后一行\nnG      跳转到第n行\nn%      跳到文件的n%\n```\n\n另外，如果你想看文件总行数，可以用`CTRL-g`查看。\n\n## 窗格导航\n\n为了移动到当前窗格的顶部，中间，底部，你可以使用`H`，`M`和`L`。\n\n你也可以给`H`和`L`传一个数字前缀。 如果你输入`10H`你会跳转到窗格顶部往下数10行的位置，如果你输入`3L`，你会跳转到距离当前窗格的底部一行向上数3行的位置。\n\n```\nH   跳转到屏幕的顶部\nM   跳转到屏幕的中间\nL   跳转到屏幕的底部\nnH  跳转到距离顶部n行的位置\nnL  跳转到距离底部n行的位置\n```\n\n## 滚动\n\n在文件中滚动，你有三种速度可以选择： 滚动一整页(`CTRL-F`/`CTRL-B`)，滚动半页(`CTRL-D`/`CTRL-U`)，滚动一行`CTRL-E`/`CTRL-Y`)。\n\n```\nCtrl-e    向下滚动一行\nCtrl-d    向下滚动半屏\nCtrl-f    向下滚动一屏\nCtrl-y    向上滚动一行\nCtrl-u    向上滚动半屏\nCtrl-b    向上滚动一屏\n```\n\n你也可以相对当前行进行滚动\n\n```\nzt    将当前行置于屏幕顶部附近\nzz    将当前行置于屏幕中央\nzb    将当前行置于屏幕底部\n```\n\n## 搜索导航\n\n通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过`/`向下搜索，也可以通过`?`向上搜索一个字段。 你可以通过`n`重复最近一次搜索，`N`向反方向重复最近一次搜索。\n\n```\n/   向后搜索一个匹配\n?   向前搜素一个匹配\nn   重复上一次搜索(和上一次方向相同)\nN   重复上一次搜索(和上一次方向相反)\n```\n\n假设你有一下文本：\n\n```\nlet one = 1;\nlet two = 2;\none = \"01\";\none = \"one\";\nlet onetwo = 12;\n```\n\n你可以通过`/let`搜索\"let\"，然后通过`n`快速的重复搜索下一个\"let\"，如果需要向相反方向搜索，可以使用`N`。 如果你用`?let`搜索，会得到一个向前的搜索，这时你使用`n`，它会继续向前搜索，就和`?`的方向一致。(`N`将会向后搜索\"let\")。\n\n你可以通过`:set hlsearch`设置搜索高亮。 这样，当你搜索`/let`，它将高亮文件中所有匹配的字段。 另外，如果你通过`:set incsearch`设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用`:nohlsearch`。 因为我经常使用这个功能，所以我会设置一个映射：\n\n```\nnnoremap <esc><esc> :noh<return><esc>\n```\n\n你可以通过`*`快速的向前搜索光标下的文本，通过`#`快速向后搜索光标下的文本。 如果你的光标位于一个字符串\"one\"上，按下`*`相当于`/\\<one\\>`。\n`/\\<one\\>`中的`\\<`和`\\>`表示整词匹配，使得一个更长的包含\"one\"的单词不会被匹配上，也就是说它会匹配\"one\"，但不会匹配\"onetwo\"。 如果你的光标在\"one\"上并且你想向后搜索完全或部分匹配的单词，例如\"one\"和\"onetwo\"，你可以用`g*`替代`*`。\n\n```\n*   向后查找光标所在的完整单词\n#   向前查找光标所在的完整单词\ng*  向后搜索光标所在的单词\ng#  向前搜索光标所在的单词\n```\n\n## 位置标记\n\n你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过`mx`设置一个标记，其中`x`可以是`a-zA-Z`。 有两种办法能回到标记的位置： 用`` `x``精确回到(行和列)，或者用`'x`回到行级位置。\n\n```\nma    用a标签标记一个位置\n`a    精确回到a标签的位置(行和列)\n'a    跳转到a标签的行\n```\n\n`a-z`的标签和`A-Z`的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。\n\n我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记\"a\"(`ma`)，然后在另一个文件中设置另一个标记\"a\"(`ma`)。\n\n不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在`myFile.txt`中设置了标签`mA`，下一次你在另一个文件中设置`mA`时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。\n\n使用`:marks`查看所有标签，你也许会注意到除了`a-zA-Z`以外还有别的标签，其中有一些例如：\n\n```\n''   在当前buffer中跳转回到上一次跳转前的最后一行\n``  在当前buffer中跳转回到上一次跳转前的最后一个位置\n`[  跳转到上一次修改或拷贝的文本的开头\n`]  跳转到上一次修改或拷贝的文本的结尾\n`<  跳转到最近一次可视模式下选择的部分的开头\n`>  跳转到最近一次可视模式下选择的部分的结尾\n`0  跳转到退出Vim前编辑的最后一个文件\n```\n\n除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过`: marks`查看。\n\n## 跳转\n最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用`j`向下移动一行就不被看做一个跳转，即使你使用`10j`向下移动10行，也不是一个跳转。 但是你通过`10G`去往第10行被算作一个跳转。\n\n```\n'   跳转到标记的行\n`   跳转到标记的位置(行和列)\nG   跳转到行\n/   向后搜索\n?   向前搜索\nn   重复上一次搜索，相同方向\nN   重复上一次搜索，相反方向\n%   查找匹配\n(   跳转上一个句子\n)   跳转下一个句子\n{   跳转上一个段落\n}   跳转下一个段落\nL   跳转到当前屏幕的最后一行\nM   跳转到当前屏幕的中间\nH   跳转到当前屏幕的第一行\n[[  跳转到上一个小节\n]]  跳转到下一个小节\n:s  替换\n:tag  跳转到tag定义\n```\n我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过`:jumps`查看这个列表，如果想了解更多，可以查看`:h jump-motions`。\n\n为什么跳转有用呢? 因为你可以在跳转列表中通过`Ctrl-o`和`Ctrl-i`在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。\n\n## 聪明地学习导航\n如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。\n\n我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从`h,j,k,l,w,b,G,/,?,n`开始，不断地重复这10个移动知道形成肌肉记忆，这花不了多少时间。\n\n为了让你更擅长导航，我有两个建议：\n1. 注意重复的动作。 如果你发现你自己在重复的使用`l`，你可以去找一个方法让你前进的更快，然后你会发现你可以用`w`在单词间移动。 如果你发现你自己的重复的使用`w`，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用`$`。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。\n2. 当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。\n\n最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。\n\n慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。\n","slug":"Vim/ch05_moving_in_file","published":1,"updated":"2022-08-28T07:38:59.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1t001bscvmac5bae67","content":"<h1 id=\"第05章-在文件中移动\"><a href=\"#第05章-在文件中移动\" class=\"headerlink\" title=\"第05章 在文件中移动\"></a>第05章 在文件中移动</h1><p>一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。</p>\n<p>这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令(motions)，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>。</p>\n<h2 id=\"字符导航\"><a href=\"#字符导航\" class=\"headerlink\" title=\"字符导航\"></a>字符导航</h2><p>最基本的移动单元是上下左右移动一个字符。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">h   左<br><span class=\"hljs-keyword\">j </span>  下<br>k   上<br>l   右<br></code></pre></td></tr></table></figure>\n\n<p>你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。</p>\n<p>我更喜欢<code>hjkl</code>因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过<code>~/.vimrc</code>关闭了方向键：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Up&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Down&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Left&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Right&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>也有一些插件可以帮助改掉这个坏习惯，其中有一个叫<a href=\"https://github.com/takac/vim-hardtime\">vim-hardtime</a>。 让我感到惊讶的是，我只用了几天就习惯了使用<code>hjkl</code>。</p>\n<p>另外，如果你想知道为什么Vim使用<code>hjkl</code>进行移动，<em>这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把<code>hjkl</code>当做方向键</em>。</p>\n<p>如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用<code>h</code>和<code>l</code>。 如果我需要在可见的范围内上下移动几行，我会使用<code>j</code>和<code>k</code>。 如果我想去更远的地方，我倾向于使用其他移动命令。</p>\n<h2 id=\"相对行号\"><a href=\"#相对行号\" class=\"headerlink\" title=\"相对行号\"></a>相对行号</h2><p>我觉得设置<code>number</code>和<code>relativenumber</code>非常有用，你可以在<code>~/.vimrc</code>中设置:</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\"><span class=\"hljs-keyword\">set</span> relativenumber <span class=\"hljs-built_in\">number</span><br></code></pre></td></tr></table></figure>\n\n<p>这将会展示当前行号和其他行相对当前行的行号。</p>\n<p>为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用<code>12j</code>去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69&#x3D;12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。</p>\n<p>这是一个100%的个人偏好，你可以尝试<code>relativenumber</code>&#x2F;<code>norelativenumber</code>，<code>number</code>&#x2F;<code>nonumber</code> 然后选择自己觉得最有用的。</p>\n<h2 id=\"对移动计数\"><a href=\"#对移动计数\" class=\"headerlink\" title=\"对移动计数\"></a>对移动计数</h2><p>在继续之前，让我们讨论一下”计数”参数。 一个移动(motion)可以接受一个数字前缀作为参数，上面我提到的你可以通过<code>12j</code>向下移动12行，其中<code>12j</code>中的<code>12</code>就是计数数字。</p>\n<p>你使用带计数的移动的语法如下：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-string\">[计数]</span> + 移动<br></code></pre></td></tr></table></figure>\n\n<p>你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用<code>9l</code>来代替按9次<code>l</code>。 当你学到了更多的动作时，你都可以试试给定计数参数。</p>\n<h2 id=\"单词导航\"><a href=\"#单词导航\" class=\"headerlink\" title=\"单词导航\"></a>单词导航</h2><p>我们现在移动一个更长的单元：单词(word)。 你可以通过<code>w</code>移动到下一个单词的开始，通过<code>e</code>移动到下一个单词的结尾，通过<code>b</code>移动到上一个单词的开始，通过<code>ge</code>移动到前一个单词的结尾。</p>\n<p>另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过<code>W</code>移动到下一个词组的开始，通过<code>E</code>移动到下一个词组的结尾，通过<code>B</code>移动到前一个词组的开头，通过<code>gE</code>移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\">w\t\t移动到下一个单词的开头<br>W\t\t移动到下一个词组的开头<br>e\t\t移动到下一个单词的结尾<br>E\t\t移动到下一个词组的结尾<br><span class=\"hljs-keyword\">b</span>\t\t移动到前一个单词的开头<br><span class=\"hljs-keyword\">B</span>\t\t移动到前一个词组的开头<br><span class=\"hljs-symbol\">ge</span>\t移动到前一个单词的结尾<br><span class=\"hljs-symbol\">gE</span>\t移动到前一个词组的结尾<br></code></pre></td></tr></table></figure>\n\n<p>词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-zA-Z0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过<code>:h word</code>和<code>:h WORD</code>了解更多。</p>\n<p>例如，假如你有下面这段内容：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;world&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>当你光标位于这行的开头时，你可以通过<code>l</code>走到行尾，但是你需要按21下，使用<code>w</code>，你需要6下，使用<code>W</code>只需要4下。 单词和词组都是短距离移动的很好的选择。</p>\n<p>然而，之后你可以通过当前行导航只按一次从<code>c</code>移动到<code>;</code>。</p>\n<h2 id=\"当前行导航\"><a href=\"#当前行导航\" class=\"headerlink\" title=\"当前行导航\"></a>当前行导航</h2><p>当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过<code>0</code>跳到本行第一个字符，通过<code>$</code>跳到本行最后一个字符。 另外，你可以使用<code>^</code>跳到本行第一个非空字符，通过<code>g_</code>跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用<code>n|</code>。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\"><span class=\"hljs-number\">0</span>\t\t跳到本行第一个字符<br>^\t\t跳到本行第一个非空字符<br>g_      跳到本行最后一个非空字符<br>$\t\t跳到本行最后一个字符<br><span class=\"hljs-built_in\">n</span>|      跳到本行第<span class=\"hljs-built_in\">n</span>列<br></code></pre></td></tr></table></figure>\n\n<p>你也可以在本行通过<code>f</code>和<code>t</code>进行行内搜索，<code>f</code>和<code>t</code>的区别在于<code>f</code>会停在第一个匹配的字母上，<code>t</code>会停在第一个匹配的字母前。 因此如果你想要搜索并停留在”h”上，使用<code>fh</code>。 如果你想搜索第一个”h”并停留在它的前一个字母上，可以使用<code>th</code>。 如果你想去下一个行内匹配的位置，使用<code>;</code>，如果你想去前一个行内匹配的位置，使用<code>,</code>。</p>\n<p><code>F</code>和<code>T</code>是<code>f</code>和<code>t</code>对应的向后搜索版本。如果想向前搜索”h”，可以使用<code>Fh</code>，使用<code>;</code>，保持相同的搜索方向搜索下一个匹配的字母。 注意，<code>;</code>不是总是向后搜索，<code>;</code>表示的是上一次搜索的方向，因此如果你使用的<code>F</code>，那么使用<code>;</code>时将会向前搜索使用<code>,</code>时向后搜索。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">f   在同一行向后搜索第一个匹配<br>F   在同一行向前搜索第一个匹配<br><span class=\"hljs-built_in\">t</span>   在同一行向后搜索第一个匹配，并停在匹配前<br><span class=\"hljs-built_in\">T</span>   在同一行向前搜索第一个匹配，并停在匹配前<br>;   在同一行重复最近一次搜索<br>,   在同一行向相反方向重复最近一次搜索<br></code></pre></td></tr></table></figure>\n\n<p>回到上一个例子：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;world&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符”;”。 如果想去往”world”中的”w”，你可以使用<code>fw</code>。 一个建议是，在行内目标附近通过寻找重复出现最少的字母例如”j”，”x”，”z”来前往行中的该位置更快。</p>\n<h2 id=\"句子和段落导航\"><a href=\"#句子和段落导航\" class=\"headerlink\" title=\"句子和段落导航\"></a>句子和段落导航</h2><p>接下来两个移动的单元是句子和段落。</p>\n<p>首先我们来聊聊句子。 一个句子的定义是以<code>.!?</code>和跟着的一个换行符或空格，tab结尾的。 你可以通过<code>)</code>和<code>(</code>跳到下一个和上一个句子。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-comment\">(   跳到前一个句子</span><br><span class=\"hljs-comment\">)</span>   跳到下一个句子<br></code></pre></td></tr></table></figure>\n\n<p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用<code>(</code>和<code>)</code>感受一下。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">I</span> am <span class=\"hljs-selector-tag\">a</span> sentence. <span class=\"hljs-selector-tag\">I</span> am another sentence because <span class=\"hljs-selector-tag\">I</span> end with <span class=\"hljs-selector-tag\">a</span> period. <span class=\"hljs-selector-tag\">I</span> am still <span class=\"hljs-selector-tag\">a</span> sentence when ending with an exclamation point! What about question <span class=\"hljs-selector-tag\">mark</span>? <span class=\"hljs-selector-tag\">I</span> am not quite <span class=\"hljs-selector-tag\">a</span> sentence because of the hyphen - and neither semicolon ; nor colon :<br><br>There is an empty line above me.<br><br></code></pre></td></tr></table></figure>\n\n<p>另外，如果你的Vim中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于<code>compatible</code>的模式。 运行<code>:set nocompatible</code>可以修复。 在Vi中，一个句子是以<strong>两个</strong>空格结尾的，你应该总是保持的<code>nocompatible</code>的设置。</p>\n<p>接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项(<code>paragraphs</code>)中”字符对”所指定的段落宏的每个集合开始。</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;   跳转到上一个段落</span><br><span class=\"hljs-template-variable\">&#125;</span><span class=\"language-xml\">   跳转到下一个段落</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。</p>\n<p>我们来看这个例子。 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>()</code>这样的句子导航。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">Hello. How are you? I am great, thanks!<br>Vim <span class=\"hljs-keyword\">is</span> awesome.<br>It may <span class=\"hljs-keyword\">not</span> easy <span class=\"hljs-keyword\">to</span> learn <span class=\"hljs-keyword\">it</span> <span class=\"hljs-keyword\">at</span> <span class=\"hljs-keyword\">first</span>...- <span class=\"hljs-keyword\">but</span> we are <span class=\"hljs-keyword\">in</span> this together. Good luck!<br><br>Hello again.<br><br>Try <span class=\"hljs-keyword\">to</span> move <span class=\"hljs-keyword\">around</span> <span class=\"hljs-keyword\">with</span> ), (, &#125;, <span class=\"hljs-keyword\">and</span> &#123;. Feel how they work.<br>You got this.<br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多。</p>\n<h2 id=\"匹配导航\"><a href=\"#匹配导航\" class=\"headerlink\" title=\"匹配导航\"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过<code>%</code>跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\"><span class=\"hljs-comment\">%    Navigate to another match, usually works for (), [], &#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用<code>%</code>移动</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">fib</span> n)<br>  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> n <span class=\"hljs-number\">0</span>) <span class=\"hljs-number\">0</span>)<br>        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> n <span class=\"hljs-number\">1</span>) <span class=\"hljs-number\">1</span>)<br>        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span><br>          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">+</span></span> (<span class=\"hljs-name\">fib</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-</span></span> n <span class=\"hljs-number\">1</span>)) (<span class=\"hljs-name\">fib</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-</span></span> n <span class=\"hljs-number\">2</span>)))<br>        )))<br></code></pre></td></tr></table></figure>\n\n<p>我个人喜欢使用类似<a href=\"https://github.com/frazrepo/vim-rainbow\">vim-rainbow</a>这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多。</p>\n<h2 id=\"行号导航\"><a href=\"#行号导航\" class=\"headerlink\" title=\"行号导航\"></a>行号导航</h2><p>你可以通过<code>nG</code>调到行号为<code>n</code>的行，例如如果你想跳到第7行，你可以使用<code>7G</code>，跳到第一行使用<code>gg</code>或<code>1G</code>，跳到最后一行使用<code>G</code>。</p>\n<p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用<code>70%</code>跳过去，可以使用<code>50%</code>跳到文件的中间。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">gg      跳转到第一行<br>G       跳转到最后一行<br>nG      跳转到第<span class=\"hljs-built_in\">n</span>行<br><span class=\"hljs-built_in\">n</span>%      跳到文件的<span class=\"hljs-built_in\">n</span>%<br></code></pre></td></tr></table></figure>\n\n<p>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看。</p>\n<h2 id=\"窗格导航\"><a href=\"#窗格导航\" class=\"headerlink\" title=\"窗格导航\"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>。</p>\n<p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀。 如果你输入<code>10H</code>你会跳转到窗格顶部往下数10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">H   跳转到屏幕的顶部<br>M   跳转到屏幕的中间<br>L   跳转到屏幕的底部<br>nH  跳转到距离顶部<span class=\"hljs-built_in\">n</span>行的位置<br>nL  跳转到距离底部<span class=\"hljs-built_in\">n</span>行的位置<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"滚动\"><a href=\"#滚动\" class=\"headerlink\" title=\"滚动\"></a>滚动</h2><p>在文件中滚动，你有三种速度可以选择： 滚动一整页(<code>CTRL-F</code>&#x2F;<code>CTRL-B</code>)，滚动半页(<code>CTRL-D</code>&#x2F;<code>CTRL-U</code>)，滚动一行<code>CTRL-E</code>&#x2F;<code>CTRL-Y</code>)。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">Ctrl</span>-e    向下滚动一行<br><span class=\"hljs-symbol\">Ctrl</span>-d    向下滚动半屏<br><span class=\"hljs-symbol\">Ctrl</span>-f    向下滚动一屏<br><span class=\"hljs-symbol\">Ctrl</span>-y    向上滚动一行<br><span class=\"hljs-symbol\">Ctrl</span>-u    向上滚动半屏<br><span class=\"hljs-symbol\">Ctrl</span>-<span class=\"hljs-keyword\">b</span>    向上滚动一屏<br></code></pre></td></tr></table></figure>\n\n<p>你也可以相对当前行进行滚动</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">zt</span>    将当前行置于屏幕顶部附近<br>zz    将当前行置于屏幕中央<br>zb    将当前行置于屏幕底部<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"搜索导航\"><a href=\"#搜索导航\" class=\"headerlink\" title=\"搜索导航\"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过<code>/</code>向下搜索，也可以通过<code>?</code>向上搜索一个字段。 你可以通过<code>n</code>重复最近一次搜索，<code>N</code>向反方向重复最近一次搜索。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">/   向后搜索一个匹配<br>?   向前搜素一个匹配<br><span class=\"hljs-built_in\">n</span>   重复上一次搜索(和上一次方向相同)<br><span class=\"hljs-built_in\">N</span>   重复上一次搜索(和上一次方向相反)<br></code></pre></td></tr></table></figure>\n\n<p>假设你有一下文本：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">one</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01&quot;</span><span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">one</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;one&quot;</span><span class=\"hljs-comment\">;</span><br>let onetwo <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">12</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>/let</code>搜索”let”，然后通过<code>n</code>快速的重复搜索下一个”let”，如果需要向相反方向搜索，可以使用<code>N</code>。 如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索”let”)。</p>\n<p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段。 另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>。 因为我经常使用这个功能，所以我会设置一个映射：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">nnoremap &lt;esc&gt;&lt;esc&gt; <span class=\"hljs-symbol\">:noh&lt;return&gt;&lt;esc&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>*</code>快速的向前搜索光标下的文本，通过<code>#</code>快速向后搜索光标下的文本。 如果你的光标位于一个字符串”one”上，按下<code>*</code>相当于<code>/\\&lt;one\\&gt;</code>。<br><code>/\\&lt;one\\&gt;</code>中的<code>\\&lt;</code>和<code>\\&gt;</code>表示整词匹配，使得一个更长的包含”one”的单词不会被匹配上，也就是说它会匹配”one”，但不会匹配”onetwo”。 如果你的光标在”one”上并且你想向后搜索完全或部分匹配的单词，例如”one”和”onetwo”，你可以用<code>g*</code>替代<code>*</code>。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">*   向后查找光标所在的完整单词<br><span class=\"hljs-meta\">#   向前查找光标所在的完整单词</span><br>g*  向后搜索光标所在的单词<br>g<span class=\"hljs-meta\">#  向前搜索光标所在的单词</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"位置标记\"><a href=\"#位置标记\" class=\"headerlink\" title=\"位置标记\"></a>位置标记</h2><p>你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过<code>mx</code>设置一个标记，其中<code>x</code>可以是<code>a-zA-Z</code>。 有两种办法能回到标记的位置： 用<code> `x</code>精确回到(行和列)，或者用<code>&#39;x</code>回到行级位置。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">ma    用<span class=\"hljs-keyword\">a</span>标签标记一个位置<br>`<span class=\"hljs-keyword\">a</span>    精确回到<span class=\"hljs-keyword\">a</span>标签的位置(行和列)<br><span class=\"hljs-string\">&#x27;a    跳转到a标签的行</span><br></code></pre></td></tr></table></figure>\n\n<p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。</p>\n<p>我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记”a”(<code>ma</code>)，然后在另一个文件中设置另一个标记”a”(<code>ma</code>)。</p>\n<p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在<code>myFile.txt</code>中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。</p>\n<p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-zA-Z</code>以外还有别的标签，其中有一些例如：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-string\">&#x27;&#x27;</span>   在当前<span class=\"hljs-built_in\">buffer</span>中跳转回到上一次跳转前的最后一行<br><span class=\"hljs-string\">``</span>  在当前<span class=\"hljs-built_in\">buffer</span>中跳转回到上一次跳转前的最后一个位置<br><span class=\"hljs-string\">`[  跳转到上一次修改或拷贝的文本的开头</span><br><span class=\"hljs-string\">`</span>]  跳转到上一次修改或拷贝的文本的结尾<br><span class=\"hljs-string\">`&lt;  跳转到最近一次可视模式下选择的部分的开头</span><br><span class=\"hljs-string\">`</span>&gt;  跳转到最近一次可视模式下选择的部分的结尾<br><span class=\"hljs-string\">`0  跳转到退出Vim前编辑的最后一个文件</span><br></code></pre></td></tr></table></figure>\n\n<p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看。</p>\n<h2 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用<code>j</code>向下移动一行就不被看做一个跳转，即使你使用<code>10j</code>向下移动10行，也不是一个跳转。 但是你通过<code>10G</code>去往第10行被算作一个跳转。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">&#x27;   跳转到标记的行<br>`   跳转到标记的位置(行和列)<br>G   跳转到行<br>/   向后搜索<br>?   向前搜索<br>n   重复上一次搜索，相同方向<br>N   重复上一次搜索，相反方向<br>%   查找匹配<br>(   跳转上一个句子<br>)   跳转下一个句子<br>&#123;   跳转上一个段落<br>&#125;   跳转下一个段落<br>L   跳转到当前屏幕的最后一行<br>M   跳转到当前屏幕的中间<br>H   跳转到当前屏幕的第一行<br>[[  跳转到上一个小节<br>]]  跳转到下一个小节<br>:s  替换<br>:<span class=\"hljs-keyword\">tag</span>  <span class=\"hljs-title\">跳转到tag</span>定义<br></code></pre></td></tr></table></figure>\n<p>我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>。</p>\n<p>为什么跳转有用呢? 因为你可以在跳转列表中通过<code>Ctrl-o</code>和<code>Ctrl-i</code>在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。</p>\n<h2 id=\"聪明地学习导航\"><a href=\"#聪明地学习导航\" class=\"headerlink\" title=\"聪明地学习导航\"></a>聪明地学习导航</h2><p>如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。</p>\n<p>我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从<code>h,j,k,l,w,b,G,/,?,n</code>开始，不断地重复这10个移动知道形成肌肉记忆，这花不了多少时间。</p>\n<p>为了让你更擅长导航，我有两个建议：</p>\n<ol>\n<li>注意重复的动作。 如果你发现你自己在重复的使用<code>l</code>，你可以去找一个方法让你前进的更快，然后你会发现你可以用<code>w</code>在单词间移动。 如果你发现你自己的重复的使用<code>w</code>，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用<code>$</code>。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。</li>\n<li>当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。</li>\n</ol>\n<p>最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。</p>\n<p>慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。</p>\n","site":{"data":{}},"wordcount":7008,"excerpt":"","more":"<h1 id=\"第05章-在文件中移动\"><a href=\"#第05章-在文件中移动\" class=\"headerlink\" title=\"第05章 在文件中移动\"></a>第05章 在文件中移动</h1><p>一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。</p>\n<p>这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令(motions)，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>。</p>\n<h2 id=\"字符导航\"><a href=\"#字符导航\" class=\"headerlink\" title=\"字符导航\"></a>字符导航</h2><p>最基本的移动单元是上下左右移动一个字符。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">h   左<br><span class=\"hljs-keyword\">j </span>  下<br>k   上<br>l   右<br></code></pre></td></tr></table></figure>\n\n<p>你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。</p>\n<p>我更喜欢<code>hjkl</code>因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过<code>~/.vimrc</code>关闭了方向键：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Up&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Down&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Left&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br><span class=\"hljs-keyword\">noremap</span> <span class=\"hljs-symbol\">&lt;Right&gt;</span> <span class=\"hljs-symbol\">&lt;NOP&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>也有一些插件可以帮助改掉这个坏习惯，其中有一个叫<a href=\"https://github.com/takac/vim-hardtime\">vim-hardtime</a>。 让我感到惊讶的是，我只用了几天就习惯了使用<code>hjkl</code>。</p>\n<p>另外，如果你想知道为什么Vim使用<code>hjkl</code>进行移动，<em>这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把<code>hjkl</code>当做方向键</em>。</p>\n<p>如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用<code>h</code>和<code>l</code>。 如果我需要在可见的范围内上下移动几行，我会使用<code>j</code>和<code>k</code>。 如果我想去更远的地方，我倾向于使用其他移动命令。</p>\n<h2 id=\"相对行号\"><a href=\"#相对行号\" class=\"headerlink\" title=\"相对行号\"></a>相对行号</h2><p>我觉得设置<code>number</code>和<code>relativenumber</code>非常有用，你可以在<code>~/.vimrc</code>中设置:</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\"><span class=\"hljs-keyword\">set</span> relativenumber <span class=\"hljs-built_in\">number</span><br></code></pre></td></tr></table></figure>\n\n<p>这将会展示当前行号和其他行相对当前行的行号。</p>\n<p>为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用<code>12j</code>去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69&#x3D;12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。</p>\n<p>这是一个100%的个人偏好，你可以尝试<code>relativenumber</code>&#x2F;<code>norelativenumber</code>，<code>number</code>&#x2F;<code>nonumber</code> 然后选择自己觉得最有用的。</p>\n<h2 id=\"对移动计数\"><a href=\"#对移动计数\" class=\"headerlink\" title=\"对移动计数\"></a>对移动计数</h2><p>在继续之前，让我们讨论一下”计数”参数。 一个移动(motion)可以接受一个数字前缀作为参数，上面我提到的你可以通过<code>12j</code>向下移动12行，其中<code>12j</code>中的<code>12</code>就是计数数字。</p>\n<p>你使用带计数的移动的语法如下：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-string\">[计数]</span> + 移动<br></code></pre></td></tr></table></figure>\n\n<p>你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用<code>9l</code>来代替按9次<code>l</code>。 当你学到了更多的动作时，你都可以试试给定计数参数。</p>\n<h2 id=\"单词导航\"><a href=\"#单词导航\" class=\"headerlink\" title=\"单词导航\"></a>单词导航</h2><p>我们现在移动一个更长的单元：单词(word)。 你可以通过<code>w</code>移动到下一个单词的开始，通过<code>e</code>移动到下一个单词的结尾，通过<code>b</code>移动到上一个单词的开始，通过<code>ge</code>移动到前一个单词的结尾。</p>\n<p>另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过<code>W</code>移动到下一个词组的开始，通过<code>E</code>移动到下一个词组的结尾，通过<code>B</code>移动到前一个词组的开头，通过<code>gE</code>移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\">w\t\t移动到下一个单词的开头<br>W\t\t移动到下一个词组的开头<br>e\t\t移动到下一个单词的结尾<br>E\t\t移动到下一个词组的结尾<br><span class=\"hljs-keyword\">b</span>\t\t移动到前一个单词的开头<br><span class=\"hljs-keyword\">B</span>\t\t移动到前一个词组的开头<br><span class=\"hljs-symbol\">ge</span>\t移动到前一个单词的结尾<br><span class=\"hljs-symbol\">gE</span>\t移动到前一个词组的结尾<br></code></pre></td></tr></table></figure>\n\n<p>词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-zA-Z0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过<code>:h word</code>和<code>:h WORD</code>了解更多。</p>\n<p>例如，假如你有下面这段内容：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;world&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>当你光标位于这行的开头时，你可以通过<code>l</code>走到行尾，但是你需要按21下，使用<code>w</code>，你需要6下，使用<code>W</code>只需要4下。 单词和词组都是短距离移动的很好的选择。</p>\n<p>然而，之后你可以通过当前行导航只按一次从<code>c</code>移动到<code>;</code>。</p>\n<h2 id=\"当前行导航\"><a href=\"#当前行导航\" class=\"headerlink\" title=\"当前行导航\"></a>当前行导航</h2><p>当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过<code>0</code>跳到本行第一个字符，通过<code>$</code>跳到本行最后一个字符。 另外，你可以使用<code>^</code>跳到本行第一个非空字符，通过<code>g_</code>跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用<code>n|</code>。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\"><span class=\"hljs-number\">0</span>\t\t跳到本行第一个字符<br>^\t\t跳到本行第一个非空字符<br>g_      跳到本行最后一个非空字符<br>$\t\t跳到本行最后一个字符<br><span class=\"hljs-built_in\">n</span>|      跳到本行第<span class=\"hljs-built_in\">n</span>列<br></code></pre></td></tr></table></figure>\n\n<p>你也可以在本行通过<code>f</code>和<code>t</code>进行行内搜索，<code>f</code>和<code>t</code>的区别在于<code>f</code>会停在第一个匹配的字母上，<code>t</code>会停在第一个匹配的字母前。 因此如果你想要搜索并停留在”h”上，使用<code>fh</code>。 如果你想搜索第一个”h”并停留在它的前一个字母上，可以使用<code>th</code>。 如果你想去下一个行内匹配的位置，使用<code>;</code>，如果你想去前一个行内匹配的位置，使用<code>,</code>。</p>\n<p><code>F</code>和<code>T</code>是<code>f</code>和<code>t</code>对应的向后搜索版本。如果想向前搜索”h”，可以使用<code>Fh</code>，使用<code>;</code>，保持相同的搜索方向搜索下一个匹配的字母。 注意，<code>;</code>不是总是向后搜索，<code>;</code>表示的是上一次搜索的方向，因此如果你使用的<code>F</code>，那么使用<code>;</code>时将会向前搜索使用<code>,</code>时向后搜索。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">f   在同一行向后搜索第一个匹配<br>F   在同一行向前搜索第一个匹配<br><span class=\"hljs-built_in\">t</span>   在同一行向后搜索第一个匹配，并停在匹配前<br><span class=\"hljs-built_in\">T</span>   在同一行向前搜索第一个匹配，并停在匹配前<br>;   在同一行重复最近一次搜索<br>,   在同一行向相反方向重复最近一次搜索<br></code></pre></td></tr></table></figure>\n\n<p>回到上一个例子：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;world&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符”;”。 如果想去往”world”中的”w”，你可以使用<code>fw</code>。 一个建议是，在行内目标附近通过寻找重复出现最少的字母例如”j”，”x”，”z”来前往行中的该位置更快。</p>\n<h2 id=\"句子和段落导航\"><a href=\"#句子和段落导航\" class=\"headerlink\" title=\"句子和段落导航\"></a>句子和段落导航</h2><p>接下来两个移动的单元是句子和段落。</p>\n<p>首先我们来聊聊句子。 一个句子的定义是以<code>.!?</code>和跟着的一个换行符或空格，tab结尾的。 你可以通过<code>)</code>和<code>(</code>跳到下一个和上一个句子。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-comment\">(   跳到前一个句子</span><br><span class=\"hljs-comment\">)</span>   跳到下一个句子<br></code></pre></td></tr></table></figure>\n\n<p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用<code>(</code>和<code>)</code>感受一下。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">I</span> am <span class=\"hljs-selector-tag\">a</span> sentence. <span class=\"hljs-selector-tag\">I</span> am another sentence because <span class=\"hljs-selector-tag\">I</span> end with <span class=\"hljs-selector-tag\">a</span> period. <span class=\"hljs-selector-tag\">I</span> am still <span class=\"hljs-selector-tag\">a</span> sentence when ending with an exclamation point! What about question <span class=\"hljs-selector-tag\">mark</span>? <span class=\"hljs-selector-tag\">I</span> am not quite <span class=\"hljs-selector-tag\">a</span> sentence because of the hyphen - and neither semicolon ; nor colon :<br><br>There is an empty line above me.<br><br></code></pre></td></tr></table></figure>\n\n<p>另外，如果你的Vim中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于<code>compatible</code>的模式。 运行<code>:set nocompatible</code>可以修复。 在Vi中，一个句子是以<strong>两个</strong>空格结尾的，你应该总是保持的<code>nocompatible</code>的设置。</p>\n<p>接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项(<code>paragraphs</code>)中”字符对”所指定的段落宏的每个集合开始。</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;   跳转到上一个段落</span><br><span class=\"hljs-template-variable\">&#125;</span><span class=\"language-xml\">   跳转到下一个段落</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。</p>\n<p>我们来看这个例子。 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>()</code>这样的句子导航。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">Hello. How are you? I am great, thanks!<br>Vim <span class=\"hljs-keyword\">is</span> awesome.<br>It may <span class=\"hljs-keyword\">not</span> easy <span class=\"hljs-keyword\">to</span> learn <span class=\"hljs-keyword\">it</span> <span class=\"hljs-keyword\">at</span> <span class=\"hljs-keyword\">first</span>...- <span class=\"hljs-keyword\">but</span> we are <span class=\"hljs-keyword\">in</span> this together. Good luck!<br><br>Hello again.<br><br>Try <span class=\"hljs-keyword\">to</span> move <span class=\"hljs-keyword\">around</span> <span class=\"hljs-keyword\">with</span> ), (, &#125;, <span class=\"hljs-keyword\">and</span> &#123;. Feel how they work.<br>You got this.<br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多。</p>\n<h2 id=\"匹配导航\"><a href=\"#匹配导航\" class=\"headerlink\" title=\"匹配导航\"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过<code>%</code>跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\"><span class=\"hljs-comment\">%    Navigate to another match, usually works for (), [], &#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用<code>%</code>移动</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">fib</span> n)<br>  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> n <span class=\"hljs-number\">0</span>) <span class=\"hljs-number\">0</span>)<br>        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> n <span class=\"hljs-number\">1</span>) <span class=\"hljs-number\">1</span>)<br>        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span><br>          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">+</span></span> (<span class=\"hljs-name\">fib</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-</span></span> n <span class=\"hljs-number\">1</span>)) (<span class=\"hljs-name\">fib</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-</span></span> n <span class=\"hljs-number\">2</span>)))<br>        )))<br></code></pre></td></tr></table></figure>\n\n<p>我个人喜欢使用类似<a href=\"https://github.com/frazrepo/vim-rainbow\">vim-rainbow</a>这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多。</p>\n<h2 id=\"行号导航\"><a href=\"#行号导航\" class=\"headerlink\" title=\"行号导航\"></a>行号导航</h2><p>你可以通过<code>nG</code>调到行号为<code>n</code>的行，例如如果你想跳到第7行，你可以使用<code>7G</code>，跳到第一行使用<code>gg</code>或<code>1G</code>，跳到最后一行使用<code>G</code>。</p>\n<p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用<code>70%</code>跳过去，可以使用<code>50%</code>跳到文件的中间。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">gg      跳转到第一行<br>G       跳转到最后一行<br>nG      跳转到第<span class=\"hljs-built_in\">n</span>行<br><span class=\"hljs-built_in\">n</span>%      跳到文件的<span class=\"hljs-built_in\">n</span>%<br></code></pre></td></tr></table></figure>\n\n<p>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看。</p>\n<h2 id=\"窗格导航\"><a href=\"#窗格导航\" class=\"headerlink\" title=\"窗格导航\"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>。</p>\n<p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀。 如果你输入<code>10H</code>你会跳转到窗格顶部往下数10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">H   跳转到屏幕的顶部<br>M   跳转到屏幕的中间<br>L   跳转到屏幕的底部<br>nH  跳转到距离顶部<span class=\"hljs-built_in\">n</span>行的位置<br>nL  跳转到距离底部<span class=\"hljs-built_in\">n</span>行的位置<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"滚动\"><a href=\"#滚动\" class=\"headerlink\" title=\"滚动\"></a>滚动</h2><p>在文件中滚动，你有三种速度可以选择： 滚动一整页(<code>CTRL-F</code>&#x2F;<code>CTRL-B</code>)，滚动半页(<code>CTRL-D</code>&#x2F;<code>CTRL-U</code>)，滚动一行<code>CTRL-E</code>&#x2F;<code>CTRL-Y</code>)。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">Ctrl</span>-e    向下滚动一行<br><span class=\"hljs-symbol\">Ctrl</span>-d    向下滚动半屏<br><span class=\"hljs-symbol\">Ctrl</span>-f    向下滚动一屏<br><span class=\"hljs-symbol\">Ctrl</span>-y    向上滚动一行<br><span class=\"hljs-symbol\">Ctrl</span>-u    向上滚动半屏<br><span class=\"hljs-symbol\">Ctrl</span>-<span class=\"hljs-keyword\">b</span>    向上滚动一屏<br></code></pre></td></tr></table></figure>\n\n<p>你也可以相对当前行进行滚动</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">zt</span>    将当前行置于屏幕顶部附近<br>zz    将当前行置于屏幕中央<br>zb    将当前行置于屏幕底部<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"搜索导航\"><a href=\"#搜索导航\" class=\"headerlink\" title=\"搜索导航\"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过<code>/</code>向下搜索，也可以通过<code>?</code>向上搜索一个字段。 你可以通过<code>n</code>重复最近一次搜索，<code>N</code>向反方向重复最近一次搜索。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">/   向后搜索一个匹配<br>?   向前搜素一个匹配<br><span class=\"hljs-built_in\">n</span>   重复上一次搜索(和上一次方向相同)<br><span class=\"hljs-built_in\">N</span>   重复上一次搜索(和上一次方向相反)<br></code></pre></td></tr></table></figure>\n\n<p>假设你有一下文本：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">one</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;01&quot;</span><span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">one</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;one&quot;</span><span class=\"hljs-comment\">;</span><br>let onetwo <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">12</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>/let</code>搜索”let”，然后通过<code>n</code>快速的重复搜索下一个”let”，如果需要向相反方向搜索，可以使用<code>N</code>。 如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索”let”)。</p>\n<p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段。 另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>。 因为我经常使用这个功能，所以我会设置一个映射：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">nnoremap &lt;esc&gt;&lt;esc&gt; <span class=\"hljs-symbol\">:noh&lt;return&gt;&lt;esc&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>你可以通过<code>*</code>快速的向前搜索光标下的文本，通过<code>#</code>快速向后搜索光标下的文本。 如果你的光标位于一个字符串”one”上，按下<code>*</code>相当于<code>/\\&lt;one\\&gt;</code>。<br><code>/\\&lt;one\\&gt;</code>中的<code>\\&lt;</code>和<code>\\&gt;</code>表示整词匹配，使得一个更长的包含”one”的单词不会被匹配上，也就是说它会匹配”one”，但不会匹配”onetwo”。 如果你的光标在”one”上并且你想向后搜索完全或部分匹配的单词，例如”one”和”onetwo”，你可以用<code>g*</code>替代<code>*</code>。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">*   向后查找光标所在的完整单词<br><span class=\"hljs-meta\">#   向前查找光标所在的完整单词</span><br>g*  向后搜索光标所在的单词<br>g<span class=\"hljs-meta\">#  向前搜索光标所在的单词</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"位置标记\"><a href=\"#位置标记\" class=\"headerlink\" title=\"位置标记\"></a>位置标记</h2><p>你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过<code>mx</code>设置一个标记，其中<code>x</code>可以是<code>a-zA-Z</code>。 有两种办法能回到标记的位置： 用<code> `x</code>精确回到(行和列)，或者用<code>&#39;x</code>回到行级位置。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">ma    用<span class=\"hljs-keyword\">a</span>标签标记一个位置<br>`<span class=\"hljs-keyword\">a</span>    精确回到<span class=\"hljs-keyword\">a</span>标签的位置(行和列)<br><span class=\"hljs-string\">&#x27;a    跳转到a标签的行</span><br></code></pre></td></tr></table></figure>\n\n<p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。</p>\n<p>我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记”a”(<code>ma</code>)，然后在另一个文件中设置另一个标记”a”(<code>ma</code>)。</p>\n<p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在<code>myFile.txt</code>中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。</p>\n<p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-zA-Z</code>以外还有别的标签，其中有一些例如：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-string\">&#x27;&#x27;</span>   在当前<span class=\"hljs-built_in\">buffer</span>中跳转回到上一次跳转前的最后一行<br><span class=\"hljs-string\">``</span>  在当前<span class=\"hljs-built_in\">buffer</span>中跳转回到上一次跳转前的最后一个位置<br><span class=\"hljs-string\">`[  跳转到上一次修改或拷贝的文本的开头</span><br><span class=\"hljs-string\">`</span>]  跳转到上一次修改或拷贝的文本的结尾<br><span class=\"hljs-string\">`&lt;  跳转到最近一次可视模式下选择的部分的开头</span><br><span class=\"hljs-string\">`</span>&gt;  跳转到最近一次可视模式下选择的部分的结尾<br><span class=\"hljs-string\">`0  跳转到退出Vim前编辑的最后一个文件</span><br></code></pre></td></tr></table></figure>\n\n<p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看。</p>\n<h2 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用<code>j</code>向下移动一行就不被看做一个跳转，即使你使用<code>10j</code>向下移动10行，也不是一个跳转。 但是你通过<code>10G</code>去往第10行被算作一个跳转。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">&#x27;   跳转到标记的行<br>`   跳转到标记的位置(行和列)<br>G   跳转到行<br>/   向后搜索<br>?   向前搜索<br>n   重复上一次搜索，相同方向<br>N   重复上一次搜索，相反方向<br>%   查找匹配<br>(   跳转上一个句子<br>)   跳转下一个句子<br>&#123;   跳转上一个段落<br>&#125;   跳转下一个段落<br>L   跳转到当前屏幕的最后一行<br>M   跳转到当前屏幕的中间<br>H   跳转到当前屏幕的第一行<br>[[  跳转到上一个小节<br>]]  跳转到下一个小节<br>:s  替换<br>:<span class=\"hljs-keyword\">tag</span>  <span class=\"hljs-title\">跳转到tag</span>定义<br></code></pre></td></tr></table></figure>\n<p>我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>。</p>\n<p>为什么跳转有用呢? 因为你可以在跳转列表中通过<code>Ctrl-o</code>和<code>Ctrl-i</code>在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。</p>\n<h2 id=\"聪明地学习导航\"><a href=\"#聪明地学习导航\" class=\"headerlink\" title=\"聪明地学习导航\"></a>聪明地学习导航</h2><p>如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。</p>\n<p>我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从<code>h,j,k,l,w,b,G,/,?,n</code>开始，不断地重复这10个移动知道形成肌肉记忆，这花不了多少时间。</p>\n<p>为了让你更擅长导航，我有两个建议：</p>\n<ol>\n<li>注意重复的动作。 如果你发现你自己在重复的使用<code>l</code>，你可以去找一个方法让你前进的更快，然后你会发现你可以用<code>w</code>在单词间移动。 如果你发现你自己的重复的使用<code>w</code>，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用<code>$</code>。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。</li>\n<li>当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。</li>\n</ol>\n<p>最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。</p>\n<p>慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。</p>\n"},{"title":"VIM-点命令","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 点命令\n\n在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。\n\n## 用法\n\n正如这个命令的名字一样，你可以通过按下`.`键来使用点命令。\n\n比如，如果你想将下面文本中的所有”let“替换为\"const\"：\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\n```\n\n- 首先，使用`/let`来进行匹配。\n- 接着，使用`cwconst<esc>`来将\"let\"替换成\"const\"。\n- 第三步，使用`n`来找到下一个匹配的位置。\n- 最后，使用点命令(`.`)来重复之前的操作。\n- 持续地使用`n . n .`直到每一个匹配的词都被替换。\n\n在这个例子里面，点命令重复的是`cwconst<esc>`这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。\n\n## 什么才算是修改操作？\n\n如果你查看点命令的定义的话(`:h .`),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？\n\n当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以`：`开头的命令），这些命令不算作修改操作。\n\n在第一个例子中，你看到的`cwconst<esc>`就是一个修改操作。现在假设你有以下这么一个句子：\n\n```\npancake, potatoes, fruit-juice,\n```\n\n我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用`df,`来完成这个操作,使用`.`来重复两次直到你将整个句子删除。\n\n让我们再来试试另一个例子：\n\n```\npancake, potatoes, fruit-juice,\n```\n\n这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用`f,`来找到第一个逗号，再使用`x`来删除光标下的字符。然后使用用`.`来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？\n\n在Vim里，修改操作是不包括移动（motions）的，因为移动(motions)不会更新缓冲区的内容。当你运行`f,x`，你实际上是在执行两个独立的操作：`f,`命令只移动光标，而`x`更新缓冲区的内容，只有后者算作修改动作。和之前例子中的`df,`进行一下对比的话，你会发现`df,`中的`f,`告诉删除操作`d`哪里需要删除，是整个删除命令`df,`的一部分。\n\n让我们想想办法完成这个任务。在你运行`f,`并执行`x`来删除第一个逗号后，使用`;`来继续匹配`f`的下一个目标（下一个逗号）。之后再使用`.`来重复修改操作，删除光标下的字符。重复`; . ; .`直到所有的逗号都被删除。完整的命令即为`f,x;.;.`。\n\n再来试试下一个例子：\n\n```\npancake\npotatoes\nfruit-juice\n```\n\n我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令`A,<esc>j`来给结尾加上逗号并移动到下一行。现在我们知道了`j`是不算作修改操作的，只有`A,`算作修改操作。你可以使用`j . j . `来移动并重复修改操作。完整的命令是`A,<esc>j`。\n\n从你按下输入命令（A）开始到你退出输入模式（<esc>）之间的所有输入都算作是一整个修改操作。\n\n## 重复多行修改操作\n\n假设你有如下的文本：\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nconst foo = \"bar\";\nlet four = \"4\";\nlet five = \"5\";\nlet six = \"6\";\nlet seven = \"7\";\nlet eight = \"8\";\nlet nine = \"9\";\n```\n\n你的目标是删除除了含有\"foo\"那一行以外的所有行。首先，使用`d2j`删除前三行。之后跳过\"foo\"这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是`d2jj..`。\n\n这里的修改操作是`d2j`，`2j`不是一个移动(motion)操作，而是整个删除命令的一部分。\n\n我们再来看看下一个例子：\n\n```\nzlet zzone = \"1\";\nzlet zztwo = \"2\";\nzlet zzthree = \"3\";\nlet four = \"4\";\n```\n\n我们的目标是删除所有的'z'。从第一行第一个字符开始，首先，在块可视化模式下使用`Ctrl-vjj`来选中前三行的第一个'z'字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个'z'后，使用`d`来删除它们。接着用`w`移动到下一个z字母上，使用`..`重复两次之前选中加删除的动作。完整的命令为`Ctrl-vjjdw..`。\n\n你删除一列上的三个’z‘的操作(`Ctrl-vjjd`)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。\n\n## 在修改中包含移动操作\n\n让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了`/letcwconst<esc>`紧接着`n . n .`将下面的文本中的'let'都替换成了'const'。\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\n```\n\n其实还有更快的方法来完成整个操作。当你使用`/let`搜索后，执行`cgnconst<Esc>`，然后`. . .`。\n\n`gn`是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为`/let`）匹配的位置，并且 **自动对匹配的文本进行可视化模式下的选取**。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（`n . n .`），而是简单地使用`. .`就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。\n\n当你在编辑文本时，应该时刻关注像`gn`命令这种能一下子做好几件事的移动操作。\n\n> （译者在这里研究了一会，并做了不少实验，总结规律是：单独的motion(第4章中所说的名词)不算修改操作，而opeartor(动词)+motion(名词)时(请回顾第4章)，motion被视为一个完整的修改操作中的一部分。再看一个例子，看看`/`命令是如何被包含在一个修改操作中的：\n\n```\na\nb\nfoo\nc\nd\nfoo\ne\nf\n```\n\n> 假设你的光标在第一行的a上，执行命令`d/foo<Esc>`，Vim会删除a,b。然后`.`，Vim会删除foo, c, d，再按`.`，Vim什么也不做，因为后面没有\"foo\"了。在这个例子中，`/foo`是一个motion（名词），是Vim语法(动词+名词：operator + motion)的一部分，前面的`d`则是动词。`d/foo<Esc>`这条命令的功能是：从当前光标所在位置开始删除，直到遇到\"foo\"为止。后面的点命令就重复这个功能，第二次按`.`之所以Vim什么也不做，是因为找不到下一个匹配了，所以这条命令就失效了。\n\n## 聪明地学习点命令\n\n点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于`x`这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像`cgnconst<esc>`这种复杂命令的话，使用点命令来替代就有非常可观的收益了。\n\n在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用`d3w`更划算，还是`dw`再使用`.`两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用`dw`好几次确实比`d3w`更加合理，因为`dw`更加有复用性。在编辑时应该养成“修改操作驱动”的观念。\n\n点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。\n","source":"_posts/Vim/ch07_the_dot_command.md","raw":"---\ntitle: VIM-点命令\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 点命令\n\n在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。\n\n## 用法\n\n正如这个命令的名字一样，你可以通过按下`.`键来使用点命令。\n\n比如，如果你想将下面文本中的所有”let“替换为\"const\"：\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\n```\n\n- 首先，使用`/let`来进行匹配。\n- 接着，使用`cwconst<esc>`来将\"let\"替换成\"const\"。\n- 第三步，使用`n`来找到下一个匹配的位置。\n- 最后，使用点命令(`.`)来重复之前的操作。\n- 持续地使用`n . n .`直到每一个匹配的词都被替换。\n\n在这个例子里面，点命令重复的是`cwconst<esc>`这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。\n\n## 什么才算是修改操作？\n\n如果你查看点命令的定义的话(`:h .`),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？\n\n当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以`：`开头的命令），这些命令不算作修改操作。\n\n在第一个例子中，你看到的`cwconst<esc>`就是一个修改操作。现在假设你有以下这么一个句子：\n\n```\npancake, potatoes, fruit-juice,\n```\n\n我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用`df,`来完成这个操作,使用`.`来重复两次直到你将整个句子删除。\n\n让我们再来试试另一个例子：\n\n```\npancake, potatoes, fruit-juice,\n```\n\n这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用`f,`来找到第一个逗号，再使用`x`来删除光标下的字符。然后使用用`.`来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？\n\n在Vim里，修改操作是不包括移动（motions）的，因为移动(motions)不会更新缓冲区的内容。当你运行`f,x`，你实际上是在执行两个独立的操作：`f,`命令只移动光标，而`x`更新缓冲区的内容，只有后者算作修改动作。和之前例子中的`df,`进行一下对比的话，你会发现`df,`中的`f,`告诉删除操作`d`哪里需要删除，是整个删除命令`df,`的一部分。\n\n让我们想想办法完成这个任务。在你运行`f,`并执行`x`来删除第一个逗号后，使用`;`来继续匹配`f`的下一个目标（下一个逗号）。之后再使用`.`来重复修改操作，删除光标下的字符。重复`; . ; .`直到所有的逗号都被删除。完整的命令即为`f,x;.;.`。\n\n再来试试下一个例子：\n\n```\npancake\npotatoes\nfruit-juice\n```\n\n我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令`A,<esc>j`来给结尾加上逗号并移动到下一行。现在我们知道了`j`是不算作修改操作的，只有`A,`算作修改操作。你可以使用`j . j . `来移动并重复修改操作。完整的命令是`A,<esc>j`。\n\n从你按下输入命令（A）开始到你退出输入模式（<esc>）之间的所有输入都算作是一整个修改操作。\n\n## 重复多行修改操作\n\n假设你有如下的文本：\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nconst foo = \"bar\";\nlet four = \"4\";\nlet five = \"5\";\nlet six = \"6\";\nlet seven = \"7\";\nlet eight = \"8\";\nlet nine = \"9\";\n```\n\n你的目标是删除除了含有\"foo\"那一行以外的所有行。首先，使用`d2j`删除前三行。之后跳过\"foo\"这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是`d2jj..`。\n\n这里的修改操作是`d2j`，`2j`不是一个移动(motion)操作，而是整个删除命令的一部分。\n\n我们再来看看下一个例子：\n\n```\nzlet zzone = \"1\";\nzlet zztwo = \"2\";\nzlet zzthree = \"3\";\nlet four = \"4\";\n```\n\n我们的目标是删除所有的'z'。从第一行第一个字符开始，首先，在块可视化模式下使用`Ctrl-vjj`来选中前三行的第一个'z'字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个'z'后，使用`d`来删除它们。接着用`w`移动到下一个z字母上，使用`..`重复两次之前选中加删除的动作。完整的命令为`Ctrl-vjjdw..`。\n\n你删除一列上的三个’z‘的操作(`Ctrl-vjjd`)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。\n\n## 在修改中包含移动操作\n\n让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了`/letcwconst<esc>`紧接着`n . n .`将下面的文本中的'let'都替换成了'const'。\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\n```\n\n其实还有更快的方法来完成整个操作。当你使用`/let`搜索后，执行`cgnconst<Esc>`，然后`. . .`。\n\n`gn`是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为`/let`）匹配的位置，并且 **自动对匹配的文本进行可视化模式下的选取**。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（`n . n .`），而是简单地使用`. .`就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。\n\n当你在编辑文本时，应该时刻关注像`gn`命令这种能一下子做好几件事的移动操作。\n\n> （译者在这里研究了一会，并做了不少实验，总结规律是：单独的motion(第4章中所说的名词)不算修改操作，而opeartor(动词)+motion(名词)时(请回顾第4章)，motion被视为一个完整的修改操作中的一部分。再看一个例子，看看`/`命令是如何被包含在一个修改操作中的：\n\n```\na\nb\nfoo\nc\nd\nfoo\ne\nf\n```\n\n> 假设你的光标在第一行的a上，执行命令`d/foo<Esc>`，Vim会删除a,b。然后`.`，Vim会删除foo, c, d，再按`.`，Vim什么也不做，因为后面没有\"foo\"了。在这个例子中，`/foo`是一个motion（名词），是Vim语法(动词+名词：operator + motion)的一部分，前面的`d`则是动词。`d/foo<Esc>`这条命令的功能是：从当前光标所在位置开始删除，直到遇到\"foo\"为止。后面的点命令就重复这个功能，第二次按`.`之所以Vim什么也不做，是因为找不到下一个匹配了，所以这条命令就失效了。\n\n## 聪明地学习点命令\n\n点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于`x`这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像`cgnconst<esc>`这种复杂命令的话，使用点命令来替代就有非常可观的收益了。\n\n在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用`d3w`更划算，还是`dw`再使用`.`两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用`dw`好几次确实比`d3w`更加合理，因为`dw`更加有复用性。在编辑时应该养成“修改操作驱动”的观念。\n\n点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。\n","slug":"Vim/ch07_the_dot_command","published":1,"updated":"2022-08-28T07:38:59.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1u001fscvm543obtck","content":"<h1 id=\"点命令\"><a href=\"#点命令\" class=\"headerlink\" title=\"点命令\"></a>点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令。</p>\n<p>比如，如果你想将下面文本中的所有”let“替换为”const”：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>首先，使用<code>/let</code>来进行匹配。</li>\n<li>接着，使用<code>cwconst&lt;esc&gt;</code>来将”let”替换成”const”。</li>\n<li>第三步，使用<code>n</code>来找到下一个匹配的位置。</li>\n<li>最后，使用点命令(<code>.</code>)来重复之前的操作。</li>\n<li>持续地使用<code>n . n .</code>直到每一个匹配的词都被替换。</li>\n</ul>\n<p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。</p>\n<h2 id=\"什么才算是修改操作？\"><a href=\"#什么才算是修改操作？\" class=\"headerlink\" title=\"什么才算是修改操作？\"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？</p>\n<p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作。</p>\n<p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作。现在假设你有以下这么一个句子：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><span class=\"hljs-built_in\">pancake,</span> potatoes, fruit-juice,<br></code></pre></td></tr></table></figure>\n\n<p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df,</code>来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除。</p>\n<p>让我们再来试试另一个例子：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><span class=\"hljs-built_in\">pancake,</span> potatoes, fruit-juice,<br></code></pre></td></tr></table></figure>\n\n<p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f,</code>来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用<code>.</code>来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？</p>\n<p>在Vim里，修改操作是不包括移动（motions）的，因为移动(motions)不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df,</code>进行一下对比的话，你会发现<code>df,</code>中的<code>f,</code>告诉删除操作<code>d</code>哪里需要删除，是整个删除命令<code>df,</code>的一部分。</p>\n<p>让我们想想办法完成这个任务。在你运行<code>f,</code>并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; . ; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.</code>。</p>\n<p>再来试试下一个例子：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancake</span><br><span class=\"hljs-attribute\">potatoes</span><br><span class=\"hljs-attribute\">fruit-juice</span><br></code></pre></td></tr></table></figure>\n\n<p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j . j . </code>来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>。</p>\n<p>从你按下输入命令（A）开始到你退出输入模式（<esc>）之间的所有输入都算作是一整个修改操作。</p>\n<h2 id=\"重复多行修改操作\"><a href=\"#重复多行修改操作\" class=\"headerlink\" title=\"重复多行修改操作\"></a>重复多行修改操作</h2><p>假设你有如下的文本：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>const foo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;bar&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br>let six <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;6&quot;</span><span class=\"hljs-comment\">;</span><br>let seven <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;7&quot;</span><span class=\"hljs-comment\">;</span><br>let eight <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;8&quot;</span><span class=\"hljs-comment\">;</span><br>let nine <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;9&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>你的目标是删除除了含有”foo”那一行以外的所有行。首先，使用<code>d2j</code>删除前三行。之后跳过”foo”这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是<code>d2jj..</code>。</p>\n<p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动(motion)操作，而是整个删除命令的一部分。</p>\n<p>我们再来看看下一个例子：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">zlet zzone <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>zlet zztwo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>zlet zzthree <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们的目标是删除所有的’z’。从第一行第一个字符开始，首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个’z’字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个’z’后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个z字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>。</p>\n<p>你删除一列上的三个’z‘的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。</p>\n<h2 id=\"在修改中包含移动操作\"><a href=\"#在修改中包含移动操作\" class=\"headerlink\" title=\"在修改中包含移动操作\"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n . n .</code>将下面的文本中的’let’都替换成了’const’。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>其实还有更快的方法来完成整个操作。当你使用<code>/let</code>搜索后，执行<code>cgnconst&lt;Esc&gt;</code>，然后<code>. . .</code>。</p>\n<p><code>gn</code>是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且 <strong>自动对匹配的文本进行可视化模式下的选取</strong>。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n . n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。</p>\n<p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作。</p>\n<blockquote>\n<p>（译者在这里研究了一会，并做了不少实验，总结规律是：单独的motion(第4章中所说的名词)不算修改操作，而opeartor(动词)+motion(名词)时(请回顾第4章)，motion被视为一个完整的修改操作中的一部分。再看一个例子，看看<code>/</code>命令是如何被包含在一个修改操作中的：</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span><br><span class=\"hljs-selector-tag\">b</span><br>foo<br>c<br>d<br>foo<br>e<br>f<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假设你的光标在第一行的a上，执行命令<code>d/foo&lt;Esc&gt;</code>，Vim会删除a,b。然后<code>.</code>，Vim会删除foo, c, d，再按<code>.</code>，Vim什么也不做，因为后面没有”foo”了。在这个例子中，<code>/foo</code>是一个motion（名词），是Vim语法(动词+名词：operator + motion)的一部分，前面的<code>d</code>则是动词。<code>d/foo&lt;Esc&gt;</code>这条命令的功能是：从当前光标所在位置开始删除，直到遇到”foo”为止。后面的点命令就重复这个功能，第二次按<code>.</code>之所以Vim什么也不做，是因为找不到下一个匹配了，所以这条命令就失效了。</p>\n</blockquote>\n<h2 id=\"聪明地学习点命令\"><a href=\"#聪明地学习点命令\" class=\"headerlink\" title=\"聪明地学习点命令\"></a>聪明地学习点命令</h2><p>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了。</p>\n<p>在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念。</p>\n<p>点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。</p>\n","site":{"data":{}},"wordcount":3307,"excerpt":"","more":"<h1 id=\"点命令\"><a href=\"#点命令\" class=\"headerlink\" title=\"点命令\"></a>点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令。</p>\n<p>比如，如果你想将下面文本中的所有”let“替换为”const”：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>首先，使用<code>/let</code>来进行匹配。</li>\n<li>接着，使用<code>cwconst&lt;esc&gt;</code>来将”let”替换成”const”。</li>\n<li>第三步，使用<code>n</code>来找到下一个匹配的位置。</li>\n<li>最后，使用点命令(<code>.</code>)来重复之前的操作。</li>\n<li>持续地使用<code>n . n .</code>直到每一个匹配的词都被替换。</li>\n</ul>\n<p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。</p>\n<h2 id=\"什么才算是修改操作？\"><a href=\"#什么才算是修改操作？\" class=\"headerlink\" title=\"什么才算是修改操作？\"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？</p>\n<p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作。</p>\n<p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作。现在假设你有以下这么一个句子：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><span class=\"hljs-built_in\">pancake,</span> potatoes, fruit-juice,<br></code></pre></td></tr></table></figure>\n\n<p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df,</code>来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除。</p>\n<p>让我们再来试试另一个例子：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><span class=\"hljs-built_in\">pancake,</span> potatoes, fruit-juice,<br></code></pre></td></tr></table></figure>\n\n<p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f,</code>来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用<code>.</code>来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？</p>\n<p>在Vim里，修改操作是不包括移动（motions）的，因为移动(motions)不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df,</code>进行一下对比的话，你会发现<code>df,</code>中的<code>f,</code>告诉删除操作<code>d</code>哪里需要删除，是整个删除命令<code>df,</code>的一部分。</p>\n<p>让我们想想办法完成这个任务。在你运行<code>f,</code>并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; . ; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.</code>。</p>\n<p>再来试试下一个例子：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancake</span><br><span class=\"hljs-attribute\">potatoes</span><br><span class=\"hljs-attribute\">fruit-juice</span><br></code></pre></td></tr></table></figure>\n\n<p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j . j . </code>来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>。</p>\n<p>从你按下输入命令（A）开始到你退出输入模式（<esc>）之间的所有输入都算作是一整个修改操作。</p>\n<h2 id=\"重复多行修改操作\"><a href=\"#重复多行修改操作\" class=\"headerlink\" title=\"重复多行修改操作\"></a>重复多行修改操作</h2><p>假设你有如下的文本：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>const foo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;bar&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br>let six <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;6&quot;</span><span class=\"hljs-comment\">;</span><br>let seven <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;7&quot;</span><span class=\"hljs-comment\">;</span><br>let eight <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;8&quot;</span><span class=\"hljs-comment\">;</span><br>let nine <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;9&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>你的目标是删除除了含有”foo”那一行以外的所有行。首先，使用<code>d2j</code>删除前三行。之后跳过”foo”这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是<code>d2jj..</code>。</p>\n<p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动(motion)操作，而是整个删除命令的一部分。</p>\n<p>我们再来看看下一个例子：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">zlet zzone <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>zlet zztwo <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>zlet zzthree <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们的目标是删除所有的’z’。从第一行第一个字符开始，首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个’z’字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个’z’后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个z字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>。</p>\n<p>你删除一列上的三个’z‘的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。</p>\n<h2 id=\"在修改中包含移动操作\"><a href=\"#在修改中包含移动操作\" class=\"headerlink\" title=\"在修改中包含移动操作\"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n . n .</code>将下面的文本中的’let’都替换成了’const’。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>其实还有更快的方法来完成整个操作。当你使用<code>/let</code>搜索后，执行<code>cgnconst&lt;Esc&gt;</code>，然后<code>. . .</code>。</p>\n<p><code>gn</code>是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且 <strong>自动对匹配的文本进行可视化模式下的选取</strong>。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n . n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。</p>\n<p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作。</p>\n<blockquote>\n<p>（译者在这里研究了一会，并做了不少实验，总结规律是：单独的motion(第4章中所说的名词)不算修改操作，而opeartor(动词)+motion(名词)时(请回顾第4章)，motion被视为一个完整的修改操作中的一部分。再看一个例子，看看<code>/</code>命令是如何被包含在一个修改操作中的：</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span><br><span class=\"hljs-selector-tag\">b</span><br>foo<br>c<br>d<br>foo<br>e<br>f<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假设你的光标在第一行的a上，执行命令<code>d/foo&lt;Esc&gt;</code>，Vim会删除a,b。然后<code>.</code>，Vim会删除foo, c, d，再按<code>.</code>，Vim什么也不做，因为后面没有”foo”了。在这个例子中，<code>/foo</code>是一个motion（名词），是Vim语法(动词+名词：operator + motion)的一部分，前面的<code>d</code>则是动词。<code>d/foo&lt;Esc&gt;</code>这条命令的功能是：从当前光标所在位置开始删除，直到遇到”foo”为止。后面的点命令就重复这个功能，第二次按<code>.</code>之所以Vim什么也不做，是因为找不到下一个匹配了，所以这条命令就失效了。</p>\n</blockquote>\n<h2 id=\"聪明地学习点命令\"><a href=\"#聪明地学习点命令\" class=\"headerlink\" title=\"聪明地学习点命令\"></a>聪明地学习点命令</h2><p>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了。</p>\n<p>在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念。</p>\n<p>点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。</p>\n"},{"title":"VIM-寄存器","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第08章 寄存器\n\n学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。\n\n你可能已经在复制或删除文本并用`p`或`P`粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？如果正确地使用Vim寄存器，将帮助您从重复的输入中解放出来。\n\n在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。\n\n## 寄存器的10种类型\n\n下面是Vim所拥有的10种寄存器类型：\n\n1. 匿名寄存器（`\"\"`）.\n2. 编号寄存器(`\"0-9`).\n3. 小删除寄存器 (`\"-`).\n4. 命名寄存器 (`\"a-z`).\n5. 只读寄存器 (`\":`, `\".`, and `\"%`).\n6. Buffer交替文件寄存器 (`\"#`).\n7. 表达式寄存器 (`\"=`).\n8. 选取和拖放寄存器(`\"*` and `\"+`).\n9. 黑洞寄存器 (`\"_`).\n10. 搜索模式寄存器 (`\"/`).\n\n\n## 寄存器命令\n\n要使用寄存器，您必须先使用命令将内容存储到寄存器，以下是一些存值到寄存器中的操作：\n\n```\ny    复制\nc    删除文本并进入输入模式\nd    删除文本\n```\n\n其实还有更多的寄存器写入操作（比如`s`或`x`），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。\n\n想要从寄存器中取出（粘贴）文本，你可以用以下的命令：\n\n```\np    在光标位置之后粘贴文本\nP    在光标位置之前粘贴文本\n```\n\n`p`和`P`都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用`10p`。想粘贴寄存器\"a\"中的文本，可以用`\"ap`。想将寄存器“a”中的文本粘贴10次的话，可以使用`10\"ap`。注意，从技术层面讲，命令`p`实际上表示的是\"put\"(放置)，而不是\"paste\"(粘贴)，使用粘贴只是因为它更符合传统习惯。\n\n从某个特定寄存器中读取文本的通用语法是`\"x`，其中`x`是这个寄存器的标志。\n\n## 在输入模式中使用寄存器\n\n在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器\"a\"中的文本，通常可以使用`\"ap`来进行。不过当你在输入模式下时，你需要运行`Ctrl-r a`。在输入模式下使用寄存器的语法是：\n\n```\nCtrl-r x\n```\n\n其中`x`是寄存器标志。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。\n\n\n##  匿名寄存器(`\"\"`)\n\n想从匿名寄存器中获取文本，可以使用`\"\"p`。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。\n\n默认情况下，`p`(或者`P`)是和匿名寄存器相关联的（从现在起我将使用`p`而不是`\"\"p`来指代匿名寄存器）。\n\n## 编号寄存器(`\"0-9`)\n\n编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(`0`)和其他编号寄存器(`1-9`)。让我们先来讨论复制寄存器。\n\n### 复制寄存器 (`\"0`)\n\n如果你使用`yy`来复制一整行文本，事实上Vim会将文本存放两个寄存器中：\n\n1. 匿名寄存器 (`p`).\n2. 复制寄存器 (`\"0p`).\n\n在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器(`0`)中的内容。其他的任何操作都不会被存放在`0`号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。\n\n比如，如果你：\n1. 复制一整行 (`yy`)\n2. 删除一整行(`dd`)\n3. 再删除另一行 (`dd`)\n\n复制寄存器中的文本仍然是第一步中复制的文本。\n\n如果你:\n1. 复制一整行 (`yy`)\n2. 删除一整行 (`dd`)\n3. 复制另一行 (`yy`)\n\n复制寄存器中的内容则是第三步中复制的内容。\n\n还有一个小技巧，在输入模式下，你可以使用`Ctrl-r 0`快速地粘贴你刚才复制的内容。\n\n### 编号寄存器 (`\"1-9`)\n\n当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（编号越小时间距离越近）\n\n比如，你有以下这些文本：\n\n```\nline three\nline two\nline one\n```\n\n当你的光标在文本“line three”上时,使用`dd`来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是\"line one\"（时间上最近的文本）， 2号寄存器则包含\"line two\"(时间上第二近的文本)，3号寄存器中则包含\"line three\"（最早删除的文本）。普通模式下可以使用`\"1p`来获取1号寄存器中的内容。\n\n编号寄存器的编号在使用点命令时会自动增加。比如，如果你的1号编号寄存器（`\"1`）中的内容为\"line one\"， 2号寄存器（`\"2`）为\"line two\", 三号寄存器（`\"3`）\"line three\",你可以使用以下的技巧来连续地粘贴他们：\n- 使用`\"1p`来粘贴1号寄存器中的内容。\n- 使用`.` (点命令)来粘贴2号寄存器（`\"2`）中的内容。\n- 使用`.` (点命令)来粘贴3号寄存器（`\"3`）中的内容。\n\n在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(`\"5P`), 点命令`.`会执行`\"6P`,再次使用`.`则会执行`\"7P`,等等。\n\n小型的删除比如单词删除（`dw`)或者单词修改(`cw`)不会被存储在编号寄存器中，它们被存储在小删除寄存器(`\"-`)中，我将在接下来的一小节讨论小删除寄存器。\n\n## 小删除寄存器(`\"-`)\n\n不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (`\"-`)中。\n\n比如:\n1. 删除一个单词 (`diw`)\n2. 删除一行文本 (`dd`)\n3. 删除一行文本 (`dd`)\n\n`\"-p` 会给你第一步中删除的单词。\n\n另一个例子:\n1. 删除一个单词(`diw`)\n2. 删除一行文本 (`dd`)\n3. 删除一个单词 (`diw`)\n\n`\"-p` 会给出第三步中删除的单词。类似地, `\"1p` 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。\n\n## 命名寄存器 (`\"a-z`)\n\n命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。\n\n为了复制一个单词到寄存器\"a\"中，你可以使用命令`\"ayiw`。\n- `\"a`告诉Vim下一个动作（删除/修改/复制）会被存储在寄存器\"a\"中\n- `yiw`复制这个单词\n\n为了从寄存器\"a\"中获取文本，可以使用命令`\"ap`。你可以使用以26个字母命名的寄存器来存储26个不同的文本。\n\n有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的\"a\"寄存器中已经存有文本\"Hello\"，如果你想继续添加\"world\"到寄存器\"a\"中，你可以先找到文本\"world\"然后使用`\"Aiw`来进行复制,即可完成追加。\n\n## 只读寄存器(`\":`, `\".`, `\"%`)\n\nVim有三个只读寄存器：`.`,`:`和`%`，它们的用法非常简单：\n\n```\n.    存储上一个输入的文本\n:    存储上一次执行的命令\n%    存储当前文件的文件名\n```\n\n如果你写入\"Hello Vim\",之后再运行`\".p`就会打印出文本\"Hello Vim\"。如果你想要获得当前文件的文件名，可以运行命令`\"%p`。如果你运行命令`:s/foo/bar/g`，再运行`\":p`的话则会打印出文本\"s/foo/bar/g\"。\n\n## Buffer交替文件寄存器 (`\"#`)\n\n在Vim中，`#`通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令`\"#p`。\n\n## 表达式寄存器 (`\"=`)\n\nVim有一个表达式寄存器，`\"=`,用于计算表达式的结果。\n\n你可以使用以下命令计算数学表达式`1+1`的值：\n\n```\n\"=1+1<Enter>p\n```\n\n在这里，你在告诉Vim你正在使用表达式寄存器`\"=`，你的表达式是（`1+1`），你还需要输入`p`来得到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：\n\n```\nCtrl-r =1+1\n```\n\n你可以使用`@`来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器\"a\"中获取文本：\n\n```\n\"=@a\n```\n\n之后输入`<enter>`，再输入`p`。类似地，想在输入模式中得到寄存器\"a\"中的值可以使用：\n\n```\nCtrl-r =@a\n```\n\n表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的VimScript章节中进一步讲解更多关于表达式的细节。\n\n##  选取和拖放寄存器 (`\"*`, `\"+`)\n\n你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：`quotestar` (`\"*`) 和 `quoteplus` (`\"+`)。你可以用它们来访问从外部程序中复制的文本。\n\n如果你在运行一个外部程序（比如Chrome浏览器），然后你使用`Ctrl-c`(或者`Cmd-c`,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用`p`来粘贴这部分文本的。但是，Vim的两个寄存器`\"+`和`\"*`都是和你系统的粘贴板相连接的，所以你可以使用`\"+p`和`\"*p`来粘贴这些文本。反过来，如果你使用`\"+yiw`或者`\"*yiw`在Vim中复制了一些文本，你可以使用`Ctrl-v`（或者`Cmd-v`）。值得注意的是这个方法只在你的Vim开启了`+clipboard`选项时才有用，可以在命令行中运行`vim --version`查看这一选项。如果你看见`-clipboard`的话，则需要安装一下支持Vim粘贴板的配置。\n\n你也许会想如果`\"*`和`\"+`能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是`quotestar` (`\"*`)寄存器作为X11的首选选项，并使用 `quoteplus` (`\"+`)作为粘贴板选项。这只在你的Vim配置里开启了`xterm_clipboard` 选项时才有效（`vim --version`中的`+xterm_clipboard`）。如果你的的Vim配置中没有 `xterm_clipboard`也不是什么大问题。这只是意味着`quotestar` 和`quoteplus`两个寄存器是可以互相替代的。\n\n我发觉使用`=*p`或者`=+p`的话比较麻烦，为了使Vim仅使用`p`就能粘贴从外部程序复制的文本，你可以在你的`vimrc`配置文件中加入下面一行：\n\n```\nset clipboard=unnamed\n```\n\n现在当我从外部程序中复制文本时，我可以使用匿名寄存器`p`来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用`Ctrl-v`来粘贴。如果你的Vim开启了 `+xterm_clipboard`设置，你或许会想同时也使用`unnamed`和`unnamedplus`的粘贴板选项。\n\n## 黑洞寄存器 (`\"_`)\n\n你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？\n\n你可以使用黑洞寄存器（`\"_`）。想要删除一行并且不将其存储在任何寄存器中时，可以使用`\"_dd`命令.\n\n它是和 `/dev/null` 类似的寄存器。\n\n##  搜索模式寄存器 (`\"/`)\n\n为了粘贴你的上一个搜索询问（`/` 或 `?`），你可以使用搜索模式寄存器(`\"/`)。使用命令 `\"/p`就能粘贴上一个搜索的条目。\n\n## 查看所有的寄存器\n\n你可以使用`:register`命令来查看你的所有寄存器。如果你只想查看\"a\",\"1\"和\"-\"寄存器的内容的话则可以使用命令`:register a 1 -`。\n\n有一个Vim的插件叫做 [vim-peekaboo](https://github.com/junegunn/vim-peekaboo) ,可以让你查看到寄存器的内容，在普通模式下输入`\"`或`@` 即可，或者在输入模式中输入`Ctrl-r`。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！\n\n## 执行寄存器\n\n命名寄存器不只可以用来存放文本，你还可以借助`@`来执行宏命令。我会在下一章节中介绍宏命令。\n\n注意，因为宏命令时存储在Vim寄存器中的，使用宏时可能会覆盖存储的内容。如果你将文本\"Hello Vim\"存放在寄存器\"a\"中，并且之后你在同一个寄存器里记录了一个宏命令 (`qa{macro-commands}q`),那么这个宏命令将会覆盖之前存储的文本\"Hello Vim\"（你可以使用`@a`来执行寄存器中存储的宏命令）。\n\n## 清除寄存器\n\n从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行`qaq`，Vim就会在寄存器\"a\"中记录一个空的宏命令。\n\n还有一种方法就是运行命令`:call setreg('a','hello register a')`,其中'a'代表的就是寄存器\"a\"。而\"hello register a\"就是你想存储的内容。\n\n还有一种清除寄存器的方法就是使用表达式`:let @a = ''`来将寄存器\"a 的值设为空的字符串。\n\n## 获取寄存器中的内容\n\n你可以使用`:put`命令来粘贴任何寄存器的内容。比如，如果你运行命令`:put a`,Vim就会打印出寄存器\"a\"的内容，这和`\"ap`非常像，唯一的区别在于在普通模式下命令`p`在当前光标位置之后打印寄存器的内容，而`:put`新起一行来打印寄存器的内容。\n\n因为`:put`是一个命令行命令，您可以传一个地址给它。`:10put a`将会在当前光标下数10行，然后插入新行，内容为寄存器a中的内容。\n\n一个很酷的技巧是将黑洞寄存器(`\"_`)传给`:put`命令。因为黑洞寄存器不保存任何值，`:put _`命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本\"end\"结尾的行下插入空行，使用`:g/end/put _`。在后面您将了解关于全局命令的知识。\n\n## 聪明地学习寄存器\n\n恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。\n\n我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：\n1. 匿名寄存器(`\"\"`).\n2. 命名寄存器 (`\"a-z`).\n3. 编号寄存器 (`\"0-9`).\n\n既然匿名寄存器是默认和`p`或`P`，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。\n\n普通人的短期记忆都是有极限的，大概每次只能记住5-7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器\"a\"开始用，之后用寄存器\"b\",以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。\n\nVim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。\n","source":"_posts/Vim/ch08_registers.md","raw":"---\ntitle: VIM-寄存器\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第08章 寄存器\n\n学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。\n\n你可能已经在复制或删除文本并用`p`或`P`粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？如果正确地使用Vim寄存器，将帮助您从重复的输入中解放出来。\n\n在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。\n\n## 寄存器的10种类型\n\n下面是Vim所拥有的10种寄存器类型：\n\n1. 匿名寄存器（`\"\"`）.\n2. 编号寄存器(`\"0-9`).\n3. 小删除寄存器 (`\"-`).\n4. 命名寄存器 (`\"a-z`).\n5. 只读寄存器 (`\":`, `\".`, and `\"%`).\n6. Buffer交替文件寄存器 (`\"#`).\n7. 表达式寄存器 (`\"=`).\n8. 选取和拖放寄存器(`\"*` and `\"+`).\n9. 黑洞寄存器 (`\"_`).\n10. 搜索模式寄存器 (`\"/`).\n\n\n## 寄存器命令\n\n要使用寄存器，您必须先使用命令将内容存储到寄存器，以下是一些存值到寄存器中的操作：\n\n```\ny    复制\nc    删除文本并进入输入模式\nd    删除文本\n```\n\n其实还有更多的寄存器写入操作（比如`s`或`x`），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。\n\n想要从寄存器中取出（粘贴）文本，你可以用以下的命令：\n\n```\np    在光标位置之后粘贴文本\nP    在光标位置之前粘贴文本\n```\n\n`p`和`P`都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用`10p`。想粘贴寄存器\"a\"中的文本，可以用`\"ap`。想将寄存器“a”中的文本粘贴10次的话，可以使用`10\"ap`。注意，从技术层面讲，命令`p`实际上表示的是\"put\"(放置)，而不是\"paste\"(粘贴)，使用粘贴只是因为它更符合传统习惯。\n\n从某个特定寄存器中读取文本的通用语法是`\"x`，其中`x`是这个寄存器的标志。\n\n## 在输入模式中使用寄存器\n\n在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器\"a\"中的文本，通常可以使用`\"ap`来进行。不过当你在输入模式下时，你需要运行`Ctrl-r a`。在输入模式下使用寄存器的语法是：\n\n```\nCtrl-r x\n```\n\n其中`x`是寄存器标志。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。\n\n\n##  匿名寄存器(`\"\"`)\n\n想从匿名寄存器中获取文本，可以使用`\"\"p`。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。\n\n默认情况下，`p`(或者`P`)是和匿名寄存器相关联的（从现在起我将使用`p`而不是`\"\"p`来指代匿名寄存器）。\n\n## 编号寄存器(`\"0-9`)\n\n编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(`0`)和其他编号寄存器(`1-9`)。让我们先来讨论复制寄存器。\n\n### 复制寄存器 (`\"0`)\n\n如果你使用`yy`来复制一整行文本，事实上Vim会将文本存放两个寄存器中：\n\n1. 匿名寄存器 (`p`).\n2. 复制寄存器 (`\"0p`).\n\n在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器(`0`)中的内容。其他的任何操作都不会被存放在`0`号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。\n\n比如，如果你：\n1. 复制一整行 (`yy`)\n2. 删除一整行(`dd`)\n3. 再删除另一行 (`dd`)\n\n复制寄存器中的文本仍然是第一步中复制的文本。\n\n如果你:\n1. 复制一整行 (`yy`)\n2. 删除一整行 (`dd`)\n3. 复制另一行 (`yy`)\n\n复制寄存器中的内容则是第三步中复制的内容。\n\n还有一个小技巧，在输入模式下，你可以使用`Ctrl-r 0`快速地粘贴你刚才复制的内容。\n\n### 编号寄存器 (`\"1-9`)\n\n当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（编号越小时间距离越近）\n\n比如，你有以下这些文本：\n\n```\nline three\nline two\nline one\n```\n\n当你的光标在文本“line three”上时,使用`dd`来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是\"line one\"（时间上最近的文本）， 2号寄存器则包含\"line two\"(时间上第二近的文本)，3号寄存器中则包含\"line three\"（最早删除的文本）。普通模式下可以使用`\"1p`来获取1号寄存器中的内容。\n\n编号寄存器的编号在使用点命令时会自动增加。比如，如果你的1号编号寄存器（`\"1`）中的内容为\"line one\"， 2号寄存器（`\"2`）为\"line two\", 三号寄存器（`\"3`）\"line three\",你可以使用以下的技巧来连续地粘贴他们：\n- 使用`\"1p`来粘贴1号寄存器中的内容。\n- 使用`.` (点命令)来粘贴2号寄存器（`\"2`）中的内容。\n- 使用`.` (点命令)来粘贴3号寄存器（`\"3`）中的内容。\n\n在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(`\"5P`), 点命令`.`会执行`\"6P`,再次使用`.`则会执行`\"7P`,等等。\n\n小型的删除比如单词删除（`dw`)或者单词修改(`cw`)不会被存储在编号寄存器中，它们被存储在小删除寄存器(`\"-`)中，我将在接下来的一小节讨论小删除寄存器。\n\n## 小删除寄存器(`\"-`)\n\n不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (`\"-`)中。\n\n比如:\n1. 删除一个单词 (`diw`)\n2. 删除一行文本 (`dd`)\n3. 删除一行文本 (`dd`)\n\n`\"-p` 会给你第一步中删除的单词。\n\n另一个例子:\n1. 删除一个单词(`diw`)\n2. 删除一行文本 (`dd`)\n3. 删除一个单词 (`diw`)\n\n`\"-p` 会给出第三步中删除的单词。类似地, `\"1p` 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。\n\n## 命名寄存器 (`\"a-z`)\n\n命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。\n\n为了复制一个单词到寄存器\"a\"中，你可以使用命令`\"ayiw`。\n- `\"a`告诉Vim下一个动作（删除/修改/复制）会被存储在寄存器\"a\"中\n- `yiw`复制这个单词\n\n为了从寄存器\"a\"中获取文本，可以使用命令`\"ap`。你可以使用以26个字母命名的寄存器来存储26个不同的文本。\n\n有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的\"a\"寄存器中已经存有文本\"Hello\"，如果你想继续添加\"world\"到寄存器\"a\"中，你可以先找到文本\"world\"然后使用`\"Aiw`来进行复制,即可完成追加。\n\n## 只读寄存器(`\":`, `\".`, `\"%`)\n\nVim有三个只读寄存器：`.`,`:`和`%`，它们的用法非常简单：\n\n```\n.    存储上一个输入的文本\n:    存储上一次执行的命令\n%    存储当前文件的文件名\n```\n\n如果你写入\"Hello Vim\",之后再运行`\".p`就会打印出文本\"Hello Vim\"。如果你想要获得当前文件的文件名，可以运行命令`\"%p`。如果你运行命令`:s/foo/bar/g`，再运行`\":p`的话则会打印出文本\"s/foo/bar/g\"。\n\n## Buffer交替文件寄存器 (`\"#`)\n\n在Vim中，`#`通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令`\"#p`。\n\n## 表达式寄存器 (`\"=`)\n\nVim有一个表达式寄存器，`\"=`,用于计算表达式的结果。\n\n你可以使用以下命令计算数学表达式`1+1`的值：\n\n```\n\"=1+1<Enter>p\n```\n\n在这里，你在告诉Vim你正在使用表达式寄存器`\"=`，你的表达式是（`1+1`），你还需要输入`p`来得到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：\n\n```\nCtrl-r =1+1\n```\n\n你可以使用`@`来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器\"a\"中获取文本：\n\n```\n\"=@a\n```\n\n之后输入`<enter>`，再输入`p`。类似地，想在输入模式中得到寄存器\"a\"中的值可以使用：\n\n```\nCtrl-r =@a\n```\n\n表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的VimScript章节中进一步讲解更多关于表达式的细节。\n\n##  选取和拖放寄存器 (`\"*`, `\"+`)\n\n你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：`quotestar` (`\"*`) 和 `quoteplus` (`\"+`)。你可以用它们来访问从外部程序中复制的文本。\n\n如果你在运行一个外部程序（比如Chrome浏览器），然后你使用`Ctrl-c`(或者`Cmd-c`,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用`p`来粘贴这部分文本的。但是，Vim的两个寄存器`\"+`和`\"*`都是和你系统的粘贴板相连接的，所以你可以使用`\"+p`和`\"*p`来粘贴这些文本。反过来，如果你使用`\"+yiw`或者`\"*yiw`在Vim中复制了一些文本，你可以使用`Ctrl-v`（或者`Cmd-v`）。值得注意的是这个方法只在你的Vim开启了`+clipboard`选项时才有用，可以在命令行中运行`vim --version`查看这一选项。如果你看见`-clipboard`的话，则需要安装一下支持Vim粘贴板的配置。\n\n你也许会想如果`\"*`和`\"+`能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是`quotestar` (`\"*`)寄存器作为X11的首选选项，并使用 `quoteplus` (`\"+`)作为粘贴板选项。这只在你的Vim配置里开启了`xterm_clipboard` 选项时才有效（`vim --version`中的`+xterm_clipboard`）。如果你的的Vim配置中没有 `xterm_clipboard`也不是什么大问题。这只是意味着`quotestar` 和`quoteplus`两个寄存器是可以互相替代的。\n\n我发觉使用`=*p`或者`=+p`的话比较麻烦，为了使Vim仅使用`p`就能粘贴从外部程序复制的文本，你可以在你的`vimrc`配置文件中加入下面一行：\n\n```\nset clipboard=unnamed\n```\n\n现在当我从外部程序中复制文本时，我可以使用匿名寄存器`p`来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用`Ctrl-v`来粘贴。如果你的Vim开启了 `+xterm_clipboard`设置，你或许会想同时也使用`unnamed`和`unnamedplus`的粘贴板选项。\n\n## 黑洞寄存器 (`\"_`)\n\n你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？\n\n你可以使用黑洞寄存器（`\"_`）。想要删除一行并且不将其存储在任何寄存器中时，可以使用`\"_dd`命令.\n\n它是和 `/dev/null` 类似的寄存器。\n\n##  搜索模式寄存器 (`\"/`)\n\n为了粘贴你的上一个搜索询问（`/` 或 `?`），你可以使用搜索模式寄存器(`\"/`)。使用命令 `\"/p`就能粘贴上一个搜索的条目。\n\n## 查看所有的寄存器\n\n你可以使用`:register`命令来查看你的所有寄存器。如果你只想查看\"a\",\"1\"和\"-\"寄存器的内容的话则可以使用命令`:register a 1 -`。\n\n有一个Vim的插件叫做 [vim-peekaboo](https://github.com/junegunn/vim-peekaboo) ,可以让你查看到寄存器的内容，在普通模式下输入`\"`或`@` 即可，或者在输入模式中输入`Ctrl-r`。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！\n\n## 执行寄存器\n\n命名寄存器不只可以用来存放文本，你还可以借助`@`来执行宏命令。我会在下一章节中介绍宏命令。\n\n注意，因为宏命令时存储在Vim寄存器中的，使用宏时可能会覆盖存储的内容。如果你将文本\"Hello Vim\"存放在寄存器\"a\"中，并且之后你在同一个寄存器里记录了一个宏命令 (`qa{macro-commands}q`),那么这个宏命令将会覆盖之前存储的文本\"Hello Vim\"（你可以使用`@a`来执行寄存器中存储的宏命令）。\n\n## 清除寄存器\n\n从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行`qaq`，Vim就会在寄存器\"a\"中记录一个空的宏命令。\n\n还有一种方法就是运行命令`:call setreg('a','hello register a')`,其中'a'代表的就是寄存器\"a\"。而\"hello register a\"就是你想存储的内容。\n\n还有一种清除寄存器的方法就是使用表达式`:let @a = ''`来将寄存器\"a 的值设为空的字符串。\n\n## 获取寄存器中的内容\n\n你可以使用`:put`命令来粘贴任何寄存器的内容。比如，如果你运行命令`:put a`,Vim就会打印出寄存器\"a\"的内容，这和`\"ap`非常像，唯一的区别在于在普通模式下命令`p`在当前光标位置之后打印寄存器的内容，而`:put`新起一行来打印寄存器的内容。\n\n因为`:put`是一个命令行命令，您可以传一个地址给它。`:10put a`将会在当前光标下数10行，然后插入新行，内容为寄存器a中的内容。\n\n一个很酷的技巧是将黑洞寄存器(`\"_`)传给`:put`命令。因为黑洞寄存器不保存任何值，`:put _`命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本\"end\"结尾的行下插入空行，使用`:g/end/put _`。在后面您将了解关于全局命令的知识。\n\n## 聪明地学习寄存器\n\n恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。\n\n我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：\n1. 匿名寄存器(`\"\"`).\n2. 命名寄存器 (`\"a-z`).\n3. 编号寄存器 (`\"0-9`).\n\n既然匿名寄存器是默认和`p`或`P`，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。\n\n普通人的短期记忆都是有极限的，大概每次只能记住5-7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器\"a\"开始用，之后用寄存器\"b\",以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。\n\nVim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。\n","slug":"Vim/ch08_registers","published":1,"updated":"2022-08-28T07:38:59.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1v001iscvm97z0f96o","content":"<h1 id=\"第08章-寄存器\"><a href=\"#第08章-寄存器\" class=\"headerlink\" title=\"第08章 寄存器\"></a>第08章 寄存器</h1><p>学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。</p>\n<p>你可能已经在复制或删除文本并用<code>p</code>或<code>P</code>粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？如果正确地使用Vim寄存器，将帮助您从重复的输入中解放出来。</p>\n<p>在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。</p>\n<h2 id=\"寄存器的10种类型\"><a href=\"#寄存器的10种类型\" class=\"headerlink\" title=\"寄存器的10种类型\"></a>寄存器的10种类型</h2><p>下面是Vim所拥有的10种寄存器类型：</p>\n<ol>\n<li>匿名寄存器（<code>&quot;&quot;</code>）.</li>\n<li>编号寄存器(<code>&quot;0-9</code>).</li>\n<li>小删除寄存器 (<code>&quot;-</code>).</li>\n<li>命名寄存器 (<code>&quot;a-z</code>).</li>\n<li>只读寄存器 (<code>&quot;:</code>, <code>&quot;.</code>, and <code>&quot;%</code>).</li>\n<li>Buffer交替文件寄存器 (<code>&quot;#</code>).</li>\n<li>表达式寄存器 (<code>&quot;=</code>).</li>\n<li>选取和拖放寄存器(<code>&quot;*</code> and <code>&quot;+</code>).</li>\n<li>黑洞寄存器 (<code>&quot;_</code>).</li>\n<li>搜索模式寄存器 (<code>&quot;/</code>).</li>\n</ol>\n<h2 id=\"寄存器命令\"><a href=\"#寄存器命令\" class=\"headerlink\" title=\"寄存器命令\"></a>寄存器命令</h2><p>要使用寄存器，您必须先使用命令将内容存储到寄存器，以下是一些存值到寄存器中的操作：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs llvm\">y    复制<br><span class=\"hljs-keyword\">c</span>    删除文本并进入输入模式<br>d    删除文本<br></code></pre></td></tr></table></figure>\n\n<p>其实还有更多的寄存器写入操作（比如<code>s</code>或<code>x</code>），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。</p>\n<p>想要从寄存器中取出（粘贴）文本，你可以用以下的命令：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>    在光标位置之后粘贴文本<br><span class=\"hljs-selector-tag\">P</span>    在光标位置之前粘贴文本<br></code></pre></td></tr></table></figure>\n\n<p><code>p</code>和<code>P</code>都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用<code>10p</code>。想粘贴寄存器”a”中的文本，可以用<code>&quot;ap</code>。想将寄存器“a”中的文本粘贴10次的话，可以使用<code>10&quot;ap</code>。注意，从技术层面讲，命令<code>p</code>实际上表示的是”put”(放置)，而不是”paste”(粘贴)，使用粘贴只是因为它更符合传统习惯。</p>\n<p>从某个特定寄存器中读取文本的通用语法是<code>&quot;x</code>，其中<code>x</code>是这个寄存器的标志。</p>\n<h2 id=\"在输入模式中使用寄存器\"><a href=\"#在输入模式中使用寄存器\" class=\"headerlink\" title=\"在输入模式中使用寄存器\"></a>在输入模式中使用寄存器</h2><p>在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器”a”中的文本，通常可以使用<code>&quot;ap</code>来进行。不过当你在输入模式下时，你需要运行<code>Ctrl-r a</code>。在输入模式下使用寄存器的语法是：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">Ctrl-r x</span><br></code></pre></td></tr></table></figure>\n\n<p>其中<code>x</code>是寄存器标志。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。</p>\n<h2 id=\"匿名寄存器-quot-quot\"><a href=\"#匿名寄存器-quot-quot\" class=\"headerlink\" title=\"匿名寄存器(&quot;&quot;)\"></a>匿名寄存器(<code>&quot;&quot;</code>)</h2><p>想从匿名寄存器中获取文本，可以使用<code>&quot;&quot;p</code>。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。</p>\n<p>默认情况下，<code>p</code>(或者<code>P</code>)是和匿名寄存器相关联的（从现在起我将使用<code>p</code>而不是<code>&quot;&quot;p</code>来指代匿名寄存器）。</p>\n<h2 id=\"编号寄存器-quot-0-9\"><a href=\"#编号寄存器-quot-0-9\" class=\"headerlink\" title=\"编号寄存器(&quot;0-9)\"></a>编号寄存器(<code>&quot;0-9</code>)</h2><p>编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(<code>0</code>)和其他编号寄存器(<code>1-9</code>)。让我们先来讨论复制寄存器。</p>\n<h3 id=\"复制寄存器-quot-0\"><a href=\"#复制寄存器-quot-0\" class=\"headerlink\" title=\"复制寄存器 (&quot;0)\"></a>复制寄存器 (<code>&quot;0</code>)</h3><p>如果你使用<code>yy</code>来复制一整行文本，事实上Vim会将文本存放两个寄存器中：</p>\n<ol>\n<li>匿名寄存器 (<code>p</code>).</li>\n<li>复制寄存器 (<code>&quot;0p</code>).</li>\n</ol>\n<p>在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器(<code>0</code>)中的内容。其他的任何操作都不会被存放在<code>0</code>号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。</p>\n<p>比如，如果你：</p>\n<ol>\n<li>复制一整行 (<code>yy</code>)</li>\n<li>删除一整行(<code>dd</code>)</li>\n<li>再删除另一行 (<code>dd</code>)</li>\n</ol>\n<p>复制寄存器中的文本仍然是第一步中复制的文本。</p>\n<p>如果你:</p>\n<ol>\n<li>复制一整行 (<code>yy</code>)</li>\n<li>删除一整行 (<code>dd</code>)</li>\n<li>复制另一行 (<code>yy</code>)</li>\n</ol>\n<p>复制寄存器中的内容则是第三步中复制的内容。</p>\n<p>还有一个小技巧，在输入模式下，你可以使用<code>Ctrl-r 0</code>快速地粘贴你刚才复制的内容。</p>\n<h3 id=\"编号寄存器-quot-1-9\"><a href=\"#编号寄存器-quot-1-9\" class=\"headerlink\" title=\"编号寄存器 (&quot;1-9)\"></a>编号寄存器 (<code>&quot;1-9</code>)</h3><p>当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（编号越小时间距离越近）</p>\n<p>比如，你有以下这些文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-built_in\">line</span> <span class=\"hljs-literal\">three</span><br><span class=\"hljs-built_in\">line</span> <span class=\"hljs-literal\">two</span><br><span class=\"hljs-built_in\">line</span> <span class=\"hljs-literal\">one</span><br></code></pre></td></tr></table></figure>\n\n<p>当你的光标在文本“line three”上时,使用<code>dd</code>来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是”line one”（时间上最近的文本）， 2号寄存器则包含”line two”(时间上第二近的文本)，3号寄存器中则包含”line three”（最早删除的文本）。普通模式下可以使用<code>&quot;1p</code>来获取1号寄存器中的内容。</p>\n<p>编号寄存器的编号在使用点命令时会自动增加。比如，如果你的1号编号寄存器（<code>&quot;1</code>）中的内容为”line one”， 2号寄存器（<code>&quot;2</code>）为”line two”, 三号寄存器（<code>&quot;3</code>）”line three”,你可以使用以下的技巧来连续地粘贴他们：</p>\n<ul>\n<li>使用<code>&quot;1p</code>来粘贴1号寄存器中的内容。</li>\n<li>使用<code>.</code> (点命令)来粘贴2号寄存器（<code>&quot;2</code>）中的内容。</li>\n<li>使用<code>.</code> (点命令)来粘贴3号寄存器（<code>&quot;3</code>）中的内容。</li>\n</ul>\n<p>在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(<code>&quot;5P</code>), 点命令<code>.</code>会执行<code>&quot;6P</code>,再次使用<code>.</code>则会执行<code>&quot;7P</code>,等等。</p>\n<p>小型的删除比如单词删除（<code>dw</code>)或者单词修改(<code>cw</code>)不会被存储在编号寄存器中，它们被存储在小删除寄存器(<code>&quot;-</code>)中，我将在接下来的一小节讨论小删除寄存器。</p>\n<h2 id=\"小删除寄存器-quot\"><a href=\"#小删除寄存器-quot\" class=\"headerlink\" title=\"小删除寄存器(&quot;-)\"></a>小删除寄存器(<code>&quot;-</code>)</h2><p>不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (<code>&quot;-</code>)中。</p>\n<p>比如:</p>\n<ol>\n<li>删除一个单词 (<code>diw</code>)</li>\n<li>删除一行文本 (<code>dd</code>)</li>\n<li>删除一行文本 (<code>dd</code>)</li>\n</ol>\n<p><code>&quot;-p</code> 会给你第一步中删除的单词。</p>\n<p>另一个例子:</p>\n<ol>\n<li>删除一个单词(<code>diw</code>)</li>\n<li>删除一行文本 (<code>dd</code>)</li>\n<li>删除一个单词 (<code>diw</code>)</li>\n</ol>\n<p><code>&quot;-p</code> 会给出第三步中删除的单词。类似地, <code>&quot;1p</code> 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。</p>\n<h2 id=\"命名寄存器-quot-a-z\"><a href=\"#命名寄存器-quot-a-z\" class=\"headerlink\" title=\"命名寄存器 (&quot;a-z)\"></a>命名寄存器 (<code>&quot;a-z</code>)</h2><p>命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。</p>\n<p>为了复制一个单词到寄存器”a”中，你可以使用命令<code>&quot;ayiw</code>。</p>\n<ul>\n<li><code>&quot;a</code>告诉Vim下一个动作（删除&#x2F;修改&#x2F;复制）会被存储在寄存器”a”中</li>\n<li><code>yiw</code>复制这个单词</li>\n</ul>\n<p>为了从寄存器”a”中获取文本，可以使用命令<code>&quot;ap</code>。你可以使用以26个字母命名的寄存器来存储26个不同的文本。</p>\n<p>有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的”a”寄存器中已经存有文本”Hello”，如果你想继续添加”world”到寄存器”a”中，你可以先找到文本”world”然后使用<code>&quot;Aiw</code>来进行复制,即可完成追加。</p>\n<h2 id=\"只读寄存器-quot-quot-quot\"><a href=\"#只读寄存器-quot-quot-quot\" class=\"headerlink\" title=\"只读寄存器(&quot;:, &quot;., &quot;%)\"></a>只读寄存器(<code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code>)</h2><p>Vim有三个只读寄存器：<code>.</code>,<code>:</code>和<code>%</code>，它们的用法非常简单：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">.    存储上一个输入的文本<br>:    存储上一次执行的命令<br>%    存储当前文件的文件名<br></code></pre></td></tr></table></figure>\n\n<p>如果你写入”Hello Vim”,之后再运行<code>&quot;.p</code>就会打印出文本”Hello Vim”。如果你想要获得当前文件的文件名，可以运行命令<code>&quot;%p</code>。如果你运行命令<code>:s/foo/bar/g</code>，再运行<code>&quot;:p</code>的话则会打印出文本”s&#x2F;foo&#x2F;bar&#x2F;g”。</p>\n<h2 id=\"Buffer交替文件寄存器-quot\"><a href=\"#Buffer交替文件寄存器-quot\" class=\"headerlink\" title=\"Buffer交替文件寄存器 (&quot;#)\"></a>Buffer交替文件寄存器 (<code>&quot;#</code>)</h2><p>在Vim中，<code>#</code>通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令<code>&quot;#p</code>。</p>\n<h2 id=\"表达式寄存器-quot\"><a href=\"#表达式寄存器-quot\" class=\"headerlink\" title=\"表达式寄存器 (&quot;=)\"></a>表达式寄存器 (<code>&quot;=</code>)</h2><p>Vim有一个表达式寄存器，<code>&quot;=</code>,用于计算表达式的结果。</p>\n<p>你可以使用以下命令计算数学表达式<code>1+1</code>的值：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;=1+1&lt;Enter&gt;p</span><br></code></pre></td></tr></table></figure>\n\n<p>在这里，你在告诉Vim你正在使用表达式寄存器<code>&quot;=</code>，你的表达式是（<code>1+1</code>），你还需要输入<code>p</code>来得到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Ctrl</span>-r =<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>你可以使用<code>@</code>来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器”a”中获取文本：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;=@a</span><br></code></pre></td></tr></table></figure>\n\n<p>之后输入<code>&lt;enter&gt;</code>，再输入<code>p</code>。类似地，想在输入模式中得到寄存器”a”中的值可以使用：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">Ctrl-r</span> =@a<br></code></pre></td></tr></table></figure>\n\n<p>表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的VimScript章节中进一步讲解更多关于表达式的细节。</p>\n<h2 id=\"选取和拖放寄存器-quot-quot\"><a href=\"#选取和拖放寄存器-quot-quot\" class=\"headerlink\" title=\"选取和拖放寄存器 (&quot;*, &quot;+)\"></a>选取和拖放寄存器 (<code>&quot;*</code>, <code>&quot;+</code>)</h2><p>你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：<code>quotestar</code> (<code>&quot;*</code>) 和 <code>quoteplus</code> (<code>&quot;+</code>)。你可以用它们来访问从外部程序中复制的文本。</p>\n<p>如果你在运行一个外部程序（比如Chrome浏览器），然后你使用<code>Ctrl-c</code>(或者<code>Cmd-c</code>,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用<code>p</code>来粘贴这部分文本的。但是，Vim的两个寄存器<code>&quot;+</code>和<code>&quot;*</code>都是和你系统的粘贴板相连接的，所以你可以使用<code>&quot;+p</code>和<code>&quot;*p</code>来粘贴这些文本。反过来，如果你使用<code>&quot;+yiw</code>或者<code>&quot;*yiw</code>在Vim中复制了一些文本，你可以使用<code>Ctrl-v</code>（或者<code>Cmd-v</code>）。值得注意的是这个方法只在你的Vim开启了<code>+clipboard</code>选项时才有用，可以在命令行中运行<code>vim --version</code>查看这一选项。如果你看见<code>-clipboard</code>的话，则需要安装一下支持Vim粘贴板的配置。</p>\n<p>你也许会想如果<code>&quot;*</code>和<code>&quot;+</code>能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是<code>quotestar</code> (<code>&quot;*</code>)寄存器作为X11的首选选项，并使用 <code>quoteplus</code> (<code>&quot;+</code>)作为粘贴板选项。这只在你的Vim配置里开启了<code>xterm_clipboard</code> 选项时才有效（<code>vim --version</code>中的<code>+xterm_clipboard</code>）。如果你的的Vim配置中没有 <code>xterm_clipboard</code>也不是什么大问题。这只是意味着<code>quotestar</code> 和<code>quoteplus</code>两个寄存器是可以互相替代的。</p>\n<p>我发觉使用<code>=*p</code>或者<code>=+p</code>的话比较麻烦，为了使Vim仅使用<code>p</code>就能粘贴从外部程序复制的文本，你可以在你的<code>vimrc</code>配置文件中加入下面一行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">clipboard</span>=unnamed<br></code></pre></td></tr></table></figure>\n\n<p>现在当我从外部程序中复制文本时，我可以使用匿名寄存器<code>p</code>来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用<code>Ctrl-v</code>来粘贴。如果你的Vim开启了 <code>+xterm_clipboard</code>设置，你或许会想同时也使用<code>unnamed</code>和<code>unnamedplus</code>的粘贴板选项。</p>\n<h2 id=\"黑洞寄存器-quot\"><a href=\"#黑洞寄存器-quot\" class=\"headerlink\" title=\"黑洞寄存器 (&quot;_)\"></a>黑洞寄存器 (<code>&quot;_</code>)</h2><p>你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？</p>\n<p>你可以使用黑洞寄存器（<code>&quot;_</code>）。想要删除一行并且不将其存储在任何寄存器中时，可以使用<code>&quot;_dd</code>命令.</p>\n<p>它是和 <code>/dev/null</code> 类似的寄存器。</p>\n<h2 id=\"搜索模式寄存器-quot\"><a href=\"#搜索模式寄存器-quot\" class=\"headerlink\" title=\"搜索模式寄存器 (&quot;/)\"></a>搜索模式寄存器 (<code>&quot;/</code>)</h2><p>为了粘贴你的上一个搜索询问（<code>/</code> 或 <code>?</code>），你可以使用搜索模式寄存器(<code>&quot;/</code>)。使用命令 <code>&quot;/p</code>就能粘贴上一个搜索的条目。</p>\n<h2 id=\"查看所有的寄存器\"><a href=\"#查看所有的寄存器\" class=\"headerlink\" title=\"查看所有的寄存器\"></a>查看所有的寄存器</h2><p>你可以使用<code>:register</code>命令来查看你的所有寄存器。如果你只想查看”a”,”1”和”-“寄存器的内容的话则可以使用命令<code>:register a 1 -</code>。</p>\n<p>有一个Vim的插件叫做 <a href=\"https://github.com/junegunn/vim-peekaboo\">vim-peekaboo</a> ,可以让你查看到寄存器的内容，在普通模式下输入<code>&quot;</code>或<code>@</code> 即可，或者在输入模式中输入<code>Ctrl-r</code>。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！</p>\n<h2 id=\"执行寄存器\"><a href=\"#执行寄存器\" class=\"headerlink\" title=\"执行寄存器\"></a>执行寄存器</h2><p>命名寄存器不只可以用来存放文本，你还可以借助<code>@</code>来执行宏命令。我会在下一章节中介绍宏命令。</p>\n<p>注意，因为宏命令时存储在Vim寄存器中的，使用宏时可能会覆盖存储的内容。如果你将文本”Hello Vim”存放在寄存器”a”中，并且之后你在同一个寄存器里记录了一个宏命令 (<code>qa&#123;macro-commands&#125;q</code>),那么这个宏命令将会覆盖之前存储的文本”Hello Vim”（你可以使用<code>@a</code>来执行寄存器中存储的宏命令）。</p>\n<h2 id=\"清除寄存器\"><a href=\"#清除寄存器\" class=\"headerlink\" title=\"清除寄存器\"></a>清除寄存器</h2><p>从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行<code>qaq</code>，Vim就会在寄存器”a”中记录一个空的宏命令。</p>\n<p>还有一种方法就是运行命令<code>:call setreg(&#39;a&#39;,&#39;hello register a&#39;)</code>,其中’a’代表的就是寄存器”a”。而”hello register a”就是你想存储的内容。</p>\n<p>还有一种清除寄存器的方法就是使用表达式<code>:let @a = &#39;&#39;</code>来将寄存器”a 的值设为空的字符串。</p>\n<h2 id=\"获取寄存器中的内容\"><a href=\"#获取寄存器中的内容\" class=\"headerlink\" title=\"获取寄存器中的内容\"></a>获取寄存器中的内容</h2><p>你可以使用<code>:put</code>命令来粘贴任何寄存器的内容。比如，如果你运行命令<code>:put a</code>,Vim就会打印出寄存器”a”的内容，这和<code>&quot;ap</code>非常像，唯一的区别在于在普通模式下命令<code>p</code>在当前光标位置之后打印寄存器的内容，而<code>:put</code>新起一行来打印寄存器的内容。</p>\n<p>因为<code>:put</code>是一个命令行命令，您可以传一个地址给它。<code>:10put a</code>将会在当前光标下数10行，然后插入新行，内容为寄存器a中的内容。</p>\n<p>一个很酷的技巧是将黑洞寄存器(<code>&quot;_</code>)传给<code>:put</code>命令。因为黑洞寄存器不保存任何值，<code>:put _</code>命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本”end”结尾的行下插入空行，使用<code>:g/end/put _</code>。在后面您将了解关于全局命令的知识。</p>\n<h2 id=\"聪明地学习寄存器\"><a href=\"#聪明地学习寄存器\" class=\"headerlink\" title=\"聪明地学习寄存器\"></a>聪明地学习寄存器</h2><p>恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。</p>\n<p>我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：</p>\n<ol>\n<li>匿名寄存器(<code>&quot;&quot;</code>).</li>\n<li>命名寄存器 (<code>&quot;a-z</code>).</li>\n<li>编号寄存器 (<code>&quot;0-9</code>).</li>\n</ol>\n<p>既然匿名寄存器是默认和<code>p</code>或<code>P</code>，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。</p>\n<p>普通人的短期记忆都是有极限的，大概每次只能记住5-7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器”a”开始用，之后用寄存器”b”,以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。</p>\n<p>Vim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。</p>\n","site":{"data":{}},"wordcount":6486,"excerpt":"","more":"<h1 id=\"第08章-寄存器\"><a href=\"#第08章-寄存器\" class=\"headerlink\" title=\"第08章 寄存器\"></a>第08章 寄存器</h1><p>学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。</p>\n<p>你可能已经在复制或删除文本并用<code>p</code>或<code>P</code>粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？如果正确地使用Vim寄存器，将帮助您从重复的输入中解放出来。</p>\n<p>在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。</p>\n<h2 id=\"寄存器的10种类型\"><a href=\"#寄存器的10种类型\" class=\"headerlink\" title=\"寄存器的10种类型\"></a>寄存器的10种类型</h2><p>下面是Vim所拥有的10种寄存器类型：</p>\n<ol>\n<li>匿名寄存器（<code>&quot;&quot;</code>）.</li>\n<li>编号寄存器(<code>&quot;0-9</code>).</li>\n<li>小删除寄存器 (<code>&quot;-</code>).</li>\n<li>命名寄存器 (<code>&quot;a-z</code>).</li>\n<li>只读寄存器 (<code>&quot;:</code>, <code>&quot;.</code>, and <code>&quot;%</code>).</li>\n<li>Buffer交替文件寄存器 (<code>&quot;#</code>).</li>\n<li>表达式寄存器 (<code>&quot;=</code>).</li>\n<li>选取和拖放寄存器(<code>&quot;*</code> and <code>&quot;+</code>).</li>\n<li>黑洞寄存器 (<code>&quot;_</code>).</li>\n<li>搜索模式寄存器 (<code>&quot;/</code>).</li>\n</ol>\n<h2 id=\"寄存器命令\"><a href=\"#寄存器命令\" class=\"headerlink\" title=\"寄存器命令\"></a>寄存器命令</h2><p>要使用寄存器，您必须先使用命令将内容存储到寄存器，以下是一些存值到寄存器中的操作：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">y    复制<br><span class=\"hljs-keyword\">c</span>    删除文本并进入输入模式<br>d    删除文本<br></code></pre></td></tr></table></figure>\n\n<p>其实还有更多的寄存器写入操作（比如<code>s</code>或<code>x</code>），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。</p>\n<p>想要从寄存器中取出（粘贴）文本，你可以用以下的命令：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">p</span>    在光标位置之后粘贴文本<br><span class=\"hljs-selector-tag\">P</span>    在光标位置之前粘贴文本<br></code></pre></td></tr></table></figure>\n\n<p><code>p</code>和<code>P</code>都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用<code>10p</code>。想粘贴寄存器”a”中的文本，可以用<code>&quot;ap</code>。想将寄存器“a”中的文本粘贴10次的话，可以使用<code>10&quot;ap</code>。注意，从技术层面讲，命令<code>p</code>实际上表示的是”put”(放置)，而不是”paste”(粘贴)，使用粘贴只是因为它更符合传统习惯。</p>\n<p>从某个特定寄存器中读取文本的通用语法是<code>&quot;x</code>，其中<code>x</code>是这个寄存器的标志。</p>\n<h2 id=\"在输入模式中使用寄存器\"><a href=\"#在输入模式中使用寄存器\" class=\"headerlink\" title=\"在输入模式中使用寄存器\"></a>在输入模式中使用寄存器</h2><p>在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器”a”中的文本，通常可以使用<code>&quot;ap</code>来进行。不过当你在输入模式下时，你需要运行<code>Ctrl-r a</code>。在输入模式下使用寄存器的语法是：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">Ctrl-r x</span><br></code></pre></td></tr></table></figure>\n\n<p>其中<code>x</code>是寄存器标志。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。</p>\n<h2 id=\"匿名寄存器-quot-quot\"><a href=\"#匿名寄存器-quot-quot\" class=\"headerlink\" title=\"匿名寄存器(&quot;&quot;)\"></a>匿名寄存器(<code>&quot;&quot;</code>)</h2><p>想从匿名寄存器中获取文本，可以使用<code>&quot;&quot;p</code>。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。</p>\n<p>默认情况下，<code>p</code>(或者<code>P</code>)是和匿名寄存器相关联的（从现在起我将使用<code>p</code>而不是<code>&quot;&quot;p</code>来指代匿名寄存器）。</p>\n<h2 id=\"编号寄存器-quot-0-9\"><a href=\"#编号寄存器-quot-0-9\" class=\"headerlink\" title=\"编号寄存器(&quot;0-9)\"></a>编号寄存器(<code>&quot;0-9</code>)</h2><p>编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(<code>0</code>)和其他编号寄存器(<code>1-9</code>)。让我们先来讨论复制寄存器。</p>\n<h3 id=\"复制寄存器-quot-0\"><a href=\"#复制寄存器-quot-0\" class=\"headerlink\" title=\"复制寄存器 (&quot;0)\"></a>复制寄存器 (<code>&quot;0</code>)</h3><p>如果你使用<code>yy</code>来复制一整行文本，事实上Vim会将文本存放两个寄存器中：</p>\n<ol>\n<li>匿名寄存器 (<code>p</code>).</li>\n<li>复制寄存器 (<code>&quot;0p</code>).</li>\n</ol>\n<p>在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器(<code>0</code>)中的内容。其他的任何操作都不会被存放在<code>0</code>号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。</p>\n<p>比如，如果你：</p>\n<ol>\n<li>复制一整行 (<code>yy</code>)</li>\n<li>删除一整行(<code>dd</code>)</li>\n<li>再删除另一行 (<code>dd</code>)</li>\n</ol>\n<p>复制寄存器中的文本仍然是第一步中复制的文本。</p>\n<p>如果你:</p>\n<ol>\n<li>复制一整行 (<code>yy</code>)</li>\n<li>删除一整行 (<code>dd</code>)</li>\n<li>复制另一行 (<code>yy</code>)</li>\n</ol>\n<p>复制寄存器中的内容则是第三步中复制的内容。</p>\n<p>还有一个小技巧，在输入模式下，你可以使用<code>Ctrl-r 0</code>快速地粘贴你刚才复制的内容。</p>\n<h3 id=\"编号寄存器-quot-1-9\"><a href=\"#编号寄存器-quot-1-9\" class=\"headerlink\" title=\"编号寄存器 (&quot;1-9)\"></a>编号寄存器 (<code>&quot;1-9</code>)</h3><p>当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（编号越小时间距离越近）</p>\n<p>比如，你有以下这些文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-built_in\">line</span> <span class=\"hljs-literal\">three</span><br><span class=\"hljs-built_in\">line</span> <span class=\"hljs-literal\">two</span><br><span class=\"hljs-built_in\">line</span> <span class=\"hljs-literal\">one</span><br></code></pre></td></tr></table></figure>\n\n<p>当你的光标在文本“line three”上时,使用<code>dd</code>来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是”line one”（时间上最近的文本）， 2号寄存器则包含”line two”(时间上第二近的文本)，3号寄存器中则包含”line three”（最早删除的文本）。普通模式下可以使用<code>&quot;1p</code>来获取1号寄存器中的内容。</p>\n<p>编号寄存器的编号在使用点命令时会自动增加。比如，如果你的1号编号寄存器（<code>&quot;1</code>）中的内容为”line one”， 2号寄存器（<code>&quot;2</code>）为”line two”, 三号寄存器（<code>&quot;3</code>）”line three”,你可以使用以下的技巧来连续地粘贴他们：</p>\n<ul>\n<li>使用<code>&quot;1p</code>来粘贴1号寄存器中的内容。</li>\n<li>使用<code>.</code> (点命令)来粘贴2号寄存器（<code>&quot;2</code>）中的内容。</li>\n<li>使用<code>.</code> (点命令)来粘贴3号寄存器（<code>&quot;3</code>）中的内容。</li>\n</ul>\n<p>在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(<code>&quot;5P</code>), 点命令<code>.</code>会执行<code>&quot;6P</code>,再次使用<code>.</code>则会执行<code>&quot;7P</code>,等等。</p>\n<p>小型的删除比如单词删除（<code>dw</code>)或者单词修改(<code>cw</code>)不会被存储在编号寄存器中，它们被存储在小删除寄存器(<code>&quot;-</code>)中，我将在接下来的一小节讨论小删除寄存器。</p>\n<h2 id=\"小删除寄存器-quot\"><a href=\"#小删除寄存器-quot\" class=\"headerlink\" title=\"小删除寄存器(&quot;-)\"></a>小删除寄存器(<code>&quot;-</code>)</h2><p>不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (<code>&quot;-</code>)中。</p>\n<p>比如:</p>\n<ol>\n<li>删除一个单词 (<code>diw</code>)</li>\n<li>删除一行文本 (<code>dd</code>)</li>\n<li>删除一行文本 (<code>dd</code>)</li>\n</ol>\n<p><code>&quot;-p</code> 会给你第一步中删除的单词。</p>\n<p>另一个例子:</p>\n<ol>\n<li>删除一个单词(<code>diw</code>)</li>\n<li>删除一行文本 (<code>dd</code>)</li>\n<li>删除一个单词 (<code>diw</code>)</li>\n</ol>\n<p><code>&quot;-p</code> 会给出第三步中删除的单词。类似地, <code>&quot;1p</code> 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。</p>\n<h2 id=\"命名寄存器-quot-a-z\"><a href=\"#命名寄存器-quot-a-z\" class=\"headerlink\" title=\"命名寄存器 (&quot;a-z)\"></a>命名寄存器 (<code>&quot;a-z</code>)</h2><p>命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。</p>\n<p>为了复制一个单词到寄存器”a”中，你可以使用命令<code>&quot;ayiw</code>。</p>\n<ul>\n<li><code>&quot;a</code>告诉Vim下一个动作（删除&#x2F;修改&#x2F;复制）会被存储在寄存器”a”中</li>\n<li><code>yiw</code>复制这个单词</li>\n</ul>\n<p>为了从寄存器”a”中获取文本，可以使用命令<code>&quot;ap</code>。你可以使用以26个字母命名的寄存器来存储26个不同的文本。</p>\n<p>有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的”a”寄存器中已经存有文本”Hello”，如果你想继续添加”world”到寄存器”a”中，你可以先找到文本”world”然后使用<code>&quot;Aiw</code>来进行复制,即可完成追加。</p>\n<h2 id=\"只读寄存器-quot-quot-quot\"><a href=\"#只读寄存器-quot-quot-quot\" class=\"headerlink\" title=\"只读寄存器(&quot;:, &quot;., &quot;%)\"></a>只读寄存器(<code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code>)</h2><p>Vim有三个只读寄存器：<code>.</code>,<code>:</code>和<code>%</code>，它们的用法非常简单：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">.    存储上一个输入的文本<br>:    存储上一次执行的命令<br>%    存储当前文件的文件名<br></code></pre></td></tr></table></figure>\n\n<p>如果你写入”Hello Vim”,之后再运行<code>&quot;.p</code>就会打印出文本”Hello Vim”。如果你想要获得当前文件的文件名，可以运行命令<code>&quot;%p</code>。如果你运行命令<code>:s/foo/bar/g</code>，再运行<code>&quot;:p</code>的话则会打印出文本”s&#x2F;foo&#x2F;bar&#x2F;g”。</p>\n<h2 id=\"Buffer交替文件寄存器-quot\"><a href=\"#Buffer交替文件寄存器-quot\" class=\"headerlink\" title=\"Buffer交替文件寄存器 (&quot;#)\"></a>Buffer交替文件寄存器 (<code>&quot;#</code>)</h2><p>在Vim中，<code>#</code>通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令<code>&quot;#p</code>。</p>\n<h2 id=\"表达式寄存器-quot\"><a href=\"#表达式寄存器-quot\" class=\"headerlink\" title=\"表达式寄存器 (&quot;=)\"></a>表达式寄存器 (<code>&quot;=</code>)</h2><p>Vim有一个表达式寄存器，<code>&quot;=</code>,用于计算表达式的结果。</p>\n<p>你可以使用以下命令计算数学表达式<code>1+1</code>的值：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;=1+1&lt;Enter&gt;p</span><br></code></pre></td></tr></table></figure>\n\n<p>在这里，你在告诉Vim你正在使用表达式寄存器<code>&quot;=</code>，你的表达式是（<code>1+1</code>），你还需要输入<code>p</code>来得到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Ctrl</span>-r =<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>你可以使用<code>@</code>来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器”a”中获取文本：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;=@a</span><br></code></pre></td></tr></table></figure>\n\n<p>之后输入<code>&lt;enter&gt;</code>，再输入<code>p</code>。类似地，想在输入模式中得到寄存器”a”中的值可以使用：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">Ctrl-r</span> =@a<br></code></pre></td></tr></table></figure>\n\n<p>表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的VimScript章节中进一步讲解更多关于表达式的细节。</p>\n<h2 id=\"选取和拖放寄存器-quot-quot\"><a href=\"#选取和拖放寄存器-quot-quot\" class=\"headerlink\" title=\"选取和拖放寄存器 (&quot;*, &quot;+)\"></a>选取和拖放寄存器 (<code>&quot;*</code>, <code>&quot;+</code>)</h2><p>你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：<code>quotestar</code> (<code>&quot;*</code>) 和 <code>quoteplus</code> (<code>&quot;+</code>)。你可以用它们来访问从外部程序中复制的文本。</p>\n<p>如果你在运行一个外部程序（比如Chrome浏览器），然后你使用<code>Ctrl-c</code>(或者<code>Cmd-c</code>,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用<code>p</code>来粘贴这部分文本的。但是，Vim的两个寄存器<code>&quot;+</code>和<code>&quot;*</code>都是和你系统的粘贴板相连接的，所以你可以使用<code>&quot;+p</code>和<code>&quot;*p</code>来粘贴这些文本。反过来，如果你使用<code>&quot;+yiw</code>或者<code>&quot;*yiw</code>在Vim中复制了一些文本，你可以使用<code>Ctrl-v</code>（或者<code>Cmd-v</code>）。值得注意的是这个方法只在你的Vim开启了<code>+clipboard</code>选项时才有用，可以在命令行中运行<code>vim --version</code>查看这一选项。如果你看见<code>-clipboard</code>的话，则需要安装一下支持Vim粘贴板的配置。</p>\n<p>你也许会想如果<code>&quot;*</code>和<code>&quot;+</code>能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是<code>quotestar</code> (<code>&quot;*</code>)寄存器作为X11的首选选项，并使用 <code>quoteplus</code> (<code>&quot;+</code>)作为粘贴板选项。这只在你的Vim配置里开启了<code>xterm_clipboard</code> 选项时才有效（<code>vim --version</code>中的<code>+xterm_clipboard</code>）。如果你的的Vim配置中没有 <code>xterm_clipboard</code>也不是什么大问题。这只是意味着<code>quotestar</code> 和<code>quoteplus</code>两个寄存器是可以互相替代的。</p>\n<p>我发觉使用<code>=*p</code>或者<code>=+p</code>的话比较麻烦，为了使Vim仅使用<code>p</code>就能粘贴从外部程序复制的文本，你可以在你的<code>vimrc</code>配置文件中加入下面一行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">clipboard</span>=unnamed<br></code></pre></td></tr></table></figure>\n\n<p>现在当我从外部程序中复制文本时，我可以使用匿名寄存器<code>p</code>来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用<code>Ctrl-v</code>来粘贴。如果你的Vim开启了 <code>+xterm_clipboard</code>设置，你或许会想同时也使用<code>unnamed</code>和<code>unnamedplus</code>的粘贴板选项。</p>\n<h2 id=\"黑洞寄存器-quot\"><a href=\"#黑洞寄存器-quot\" class=\"headerlink\" title=\"黑洞寄存器 (&quot;_)\"></a>黑洞寄存器 (<code>&quot;_</code>)</h2><p>你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？</p>\n<p>你可以使用黑洞寄存器（<code>&quot;_</code>）。想要删除一行并且不将其存储在任何寄存器中时，可以使用<code>&quot;_dd</code>命令.</p>\n<p>它是和 <code>/dev/null</code> 类似的寄存器。</p>\n<h2 id=\"搜索模式寄存器-quot\"><a href=\"#搜索模式寄存器-quot\" class=\"headerlink\" title=\"搜索模式寄存器 (&quot;/)\"></a>搜索模式寄存器 (<code>&quot;/</code>)</h2><p>为了粘贴你的上一个搜索询问（<code>/</code> 或 <code>?</code>），你可以使用搜索模式寄存器(<code>&quot;/</code>)。使用命令 <code>&quot;/p</code>就能粘贴上一个搜索的条目。</p>\n<h2 id=\"查看所有的寄存器\"><a href=\"#查看所有的寄存器\" class=\"headerlink\" title=\"查看所有的寄存器\"></a>查看所有的寄存器</h2><p>你可以使用<code>:register</code>命令来查看你的所有寄存器。如果你只想查看”a”,”1”和”-“寄存器的内容的话则可以使用命令<code>:register a 1 -</code>。</p>\n<p>有一个Vim的插件叫做 <a href=\"https://github.com/junegunn/vim-peekaboo\">vim-peekaboo</a> ,可以让你查看到寄存器的内容，在普通模式下输入<code>&quot;</code>或<code>@</code> 即可，或者在输入模式中输入<code>Ctrl-r</code>。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！</p>\n<h2 id=\"执行寄存器\"><a href=\"#执行寄存器\" class=\"headerlink\" title=\"执行寄存器\"></a>执行寄存器</h2><p>命名寄存器不只可以用来存放文本，你还可以借助<code>@</code>来执行宏命令。我会在下一章节中介绍宏命令。</p>\n<p>注意，因为宏命令时存储在Vim寄存器中的，使用宏时可能会覆盖存储的内容。如果你将文本”Hello Vim”存放在寄存器”a”中，并且之后你在同一个寄存器里记录了一个宏命令 (<code>qa&#123;macro-commands&#125;q</code>),那么这个宏命令将会覆盖之前存储的文本”Hello Vim”（你可以使用<code>@a</code>来执行寄存器中存储的宏命令）。</p>\n<h2 id=\"清除寄存器\"><a href=\"#清除寄存器\" class=\"headerlink\" title=\"清除寄存器\"></a>清除寄存器</h2><p>从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行<code>qaq</code>，Vim就会在寄存器”a”中记录一个空的宏命令。</p>\n<p>还有一种方法就是运行命令<code>:call setreg(&#39;a&#39;,&#39;hello register a&#39;)</code>,其中’a’代表的就是寄存器”a”。而”hello register a”就是你想存储的内容。</p>\n<p>还有一种清除寄存器的方法就是使用表达式<code>:let @a = &#39;&#39;</code>来将寄存器”a 的值设为空的字符串。</p>\n<h2 id=\"获取寄存器中的内容\"><a href=\"#获取寄存器中的内容\" class=\"headerlink\" title=\"获取寄存器中的内容\"></a>获取寄存器中的内容</h2><p>你可以使用<code>:put</code>命令来粘贴任何寄存器的内容。比如，如果你运行命令<code>:put a</code>,Vim就会打印出寄存器”a”的内容，这和<code>&quot;ap</code>非常像，唯一的区别在于在普通模式下命令<code>p</code>在当前光标位置之后打印寄存器的内容，而<code>:put</code>新起一行来打印寄存器的内容。</p>\n<p>因为<code>:put</code>是一个命令行命令，您可以传一个地址给它。<code>:10put a</code>将会在当前光标下数10行，然后插入新行，内容为寄存器a中的内容。</p>\n<p>一个很酷的技巧是将黑洞寄存器(<code>&quot;_</code>)传给<code>:put</code>命令。因为黑洞寄存器不保存任何值，<code>:put _</code>命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本”end”结尾的行下插入空行，使用<code>:g/end/put _</code>。在后面您将了解关于全局命令的知识。</p>\n<h2 id=\"聪明地学习寄存器\"><a href=\"#聪明地学习寄存器\" class=\"headerlink\" title=\"聪明地学习寄存器\"></a>聪明地学习寄存器</h2><p>恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。</p>\n<p>我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：</p>\n<ol>\n<li>匿名寄存器(<code>&quot;&quot;</code>).</li>\n<li>命名寄存器 (<code>&quot;a-z</code>).</li>\n<li>编号寄存器 (<code>&quot;0-9</code>).</li>\n</ol>\n<p>既然匿名寄存器是默认和<code>p</code>或<code>P</code>，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。</p>\n<p>普通人的短期记忆都是有极限的，大概每次只能记住5-7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器”a”开始用，之后用寄存器”b”,以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。</p>\n<p>Vim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。</p>\n"},{"title":"VIM-宏命令","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第09章 宏命令\n\n在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。\n\n在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。\n\n## 基本宏命令\n\n宏命令的基本语法如下：\n\n```\nqa                     开始记录动作到寄存器 a\nq (while recording)    停止记录\n```\n\n你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：\n\n```\n@a    Execute macro from register a\n@@    Execute the last executed macros\n```\n\n假设你有如下的文本，你打算将每一行中的所有字母都变为大写。\n\n```\nhello\nvim\nmacros\nare\nawesome\n```\n\n将你的光标移动到 “hello” 栏的行首，并执行：\n\n```\nqa0gU$jq\n```\n\n上面命令的分解如下：\n- `qa` 开始记录一个宏定义并存储在 a 寄存器。\n- `0` 移动到行首。\n- `gU$` 将从光标到行尾的字母变为大写。\n- `j` 移动到下一行。\n- `q` 停止记录。\n\n调用 `@a` 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 `3@a` 去执行 `a` 命令3次。你也可以执行 `3@@` 去执行上一次执行过的宏命令3次。\n\n## 安全保护\n\n在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：\n\n```\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\n```\n\n你想将每一行的第一个词变为大写，你可以使用如下的宏命令：\n\n```\nqa0W~jq\n```\n\n上面命令的分解如下：\n- `qa` 开始记录一个宏定义并存储在 a 寄存器。\n- `0` 移动到行首。\n- `W` 移动到下一个单词。\n- `~` 将光标选中的单词变为大写。\n- `j` 移动到下一行。\n- `q` 停止记录。\n\n我喜欢对宏命令进行超过所需次数的调用，所以我通常使用 `99@a` 命令去执行该宏命令99次。使用该命令，Vim并不会真正执行这个宏99次，当 Vim 到达最后一行执行`j`时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。\n\n实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。\n\n## 命令行执行宏\n\n在正常模式执行 `@a` 并不是宏命令调用的唯一方式。你也可以在命令行执行 `：normal @a` 。`：normal` 会将任何用户添加的参数作为命令去执行。例如添加 `@a`，和在 normal mode 执行 `@a` 的效果是一样的。\n\n`:normal` 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 `：2,3 normal @a`。\n\n## 在多个文件中执行宏命令\n\n假如你有多个 `.txt` 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是`0W~j`(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？\n\n第一个文件:\n\n```\n## savory.txt\na. cheddar jalapeno donut\nb. mac n cheese donut\nc. fried dumpling\n```\n\n第二个文件:\n\n```\n## sweet.txt\na. chocolate donut\nb. chocolate pancake\nc. powdered sugar donut\n```\n\n第三个文件:\n\n```\n## plain.txt\na. wheat bread\nb. plain donut\n```\n\n你可以这么做:\n- `:args *.txt` 查找当前目录下的所有 `.txt` 文件。\n- `:argdo g/donut/normal @a` 在 `:args` 中包含的每一个文件里执行一个全局命令 `g/donut/normal @a`。\n- `:argdo update` 在 `:args` 中包含的每一个文件里执行 `update` 命令,保存修改后的内容。\n\n也许你对全局命令 `:g/donut/normal @a` 不是很了解，该命令会执行 `/donut/`搜索命令，然后在所有匹配的行中执行`normal @a` 命令。我会在后面的章节中介绍全局命令。\n\n## 递归执行宏命令\n\n你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏寄存器来实现。假如你有如下文本，你希望改变第一个单词的大小写：\n\n```\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\n```\n\n如下命令会递归地执行:\n\n```\nqaqqa0W~j@aq\n```\n\n上面命令的分解如下：\n\n- `qaq` 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。\n- `qa` 开始录入宏命令到寄存器 “a”。\n- `0` 移动到行首。\n- `W` 移动到下一个单词。\n- `~` 改变光标选中的单词的大小写。\n- `j` 移动到下一行。\n- `@a` 执行宏命令 “a”。当你记录该宏命令时，`@a` 应该是空白的，因为你刚刚调用了 `qaq`。\n- `q` 停止记录。\n\n现在，让我们调用 `@a` 来查看 Vim 如何递归的调用该宏命令。\n\n宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 `j` 命令时，发现已经没有下一行了，就会停止执行。\n\n## 增添一个已知宏\n\n如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来想该寄存器中添加内容。同样的，为了在寄存器\"a\"中添加更多的操作，你也可以使用大写字母\"A\"。\n\n假设寄存器a中已经存储了这个宏命令:`qa0W~q`(该宏命令将某行的第二个词组的头一个字母执行改变大小写操作)，假设你想在这个基础上添加一些操作命令序列，使得每一行末尾添加一个句点，运行：\n\n```\nqAA.<esc>q\n```\n\n分解如下:\n- `qA` 开始在寄存器 “A” 中记录宏命令。\n- `A.<esc>` 在行的末尾加上一个句点(这里的`A`是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。\n- `q` 停止记录宏命令。\n\n现在，当你执行`@a`时，它不仅将第二个词组的首字母转变大小写，同时还在行尾添加一个句点。\n\n## 修改一个已知宏\n\n如果想在一个宏的中间添加新的操作该怎么办呢？\n\n假设您在寄存器a中已经存有一个宏命令`0W~A.<Esc>`，即改变首字母大小写，并在行尾添加句号。如果您想在改变首字母大小写和行尾添加句号之间，在单词\"dount\"前面加入\"deep fried\"。（因为唯一比甜甜圈好的东西就是炸甜甜圈）。\n\n我会重新使用上一节使用过的文本:\n```\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\n```\n\n首先，让我们通过 `:put a` 调用一个已经录制好的宏命令（假设你上一节中保存在寄存器a中的宏命令还在）：\n\n```\n0W~A.^[\n```\n\n`^[` 是什么意思呢？不记得了吗，你之前执行过 `0W~A.<esc>`。 `^[` 是 Vim 的 **内部指令**，表示 `<esc>`。通过这些指定的特殊键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 `<esc>`，`<backspace>`，`<enter>`。还有一些其他的键值组合，但这不是本章的内容。\n\n回到宏命令，在改变大小写之后的键后面（`~`），让我们添加（`$`）来移动光标到行末，回退一个单词（`b`），进入插入模式（`i`），输入\"deep fried \" （别忽略\"fried \"后面的这个空格），之后退出插入模式（`<esc>`）。\n\n完整的命令如下:\n\n```\n0W~$bideep fried <esc>A.^[\n```\n\n这里有一个问题，Vim 不能理解 `<esc>`。您不能依葫芦画瓢输入\"<Esc>\"，所以你需要将`<Esc>`写成内部代码的形式。在插入模式，在按下`<esc>`后按下 `Ctrl-v`，Vim 会打印 `^[`。 `Ctrl-v` 是一个插入模式的操作符，可以逐字地插入一个非数字字符。你的宏命令应该如下:\n\n```\n0W~$bideep fried ^[A.^[\n```\n\n为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知命名寄存器中添加一个新条目的方式来实现。在一行的行首，执行 `\"ay$`，使用寄存器 \"a\"来存储复制的文本。\n\n现在，但你执行 `@a` 时，你的宏命令会自动改变第一个单词的大小写，在\"donut\"前面添加\"deep fried \"，之后在行末添加“.”。\n\n另一个修改宏命令的方式是通过命令行表达式。执行 `:let @a=\"`，之后执行 `Ctrl-r Ctrl-r a`，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（`\"`）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 `Ctrl-v`。\n\n## 拷贝宏\n\n你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 `:let @z = @a` 将寄存器\"a\" 中的命令拷贝到寄存器\"z\"。 `@a` 表示寄存器“a”中存储的内容，你现在执行 `@z`，将会执行和 `@a` 一样的指令。\n\n我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。\n\n## 串行宏和并行宏\n\nVim 可以连续和同时运行宏命令，假设你有如下的文本：\n\n```\nimport { FUNC1 } from \"library1\";\nimport { FUNC2 } from \"library2\";\nimport { FUNC3 } from \"library3\";\nimport { FUNC4 } from \"library4\";\nimport { FUNC5 } from \"library5\";\n```\n\n假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：\n\n```\nqa0f{gui{jq\n```\n\n分解如下：\n- `qa` 开始记录宏命令到 “a” 寄存器。\n- `0`移动到第一行。\n- `f{` 查找第一个 “{” 字符。\n- `gui{` 把括号内的文本（`i{`）变为小写（`gu`）。\n- `j` 移动到下一行。\n- `q` 停止记录宏命令。\n\n现在，执行 `99@a` 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？\n\n```\nimport { FUNC1 } from \"library1\";\nimport { FUNC2 } from \"library2\";\nimport { FUNC3 } from \"library3\";\nimport foo from \"bar\";\nimport { FUNC4 } from \"library4\";\nimport { FUNC5 } from \"library5\";\n```\n\n执行 `99@a`，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时`f{`命令会遇到错误而停止，当宏串行执行时就会发生这样的情况。当然，你仍然可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？\n\n你可以并行地执行宏命令。\n\n如本章前面所说，可以使用 `:normal` 去执行宏命令，（例如： `:3,5 normal @a` 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 `:1,$ normal @a`，会在所有除了包含有 “foo” 的行执行，而且它不会出错。\n\n尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（`1,$`）每一行执行 `@a` 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。\n\n## 聪明地学习宏命令\n\n你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。\n\n刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。\n\n使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它(`qf`)。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的(`qn`)。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令默认寄存器，因为执行 `qq` 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 `qa` 到 `qb` 再到 `qc`。\n\n去寻找最适合你的方法吧。\n","source":"_posts/Vim/ch09_macros.md","raw":"---\ntitle: VIM-宏命令\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第09章 宏命令\n\n在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。\n\n在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。\n\n## 基本宏命令\n\n宏命令的基本语法如下：\n\n```\nqa                     开始记录动作到寄存器 a\nq (while recording)    停止记录\n```\n\n你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：\n\n```\n@a    Execute macro from register a\n@@    Execute the last executed macros\n```\n\n假设你有如下的文本，你打算将每一行中的所有字母都变为大写。\n\n```\nhello\nvim\nmacros\nare\nawesome\n```\n\n将你的光标移动到 “hello” 栏的行首，并执行：\n\n```\nqa0gU$jq\n```\n\n上面命令的分解如下：\n- `qa` 开始记录一个宏定义并存储在 a 寄存器。\n- `0` 移动到行首。\n- `gU$` 将从光标到行尾的字母变为大写。\n- `j` 移动到下一行。\n- `q` 停止记录。\n\n调用 `@a` 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 `3@a` 去执行 `a` 命令3次。你也可以执行 `3@@` 去执行上一次执行过的宏命令3次。\n\n## 安全保护\n\n在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：\n\n```\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\n```\n\n你想将每一行的第一个词变为大写，你可以使用如下的宏命令：\n\n```\nqa0W~jq\n```\n\n上面命令的分解如下：\n- `qa` 开始记录一个宏定义并存储在 a 寄存器。\n- `0` 移动到行首。\n- `W` 移动到下一个单词。\n- `~` 将光标选中的单词变为大写。\n- `j` 移动到下一行。\n- `q` 停止记录。\n\n我喜欢对宏命令进行超过所需次数的调用，所以我通常使用 `99@a` 命令去执行该宏命令99次。使用该命令，Vim并不会真正执行这个宏99次，当 Vim 到达最后一行执行`j`时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。\n\n实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。\n\n## 命令行执行宏\n\n在正常模式执行 `@a` 并不是宏命令调用的唯一方式。你也可以在命令行执行 `：normal @a` 。`：normal` 会将任何用户添加的参数作为命令去执行。例如添加 `@a`，和在 normal mode 执行 `@a` 的效果是一样的。\n\n`:normal` 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 `：2,3 normal @a`。\n\n## 在多个文件中执行宏命令\n\n假如你有多个 `.txt` 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是`0W~j`(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？\n\n第一个文件:\n\n```\n## savory.txt\na. cheddar jalapeno donut\nb. mac n cheese donut\nc. fried dumpling\n```\n\n第二个文件:\n\n```\n## sweet.txt\na. chocolate donut\nb. chocolate pancake\nc. powdered sugar donut\n```\n\n第三个文件:\n\n```\n## plain.txt\na. wheat bread\nb. plain donut\n```\n\n你可以这么做:\n- `:args *.txt` 查找当前目录下的所有 `.txt` 文件。\n- `:argdo g/donut/normal @a` 在 `:args` 中包含的每一个文件里执行一个全局命令 `g/donut/normal @a`。\n- `:argdo update` 在 `:args` 中包含的每一个文件里执行 `update` 命令,保存修改后的内容。\n\n也许你对全局命令 `:g/donut/normal @a` 不是很了解，该命令会执行 `/donut/`搜索命令，然后在所有匹配的行中执行`normal @a` 命令。我会在后面的章节中介绍全局命令。\n\n## 递归执行宏命令\n\n你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏寄存器来实现。假如你有如下文本，你希望改变第一个单词的大小写：\n\n```\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\n```\n\n如下命令会递归地执行:\n\n```\nqaqqa0W~j@aq\n```\n\n上面命令的分解如下：\n\n- `qaq` 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。\n- `qa` 开始录入宏命令到寄存器 “a”。\n- `0` 移动到行首。\n- `W` 移动到下一个单词。\n- `~` 改变光标选中的单词的大小写。\n- `j` 移动到下一行。\n- `@a` 执行宏命令 “a”。当你记录该宏命令时，`@a` 应该是空白的，因为你刚刚调用了 `qaq`。\n- `q` 停止记录。\n\n现在，让我们调用 `@a` 来查看 Vim 如何递归的调用该宏命令。\n\n宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 `j` 命令时，发现已经没有下一行了，就会停止执行。\n\n## 增添一个已知宏\n\n如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来想该寄存器中添加内容。同样的，为了在寄存器\"a\"中添加更多的操作，你也可以使用大写字母\"A\"。\n\n假设寄存器a中已经存储了这个宏命令:`qa0W~q`(该宏命令将某行的第二个词组的头一个字母执行改变大小写操作)，假设你想在这个基础上添加一些操作命令序列，使得每一行末尾添加一个句点，运行：\n\n```\nqAA.<esc>q\n```\n\n分解如下:\n- `qA` 开始在寄存器 “A” 中记录宏命令。\n- `A.<esc>` 在行的末尾加上一个句点(这里的`A`是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。\n- `q` 停止记录宏命令。\n\n现在，当你执行`@a`时，它不仅将第二个词组的首字母转变大小写，同时还在行尾添加一个句点。\n\n## 修改一个已知宏\n\n如果想在一个宏的中间添加新的操作该怎么办呢？\n\n假设您在寄存器a中已经存有一个宏命令`0W~A.<Esc>`，即改变首字母大小写，并在行尾添加句号。如果您想在改变首字母大小写和行尾添加句号之间，在单词\"dount\"前面加入\"deep fried\"。（因为唯一比甜甜圈好的东西就是炸甜甜圈）。\n\n我会重新使用上一节使用过的文本:\n```\na. chocolate donut\nb. mochi donut\nc. powdered sugar donut\nd. plain donut\n```\n\n首先，让我们通过 `:put a` 调用一个已经录制好的宏命令（假设你上一节中保存在寄存器a中的宏命令还在）：\n\n```\n0W~A.^[\n```\n\n`^[` 是什么意思呢？不记得了吗，你之前执行过 `0W~A.<esc>`。 `^[` 是 Vim 的 **内部指令**，表示 `<esc>`。通过这些指定的特殊键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 `<esc>`，`<backspace>`，`<enter>`。还有一些其他的键值组合，但这不是本章的内容。\n\n回到宏命令，在改变大小写之后的键后面（`~`），让我们添加（`$`）来移动光标到行末，回退一个单词（`b`），进入插入模式（`i`），输入\"deep fried \" （别忽略\"fried \"后面的这个空格），之后退出插入模式（`<esc>`）。\n\n完整的命令如下:\n\n```\n0W~$bideep fried <esc>A.^[\n```\n\n这里有一个问题，Vim 不能理解 `<esc>`。您不能依葫芦画瓢输入\"<Esc>\"，所以你需要将`<Esc>`写成内部代码的形式。在插入模式，在按下`<esc>`后按下 `Ctrl-v`，Vim 会打印 `^[`。 `Ctrl-v` 是一个插入模式的操作符，可以逐字地插入一个非数字字符。你的宏命令应该如下:\n\n```\n0W~$bideep fried ^[A.^[\n```\n\n为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知命名寄存器中添加一个新条目的方式来实现。在一行的行首，执行 `\"ay$`，使用寄存器 \"a\"来存储复制的文本。\n\n现在，但你执行 `@a` 时，你的宏命令会自动改变第一个单词的大小写，在\"donut\"前面添加\"deep fried \"，之后在行末添加“.”。\n\n另一个修改宏命令的方式是通过命令行表达式。执行 `:let @a=\"`，之后执行 `Ctrl-r Ctrl-r a`，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（`\"`）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 `Ctrl-v`。\n\n## 拷贝宏\n\n你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 `:let @z = @a` 将寄存器\"a\" 中的命令拷贝到寄存器\"z\"。 `@a` 表示寄存器“a”中存储的内容，你现在执行 `@z`，将会执行和 `@a` 一样的指令。\n\n我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。\n\n## 串行宏和并行宏\n\nVim 可以连续和同时运行宏命令，假设你有如下的文本：\n\n```\nimport { FUNC1 } from \"library1\";\nimport { FUNC2 } from \"library2\";\nimport { FUNC3 } from \"library3\";\nimport { FUNC4 } from \"library4\";\nimport { FUNC5 } from \"library5\";\n```\n\n假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：\n\n```\nqa0f{gui{jq\n```\n\n分解如下：\n- `qa` 开始记录宏命令到 “a” 寄存器。\n- `0`移动到第一行。\n- `f{` 查找第一个 “{” 字符。\n- `gui{` 把括号内的文本（`i{`）变为小写（`gu`）。\n- `j` 移动到下一行。\n- `q` 停止记录宏命令。\n\n现在，执行 `99@a` 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？\n\n```\nimport { FUNC1 } from \"library1\";\nimport { FUNC2 } from \"library2\";\nimport { FUNC3 } from \"library3\";\nimport foo from \"bar\";\nimport { FUNC4 } from \"library4\";\nimport { FUNC5 } from \"library5\";\n```\n\n执行 `99@a`，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时`f{`命令会遇到错误而停止，当宏串行执行时就会发生这样的情况。当然，你仍然可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？\n\n你可以并行地执行宏命令。\n\n如本章前面所说，可以使用 `:normal` 去执行宏命令，（例如： `:3,5 normal @a` 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 `:1,$ normal @a`，会在所有除了包含有 “foo” 的行执行，而且它不会出错。\n\n尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（`1,$`）每一行执行 `@a` 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。\n\n## 聪明地学习宏命令\n\n你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。\n\n刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。\n\n使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它(`qf`)。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的(`qn`)。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令默认寄存器，因为执行 `qq` 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 `qa` 到 `qb` 再到 `qc`。\n\n去寻找最适合你的方法吧。\n","slug":"Vim/ch09_macros","published":1,"updated":"2022-08-28T07:38:59.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1w001lscvmhrjf9lji","content":"<h1 id=\"第09章-宏命令\"><a href=\"#第09章-宏命令\" class=\"headerlink\" title=\"第09章 宏命令\"></a>第09章 宏命令</h1><p>在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。</p>\n<p>在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。</p>\n<h2 id=\"基本宏命令\"><a href=\"#基本宏命令\" class=\"headerlink\" title=\"基本宏命令\"></a>基本宏命令</h2><p>宏命令的基本语法如下：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs perl\">qa                     开始记录动作到寄存器 a<br><span class=\"hljs-string\">q (while recording)</span>    停止记录<br></code></pre></td></tr></table></figure>\n\n<p>你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">@<span class=\"hljs-keyword\">a</span>    Execute macro <span class=\"hljs-built_in\">from</span> register <span class=\"hljs-keyword\">a</span><br>@@    Execute <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">last</span> executed macros<br></code></pre></td></tr></table></figure>\n\n<p>假设你有如下的文本，你打算将每一行中的所有字母都变为大写。</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello</span><br><span class=\"hljs-attribute\">vim</span><br><span class=\"hljs-attribute\">macros</span><br><span class=\"hljs-attribute\">are</span><br><span class=\"hljs-attribute\">awesome</span><br></code></pre></td></tr></table></figure>\n\n<p>将你的光标移动到 “hello” 栏的行首，并执行：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">qa0<span class=\"hljs-built_in\">gU</span><span class=\"hljs-variable\">$jq</span><br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>\n<li><code>0</code> 移动到行首。</li>\n<li><code>gU$</code> 将从光标到行尾的字母变为大写。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>q</code> 停止记录。</li>\n</ul>\n<p>调用 <code>@a</code> 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 <code>3@a</code> 去执行 <code>a</code> 命令3次。你也可以执行 <code>3@@</code> 去执行上一次执行过的宏命令3次。</p>\n<h2 id=\"安全保护\"><a href=\"#安全保护\" class=\"headerlink\" title=\"安全保护\"></a>安全保护</h2><p>在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span>. chocolate donut<br><span class=\"hljs-selector-tag\">b</span>. mochi donut<br>c. powdered sugar donut<br>d. plain donut<br></code></pre></td></tr></table></figure>\n\n<p>你想将每一行的第一个词变为大写，你可以使用如下的宏命令：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">qa0W~jq<br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>\n<li><code>0</code> 移动到行首。</li>\n<li><code>W</code> 移动到下一个单词。</li>\n<li><code>~</code> 将光标选中的单词变为大写。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>q</code> 停止记录。</li>\n</ul>\n<p>我喜欢对宏命令进行超过所需次数的调用，所以我通常使用 <code>99@a</code> 命令去执行该宏命令99次。使用该命令，Vim并不会真正执行这个宏99次，当 Vim 到达最后一行执行<code>j</code>时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。</p>\n<p>实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。</p>\n<h2 id=\"命令行执行宏\"><a href=\"#命令行执行宏\" class=\"headerlink\" title=\"命令行执行宏\"></a>命令行执行宏</h2><p>在正常模式执行 <code>@a</code> 并不是宏命令调用的唯一方式。你也可以在命令行执行 <code>：normal @a</code> 。<code>：normal</code> 会将任何用户添加的参数作为命令去执行。例如添加 <code>@a</code>，和在 normal mode 执行 <code>@a</code> 的效果是一样的。</p>\n<p><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。</p>\n<h2 id=\"在多个文件中执行宏命令\"><a href=\"#在多个文件中执行宏命令\" class=\"headerlink\" title=\"在多个文件中执行宏命令\"></a>在多个文件中执行宏命令</h2><p>假如你有多个 <code>.txt</code> 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是<code>0W~j</code>(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？</p>\n<p>第一个文件:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-comment\">## savory.txt</span><br>a. cheddar <span class=\"hljs-keyword\">jalapeno </span>donut<br><span class=\"hljs-keyword\">b. </span>mac n cheese donut<br>c. fried dumpling<br></code></pre></td></tr></table></figure>\n\n<p>第二个文件:</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">## sweet.txt<br>a. chocolate donut<br>b. chocolate pancake<br>c. powdered sugar donut<br></code></pre></td></tr></table></figure>\n\n<p>第三个文件:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-comment\">## plain.txt</span><br>a. wheat <span class=\"hljs-keyword\">bread</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">b. </span>plain donut<br></code></pre></td></tr></table></figure>\n\n<p>你可以这么做:</p>\n<ul>\n<li><code>:args *.txt</code> 查找当前目录下的所有 <code>.txt</code> 文件。</li>\n<li><code>:argdo g/donut/normal @a</code> 在 <code>:args</code> 中包含的每一个文件里执行一个全局命令 <code>g/donut/normal @a</code>。</li>\n<li><code>:argdo update</code> 在 <code>:args</code> 中包含的每一个文件里执行 <code>update</code> 命令,保存修改后的内容。</li>\n</ul>\n<p>也许你对全局命令 <code>:g/donut/normal @a</code> 不是很了解，该命令会执行 <code>/donut/</code>搜索命令，然后在所有匹配的行中执行<code>normal @a</code> 命令。我会在后面的章节中介绍全局命令。</p>\n<h2 id=\"递归执行宏命令\"><a href=\"#递归执行宏命令\" class=\"headerlink\" title=\"递归执行宏命令\"></a>递归执行宏命令</h2><p>你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏寄存器来实现。假如你有如下文本，你希望改变第一个单词的大小写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span>. chocolate donut<br><span class=\"hljs-selector-tag\">b</span>. mochi donut<br>c. powdered sugar donut<br>d. plain donut<br></code></pre></td></tr></table></figure>\n\n<p>如下命令会递归地执行:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">qaqqa0W~<span class=\"hljs-symbol\">j@</span>aq<br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>qaq</code> 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。</li>\n<li><code>qa</code> 开始录入宏命令到寄存器 “a”。</li>\n<li><code>0</code> 移动到行首。</li>\n<li><code>W</code> 移动到下一个单词。</li>\n<li><code>~</code> 改变光标选中的单词的大小写。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>@a</code> 执行宏命令 “a”。当你记录该宏命令时，<code>@a</code> 应该是空白的，因为你刚刚调用了 <code>qaq</code>。</li>\n<li><code>q</code> 停止记录。</li>\n</ul>\n<p>现在，让我们调用 <code>@a</code> 来查看 Vim 如何递归的调用该宏命令。</p>\n<p>宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 <code>j</code> 命令时，发现已经没有下一行了，就会停止执行。</p>\n<h2 id=\"增添一个已知宏\"><a href=\"#增添一个已知宏\" class=\"headerlink\" title=\"增添一个已知宏\"></a>增添一个已知宏</h2><p>如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来想该寄存器中添加内容。同样的，为了在寄存器”a”中添加更多的操作，你也可以使用大写字母”A”。</p>\n<p>假设寄存器a中已经存储了这个宏命令:<code>qa0W~q</code>(该宏命令将某行的第二个词组的头一个字母执行改变大小写操作)，假设你想在这个基础上添加一些操作命令序列，使得每一行末尾添加一个句点，运行：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">qAA.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">esc</span>&gt;</span>q<br></code></pre></td></tr></table></figure>\n\n<p>分解如下:</p>\n<ul>\n<li><code>qA</code> 开始在寄存器 “A” 中记录宏命令。</li>\n<li><code>A.&lt;esc&gt;</code> 在行的末尾加上一个句点(这里的<code>A</code>是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。</li>\n<li><code>q</code> 停止记录宏命令。</li>\n</ul>\n<p>现在，当你执行<code>@a</code>时，它不仅将第二个词组的首字母转变大小写，同时还在行尾添加一个句点。</p>\n<h2 id=\"修改一个已知宏\"><a href=\"#修改一个已知宏\" class=\"headerlink\" title=\"修改一个已知宏\"></a>修改一个已知宏</h2><p>如果想在一个宏的中间添加新的操作该怎么办呢？</p>\n<p>假设您在寄存器a中已经存有一个宏命令<code>0W~A.&lt;Esc&gt;</code>，即改变首字母大小写，并在行尾添加句号。如果您想在改变首字母大小写和行尾添加句号之间，在单词”dount”前面加入”deep fried”。（因为唯一比甜甜圈好的东西就是炸甜甜圈）。</p>\n<p>我会重新使用上一节使用过的文本:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span>. chocolate donut<br><span class=\"hljs-selector-tag\">b</span>. mochi donut<br>c. powdered sugar donut<br>d. plain donut<br></code></pre></td></tr></table></figure>\n\n<p>首先，让我们通过 <code>:put a</code> 调用一个已经录制好的宏命令（假设你上一节中保存在寄存器a中的宏命令还在）：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\"><span class=\"hljs-number\">0</span>W~<span class=\"hljs-keyword\">A</span>.^[<br></code></pre></td></tr></table></figure>\n\n<p><code>^[</code> 是什么意思呢？不记得了吗，你之前执行过 <code>0W~A.&lt;esc&gt;</code>。 <code>^[</code> 是 Vim 的 <strong>内部指令</strong>，表示 <code>&lt;esc&gt;</code>。通过这些指定的特殊键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 <code>&lt;esc&gt;</code>，<code>&lt;backspace&gt;</code>，<code>&lt;enter&gt;</code>。还有一些其他的键值组合，但这不是本章的内容。</p>\n<p>回到宏命令，在改变大小写之后的键后面（<code>~</code>），让我们添加（<code>$</code>）来移动光标到行末，回退一个单词（<code>b</code>），进入插入模式（<code>i</code>），输入”deep fried “ （别忽略”fried “后面的这个空格），之后退出插入模式（<code>&lt;esc&gt;</code>）。</p>\n<p>完整的命令如下:</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\"><span class=\"hljs-number\">0</span><span class=\"hljs-keyword\">W</span>~<span class=\"hljs-variable\">$bideep</span> fried &lt;esc&gt;A.^[<br></code></pre></td></tr></table></figure>\n\n<p>这里有一个问题，Vim 不能理解 <code>&lt;esc&gt;</code>。您不能依葫芦画瓢输入”<Esc>“，所以你需要将<code>&lt;Esc&gt;</code>写成内部代码的形式。在插入模式，在按下<code>&lt;esc&gt;</code>后按下 <code>Ctrl-v</code>，Vim 会打印 <code>^[</code>。 <code>Ctrl-v</code> 是一个插入模式的操作符，可以逐字地插入一个非数字字符。你的宏命令应该如下:</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\"><span class=\"hljs-number\">0</span><span class=\"hljs-keyword\">W</span>~<span class=\"hljs-variable\">$bideep</span> fried ^[A.^[<br></code></pre></td></tr></table></figure>\n\n<p>为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知命名寄存器中添加一个新条目的方式来实现。在一行的行首，执行 <code>&quot;ay$</code>，使用寄存器 “a”来存储复制的文本。</p>\n<p>现在，但你执行 <code>@a</code> 时，你的宏命令会自动改变第一个单词的大小写，在”donut”前面添加”deep fried “，之后在行末添加“.”。</p>\n<p>另一个修改宏命令的方式是通过命令行表达式。执行 <code>:let @a=&quot;</code>，之后执行 <code>Ctrl-r Ctrl-r a</code>，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（<code>&quot;</code>）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 <code>Ctrl-v</code>。</p>\n<h2 id=\"拷贝宏\"><a href=\"#拷贝宏\" class=\"headerlink\" title=\"拷贝宏\"></a>拷贝宏</h2><p>你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 <code>:let @z = @a</code> 将寄存器”a” 中的命令拷贝到寄存器”z”。 <code>@a</code> 表示寄存器“a”中存储的内容，你现在执行 <code>@z</code>，将会执行和 <code>@a</code> 一样的指令。</p>\n<p>我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。</p>\n<h2 id=\"串行宏和并行宏\"><a href=\"#串行宏和并行宏\" class=\"headerlink\" title=\"串行宏和并行宏\"></a>串行宏和并行宏</h2><p>Vim 可以连续和同时运行宏命令，假设你有如下的文本：</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs capnproto\"><span class=\"hljs-keyword\">import</span> &#123; FUNC1 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library1&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library2&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC3 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library3&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC4 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library4&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC5 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library5&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">qa0f</span>&#123;<span class=\"hljs-keyword\">gui</span>&#123;jq<br></code></pre></td></tr></table></figure>\n\n<p>分解如下：</p>\n<ul>\n<li><code>qa</code> 开始记录宏命令到 “a” 寄存器。</li>\n<li><code>0</code>移动到第一行。</li>\n<li><code>f&#123;</code> 查找第一个 “{” 字符。</li>\n<li><code>gui&#123;</code> 把括号内的文本（<code>i&#123;</code>）变为小写（<code>gu</code>）。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>q</code> 停止记录宏命令。</li>\n</ul>\n<p>现在，执行 <code>99@a</code> 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs capnproto\"><span class=\"hljs-keyword\">import</span> &#123; FUNC1 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library1&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library2&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC3 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library3&quot;</span>;<br><span class=\"hljs-keyword\">import</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;bar&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC4 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library4&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC5 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library5&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>执行 <code>99@a</code>，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时<code>f&#123;</code>命令会遇到错误而停止，当宏串行执行时就会发生这样的情况。当然，你仍然可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？</p>\n<p>你可以并行地执行宏命令。</p>\n<p>如本章前面所说，可以使用 <code>:normal</code> 去执行宏命令，（例如： <code>:3,5 normal @a</code> 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 <code>:1,$ normal @a</code>，会在所有除了包含有 “foo” 的行执行，而且它不会出错。</p>\n<p>尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（<code>1,$</code>）每一行执行 <code>@a</code> 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。</p>\n<h2 id=\"聪明地学习宏命令\"><a href=\"#聪明地学习宏命令\" class=\"headerlink\" title=\"聪明地学习宏命令\"></a>聪明地学习宏命令</h2><p>你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。</p>\n<p>刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。</p>\n<p>使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它(<code>qf</code>)。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的(<code>qn</code>)。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令默认寄存器，因为执行 <code>qq</code> 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 <code>qa</code> 到 <code>qb</code> 再到 <code>qc</code>。</p>\n<p>去寻找最适合你的方法吧。</p>\n","site":{"data":{}},"wordcount":5187,"excerpt":"","more":"<h1 id=\"第09章-宏命令\"><a href=\"#第09章-宏命令\" class=\"headerlink\" title=\"第09章 宏命令\"></a>第09章 宏命令</h1><p>在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。</p>\n<p>在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。</p>\n<h2 id=\"基本宏命令\"><a href=\"#基本宏命令\" class=\"headerlink\" title=\"基本宏命令\"></a>基本宏命令</h2><p>宏命令的基本语法如下：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">qa                     开始记录动作到寄存器 a<br><span class=\"hljs-string\">q (while recording)</span>    停止记录<br></code></pre></td></tr></table></figure>\n\n<p>你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">@<span class=\"hljs-keyword\">a</span>    Execute macro <span class=\"hljs-built_in\">from</span> register <span class=\"hljs-keyword\">a</span><br>@@    Execute <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">last</span> executed macros<br></code></pre></td></tr></table></figure>\n\n<p>假设你有如下的文本，你打算将每一行中的所有字母都变为大写。</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello</span><br><span class=\"hljs-attribute\">vim</span><br><span class=\"hljs-attribute\">macros</span><br><span class=\"hljs-attribute\">are</span><br><span class=\"hljs-attribute\">awesome</span><br></code></pre></td></tr></table></figure>\n\n<p>将你的光标移动到 “hello” 栏的行首，并执行：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">qa0<span class=\"hljs-built_in\">gU</span><span class=\"hljs-variable\">$jq</span><br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>\n<li><code>0</code> 移动到行首。</li>\n<li><code>gU$</code> 将从光标到行尾的字母变为大写。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>q</code> 停止记录。</li>\n</ul>\n<p>调用 <code>@a</code> 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 <code>3@a</code> 去执行 <code>a</code> 命令3次。你也可以执行 <code>3@@</code> 去执行上一次执行过的宏命令3次。</p>\n<h2 id=\"安全保护\"><a href=\"#安全保护\" class=\"headerlink\" title=\"安全保护\"></a>安全保护</h2><p>在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span>. chocolate donut<br><span class=\"hljs-selector-tag\">b</span>. mochi donut<br>c. powdered sugar donut<br>d. plain donut<br></code></pre></td></tr></table></figure>\n\n<p>你想将每一行的第一个词变为大写，你可以使用如下的宏命令：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">qa0W~jq<br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>\n<li><code>0</code> 移动到行首。</li>\n<li><code>W</code> 移动到下一个单词。</li>\n<li><code>~</code> 将光标选中的单词变为大写。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>q</code> 停止记录。</li>\n</ul>\n<p>我喜欢对宏命令进行超过所需次数的调用，所以我通常使用 <code>99@a</code> 命令去执行该宏命令99次。使用该命令，Vim并不会真正执行这个宏99次，当 Vim 到达最后一行执行<code>j</code>时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。</p>\n<p>实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。</p>\n<h2 id=\"命令行执行宏\"><a href=\"#命令行执行宏\" class=\"headerlink\" title=\"命令行执行宏\"></a>命令行执行宏</h2><p>在正常模式执行 <code>@a</code> 并不是宏命令调用的唯一方式。你也可以在命令行执行 <code>：normal @a</code> 。<code>：normal</code> 会将任何用户添加的参数作为命令去执行。例如添加 <code>@a</code>，和在 normal mode 执行 <code>@a</code> 的效果是一样的。</p>\n<p><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。</p>\n<h2 id=\"在多个文件中执行宏命令\"><a href=\"#在多个文件中执行宏命令\" class=\"headerlink\" title=\"在多个文件中执行宏命令\"></a>在多个文件中执行宏命令</h2><p>假如你有多个 <code>.txt</code> 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是<code>0W~j</code>(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？</p>\n<p>第一个文件:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-comment\">## savory.txt</span><br>a. cheddar <span class=\"hljs-keyword\">jalapeno </span>donut<br><span class=\"hljs-keyword\">b. </span>mac n cheese donut<br>c. fried dumpling<br></code></pre></td></tr></table></figure>\n\n<p>第二个文件:</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">## sweet.txt<br>a. chocolate donut<br>b. chocolate pancake<br>c. powdered sugar donut<br></code></pre></td></tr></table></figure>\n\n<p>第三个文件:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-comment\">## plain.txt</span><br>a. wheat <span class=\"hljs-keyword\">bread</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">b. </span>plain donut<br></code></pre></td></tr></table></figure>\n\n<p>你可以这么做:</p>\n<ul>\n<li><code>:args *.txt</code> 查找当前目录下的所有 <code>.txt</code> 文件。</li>\n<li><code>:argdo g/donut/normal @a</code> 在 <code>:args</code> 中包含的每一个文件里执行一个全局命令 <code>g/donut/normal @a</code>。</li>\n<li><code>:argdo update</code> 在 <code>:args</code> 中包含的每一个文件里执行 <code>update</code> 命令,保存修改后的内容。</li>\n</ul>\n<p>也许你对全局命令 <code>:g/donut/normal @a</code> 不是很了解，该命令会执行 <code>/donut/</code>搜索命令，然后在所有匹配的行中执行<code>normal @a</code> 命令。我会在后面的章节中介绍全局命令。</p>\n<h2 id=\"递归执行宏命令\"><a href=\"#递归执行宏命令\" class=\"headerlink\" title=\"递归执行宏命令\"></a>递归执行宏命令</h2><p>你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏寄存器来实现。假如你有如下文本，你希望改变第一个单词的大小写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span>. chocolate donut<br><span class=\"hljs-selector-tag\">b</span>. mochi donut<br>c. powdered sugar donut<br>d. plain donut<br></code></pre></td></tr></table></figure>\n\n<p>如下命令会递归地执行:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">qaqqa0W~<span class=\"hljs-symbol\">j@</span>aq<br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>qaq</code> 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。</li>\n<li><code>qa</code> 开始录入宏命令到寄存器 “a”。</li>\n<li><code>0</code> 移动到行首。</li>\n<li><code>W</code> 移动到下一个单词。</li>\n<li><code>~</code> 改变光标选中的单词的大小写。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>@a</code> 执行宏命令 “a”。当你记录该宏命令时，<code>@a</code> 应该是空白的，因为你刚刚调用了 <code>qaq</code>。</li>\n<li><code>q</code> 停止记录。</li>\n</ul>\n<p>现在，让我们调用 <code>@a</code> 来查看 Vim 如何递归的调用该宏命令。</p>\n<p>宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 <code>j</code> 命令时，发现已经没有下一行了，就会停止执行。</p>\n<h2 id=\"增添一个已知宏\"><a href=\"#增添一个已知宏\" class=\"headerlink\" title=\"增添一个已知宏\"></a>增添一个已知宏</h2><p>如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来想该寄存器中添加内容。同样的，为了在寄存器”a”中添加更多的操作，你也可以使用大写字母”A”。</p>\n<p>假设寄存器a中已经存储了这个宏命令:<code>qa0W~q</code>(该宏命令将某行的第二个词组的头一个字母执行改变大小写操作)，假设你想在这个基础上添加一些操作命令序列，使得每一行末尾添加一个句点，运行：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">qAA.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">esc</span>&gt;</span>q<br></code></pre></td></tr></table></figure>\n\n<p>分解如下:</p>\n<ul>\n<li><code>qA</code> 开始在寄存器 “A” 中记录宏命令。</li>\n<li><code>A.&lt;esc&gt;</code> 在行的末尾加上一个句点(这里的<code>A</code>是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。</li>\n<li><code>q</code> 停止记录宏命令。</li>\n</ul>\n<p>现在，当你执行<code>@a</code>时，它不仅将第二个词组的首字母转变大小写，同时还在行尾添加一个句点。</p>\n<h2 id=\"修改一个已知宏\"><a href=\"#修改一个已知宏\" class=\"headerlink\" title=\"修改一个已知宏\"></a>修改一个已知宏</h2><p>如果想在一个宏的中间添加新的操作该怎么办呢？</p>\n<p>假设您在寄存器a中已经存有一个宏命令<code>0W~A.&lt;Esc&gt;</code>，即改变首字母大小写，并在行尾添加句号。如果您想在改变首字母大小写和行尾添加句号之间，在单词”dount”前面加入”deep fried”。（因为唯一比甜甜圈好的东西就是炸甜甜圈）。</p>\n<p>我会重新使用上一节使用过的文本:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span>. chocolate donut<br><span class=\"hljs-selector-tag\">b</span>. mochi donut<br>c. powdered sugar donut<br>d. plain donut<br></code></pre></td></tr></table></figure>\n\n<p>首先，让我们通过 <code>:put a</code> 调用一个已经录制好的宏命令（假设你上一节中保存在寄存器a中的宏命令还在）：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\"><span class=\"hljs-number\">0</span>W~<span class=\"hljs-keyword\">A</span>.^[<br></code></pre></td></tr></table></figure>\n\n<p><code>^[</code> 是什么意思呢？不记得了吗，你之前执行过 <code>0W~A.&lt;esc&gt;</code>。 <code>^[</code> 是 Vim 的 <strong>内部指令</strong>，表示 <code>&lt;esc&gt;</code>。通过这些指定的特殊键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 <code>&lt;esc&gt;</code>，<code>&lt;backspace&gt;</code>，<code>&lt;enter&gt;</code>。还有一些其他的键值组合，但这不是本章的内容。</p>\n<p>回到宏命令，在改变大小写之后的键后面（<code>~</code>），让我们添加（<code>$</code>）来移动光标到行末，回退一个单词（<code>b</code>），进入插入模式（<code>i</code>），输入”deep fried “ （别忽略”fried “后面的这个空格），之后退出插入模式（<code>&lt;esc&gt;</code>）。</p>\n<p>完整的命令如下:</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\"><span class=\"hljs-number\">0</span><span class=\"hljs-keyword\">W</span>~<span class=\"hljs-variable\">$bideep</span> fried &lt;esc&gt;A.^[<br></code></pre></td></tr></table></figure>\n\n<p>这里有一个问题，Vim 不能理解 <code>&lt;esc&gt;</code>。您不能依葫芦画瓢输入”<Esc>“，所以你需要将<code>&lt;Esc&gt;</code>写成内部代码的形式。在插入模式，在按下<code>&lt;esc&gt;</code>后按下 <code>Ctrl-v</code>，Vim 会打印 <code>^[</code>。 <code>Ctrl-v</code> 是一个插入模式的操作符，可以逐字地插入一个非数字字符。你的宏命令应该如下:</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\"><span class=\"hljs-number\">0</span><span class=\"hljs-keyword\">W</span>~<span class=\"hljs-variable\">$bideep</span> fried ^[A.^[<br></code></pre></td></tr></table></figure>\n\n<p>为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知命名寄存器中添加一个新条目的方式来实现。在一行的行首，执行 <code>&quot;ay$</code>，使用寄存器 “a”来存储复制的文本。</p>\n<p>现在，但你执行 <code>@a</code> 时，你的宏命令会自动改变第一个单词的大小写，在”donut”前面添加”deep fried “，之后在行末添加“.”。</p>\n<p>另一个修改宏命令的方式是通过命令行表达式。执行 <code>:let @a=&quot;</code>，之后执行 <code>Ctrl-r Ctrl-r a</code>，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（<code>&quot;</code>）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 <code>Ctrl-v</code>。</p>\n<h2 id=\"拷贝宏\"><a href=\"#拷贝宏\" class=\"headerlink\" title=\"拷贝宏\"></a>拷贝宏</h2><p>你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 <code>:let @z = @a</code> 将寄存器”a” 中的命令拷贝到寄存器”z”。 <code>@a</code> 表示寄存器“a”中存储的内容，你现在执行 <code>@z</code>，将会执行和 <code>@a</code> 一样的指令。</p>\n<p>我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。</p>\n<h2 id=\"串行宏和并行宏\"><a href=\"#串行宏和并行宏\" class=\"headerlink\" title=\"串行宏和并行宏\"></a>串行宏和并行宏</h2><p>Vim 可以连续和同时运行宏命令，假设你有如下的文本：</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs capnproto\"><span class=\"hljs-keyword\">import</span> &#123; FUNC1 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library1&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library2&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC3 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library3&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC4 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library4&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC5 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library5&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">qa0f</span>&#123;<span class=\"hljs-keyword\">gui</span>&#123;jq<br></code></pre></td></tr></table></figure>\n\n<p>分解如下：</p>\n<ul>\n<li><code>qa</code> 开始记录宏命令到 “a” 寄存器。</li>\n<li><code>0</code>移动到第一行。</li>\n<li><code>f&#123;</code> 查找第一个 “{” 字符。</li>\n<li><code>gui&#123;</code> 把括号内的文本（<code>i&#123;</code>）变为小写（<code>gu</code>）。</li>\n<li><code>j</code> 移动到下一行。</li>\n<li><code>q</code> 停止记录宏命令。</li>\n</ul>\n<p>现在，执行 <code>99@a</code> 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs capnproto\"><span class=\"hljs-keyword\">import</span> &#123; FUNC1 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library1&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library2&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC3 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library3&quot;</span>;<br><span class=\"hljs-keyword\">import</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;bar&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC4 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library4&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; FUNC5 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;library5&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>执行 <code>99@a</code>，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时<code>f&#123;</code>命令会遇到错误而停止，当宏串行执行时就会发生这样的情况。当然，你仍然可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？</p>\n<p>你可以并行地执行宏命令。</p>\n<p>如本章前面所说，可以使用 <code>:normal</code> 去执行宏命令，（例如： <code>:3,5 normal @a</code> 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 <code>:1,$ normal @a</code>，会在所有除了包含有 “foo” 的行执行，而且它不会出错。</p>\n<p>尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（<code>1,$</code>）每一行执行 <code>@a</code> 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。</p>\n<h2 id=\"聪明地学习宏命令\"><a href=\"#聪明地学习宏命令\" class=\"headerlink\" title=\"聪明地学习宏命令\"></a>聪明地学习宏命令</h2><p>你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。</p>\n<p>刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。</p>\n<p>使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它(<code>qf</code>)。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的(<code>qn</code>)。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令默认寄存器，因为执行 <code>qq</code> 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 <code>qa</code> 到 <code>qb</code> 再到 <code>qc</code>。</p>\n<p>去寻找最适合你的方法吧。</p>\n"},{"title":"VIM-撤销","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第10章 撤销\n\n所有人都会犯各种各样的输入错误。因此对于任何一个现代的软件来说，撤销都是一个很基本的功能。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持存取不同的文本形态，让你能控制你输入的所有文本。在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。 \n\n## 撤销(undo)，重做和行撤销(UNDO)\n\n对于一个基本的 undo 操作，你可以执行 `u` 或者 `:undo`。\n\n假设你有如下文本(注意\"one\"下面有一个空行)：\n\n```\none\n\n```\n\n然后添加另一个文本：\n\n```\none\ntwo\n```\n\n如果你执行 `u`，Vim 会删除 “two”。\n\nVim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。\n\n要取消上一次的撤销，可以执行 `Ctrl-r` 或者 `:redo`。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 `Ctrl-r` 来恢复被删除掉的文本。\n\nVim 也有另一个命令 `U` 可以实现 行撤销 (UNDO) 的功能，执行这个命令会撤销所有最新的修改。\n\n那么，`U` 和 `u` 的区别是什么呢？首先，`U` 会删除 *最近修改的行中所有的* 的修改，而 `u` 一次仅删除一次修改。 其次，执行`u` 不会被算作一次修改操作，而执行 `U` 则会被算作一次修改。\n\n让我们会的之前的例子：\n\n```\none\ntwo\n```\n\n修改第二行的内容为 “three” (`ciwthree<esc>`):\n\n```\none\nthree\n```\n\n再次修改第二行的例子为 “four” (`ciwfour<esc>`):\n\n```\none\nfour\n```\n\n此时，如果你按下 `u`，你会看到 “three”。如果你再次按下 `u`，你会看到 “two”。然而，在第二行仍为 “four” 的时候，如果你按下 `U`，你会看到 \n\n```\none\n\n```\n\n执行 `U` 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 `U` 后 再次执行 `U` 会撤销 自己。假如你连续执行 `U`，那么你将看到第二行的文本不停地出现和消失。\n\n就我个人而言，我几乎不会使用 `U`，因为很难记住文本最初的样子。（我几乎不使用它）\n\nVim 可以通过变量 `undolevels` 来选择最多可执行 undo 的次数。你可以通过 `:echo &undolevels` 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 `:set undolevels=1000`。不用担心，你可以设置它为任何一个你想设置的值。\n\n## 断点插入操作\n\n在上文中我提到，`u` 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。\n\n如果你执行 `ione two three<esc>` 之后，按下 `u`，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 `u`，你会丢失上一次输入的所有内容。 因此，假设你按下 `u` 只删除你上一次输入的一部分文本岂不是会更好。\n\n幸运的是，你可以拆分它。当你在插入模式时，按下 `Ctrl-G u` 会生成一个断点。例如，如果你执行 `ione <Ctrl-G u>two <Ctrl-G u>three<esc>`，之后你按下`u`，你仅会失去文本 “three”，再次执行 `u`，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。\n\n在插入模式中，执行删除操作时插入断点也非常有用。例如通过 `Ctrl-W` 删除光标前的单词时，以及 `Ctrl-U`删除光标前的所有文本时。一个朋友建议我使用如下的映射：\n\n```\ninoremap <c-u> <c-g>u<c-u>\ninoremap <c-w> <c-g>u<c-w>\n```\n\n通过上述命令，你可以很轻松地恢复被删除的文本。\n\n## 撤销树\n\nVim 将每一次修改存储在一个撤销树中。你打开一个空白文件，然后添加一段新文本:\n\n```\none\n\n```\n\n再插入一段新文本：\n\n```\none\ntwo\n```\n\nundo一次:\n\n```\none\n\n```\n\n插入一段不同的话：\n\n```\none\nthree\n```\n\n再次 undo\n\n```\none\n\n```\n\n再次插入另一段话：\n\n```\none\nfour\n```\n\n\n现在如果你执行 undo,您将丢失刚刚添加的文本 \"four\" :\n\n```\none\n\n```\n\n如果你再次执行 undo 操作：\n\n```\n\n```\n文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 `g+`，你会得到：\n\n```\none\n\n```\n\n再次执行 `g+` ，你将会看到一位老朋友:\n\n```\none\ntwo\n```\n\n让我们继续执行 `g+`:\n\n```\none\nthree\n```\n\n再一次执行 `g+` :\n\n```\none\nfour\n```\n\n在 Vim 中，你每一次执行 `u` 去做一次修改时，Vim都会通过创建一个\"撤销分支\"来保存之前的文本内容。在本例中，你输入\"two\"后, 执行 `u`，然后输入\"three\"，你就创建了一个叶子分支,保存了含有\"two\"的文本状态。此时，撤销树已经包含了至少两个叶子节点，主节点包含文本\"three\"（最新），而另一undo分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了\"four\"，那么此时会生成三个节点，一个主节点包含文本\"four\", 以及另外两个节点分别存储了\"three\"和\"two\"。\n\n为了在几个不同的节点状态间进行切换，你可以执行 `g+` 去获取一个较新的状态，以及执行 `g-` 去获取一个教旧的状态。 `u`， `Ctrl-R`， `g+`， 和 `g-` 之间的区别是，`u` and `Ctrl-R` 只可以在 *main* 节点之间进行切换，而`g+` 和 `g-` 可以在 *所有* 节点之间进行切换。\n\nUndo 树并不可以很轻松地可视化。我发现一个插件 [vim-mundo](https://github.com/simnalamburt/vim-mundo) 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。 \n\n## 保存撤销记录\n\n当你通过 Vim 打开一个文件，并且立即按下 `u`，Vim 很可能会显示 “*Already at oldest change*” 的警告。 \n\n要想从最近的一次编辑工作中（在vim关闭文件再打开，算做一次新的编辑工作），在撤销历史中回滚，可以通过 `:wundo`命令使Vim 保存一份你的 undo 历史记录。\n\n创建一个文件 `mynumbers.txt`. 输入:\n\n```\none\n```\n\n插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):\n\n```\none\ntwo\n```\n\n插入新的一行:\n\n```\none\ntwo\nthree\n```\n\n现在，创建你的撤销记录文件。 语法为 `:wundo myundofile`。 如果你需要覆盖一个已存在的文件，在 `wundo` 之后添加 `!`.\n\n```\n:wundo! mynumbers.undo\n```\n\n退出 Vim。\n\n此时，在目录下，应该有`mynumbers.txt` 和 `mynumbers.undo` 两个文件。再次打开 `mynumbers.txt` 文件并且按下 `u`，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 `:rundo` 来加载 undo 历史。\n\n```\n:rundo mynumbers.undo\n```\n\n此时，如果你按下 `u`，Vim 会删除 “three”。再次按下 `u`可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。\n\n如果你想要自动加载 undo 历史文件，你可以通过在你的 `.vimrc` 文件中添加如下代码：\n\n```\nset undodir=~/.vim/undo_dir\nset undofile\n```\n\n我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 `~/.vim` 目录下。 `undo_dir` 是随意的。 `set undofile` 告诉 Vim 打开 `undofile` 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用`undo_dir`目录前，请确保你已经创建了它）。\n\n## 时间旅行\n是谁说时间旅行不存在。 Vim 可以通过 `:earlier` 命令将文本恢复为之前的状态。\n\n假如有如下文本:\n\n```\none\n\n```\n之后你输入了另一行:\n\n```\none\ntwo\n```\n\n如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:\n```\n:earlier 10s\n```\n\n你可以使用 `:undolist` 去查看之前所做的修改。 `:earlier` 可以加上分钟 (`m`), 小时 (`h`), and 天 (`d`) 作为参数。 \n\n```\n:earlier 10s    恢复到10秒前的状态\n:earlier 10m    恢复到10分钟前的状态\n:earlier 10h    恢复到10小时前的状态\n:earlier 10d    恢复到10天前的状态\n\n```\n\n另外，它同样接受一个`计数`作为参数，告诉vim恢复到老状态的次数。比如，如果运行`:earlier 2`,Vim将恢复到2次修改前的状态。功能类似于执行`g-`两次。同样，你可以运行`:earlier 10f`命令告诉vim恢复到10次保存前的状态。\n\n这些参数同样作用于`:earlier`命令的对应版本:`:later`。\n\n```\n:later 10s    恢复到10秒后的状态\n:later 10m    恢复到10分钟后的状\n:later 10h    恢复到10小时后的状\n:later 10d    恢复到10天后的状态\n:later 10     恢复到新状态10次\n:later 10f    恢复到10次保存后的状态\n```\n\n## 聪明地学习撤销操作\n\n`u` 和 `Ctrl-R` 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用`:earlier` 和 `:later`，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 [vim-mundo](https://github.com/simnalamburt/vim-mundo) 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。\n\n在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。\n","source":"_posts/Vim/ch10_undo.md","raw":"---\ntitle: VIM-撤销\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第10章 撤销\n\n所有人都会犯各种各样的输入错误。因此对于任何一个现代的软件来说，撤销都是一个很基本的功能。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持存取不同的文本形态，让你能控制你输入的所有文本。在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。 \n\n## 撤销(undo)，重做和行撤销(UNDO)\n\n对于一个基本的 undo 操作，你可以执行 `u` 或者 `:undo`。\n\n假设你有如下文本(注意\"one\"下面有一个空行)：\n\n```\none\n\n```\n\n然后添加另一个文本：\n\n```\none\ntwo\n```\n\n如果你执行 `u`，Vim 会删除 “two”。\n\nVim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。\n\n要取消上一次的撤销，可以执行 `Ctrl-r` 或者 `:redo`。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 `Ctrl-r` 来恢复被删除掉的文本。\n\nVim 也有另一个命令 `U` 可以实现 行撤销 (UNDO) 的功能，执行这个命令会撤销所有最新的修改。\n\n那么，`U` 和 `u` 的区别是什么呢？首先，`U` 会删除 *最近修改的行中所有的* 的修改，而 `u` 一次仅删除一次修改。 其次，执行`u` 不会被算作一次修改操作，而执行 `U` 则会被算作一次修改。\n\n让我们会的之前的例子：\n\n```\none\ntwo\n```\n\n修改第二行的内容为 “three” (`ciwthree<esc>`):\n\n```\none\nthree\n```\n\n再次修改第二行的例子为 “four” (`ciwfour<esc>`):\n\n```\none\nfour\n```\n\n此时，如果你按下 `u`，你会看到 “three”。如果你再次按下 `u`，你会看到 “two”。然而，在第二行仍为 “four” 的时候，如果你按下 `U`，你会看到 \n\n```\none\n\n```\n\n执行 `U` 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 `U` 后 再次执行 `U` 会撤销 自己。假如你连续执行 `U`，那么你将看到第二行的文本不停地出现和消失。\n\n就我个人而言，我几乎不会使用 `U`，因为很难记住文本最初的样子。（我几乎不使用它）\n\nVim 可以通过变量 `undolevels` 来选择最多可执行 undo 的次数。你可以通过 `:echo &undolevels` 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 `:set undolevels=1000`。不用担心，你可以设置它为任何一个你想设置的值。\n\n## 断点插入操作\n\n在上文中我提到，`u` 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。\n\n如果你执行 `ione two three<esc>` 之后，按下 `u`，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 `u`，你会丢失上一次输入的所有内容。 因此，假设你按下 `u` 只删除你上一次输入的一部分文本岂不是会更好。\n\n幸运的是，你可以拆分它。当你在插入模式时，按下 `Ctrl-G u` 会生成一个断点。例如，如果你执行 `ione <Ctrl-G u>two <Ctrl-G u>three<esc>`，之后你按下`u`，你仅会失去文本 “three”，再次执行 `u`，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。\n\n在插入模式中，执行删除操作时插入断点也非常有用。例如通过 `Ctrl-W` 删除光标前的单词时，以及 `Ctrl-U`删除光标前的所有文本时。一个朋友建议我使用如下的映射：\n\n```\ninoremap <c-u> <c-g>u<c-u>\ninoremap <c-w> <c-g>u<c-w>\n```\n\n通过上述命令，你可以很轻松地恢复被删除的文本。\n\n## 撤销树\n\nVim 将每一次修改存储在一个撤销树中。你打开一个空白文件，然后添加一段新文本:\n\n```\none\n\n```\n\n再插入一段新文本：\n\n```\none\ntwo\n```\n\nundo一次:\n\n```\none\n\n```\n\n插入一段不同的话：\n\n```\none\nthree\n```\n\n再次 undo\n\n```\none\n\n```\n\n再次插入另一段话：\n\n```\none\nfour\n```\n\n\n现在如果你执行 undo,您将丢失刚刚添加的文本 \"four\" :\n\n```\none\n\n```\n\n如果你再次执行 undo 操作：\n\n```\n\n```\n文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 `g+`，你会得到：\n\n```\none\n\n```\n\n再次执行 `g+` ，你将会看到一位老朋友:\n\n```\none\ntwo\n```\n\n让我们继续执行 `g+`:\n\n```\none\nthree\n```\n\n再一次执行 `g+` :\n\n```\none\nfour\n```\n\n在 Vim 中，你每一次执行 `u` 去做一次修改时，Vim都会通过创建一个\"撤销分支\"来保存之前的文本内容。在本例中，你输入\"two\"后, 执行 `u`，然后输入\"three\"，你就创建了一个叶子分支,保存了含有\"two\"的文本状态。此时，撤销树已经包含了至少两个叶子节点，主节点包含文本\"three\"（最新），而另一undo分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了\"four\"，那么此时会生成三个节点，一个主节点包含文本\"four\", 以及另外两个节点分别存储了\"three\"和\"two\"。\n\n为了在几个不同的节点状态间进行切换，你可以执行 `g+` 去获取一个较新的状态，以及执行 `g-` 去获取一个教旧的状态。 `u`， `Ctrl-R`， `g+`， 和 `g-` 之间的区别是，`u` and `Ctrl-R` 只可以在 *main* 节点之间进行切换，而`g+` 和 `g-` 可以在 *所有* 节点之间进行切换。\n\nUndo 树并不可以很轻松地可视化。我发现一个插件 [vim-mundo](https://github.com/simnalamburt/vim-mundo) 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。 \n\n## 保存撤销记录\n\n当你通过 Vim 打开一个文件，并且立即按下 `u`，Vim 很可能会显示 “*Already at oldest change*” 的警告。 \n\n要想从最近的一次编辑工作中（在vim关闭文件再打开，算做一次新的编辑工作），在撤销历史中回滚，可以通过 `:wundo`命令使Vim 保存一份你的 undo 历史记录。\n\n创建一个文件 `mynumbers.txt`. 输入:\n\n```\none\n```\n\n插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):\n\n```\none\ntwo\n```\n\n插入新的一行:\n\n```\none\ntwo\nthree\n```\n\n现在，创建你的撤销记录文件。 语法为 `:wundo myundofile`。 如果你需要覆盖一个已存在的文件，在 `wundo` 之后添加 `!`.\n\n```\n:wundo! mynumbers.undo\n```\n\n退出 Vim。\n\n此时，在目录下，应该有`mynumbers.txt` 和 `mynumbers.undo` 两个文件。再次打开 `mynumbers.txt` 文件并且按下 `u`，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 `:rundo` 来加载 undo 历史。\n\n```\n:rundo mynumbers.undo\n```\n\n此时，如果你按下 `u`，Vim 会删除 “three”。再次按下 `u`可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。\n\n如果你想要自动加载 undo 历史文件，你可以通过在你的 `.vimrc` 文件中添加如下代码：\n\n```\nset undodir=~/.vim/undo_dir\nset undofile\n```\n\n我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 `~/.vim` 目录下。 `undo_dir` 是随意的。 `set undofile` 告诉 Vim 打开 `undofile` 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用`undo_dir`目录前，请确保你已经创建了它）。\n\n## 时间旅行\n是谁说时间旅行不存在。 Vim 可以通过 `:earlier` 命令将文本恢复为之前的状态。\n\n假如有如下文本:\n\n```\none\n\n```\n之后你输入了另一行:\n\n```\none\ntwo\n```\n\n如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:\n```\n:earlier 10s\n```\n\n你可以使用 `:undolist` 去查看之前所做的修改。 `:earlier` 可以加上分钟 (`m`), 小时 (`h`), and 天 (`d`) 作为参数。 \n\n```\n:earlier 10s    恢复到10秒前的状态\n:earlier 10m    恢复到10分钟前的状态\n:earlier 10h    恢复到10小时前的状态\n:earlier 10d    恢复到10天前的状态\n\n```\n\n另外，它同样接受一个`计数`作为参数，告诉vim恢复到老状态的次数。比如，如果运行`:earlier 2`,Vim将恢复到2次修改前的状态。功能类似于执行`g-`两次。同样，你可以运行`:earlier 10f`命令告诉vim恢复到10次保存前的状态。\n\n这些参数同样作用于`:earlier`命令的对应版本:`:later`。\n\n```\n:later 10s    恢复到10秒后的状态\n:later 10m    恢复到10分钟后的状\n:later 10h    恢复到10小时后的状\n:later 10d    恢复到10天后的状态\n:later 10     恢复到新状态10次\n:later 10f    恢复到10次保存后的状态\n```\n\n## 聪明地学习撤销操作\n\n`u` 和 `Ctrl-R` 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用`:earlier` 和 `:later`，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 [vim-mundo](https://github.com/simnalamburt/vim-mundo) 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。\n\n在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。\n","slug":"Vim/ch10_undo","published":1,"updated":"2022-08-28T07:38:59.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1w001nscvm8jgo929e","content":"<h1 id=\"第10章-撤销\"><a href=\"#第10章-撤销\" class=\"headerlink\" title=\"第10章 撤销\"></a>第10章 撤销</h1><p>所有人都会犯各种各样的输入错误。因此对于任何一个现代的软件来说，撤销都是一个很基本的功能。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持存取不同的文本形态，让你能控制你输入的所有文本。在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。 </p>\n<h2 id=\"撤销-undo-，重做和行撤销-UNDO\"><a href=\"#撤销-undo-，重做和行撤销-UNDO\" class=\"headerlink\" title=\"撤销(undo)，重做和行撤销(UNDO)\"></a>撤销(undo)，重做和行撤销(UNDO)</h2><p>对于一个基本的 undo 操作，你可以执行 <code>u</code> 或者 <code>:undo</code>。</p>\n<p>假设你有如下文本(注意”one”下面有一个空行)：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>然后添加另一个文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你执行 <code>u</code>，Vim 会删除 “two”。</p>\n<p>Vim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。</p>\n<p>要取消上一次的撤销，可以执行 <code>Ctrl-r</code> 或者 <code>:redo</code>。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 <code>Ctrl-r</code> 来恢复被删除掉的文本。</p>\n<p>Vim 也有另一个命令 <code>U</code> 可以实现 行撤销 (UNDO) 的功能，执行这个命令会撤销所有最新的修改。</p>\n<p>那么，<code>U</code> 和 <code>u</code> 的区别是什么呢？首先，<code>U</code> 会删除 <em>最近修改的行中所有的</em> 的修改，而 <code>u</code> 一次仅删除一次修改。 其次，执行<code>u</code> 不会被算作一次修改操作，而执行 <code>U</code> 则会被算作一次修改。</p>\n<p>让我们会的之前的例子：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>修改第二行的内容为 “three” (<code>ciwthree&lt;esc&gt;</code>):</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>再次修改第二行的例子为 “four” (<code>ciwfour&lt;esc&gt;</code>):</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">four</span><br></code></pre></td></tr></table></figure>\n\n<p>此时，如果你按下 <code>u</code>，你会看到 “three”。如果你再次按下 <code>u</code>，你会看到 “two”。然而，在第二行仍为 “four” 的时候，如果你按下 <code>U</code>，你会看到 </p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>执行 <code>U</code> 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 <code>U</code> 后 再次执行 <code>U</code> 会撤销 自己。假如你连续执行 <code>U</code>，那么你将看到第二行的文本不停地出现和消失。</p>\n<p>就我个人而言，我几乎不会使用 <code>U</code>，因为很难记住文本最初的样子。（我几乎不使用它）</p>\n<p>Vim 可以通过变量 <code>undolevels</code> 来选择最多可执行 undo 的次数。你可以通过 <code>:echo &amp;undolevels</code> 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 <code>:set undolevels=1000</code>。不用担心，你可以设置它为任何一个你想设置的值。</p>\n<h2 id=\"断点插入操作\"><a href=\"#断点插入操作\" class=\"headerlink\" title=\"断点插入操作\"></a>断点插入操作</h2><p>在上文中我提到，<code>u</code> 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。</p>\n<p>如果你执行 <code>ione two three&lt;esc&gt;</code> 之后，按下 <code>u</code>，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 <code>u</code>，你会丢失上一次输入的所有内容。 因此，假设你按下 <code>u</code> 只删除你上一次输入的一部分文本岂不是会更好。</p>\n<p>幸运的是，你可以拆分它。当你在插入模式时，按下 <code>Ctrl-G u</code> 会生成一个断点。例如，如果你执行 <code>ione &lt;Ctrl-G u&gt;two &lt;Ctrl-G u&gt;three&lt;esc&gt;</code>，之后你按下<code>u</code>，你仅会失去文本 “three”，再次执行 <code>u</code>，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。</p>\n<p>在插入模式中，执行删除操作时插入断点也非常有用。例如通过 <code>Ctrl-W</code> 删除光标前的单词时，以及 <code>Ctrl-U</code>删除光标前的所有文本时。一个朋友建议我使用如下的映射：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> <span class=\"hljs-symbol\">&lt;c-u&gt;</span> <span class=\"hljs-symbol\">&lt;c-g&gt;</span><span class=\"hljs-keyword\">u</span><span class=\"hljs-symbol\">&lt;c-u&gt;</span><br><span class=\"hljs-keyword\">inoremap</span> <span class=\"hljs-symbol\">&lt;c-w&gt;</span> <span class=\"hljs-symbol\">&lt;c-g&gt;</span><span class=\"hljs-keyword\">u</span><span class=\"hljs-symbol\">&lt;c-w&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过上述命令，你可以很轻松地恢复被删除的文本。</p>\n<h2 id=\"撤销树\"><a href=\"#撤销树\" class=\"headerlink\" title=\"撤销树\"></a>撤销树</h2><p>Vim 将每一次修改存储在一个撤销树中。你打开一个空白文件，然后添加一段新文本:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>再插入一段新文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>undo一次:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>插入一段不同的话：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>再次 undo</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>再次插入另一段话：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">four</span><br></code></pre></td></tr></table></figure>\n\n\n<p>现在如果你执行 undo,您将丢失刚刚添加的文本 “four” :</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>如果你再次执行 undo 操作：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\"><br></code></pre></td></tr></table></figure>\n<p>文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 <code>g+</code>，你会得到：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>再次执行 <code>g+</code> ，你将会看到一位老朋友:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们继续执行 <code>g+</code>:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>再一次执行 <code>g+</code> :</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">four</span><br></code></pre></td></tr></table></figure>\n\n<p>在 Vim 中，你每一次执行 <code>u</code> 去做一次修改时，Vim都会通过创建一个”撤销分支”来保存之前的文本内容。在本例中，你输入”two”后, 执行 <code>u</code>，然后输入”three”，你就创建了一个叶子分支,保存了含有”two”的文本状态。此时，撤销树已经包含了至少两个叶子节点，主节点包含文本”three”（最新），而另一undo分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了”four”，那么此时会生成三个节点，一个主节点包含文本”four”, 以及另外两个节点分别存储了”three”和”two”。</p>\n<p>为了在几个不同的节点状态间进行切换，你可以执行 <code>g+</code> 去获取一个较新的状态，以及执行 <code>g-</code> 去获取一个教旧的状态。 <code>u</code>， <code>Ctrl-R</code>， <code>g+</code>， 和 <code>g-</code> 之间的区别是，<code>u</code> and <code>Ctrl-R</code> 只可以在 <em>main</em> 节点之间进行切换，而<code>g+</code> 和 <code>g-</code> 可以在 <em>所有</em> 节点之间进行切换。</p>\n<p>Undo 树并不可以很轻松地可视化。我发现一个插件 <a href=\"https://github.com/simnalamburt/vim-mundo\">vim-mundo</a> 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。 </p>\n<h2 id=\"保存撤销记录\"><a href=\"#保存撤销记录\" class=\"headerlink\" title=\"保存撤销记录\"></a>保存撤销记录</h2><p>当你通过 Vim 打开一个文件，并且立即按下 <code>u</code>，Vim 很可能会显示 “<em>Already at oldest change</em>” 的警告。 </p>\n<p>要想从最近的一次编辑工作中（在vim关闭文件再打开，算做一次新的编辑工作），在撤销历史中回滚，可以通过 <code>:wundo</code>命令使Vim 保存一份你的 undo 历史记录。</p>\n<p>创建一个文件 <code>mynumbers.txt</code>. 输入:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br></code></pre></td></tr></table></figure>\n\n<p>插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>插入新的一行:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，创建你的撤销记录文件。 语法为 <code>:wundo myundofile</code>。 如果你需要覆盖一个已存在的文件，在 <code>wundo</code> 之后添加 <code>!</code>.</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:wundo!</span> mynumbers.undo<br></code></pre></td></tr></table></figure>\n\n<p>退出 Vim。</p>\n<p>此时，在目录下，应该有<code>mynumbers.txt</code> 和 <code>mynumbers.undo</code> 两个文件。再次打开 <code>mynumbers.txt</code> 文件并且按下 <code>u</code>，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 <code>:rundo</code> 来加载 undo 历史。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">rundo</span> mynumbers.<span class=\"hljs-keyword\">undo</span><br></code></pre></td></tr></table></figure>\n\n<p>此时，如果你按下 <code>u</code>，Vim 会删除 “three”。再次按下 <code>u</code>可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。</p>\n<p>如果你想要自动加载 undo 历史文件，你可以通过在你的 <code>.vimrc</code> 文件中添加如下代码：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">undodir</span>=~/.vim/undo_dir<br><span class=\"hljs-built_in\">set</span> undofile<br></code></pre></td></tr></table></figure>\n\n<p>我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 <code>~/.vim</code> 目录下。 <code>undo_dir</code> 是随意的。 <code>set undofile</code> 告诉 Vim 打开 <code>undofile</code> 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用<code>undo_dir</code>目录前，请确保你已经创建了它）。</p>\n<h2 id=\"时间旅行\"><a href=\"#时间旅行\" class=\"headerlink\" title=\"时间旅行\"></a>时间旅行</h2><p>是谁说时间旅行不存在。 Vim 可以通过 <code>:earlier</code> 命令将文本恢复为之前的状态。</p>\n<p>假如有如下文本:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n<p>之后你输入了另一行:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>s<br></code></pre></td></tr></table></figure>\n\n<p>你可以使用 <code>:undolist</code> 去查看之前所做的修改。 <code>:earlier</code> 可以加上分钟 (<code>m</code>), 小时 (<code>h</code>), and 天 (<code>d</code>) 作为参数。 </p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>s    恢复到<span class=\"hljs-number\">10</span>秒前的状态<br><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>m    恢复到<span class=\"hljs-number\">10</span>分钟前的状态<br><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>h    恢复到<span class=\"hljs-number\">10</span>小时前的状态<br><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>d    恢复到<span class=\"hljs-number\">10</span>天前的状态<br><br></code></pre></td></tr></table></figure>\n\n<p>另外，它同样接受一个<code>计数</code>作为参数，告诉vim恢复到老状态的次数。比如，如果运行<code>:earlier 2</code>,Vim将恢复到2次修改前的状态。功能类似于执行<code>g-</code>两次。同样，你可以运行<code>:earlier 10f</code>命令告诉vim恢复到10次保存前的状态。</p>\n<p>这些参数同样作用于<code>:earlier</code>命令的对应版本:<code>:later</code>。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>s    恢复到<span class=\"hljs-number\">10</span>秒后的状态<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>m    恢复到<span class=\"hljs-number\">10</span>分钟后的状<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>h    恢复到<span class=\"hljs-number\">10</span>小时后的状<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>d    恢复到<span class=\"hljs-number\">10</span>天后的状态<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>     恢复到新状态<span class=\"hljs-number\">10</span>次<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>f    恢复到<span class=\"hljs-number\">10</span>次保存后的状态<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地学习撤销操作\"><a href=\"#聪明地学习撤销操作\" class=\"headerlink\" title=\"聪明地学习撤销操作\"></a>聪明地学习撤销操作</h2><p><code>u</code> 和 <code>Ctrl-R</code> 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用<code>:earlier</code> 和 <code>:later</code>，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 <a href=\"https://github.com/simnalamburt/vim-mundo\">vim-mundo</a> 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。</p>\n<p>在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。</p>\n","site":{"data":{}},"wordcount":4026,"excerpt":"","more":"<h1 id=\"第10章-撤销\"><a href=\"#第10章-撤销\" class=\"headerlink\" title=\"第10章 撤销\"></a>第10章 撤销</h1><p>所有人都会犯各种各样的输入错误。因此对于任何一个现代的软件来说，撤销都是一个很基本的功能。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持存取不同的文本形态，让你能控制你输入的所有文本。在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。 </p>\n<h2 id=\"撤销-undo-，重做和行撤销-UNDO\"><a href=\"#撤销-undo-，重做和行撤销-UNDO\" class=\"headerlink\" title=\"撤销(undo)，重做和行撤销(UNDO)\"></a>撤销(undo)，重做和行撤销(UNDO)</h2><p>对于一个基本的 undo 操作，你可以执行 <code>u</code> 或者 <code>:undo</code>。</p>\n<p>假设你有如下文本(注意”one”下面有一个空行)：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>然后添加另一个文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你执行 <code>u</code>，Vim 会删除 “two”。</p>\n<p>Vim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。</p>\n<p>要取消上一次的撤销，可以执行 <code>Ctrl-r</code> 或者 <code>:redo</code>。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 <code>Ctrl-r</code> 来恢复被删除掉的文本。</p>\n<p>Vim 也有另一个命令 <code>U</code> 可以实现 行撤销 (UNDO) 的功能，执行这个命令会撤销所有最新的修改。</p>\n<p>那么，<code>U</code> 和 <code>u</code> 的区别是什么呢？首先，<code>U</code> 会删除 <em>最近修改的行中所有的</em> 的修改，而 <code>u</code> 一次仅删除一次修改。 其次，执行<code>u</code> 不会被算作一次修改操作，而执行 <code>U</code> 则会被算作一次修改。</p>\n<p>让我们会的之前的例子：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>修改第二行的内容为 “three” (<code>ciwthree&lt;esc&gt;</code>):</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>再次修改第二行的例子为 “four” (<code>ciwfour&lt;esc&gt;</code>):</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">four</span><br></code></pre></td></tr></table></figure>\n\n<p>此时，如果你按下 <code>u</code>，你会看到 “three”。如果你再次按下 <code>u</code>，你会看到 “two”。然而，在第二行仍为 “four” 的时候，如果你按下 <code>U</code>，你会看到 </p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>执行 <code>U</code> 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 <code>U</code> 后 再次执行 <code>U</code> 会撤销 自己。假如你连续执行 <code>U</code>，那么你将看到第二行的文本不停地出现和消失。</p>\n<p>就我个人而言，我几乎不会使用 <code>U</code>，因为很难记住文本最初的样子。（我几乎不使用它）</p>\n<p>Vim 可以通过变量 <code>undolevels</code> 来选择最多可执行 undo 的次数。你可以通过 <code>:echo &amp;undolevels</code> 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 <code>:set undolevels=1000</code>。不用担心，你可以设置它为任何一个你想设置的值。</p>\n<h2 id=\"断点插入操作\"><a href=\"#断点插入操作\" class=\"headerlink\" title=\"断点插入操作\"></a>断点插入操作</h2><p>在上文中我提到，<code>u</code> 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。</p>\n<p>如果你执行 <code>ione two three&lt;esc&gt;</code> 之后，按下 <code>u</code>，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 <code>u</code>，你会丢失上一次输入的所有内容。 因此，假设你按下 <code>u</code> 只删除你上一次输入的一部分文本岂不是会更好。</p>\n<p>幸运的是，你可以拆分它。当你在插入模式时，按下 <code>Ctrl-G u</code> 会生成一个断点。例如，如果你执行 <code>ione &lt;Ctrl-G u&gt;two &lt;Ctrl-G u&gt;three&lt;esc&gt;</code>，之后你按下<code>u</code>，你仅会失去文本 “three”，再次执行 <code>u</code>，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。</p>\n<p>在插入模式中，执行删除操作时插入断点也非常有用。例如通过 <code>Ctrl-W</code> 删除光标前的单词时，以及 <code>Ctrl-U</code>删除光标前的所有文本时。一个朋友建议我使用如下的映射：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> <span class=\"hljs-symbol\">&lt;c-u&gt;</span> <span class=\"hljs-symbol\">&lt;c-g&gt;</span><span class=\"hljs-keyword\">u</span><span class=\"hljs-symbol\">&lt;c-u&gt;</span><br><span class=\"hljs-keyword\">inoremap</span> <span class=\"hljs-symbol\">&lt;c-w&gt;</span> <span class=\"hljs-symbol\">&lt;c-g&gt;</span><span class=\"hljs-keyword\">u</span><span class=\"hljs-symbol\">&lt;c-w&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过上述命令，你可以很轻松地恢复被删除的文本。</p>\n<h2 id=\"撤销树\"><a href=\"#撤销树\" class=\"headerlink\" title=\"撤销树\"></a>撤销树</h2><p>Vim 将每一次修改存储在一个撤销树中。你打开一个空白文件，然后添加一段新文本:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>再插入一段新文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>undo一次:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>插入一段不同的话：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>再次 undo</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>再次插入另一段话：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">four</span><br></code></pre></td></tr></table></figure>\n\n\n<p>现在如果你执行 undo,您将丢失刚刚添加的文本 “four” :</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>如果你再次执行 undo 操作：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\"><br></code></pre></td></tr></table></figure>\n<p>文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 <code>g+</code>，你会得到：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n\n<p>再次执行 <code>g+</code> ，你将会看到一位老朋友:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们继续执行 <code>g+</code>:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>再一次执行 <code>g+</code> :</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">four</span><br></code></pre></td></tr></table></figure>\n\n<p>在 Vim 中，你每一次执行 <code>u</code> 去做一次修改时，Vim都会通过创建一个”撤销分支”来保存之前的文本内容。在本例中，你输入”two”后, 执行 <code>u</code>，然后输入”three”，你就创建了一个叶子分支,保存了含有”two”的文本状态。此时，撤销树已经包含了至少两个叶子节点，主节点包含文本”three”（最新），而另一undo分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了”four”，那么此时会生成三个节点，一个主节点包含文本”four”, 以及另外两个节点分别存储了”three”和”two”。</p>\n<p>为了在几个不同的节点状态间进行切换，你可以执行 <code>g+</code> 去获取一个较新的状态，以及执行 <code>g-</code> 去获取一个教旧的状态。 <code>u</code>， <code>Ctrl-R</code>， <code>g+</code>， 和 <code>g-</code> 之间的区别是，<code>u</code> and <code>Ctrl-R</code> 只可以在 <em>main</em> 节点之间进行切换，而<code>g+</code> 和 <code>g-</code> 可以在 <em>所有</em> 节点之间进行切换。</p>\n<p>Undo 树并不可以很轻松地可视化。我发现一个插件 <a href=\"https://github.com/simnalamburt/vim-mundo\">vim-mundo</a> 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。 </p>\n<h2 id=\"保存撤销记录\"><a href=\"#保存撤销记录\" class=\"headerlink\" title=\"保存撤销记录\"></a>保存撤销记录</h2><p>当你通过 Vim 打开一个文件，并且立即按下 <code>u</code>，Vim 很可能会显示 “<em>Already at oldest change</em>” 的警告。 </p>\n<p>要想从最近的一次编辑工作中（在vim关闭文件再打开，算做一次新的编辑工作），在撤销历史中回滚，可以通过 <code>:wundo</code>命令使Vim 保存一份你的 undo 历史记录。</p>\n<p>创建一个文件 <code>mynumbers.txt</code>. 输入:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br></code></pre></td></tr></table></figure>\n\n<p>插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>插入新的一行:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，创建你的撤销记录文件。 语法为 <code>:wundo myundofile</code>。 如果你需要覆盖一个已存在的文件，在 <code>wundo</code> 之后添加 <code>!</code>.</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:wundo!</span> mynumbers.undo<br></code></pre></td></tr></table></figure>\n\n<p>退出 Vim。</p>\n<p>此时，在目录下，应该有<code>mynumbers.txt</code> 和 <code>mynumbers.undo</code> 两个文件。再次打开 <code>mynumbers.txt</code> 文件并且按下 <code>u</code>，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 <code>:rundo</code> 来加载 undo 历史。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">rundo</span> mynumbers.<span class=\"hljs-keyword\">undo</span><br></code></pre></td></tr></table></figure>\n\n<p>此时，如果你按下 <code>u</code>，Vim 会删除 “three”。再次按下 <code>u</code>可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。</p>\n<p>如果你想要自动加载 undo 历史文件，你可以通过在你的 <code>.vimrc</code> 文件中添加如下代码：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">undodir</span>=~/.vim/undo_dir<br><span class=\"hljs-built_in\">set</span> undofile<br></code></pre></td></tr></table></figure>\n\n<p>我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 <code>~/.vim</code> 目录下。 <code>undo_dir</code> 是随意的。 <code>set undofile</code> 告诉 Vim 打开 <code>undofile</code> 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用<code>undo_dir</code>目录前，请确保你已经创建了它）。</p>\n<h2 id=\"时间旅行\"><a href=\"#时间旅行\" class=\"headerlink\" title=\"时间旅行\"></a>时间旅行</h2><p>是谁说时间旅行不存在。 Vim 可以通过 <code>:earlier</code> 命令将文本恢复为之前的状态。</p>\n<p>假如有如下文本:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">one</span><br><br></code></pre></td></tr></table></figure>\n<p>之后你输入了另一行:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>s<br></code></pre></td></tr></table></figure>\n\n<p>你可以使用 <code>:undolist</code> 去查看之前所做的修改。 <code>:earlier</code> 可以加上分钟 (<code>m</code>), 小时 (<code>h</code>), and 天 (<code>d</code>) 作为参数。 </p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>s    恢复到<span class=\"hljs-number\">10</span>秒前的状态<br><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>m    恢复到<span class=\"hljs-number\">10</span>分钟前的状态<br><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>h    恢复到<span class=\"hljs-number\">10</span>小时前的状态<br><span class=\"hljs-symbol\">:earlier</span> <span class=\"hljs-number\">10</span>d    恢复到<span class=\"hljs-number\">10</span>天前的状态<br><br></code></pre></td></tr></table></figure>\n\n<p>另外，它同样接受一个<code>计数</code>作为参数，告诉vim恢复到老状态的次数。比如，如果运行<code>:earlier 2</code>,Vim将恢复到2次修改前的状态。功能类似于执行<code>g-</code>两次。同样，你可以运行<code>:earlier 10f</code>命令告诉vim恢复到10次保存前的状态。</p>\n<p>这些参数同样作用于<code>:earlier</code>命令的对应版本:<code>:later</code>。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>s    恢复到<span class=\"hljs-number\">10</span>秒后的状态<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>m    恢复到<span class=\"hljs-number\">10</span>分钟后的状<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>h    恢复到<span class=\"hljs-number\">10</span>小时后的状<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>d    恢复到<span class=\"hljs-number\">10</span>天后的状态<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>     恢复到新状态<span class=\"hljs-number\">10</span>次<br><span class=\"hljs-symbol\">:later</span> <span class=\"hljs-number\">10</span>f    恢复到<span class=\"hljs-number\">10</span>次保存后的状态<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地学习撤销操作\"><a href=\"#聪明地学习撤销操作\" class=\"headerlink\" title=\"聪明地学习撤销操作\"></a>聪明地学习撤销操作</h2><p><code>u</code> 和 <code>Ctrl-R</code> 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用<code>:earlier</code> 和 <code>:later</code>，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 <a href=\"https://github.com/simnalamburt/vim-mundo\">vim-mundo</a> 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。</p>\n<p>在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。</p>\n"},{"title":"VIM-可视模式","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第11章 可视模式\n\n高亮显示文本块并对其进行更改，是很多文本编辑器中的常见功能。 Vim也可以使用可视模式实现这一功能。在本章中，您将学习如何使用可视模式来有效地处理文本块。\n\n## 三种可视模式\n\nVim有三种可视模式，分别是：\n\n```\nv         逐字符可视模式\nV         逐行可视模式\nCtrl-v    逐块可视模式\n```\n\n如果您有下列文字：\n\n```\none\ntwo\nthree\n```\n\n逐字符可视模式用于选择单个字符。在第一行的第一个字符上按`v`。然后使用`j`跳转至下一行。它高亮显示从\"one\"到光标位置的所有文本。现在，如果您按`gU`，Vim将高亮显示的字符转为大写。\n\n逐行可视模式适用于整行。按`V`并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行`gU`，Vim将高亮显示的字符转为大写。\n\n逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按`Ctrl-V`，Vim像逐字符可视模式一样高亮显示光标下的字符，但向下移动时，除非光标已经在行尾，否则不会高亮显示光标上方的整行，它跳转至下一行时高亮显示尽可能少的字符。尝试用`h/j/k/l`移动，并观察光标的移动。\n\n在Vim窗口的左下方，您会看到显示`-- VISUAL --`，`-- VISUAL LINE --`或`-- VISUAL BLOCK --`以提示您所处的可视模式。\n\n当您处于可视模式时，可以通过按`v`，`V`或`Ctrl-V`键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行`Ctrl-V`。试试吧！\n\n有三种退出可视模式的方法：`esc`，`Ctrl-C`和与当前可视模式相同的键。后者的意思是，如果您当前处于逐行可视模式(`V`)，则可以通过再次按`V`退出它。如果您处于字符可视模式，则可以通过按`v`退出它。如果您处于逐块可视模式，请按`Ctrl-V`。\n\n实际上，还有另一种进入可视模式的方式：\n\n```\ngv    转到上一个可视模式\n```\n\n它将在与上次相同的高亮显示的文本块上启动相同的可视模式。\n\n## 可视模式导航\n\n在可视模式下，您可以使用Vim动作(motion)扩展高亮显示的文本块。\n\n让我们使用之前使用的相同文本：\n\n```\none\ntwo\nthree\n```\n\n这次让我们从\"two\"行开始。按`v`进入字符可视模式(这里的方括号`[]`表示高亮显示的字符)：\n\n```\none\n[t]wo\nthree\n```\n\n按`j`，Vim将高亮显示从\"two\"行到\"three\"行的第一个字符的所有文本。\n\n```\none\n[two\nt]hree\n```\n\n假设您刚刚意识到还需要高亮显示\"one\"行，因此按`k`。令您沮丧的是，它现在排除了\"three\"高亮。\n\n```\none\n[t]wo\nthree\n```\n\n有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？\n\n答案是肯定的。让我们先恢复光标到高亮显示\"two\"和\"three\"行的位置。\n\n```\none\n[two\nt]hree    <-- 光标\n```\n\n高亮区域跟随光标移动。如果要将其向上扩展到行\"one\"，则需要将光标移动到\"two\"，现在您的光标在\"three\"行上。这时可以用`o`或`O`切换光标位置。\n\n```\none\n[two     <-- 光标\nt]hree\n```\n\n现在，当您按`k`时，它不再缩小选择，而是向上扩展。\n\n```\n[one\ntwo\nt]hree\n```\n\n在可视模式中使用`o`或`O`，光标会在高亮选择区域的开头和结尾跳转，以便与您扩展高亮区域。\n\n## 可视模式语法\n\n可视模式与普通模式使用相同的操作符(operations)。\n\n例如，如果您有以下文字，然后您想在可视模式中删除前两行：\n\n```\none\ntwo\nthree\n```\n\n用逐行可视模式(`V`)高亮显示\"one\"和\"two\"行：\n\n```\n[one\ntwo]\nthree\n```\n\n按下`d`键将删除选择，类似于普通模式。请注意，与普通模式的语法规则有所不同，动词+名词不适用可视模式。虽然存在相同的动词(`d`)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词(反过来了)，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。\n\n在普通模式下，有一些命令不需要名词(motion)，例如`x`删除光标下方的单个字符，还有`r`替换光标下方的字符(`rx`将当前光标下的字符替换为`x`)。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。回到高亮显示的文本：\n\n```\n[one\ntwo]\nthree\n```\n\n运行`x`会删除所有高亮显示的文本。\n\n您可以使用此行为在markdown文本中快速创建标题。假设您需要快速下面的文本转换为一级markdown标题(\"===\"):\n\n```\nChapter One\n```\n\n首先，您使用`yy`复制文本，然后使用`p`粘贴文本：\n\n```\nChapter One\nChapter One\n```\n\n现在转到第二行，以逐行可视模式选择它：\n\n```\nChapter One\n[Chapter One]\n```\n\n在markdown中，您可以通过在文本下方添加一系列`=`来创建标题，因此您可以通过运行`r=`来替换整个高亮显示的文本：\n\n```\nChapter One\n===========\n```\n\n要了解有关可视模式下的运算符的更多信息，请查看`:h visual-operators`。\n\n## 可视模式和Ex命令\n\n您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式,并想将前两行的\"const\"替换为\"let\"：\n\n```\nconst one = \"one\";\nconst two = \"two\";\nconst three = \"three\";\n```\n\n用 *任意* 可视模式高亮显示前两行，然后运行替换命令`:s/const/let/g`：\n\n```\nlet one = \"one\";\nlet two = \"two\";\nconst three = \"three\";\n```\n\n请注意，我说过您可以使用 *任何* 可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。只要您在每行上至少选择一个字符，就会应用Ex命令。\n\n## 跨多行编辑\n\n您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：\n\n```\nconst one = \"one\"\nconst two = \"two\"\nconst three = \"three\"\n```\n\n将光标放在第一行上：\n- 进入逐块可视模式，并向下两行(`Ctrl-V jj`)。\n- 高亮显示到行尾(`$`)。\n- 按(`A`) ，然后键入\";\"。\n- 退出可视模式(`esc`)。\n\n您应该看到在每一行后面附加的 \";\"。666! 有两种方法可以从逐块可视模式进入输入模式：可以使用`A`在光标后输入文本，也可以使用`I`在光标前输入文本。请勿将它们与普通模式下的`A`和`I`混淆。(普通模式中，`A`表示在行尾添加内容，`I`表示在行尾非空字符前插入内容)。\n\n另外，您也可以使用`:normal`命令在多行添加内容：\n-高亮显示所有3行(`vjj`)。\n-输入`:normal! A;`。\n\n记住，`:normal`命令执行普通模式命令。您可以指示它运行`A;`在该行的末尾添加文本\";\"。\n\n## 递增数字\n\nVim有`Ctrl-X`和`Ctrl-A`命令来减少和增加数字。与可视模式一起使用时，可以跨多行递增数字。\n\n如果您具有以下HTML元素：\n\n```\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n```\n\n有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：\n- 将光标移动到 **第二行**的 \"1\"。\n- 启动逐块可视模式，并向下移动3行(`Ctrl-V 3j`)。这高亮显示剩余的\"1\"，现在除了第一行，所有的\"1\"应该已经高亮。\n- 运行`g Ctrl-A`。\n\n您应该看到以下结果：\n\n```\n<div id=\"app-1\"></div>\n<div id=\"app-2\"></div>\n<div id=\"app-3\"></div>\n<div id=\"app-4\"></div>\n<div id=\"app-5\"></div>\n```\n\n`g Ctrl-A`在多行上递增数字。 `Ctrl-X/Ctrl-A`也可以增加字母。如果您运行：\n\n```\n:set nrformats+=alpha\n```\n\n`nrformats`选项指示Vim将哪个基数视为`Ctrl-A`和`Ctrl-X`递增和递减的“数字”。通过添加`alpha`，现在将字母字符视为数字。如果您具有以下HTML元素：\n\n```\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n```\n\n将光标放在第二个\"app-a\"上。使用与上述相同的技术(`Ctrl-V 3j` 然后 `g Ctrl-A`)增加ID。\n\n```\n<div id=\"app-a\"></div>\n<div id=\"app-b\"></div>\n<div id=\"app-c\"></div>\n<div id=\"app-d\"></div>\n<div id=\"app-e\"></div>\n```\n\n## 选择最后一个可视模式区域\n\n前面章节中我提到了`gv`可以快速高亮显示上一个可视模式选择的内容。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：\n\n```\n'<    转到上一个可视模式高亮显示的第一个位置（行）(译者注，英文原版中'<'前面的符号是`，但这应该是一个错误，应该是单引号')\n'>    转到上一个可视模式高亮显示的最后位置（行）\n```\n\n之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：`:s/const/let/g`。当您这样做时，您应该看到以下内容：\n\n```\n:'<,'>s/const/let/g\n```\n\n您实际上是在使用(`'<, '>`) 标记作为范围来执行 `s/const/let/g`命令。这太有趣了！\n\n您随时可以随时编辑这些标记。比如，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：\n\n```\n:'<,$s/const/let/g\n```\n\n## 从插入模式进入可视模式\n\n您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：\n\n```\nCtrl-O v\n```\n\n回想一下，在插入模式下运行`Ctrl-O`可以使您执行普通模式命令。在普通模式命令挂起模式下，运行`v`进入逐字可视模式。请注意，在屏幕的左下方，它显示为`--(insert) VISUAL--`。该技巧适用于任何可视模式运算符：`v`，`V`，和`Ctrl-V`。\n\n##  选择模式\n\nVim具有类似于可视模式的模式，称为*选择模式*。与可视模式一样，它也具有三种不同的模式：\n\n```\ngh         逐字符选择模式\ngH         逐行选择模式\ngCtrl-h    逐块选择模式\n```\n\n选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。\n\n在常规编辑器中，高亮显示文本块并键入字母（例如字母\"y\"）后，它将删除高亮显示的文本并插入字母\"y\"。如果您使用逐行选择模式(`gH`)高亮显示一行文本并键入\"y\"，它将删除高亮显示的文本并插入字母\"y\"，这与常规文本编辑器非常相似。\n\n将此行为与可视模式进行对比：如果您使用逐行可视模式(`V`)高亮显示一行文本并键入\"y\"，则高亮显示的文本不会被删除且被字母\"y\"代替，而是仅将其复制(yank)。在选择模式中，你不能执行对高亮文本执行普通模式的命令。\n\n我个人从未使用过选择模式，但是很高兴知道它的存在。\n\n## 以聪明的方式学习可视模式\n\n可视模式是Vim高亮显示文本的过程。\n\n如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。假设您需要删除一个内部单词(inner word，请回顾前面的文本对象)，如果可以只用三个按键(`diw`)，为什么要使用四个按键`viwd`（先`v`进入可视模式，然后`iw`高亮一个内部单词，最后`d`删除）呢？前者更为直接和简洁。当然，有时使用可视模式是合适的，但总的来说，更倾向于直接的方法。\n","source":"_posts/Vim/ch11_visual_mode.md","raw":"---\ntitle: VIM-可视模式\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第11章 可视模式\n\n高亮显示文本块并对其进行更改，是很多文本编辑器中的常见功能。 Vim也可以使用可视模式实现这一功能。在本章中，您将学习如何使用可视模式来有效地处理文本块。\n\n## 三种可视模式\n\nVim有三种可视模式，分别是：\n\n```\nv         逐字符可视模式\nV         逐行可视模式\nCtrl-v    逐块可视模式\n```\n\n如果您有下列文字：\n\n```\none\ntwo\nthree\n```\n\n逐字符可视模式用于选择单个字符。在第一行的第一个字符上按`v`。然后使用`j`跳转至下一行。它高亮显示从\"one\"到光标位置的所有文本。现在，如果您按`gU`，Vim将高亮显示的字符转为大写。\n\n逐行可视模式适用于整行。按`V`并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行`gU`，Vim将高亮显示的字符转为大写。\n\n逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按`Ctrl-V`，Vim像逐字符可视模式一样高亮显示光标下的字符，但向下移动时，除非光标已经在行尾，否则不会高亮显示光标上方的整行，它跳转至下一行时高亮显示尽可能少的字符。尝试用`h/j/k/l`移动，并观察光标的移动。\n\n在Vim窗口的左下方，您会看到显示`-- VISUAL --`，`-- VISUAL LINE --`或`-- VISUAL BLOCK --`以提示您所处的可视模式。\n\n当您处于可视模式时，可以通过按`v`，`V`或`Ctrl-V`键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行`Ctrl-V`。试试吧！\n\n有三种退出可视模式的方法：`esc`，`Ctrl-C`和与当前可视模式相同的键。后者的意思是，如果您当前处于逐行可视模式(`V`)，则可以通过再次按`V`退出它。如果您处于字符可视模式，则可以通过按`v`退出它。如果您处于逐块可视模式，请按`Ctrl-V`。\n\n实际上，还有另一种进入可视模式的方式：\n\n```\ngv    转到上一个可视模式\n```\n\n它将在与上次相同的高亮显示的文本块上启动相同的可视模式。\n\n## 可视模式导航\n\n在可视模式下，您可以使用Vim动作(motion)扩展高亮显示的文本块。\n\n让我们使用之前使用的相同文本：\n\n```\none\ntwo\nthree\n```\n\n这次让我们从\"two\"行开始。按`v`进入字符可视模式(这里的方括号`[]`表示高亮显示的字符)：\n\n```\none\n[t]wo\nthree\n```\n\n按`j`，Vim将高亮显示从\"two\"行到\"three\"行的第一个字符的所有文本。\n\n```\none\n[two\nt]hree\n```\n\n假设您刚刚意识到还需要高亮显示\"one\"行，因此按`k`。令您沮丧的是，它现在排除了\"three\"高亮。\n\n```\none\n[t]wo\nthree\n```\n\n有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？\n\n答案是肯定的。让我们先恢复光标到高亮显示\"two\"和\"three\"行的位置。\n\n```\none\n[two\nt]hree    <-- 光标\n```\n\n高亮区域跟随光标移动。如果要将其向上扩展到行\"one\"，则需要将光标移动到\"two\"，现在您的光标在\"three\"行上。这时可以用`o`或`O`切换光标位置。\n\n```\none\n[two     <-- 光标\nt]hree\n```\n\n现在，当您按`k`时，它不再缩小选择，而是向上扩展。\n\n```\n[one\ntwo\nt]hree\n```\n\n在可视模式中使用`o`或`O`，光标会在高亮选择区域的开头和结尾跳转，以便与您扩展高亮区域。\n\n## 可视模式语法\n\n可视模式与普通模式使用相同的操作符(operations)。\n\n例如，如果您有以下文字，然后您想在可视模式中删除前两行：\n\n```\none\ntwo\nthree\n```\n\n用逐行可视模式(`V`)高亮显示\"one\"和\"two\"行：\n\n```\n[one\ntwo]\nthree\n```\n\n按下`d`键将删除选择，类似于普通模式。请注意，与普通模式的语法规则有所不同，动词+名词不适用可视模式。虽然存在相同的动词(`d`)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词(反过来了)，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。\n\n在普通模式下，有一些命令不需要名词(motion)，例如`x`删除光标下方的单个字符，还有`r`替换光标下方的字符(`rx`将当前光标下的字符替换为`x`)。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。回到高亮显示的文本：\n\n```\n[one\ntwo]\nthree\n```\n\n运行`x`会删除所有高亮显示的文本。\n\n您可以使用此行为在markdown文本中快速创建标题。假设您需要快速下面的文本转换为一级markdown标题(\"===\"):\n\n```\nChapter One\n```\n\n首先，您使用`yy`复制文本，然后使用`p`粘贴文本：\n\n```\nChapter One\nChapter One\n```\n\n现在转到第二行，以逐行可视模式选择它：\n\n```\nChapter One\n[Chapter One]\n```\n\n在markdown中，您可以通过在文本下方添加一系列`=`来创建标题，因此您可以通过运行`r=`来替换整个高亮显示的文本：\n\n```\nChapter One\n===========\n```\n\n要了解有关可视模式下的运算符的更多信息，请查看`:h visual-operators`。\n\n## 可视模式和Ex命令\n\n您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式,并想将前两行的\"const\"替换为\"let\"：\n\n```\nconst one = \"one\";\nconst two = \"two\";\nconst three = \"three\";\n```\n\n用 *任意* 可视模式高亮显示前两行，然后运行替换命令`:s/const/let/g`：\n\n```\nlet one = \"one\";\nlet two = \"two\";\nconst three = \"three\";\n```\n\n请注意，我说过您可以使用 *任何* 可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。只要您在每行上至少选择一个字符，就会应用Ex命令。\n\n## 跨多行编辑\n\n您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：\n\n```\nconst one = \"one\"\nconst two = \"two\"\nconst three = \"three\"\n```\n\n将光标放在第一行上：\n- 进入逐块可视模式，并向下两行(`Ctrl-V jj`)。\n- 高亮显示到行尾(`$`)。\n- 按(`A`) ，然后键入\";\"。\n- 退出可视模式(`esc`)。\n\n您应该看到在每一行后面附加的 \";\"。666! 有两种方法可以从逐块可视模式进入输入模式：可以使用`A`在光标后输入文本，也可以使用`I`在光标前输入文本。请勿将它们与普通模式下的`A`和`I`混淆。(普通模式中，`A`表示在行尾添加内容，`I`表示在行尾非空字符前插入内容)。\n\n另外，您也可以使用`:normal`命令在多行添加内容：\n-高亮显示所有3行(`vjj`)。\n-输入`:normal! A;`。\n\n记住，`:normal`命令执行普通模式命令。您可以指示它运行`A;`在该行的末尾添加文本\";\"。\n\n## 递增数字\n\nVim有`Ctrl-X`和`Ctrl-A`命令来减少和增加数字。与可视模式一起使用时，可以跨多行递增数字。\n\n如果您具有以下HTML元素：\n\n```\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n<div id=\"app-1\"></div>\n```\n\n有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：\n- 将光标移动到 **第二行**的 \"1\"。\n- 启动逐块可视模式，并向下移动3行(`Ctrl-V 3j`)。这高亮显示剩余的\"1\"，现在除了第一行，所有的\"1\"应该已经高亮。\n- 运行`g Ctrl-A`。\n\n您应该看到以下结果：\n\n```\n<div id=\"app-1\"></div>\n<div id=\"app-2\"></div>\n<div id=\"app-3\"></div>\n<div id=\"app-4\"></div>\n<div id=\"app-5\"></div>\n```\n\n`g Ctrl-A`在多行上递增数字。 `Ctrl-X/Ctrl-A`也可以增加字母。如果您运行：\n\n```\n:set nrformats+=alpha\n```\n\n`nrformats`选项指示Vim将哪个基数视为`Ctrl-A`和`Ctrl-X`递增和递减的“数字”。通过添加`alpha`，现在将字母字符视为数字。如果您具有以下HTML元素：\n\n```\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n<div id=\"app-a\"></div>\n```\n\n将光标放在第二个\"app-a\"上。使用与上述相同的技术(`Ctrl-V 3j` 然后 `g Ctrl-A`)增加ID。\n\n```\n<div id=\"app-a\"></div>\n<div id=\"app-b\"></div>\n<div id=\"app-c\"></div>\n<div id=\"app-d\"></div>\n<div id=\"app-e\"></div>\n```\n\n## 选择最后一个可视模式区域\n\n前面章节中我提到了`gv`可以快速高亮显示上一个可视模式选择的内容。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：\n\n```\n'<    转到上一个可视模式高亮显示的第一个位置（行）(译者注，英文原版中'<'前面的符号是`，但这应该是一个错误，应该是单引号')\n'>    转到上一个可视模式高亮显示的最后位置（行）\n```\n\n之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：`:s/const/let/g`。当您这样做时，您应该看到以下内容：\n\n```\n:'<,'>s/const/let/g\n```\n\n您实际上是在使用(`'<, '>`) 标记作为范围来执行 `s/const/let/g`命令。这太有趣了！\n\n您随时可以随时编辑这些标记。比如，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：\n\n```\n:'<,$s/const/let/g\n```\n\n## 从插入模式进入可视模式\n\n您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：\n\n```\nCtrl-O v\n```\n\n回想一下，在插入模式下运行`Ctrl-O`可以使您执行普通模式命令。在普通模式命令挂起模式下，运行`v`进入逐字可视模式。请注意，在屏幕的左下方，它显示为`--(insert) VISUAL--`。该技巧适用于任何可视模式运算符：`v`，`V`，和`Ctrl-V`。\n\n##  选择模式\n\nVim具有类似于可视模式的模式，称为*选择模式*。与可视模式一样，它也具有三种不同的模式：\n\n```\ngh         逐字符选择模式\ngH         逐行选择模式\ngCtrl-h    逐块选择模式\n```\n\n选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。\n\n在常规编辑器中，高亮显示文本块并键入字母（例如字母\"y\"）后，它将删除高亮显示的文本并插入字母\"y\"。如果您使用逐行选择模式(`gH`)高亮显示一行文本并键入\"y\"，它将删除高亮显示的文本并插入字母\"y\"，这与常规文本编辑器非常相似。\n\n将此行为与可视模式进行对比：如果您使用逐行可视模式(`V`)高亮显示一行文本并键入\"y\"，则高亮显示的文本不会被删除且被字母\"y\"代替，而是仅将其复制(yank)。在选择模式中，你不能执行对高亮文本执行普通模式的命令。\n\n我个人从未使用过选择模式，但是很高兴知道它的存在。\n\n## 以聪明的方式学习可视模式\n\n可视模式是Vim高亮显示文本的过程。\n\n如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。假设您需要删除一个内部单词(inner word，请回顾前面的文本对象)，如果可以只用三个按键(`diw`)，为什么要使用四个按键`viwd`（先`v`进入可视模式，然后`iw`高亮一个内部单词，最后`d`删除）呢？前者更为直接和简洁。当然，有时使用可视模式是合适的，但总的来说，更倾向于直接的方法。\n","slug":"Vim/ch11_visual_mode","published":1,"updated":"2022-08-28T07:38:59.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1y001qscvmg3w6h8uy","content":"<h1 id=\"第11章-可视模式\"><a href=\"#第11章-可视模式\" class=\"headerlink\" title=\"第11章 可视模式\"></a>第11章 可视模式</h1><p>高亮显示文本块并对其进行更改，是很多文本编辑器中的常见功能。 Vim也可以使用可视模式实现这一功能。在本章中，您将学习如何使用可视模式来有效地处理文本块。</p>\n<h2 id=\"三种可视模式\"><a href=\"#三种可视模式\" class=\"headerlink\" title=\"三种可视模式\"></a>三种可视模式</h2><p>Vim有三种可视模式，分别是：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">v</span>         逐字符可视模式<br>V         逐行可视模式<br>Ctrl-v    逐块可视模式<br></code></pre></td></tr></table></figure>\n\n<p>如果您有下列文字：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>逐字符可视模式用于选择单个字符。在第一行的第一个字符上按<code>v</code>。然后使用<code>j</code>跳转至下一行。它高亮显示从”one”到光标位置的所有文本。现在，如果您按<code>gU</code>，Vim将高亮显示的字符转为大写。</p>\n<p>逐行可视模式适用于整行。按<code>V</code>并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行<code>gU</code>，Vim将高亮显示的字符转为大写。</p>\n<p>逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按<code>Ctrl-V</code>，Vim像逐字符可视模式一样高亮显示光标下的字符，但向下移动时，除非光标已经在行尾，否则不会高亮显示光标上方的整行，它跳转至下一行时高亮显示尽可能少的字符。尝试用<code>h/j/k/l</code>移动，并观察光标的移动。</p>\n<p>在Vim窗口的左下方，您会看到显示<code>-- VISUAL --</code>，<code>-- VISUAL LINE --</code>或<code>-- VISUAL BLOCK --</code>以提示您所处的可视模式。</p>\n<p>当您处于可视模式时，可以通过按<code>v</code>，<code>V</code>或<code>Ctrl-V</code>键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行<code>Ctrl-V</code>。试试吧！</p>\n<p>有三种退出可视模式的方法：<code>esc</code>，<code>Ctrl-C</code>和与当前可视模式相同的键。后者的意思是，如果您当前处于逐行可视模式(<code>V</code>)，则可以通过再次按<code>V</code>退出它。如果您处于字符可视模式，则可以通过按<code>v</code>退出它。如果您处于逐块可视模式，请按<code>Ctrl-V</code>。</p>\n<p>实际上，还有另一种进入可视模式的方式：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">gv</span>    转到上一个可视模式<br></code></pre></td></tr></table></figure>\n\n<p>它将在与上次相同的高亮显示的文本块上启动相同的可视模式。</p>\n<h2 id=\"可视模式导航\"><a href=\"#可视模式导航\" class=\"headerlink\" title=\"可视模式导航\"></a>可视模式导航</h2><p>在可视模式下，您可以使用Vim动作(motion)扩展高亮显示的文本块。</p>\n<p>让我们使用之前使用的相同文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>这次让我们从”two”行开始。按<code>v</code>进入字符可视模式(这里的方括号<code>[]</code>表示高亮显示的字符)：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">one<br><span class=\"hljs-string\">[t]</span>wo<br>three<br></code></pre></td></tr></table></figure>\n\n<p>按<code>j</code>，Vim将高亮显示从”two”行到”three”行的第一个字符的所有文本。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">one</span><br>[<span class=\"hljs-keyword\">two</span><br>t]hree<br></code></pre></td></tr></table></figure>\n\n<p>假设您刚刚意识到还需要高亮显示”one”行，因此按<code>k</code>。令您沮丧的是，它现在排除了”three”高亮。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">one<br><span class=\"hljs-string\">[t]</span>wo<br>three<br></code></pre></td></tr></table></figure>\n\n<p>有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？</p>\n<p>答案是肯定的。让我们先恢复光标到高亮显示”two”和”three”行的位置。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">one</span><br>[two<br>t]hree    <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-comment\">-- 光标</span><br></code></pre></td></tr></table></figure>\n\n<p>高亮区域跟随光标移动。如果要将其向上扩展到行”one”，则需要将光标移动到”two”，现在您的光标在”three”行上。这时可以用<code>o</code>或<code>O</code>切换光标位置。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">one</span><br>[two     <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-comment\">-- 光标</span><br>t]hree<br></code></pre></td></tr></table></figure>\n\n<p>现在，当您按<code>k</code>时，它不再缩小选择，而是向上扩展。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">[<span class=\"hljs-keyword\">one</span><br><span class=\"hljs-keyword\">two</span><br>t]hree<br></code></pre></td></tr></table></figure>\n\n<p>在可视模式中使用<code>o</code>或<code>O</code>，光标会在高亮选择区域的开头和结尾跳转，以便与您扩展高亮区域。</p>\n<h2 id=\"可视模式语法\"><a href=\"#可视模式语法\" class=\"headerlink\" title=\"可视模式语法\"></a>可视模式语法</h2><p>可视模式与普通模式使用相同的操作符(operations)。</p>\n<p>例如，如果您有以下文字，然后您想在可视模式中删除前两行：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>用逐行可视模式(<code>V</code>)高亮显示”one”和”two”行：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">[<span class=\"hljs-keyword\">one</span><br><span class=\"hljs-keyword\">two</span>]<br>three<br></code></pre></td></tr></table></figure>\n\n<p>按下<code>d</code>键将删除选择，类似于普通模式。请注意，与普通模式的语法规则有所不同，动词+名词不适用可视模式。虽然存在相同的动词(<code>d</code>)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词(反过来了)，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。</p>\n<p>在普通模式下，有一些命令不需要名词(motion)，例如<code>x</code>删除光标下方的单个字符，还有<code>r</code>替换光标下方的字符(<code>rx</code>将当前光标下的字符替换为<code>x</code>)。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。回到高亮显示的文本：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">[<span class=\"hljs-keyword\">one</span><br><span class=\"hljs-keyword\">two</span>]<br>three<br></code></pre></td></tr></table></figure>\n\n<p>运行<code>x</code>会删除所有高亮显示的文本。</p>\n<p>您可以使用此行为在markdown文本中快速创建标题。假设您需要快速下面的文本转换为一级markdown标题(“&#x3D;&#x3D;&#x3D;”):</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">Chapter One</span><br></code></pre></td></tr></table></figure>\n\n<p>首先，您使用<code>yy</code>复制文本，然后使用<code>p</code>粘贴文本：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"><span class=\"hljs-section\">Chapter One</span><br><span class=\"hljs-section\">Chapter One</span><br></code></pre></td></tr></table></figure>\n\n<p>现在转到第二行，以逐行可视模式选择它：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"><span class=\"hljs-section\">Chapter One</span><br><span class=\"hljs-comment\">[Chapter One]</span><br></code></pre></td></tr></table></figure>\n\n<p>在markdown中，您可以通过在文本下方添加一系列<code>=</code>来创建标题，因此您可以通过运行<code>r=</code>来替换整个高亮显示的文本：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">Chapter One<br><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><br></code></pre></td></tr></table></figure>\n\n<p>要了解有关可视模式下的运算符的更多信息，请查看<code>:h visual-operators</code>。</p>\n<h2 id=\"可视模式和Ex命令\"><a href=\"#可视模式和Ex命令\" class=\"headerlink\" title=\"可视模式和Ex命令\"></a>可视模式和Ex命令</h2><p>您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式,并想将前两行的”const”替换为”let”：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;one&quot;</span><span class=\"hljs-comment\">;</span><br>const two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;two&quot;</span><span class=\"hljs-comment\">;</span><br>const three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;three&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>用 <em>任意</em> 可视模式高亮显示前两行，然后运行替换命令<code>:s/const/let/g</code>：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;one&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;two&quot;</span><span class=\"hljs-comment\">;</span><br>const three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;three&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>请注意，我说过您可以使用 <em>任何</em> 可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。只要您在每行上至少选择一个字符，就会应用Ex命令。</p>\n<h2 id=\"跨多行编辑\"><a href=\"#跨多行编辑\" class=\"headerlink\" title=\"跨多行编辑\"></a>跨多行编辑</h2><p>您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = <span class=\"hljs-string\">&quot;one&quot;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = <span class=\"hljs-string\">&quot;two&quot;</span><br><span class=\"hljs-keyword\">const</span> three = <span class=\"hljs-string\">&quot;three&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>将光标放在第一行上：</p>\n<ul>\n<li>进入逐块可视模式，并向下两行(<code>Ctrl-V jj</code>)。</li>\n<li>高亮显示到行尾(<code>$</code>)。</li>\n<li>按(<code>A</code>) ，然后键入”;”。</li>\n<li>退出可视模式(<code>esc</code>)。</li>\n</ul>\n<p>您应该看到在每一行后面附加的 “;”。666! 有两种方法可以从逐块可视模式进入输入模式：可以使用<code>A</code>在光标后输入文本，也可以使用<code>I</code>在光标前输入文本。请勿将它们与普通模式下的<code>A</code>和<code>I</code>混淆。(普通模式中，<code>A</code>表示在行尾添加内容，<code>I</code>表示在行尾非空字符前插入内容)。</p>\n<p>另外，您也可以使用<code>:normal</code>命令在多行添加内容：<br>-高亮显示所有3行(<code>vjj</code>)。<br>-输入<code>:normal! A;</code>。</p>\n<p>记住，<code>:normal</code>命令执行普通模式命令。您可以指示它运行<code>A;</code>在该行的末尾添加文本”;”。</p>\n<h2 id=\"递增数字\"><a href=\"#递增数字\" class=\"headerlink\" title=\"递增数字\"></a>递增数字</h2><p>Vim有<code>Ctrl-X</code>和<code>Ctrl-A</code>命令来减少和增加数字。与可视模式一起使用时，可以跨多行递增数字。</p>\n<p>如果您具有以下HTML元素：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：</p>\n<ul>\n<li>将光标移动到 <strong>第二行</strong>的 “1”。</li>\n<li>启动逐块可视模式，并向下移动3行(<code>Ctrl-V 3j</code>)。这高亮显示剩余的”1”，现在除了第一行，所有的”1”应该已经高亮。</li>\n<li>运行<code>g Ctrl-A</code>。</li>\n</ul>\n<p>您应该看到以下结果：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-2&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-3&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-4&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-5&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>g Ctrl-A</code>在多行上递增数字。 <code>Ctrl-X/Ctrl-A</code>也可以增加字母。如果您运行：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">:<span class=\"hljs-built_in\">set</span> nrformats+=<span class=\"hljs-built_in\">alpha</span><br></code></pre></td></tr></table></figure>\n\n<p><code>nrformats</code>选项指示Vim将哪个基数视为<code>Ctrl-A</code>和<code>Ctrl-X</code>递增和递减的“数字”。通过添加<code>alpha</code>，现在将字母字符视为数字。如果您具有以下HTML元素：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>将光标放在第二个”app-a”上。使用与上述相同的技术(<code>Ctrl-V 3j</code> 然后 <code>g Ctrl-A</code>)增加ID。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-b&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-c&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-d&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-e&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"选择最后一个可视模式区域\"><a href=\"#选择最后一个可视模式区域\" class=\"headerlink\" title=\"选择最后一个可视模式区域\"></a>选择最后一个可视模式区域</h2><p>前面章节中我提到了<code>gv</code>可以快速高亮显示上一个可视模式选择的内容。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">&#x27;&lt;    转到上一个可视模式高亮显示的第一个位置（行）(译者注，英文原版中&#x27;&lt;&#x27;前面的符号是`，但这应该是一个错误，应该是单引号&#x27;)<br>&#x27;&gt;    转到上一个可视模式高亮显示的最后位置（行）<br></code></pre></td></tr></table></figure>\n\n<p>之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：<code>:s/const/let/g</code>。当您这样做时，您应该看到以下内容：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:<span class=\"hljs-string\">&#x27;&lt;,&#x27;</span>&gt;s/const/let/g</span><br></code></pre></td></tr></table></figure>\n\n<p>您实际上是在使用(<code>&#39;&lt;, &#39;&gt;</code>) 标记作为范围来执行 <code>s/const/let/g</code>命令。这太有趣了！</p>\n<p>您随时可以随时编辑这些标记。比如，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs julia\">:&#x27;&lt;,$s/<span class=\"hljs-keyword\">const</span>/<span class=\"hljs-keyword\">let</span>/g<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"从插入模式进入可视模式\"><a href=\"#从插入模式进入可视模式\" class=\"headerlink\" title=\"从插入模式进入可视模式\"></a>从插入模式进入可视模式</h2><p>您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">Ctrl-O v</span><br></code></pre></td></tr></table></figure>\n\n<p>回想一下，在插入模式下运行<code>Ctrl-O</code>可以使您执行普通模式命令。在普通模式命令挂起模式下，运行<code>v</code>进入逐字可视模式。请注意，在屏幕的左下方，它显示为<code>--(insert) VISUAL--</code>。该技巧适用于任何可视模式运算符：<code>v</code>，<code>V</code>，和<code>Ctrl-V</code>。</p>\n<h2 id=\"选择模式\"><a href=\"#选择模式\" class=\"headerlink\" title=\"选择模式\"></a>选择模式</h2><p>Vim具有类似于可视模式的模式，称为<em>选择模式</em>。与可视模式一样，它也具有三种不同的模式：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">gh</span>         逐字符选择模式<br>gH         逐行选择模式<br>gCtrl-h    逐块选择模式<br></code></pre></td></tr></table></figure>\n\n<p>选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。</p>\n<p>在常规编辑器中，高亮显示文本块并键入字母（例如字母”y”）后，它将删除高亮显示的文本并插入字母”y”。如果您使用逐行选择模式(<code>gH</code>)高亮显示一行文本并键入”y”，它将删除高亮显示的文本并插入字母”y”，这与常规文本编辑器非常相似。</p>\n<p>将此行为与可视模式进行对比：如果您使用逐行可视模式(<code>V</code>)高亮显示一行文本并键入”y”，则高亮显示的文本不会被删除且被字母”y”代替，而是仅将其复制(yank)。在选择模式中，你不能执行对高亮文本执行普通模式的命令。</p>\n<p>我个人从未使用过选择模式，但是很高兴知道它的存在。</p>\n<h2 id=\"以聪明的方式学习可视模式\"><a href=\"#以聪明的方式学习可视模式\" class=\"headerlink\" title=\"以聪明的方式学习可视模式\"></a>以聪明的方式学习可视模式</h2><p>可视模式是Vim高亮显示文本的过程。</p>\n<p>如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。假设您需要删除一个内部单词(inner word，请回顾前面的文本对象)，如果可以只用三个按键(<code>diw</code>)，为什么要使用四个按键<code>viwd</code>（先<code>v</code>进入可视模式，然后<code>iw</code>高亮一个内部单词，最后<code>d</code>删除）呢？前者更为直接和简洁。当然，有时使用可视模式是合适的，但总的来说，更倾向于直接的方法。</p>\n","site":{"data":{}},"wordcount":5251,"excerpt":"","more":"<h1 id=\"第11章-可视模式\"><a href=\"#第11章-可视模式\" class=\"headerlink\" title=\"第11章 可视模式\"></a>第11章 可视模式</h1><p>高亮显示文本块并对其进行更改，是很多文本编辑器中的常见功能。 Vim也可以使用可视模式实现这一功能。在本章中，您将学习如何使用可视模式来有效地处理文本块。</p>\n<h2 id=\"三种可视模式\"><a href=\"#三种可视模式\" class=\"headerlink\" title=\"三种可视模式\"></a>三种可视模式</h2><p>Vim有三种可视模式，分别是：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">v</span>         逐字符可视模式<br>V         逐行可视模式<br>Ctrl-v    逐块可视模式<br></code></pre></td></tr></table></figure>\n\n<p>如果您有下列文字：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>逐字符可视模式用于选择单个字符。在第一行的第一个字符上按<code>v</code>。然后使用<code>j</code>跳转至下一行。它高亮显示从”one”到光标位置的所有文本。现在，如果您按<code>gU</code>，Vim将高亮显示的字符转为大写。</p>\n<p>逐行可视模式适用于整行。按<code>V</code>并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行<code>gU</code>，Vim将高亮显示的字符转为大写。</p>\n<p>逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按<code>Ctrl-V</code>，Vim像逐字符可视模式一样高亮显示光标下的字符，但向下移动时，除非光标已经在行尾，否则不会高亮显示光标上方的整行，它跳转至下一行时高亮显示尽可能少的字符。尝试用<code>h/j/k/l</code>移动，并观察光标的移动。</p>\n<p>在Vim窗口的左下方，您会看到显示<code>-- VISUAL --</code>，<code>-- VISUAL LINE --</code>或<code>-- VISUAL BLOCK --</code>以提示您所处的可视模式。</p>\n<p>当您处于可视模式时，可以通过按<code>v</code>，<code>V</code>或<code>Ctrl-V</code>键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行<code>Ctrl-V</code>。试试吧！</p>\n<p>有三种退出可视模式的方法：<code>esc</code>，<code>Ctrl-C</code>和与当前可视模式相同的键。后者的意思是，如果您当前处于逐行可视模式(<code>V</code>)，则可以通过再次按<code>V</code>退出它。如果您处于字符可视模式，则可以通过按<code>v</code>退出它。如果您处于逐块可视模式，请按<code>Ctrl-V</code>。</p>\n<p>实际上，还有另一种进入可视模式的方式：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">gv</span>    转到上一个可视模式<br></code></pre></td></tr></table></figure>\n\n<p>它将在与上次相同的高亮显示的文本块上启动相同的可视模式。</p>\n<h2 id=\"可视模式导航\"><a href=\"#可视模式导航\" class=\"headerlink\" title=\"可视模式导航\"></a>可视模式导航</h2><p>在可视模式下，您可以使用Vim动作(motion)扩展高亮显示的文本块。</p>\n<p>让我们使用之前使用的相同文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>这次让我们从”two”行开始。按<code>v</code>进入字符可视模式(这里的方括号<code>[]</code>表示高亮显示的字符)：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">one<br><span class=\"hljs-string\">[t]</span>wo<br>three<br></code></pre></td></tr></table></figure>\n\n<p>按<code>j</code>，Vim将高亮显示从”two”行到”three”行的第一个字符的所有文本。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">one</span><br>[<span class=\"hljs-keyword\">two</span><br>t]hree<br></code></pre></td></tr></table></figure>\n\n<p>假设您刚刚意识到还需要高亮显示”one”行，因此按<code>k</code>。令您沮丧的是，它现在排除了”three”高亮。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">one<br><span class=\"hljs-string\">[t]</span>wo<br>three<br></code></pre></td></tr></table></figure>\n\n<p>有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？</p>\n<p>答案是肯定的。让我们先恢复光标到高亮显示”two”和”three”行的位置。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">one</span><br>[two<br>t]hree    <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-comment\">-- 光标</span><br></code></pre></td></tr></table></figure>\n\n<p>高亮区域跟随光标移动。如果要将其向上扩展到行”one”，则需要将光标移动到”two”，现在您的光标在”three”行上。这时可以用<code>o</code>或<code>O</code>切换光标位置。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">one</span><br>[two     <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-comment\">-- 光标</span><br>t]hree<br></code></pre></td></tr></table></figure>\n\n<p>现在，当您按<code>k</code>时，它不再缩小选择，而是向上扩展。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">[<span class=\"hljs-keyword\">one</span><br><span class=\"hljs-keyword\">two</span><br>t]hree<br></code></pre></td></tr></table></figure>\n\n<p>在可视模式中使用<code>o</code>或<code>O</code>，光标会在高亮选择区域的开头和结尾跳转，以便与您扩展高亮区域。</p>\n<h2 id=\"可视模式语法\"><a href=\"#可视模式语法\" class=\"headerlink\" title=\"可视模式语法\"></a>可视模式语法</h2><p>可视模式与普通模式使用相同的操作符(operations)。</p>\n<p>例如，如果您有以下文字，然后您想在可视模式中删除前两行：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br></code></pre></td></tr></table></figure>\n\n<p>用逐行可视模式(<code>V</code>)高亮显示”one”和”two”行：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">[<span class=\"hljs-keyword\">one</span><br><span class=\"hljs-keyword\">two</span>]<br>three<br></code></pre></td></tr></table></figure>\n\n<p>按下<code>d</code>键将删除选择，类似于普通模式。请注意，与普通模式的语法规则有所不同，动词+名词不适用可视模式。虽然存在相同的动词(<code>d</code>)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词(反过来了)，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。</p>\n<p>在普通模式下，有一些命令不需要名词(motion)，例如<code>x</code>删除光标下方的单个字符，还有<code>r</code>替换光标下方的字符(<code>rx</code>将当前光标下的字符替换为<code>x</code>)。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。回到高亮显示的文本：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">[<span class=\"hljs-keyword\">one</span><br><span class=\"hljs-keyword\">two</span>]<br>three<br></code></pre></td></tr></table></figure>\n\n<p>运行<code>x</code>会删除所有高亮显示的文本。</p>\n<p>您可以使用此行为在markdown文本中快速创建标题。假设您需要快速下面的文本转换为一级markdown标题(“&#x3D;&#x3D;&#x3D;”):</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">Chapter One</span><br></code></pre></td></tr></table></figure>\n\n<p>首先，您使用<code>yy</code>复制文本，然后使用<code>p</code>粘贴文本：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"><span class=\"hljs-section\">Chapter One</span><br><span class=\"hljs-section\">Chapter One</span><br></code></pre></td></tr></table></figure>\n\n<p>现在转到第二行，以逐行可视模式选择它：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"><span class=\"hljs-section\">Chapter One</span><br><span class=\"hljs-comment\">[Chapter One]</span><br></code></pre></td></tr></table></figure>\n\n<p>在markdown中，您可以通过在文本下方添加一系列<code>=</code>来创建标题，因此您可以通过运行<code>r=</code>来替换整个高亮显示的文本：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">Chapter One<br><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><br></code></pre></td></tr></table></figure>\n\n<p>要了解有关可视模式下的运算符的更多信息，请查看<code>:h visual-operators</code>。</p>\n<h2 id=\"可视模式和Ex命令\"><a href=\"#可视模式和Ex命令\" class=\"headerlink\" title=\"可视模式和Ex命令\"></a>可视模式和Ex命令</h2><p>您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式,并想将前两行的”const”替换为”let”：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;one&quot;</span><span class=\"hljs-comment\">;</span><br>const two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;two&quot;</span><span class=\"hljs-comment\">;</span><br>const three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;three&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>用 <em>任意</em> 可视模式高亮显示前两行，然后运行替换命令<code>:s/const/let/g</code>：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;one&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;two&quot;</span><span class=\"hljs-comment\">;</span><br>const three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;three&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>请注意，我说过您可以使用 <em>任何</em> 可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。只要您在每行上至少选择一个字符，就会应用Ex命令。</p>\n<h2 id=\"跨多行编辑\"><a href=\"#跨多行编辑\" class=\"headerlink\" title=\"跨多行编辑\"></a>跨多行编辑</h2><p>您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = <span class=\"hljs-string\">&quot;one&quot;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = <span class=\"hljs-string\">&quot;two&quot;</span><br><span class=\"hljs-keyword\">const</span> three = <span class=\"hljs-string\">&quot;three&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>将光标放在第一行上：</p>\n<ul>\n<li>进入逐块可视模式，并向下两行(<code>Ctrl-V jj</code>)。</li>\n<li>高亮显示到行尾(<code>$</code>)。</li>\n<li>按(<code>A</code>) ，然后键入”;”。</li>\n<li>退出可视模式(<code>esc</code>)。</li>\n</ul>\n<p>您应该看到在每一行后面附加的 “;”。666! 有两种方法可以从逐块可视模式进入输入模式：可以使用<code>A</code>在光标后输入文本，也可以使用<code>I</code>在光标前输入文本。请勿将它们与普通模式下的<code>A</code>和<code>I</code>混淆。(普通模式中，<code>A</code>表示在行尾添加内容，<code>I</code>表示在行尾非空字符前插入内容)。</p>\n<p>另外，您也可以使用<code>:normal</code>命令在多行添加内容：<br>-高亮显示所有3行(<code>vjj</code>)。<br>-输入<code>:normal! A;</code>。</p>\n<p>记住，<code>:normal</code>命令执行普通模式命令。您可以指示它运行<code>A;</code>在该行的末尾添加文本”;”。</p>\n<h2 id=\"递增数字\"><a href=\"#递增数字\" class=\"headerlink\" title=\"递增数字\"></a>递增数字</h2><p>Vim有<code>Ctrl-X</code>和<code>Ctrl-A</code>命令来减少和增加数字。与可视模式一起使用时，可以跨多行递增数字。</p>\n<p>如果您具有以下HTML元素：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：</p>\n<ul>\n<li>将光标移动到 <strong>第二行</strong>的 “1”。</li>\n<li>启动逐块可视模式，并向下移动3行(<code>Ctrl-V 3j</code>)。这高亮显示剩余的”1”，现在除了第一行，所有的”1”应该已经高亮。</li>\n<li>运行<code>g Ctrl-A</code>。</li>\n</ul>\n<p>您应该看到以下结果：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-1&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-2&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-3&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-4&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-5&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>g Ctrl-A</code>在多行上递增数字。 <code>Ctrl-X/Ctrl-A</code>也可以增加字母。如果您运行：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\">:<span class=\"hljs-built_in\">set</span> nrformats+=<span class=\"hljs-built_in\">alpha</span><br></code></pre></td></tr></table></figure>\n\n<p><code>nrformats</code>选项指示Vim将哪个基数视为<code>Ctrl-A</code>和<code>Ctrl-X</code>递增和递减的“数字”。通过添加<code>alpha</code>，现在将字母字符视为数字。如果您具有以下HTML元素：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>将光标放在第二个”app-a”上。使用与上述相同的技术(<code>Ctrl-V 3j</code> 然后 <code>g Ctrl-A</code>)增加ID。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-a&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-b&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-c&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-d&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br>&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;app-e&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"选择最后一个可视模式区域\"><a href=\"#选择最后一个可视模式区域\" class=\"headerlink\" title=\"选择最后一个可视模式区域\"></a>选择最后一个可视模式区域</h2><p>前面章节中我提到了<code>gv</code>可以快速高亮显示上一个可视模式选择的内容。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">&#x27;&lt;    转到上一个可视模式高亮显示的第一个位置（行）(译者注，英文原版中&#x27;&lt;&#x27;前面的符号是`，但这应该是一个错误，应该是单引号&#x27;)<br>&#x27;&gt;    转到上一个可视模式高亮显示的最后位置（行）<br></code></pre></td></tr></table></figure>\n\n<p>之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：<code>:s/const/let/g</code>。当您这样做时，您应该看到以下内容：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:<span class=\"hljs-string\">&#x27;&lt;,&#x27;</span>&gt;s/const/let/g</span><br></code></pre></td></tr></table></figure>\n\n<p>您实际上是在使用(<code>&#39;&lt;, &#39;&gt;</code>) 标记作为范围来执行 <code>s/const/let/g</code>命令。这太有趣了！</p>\n<p>您随时可以随时编辑这些标记。比如，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs julia\">:&#x27;&lt;,$s/<span class=\"hljs-keyword\">const</span>/<span class=\"hljs-keyword\">let</span>/g<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"从插入模式进入可视模式\"><a href=\"#从插入模式进入可视模式\" class=\"headerlink\" title=\"从插入模式进入可视模式\"></a>从插入模式进入可视模式</h2><p>您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">Ctrl-O v</span><br></code></pre></td></tr></table></figure>\n\n<p>回想一下，在插入模式下运行<code>Ctrl-O</code>可以使您执行普通模式命令。在普通模式命令挂起模式下，运行<code>v</code>进入逐字可视模式。请注意，在屏幕的左下方，它显示为<code>--(insert) VISUAL--</code>。该技巧适用于任何可视模式运算符：<code>v</code>，<code>V</code>，和<code>Ctrl-V</code>。</p>\n<h2 id=\"选择模式\"><a href=\"#选择模式\" class=\"headerlink\" title=\"选择模式\"></a>选择模式</h2><p>Vim具有类似于可视模式的模式，称为<em>选择模式</em>。与可视模式一样，它也具有三种不同的模式：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">gh</span>         逐字符选择模式<br>gH         逐行选择模式<br>gCtrl-h    逐块选择模式<br></code></pre></td></tr></table></figure>\n\n<p>选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。</p>\n<p>在常规编辑器中，高亮显示文本块并键入字母（例如字母”y”）后，它将删除高亮显示的文本并插入字母”y”。如果您使用逐行选择模式(<code>gH</code>)高亮显示一行文本并键入”y”，它将删除高亮显示的文本并插入字母”y”，这与常规文本编辑器非常相似。</p>\n<p>将此行为与可视模式进行对比：如果您使用逐行可视模式(<code>V</code>)高亮显示一行文本并键入”y”，则高亮显示的文本不会被删除且被字母”y”代替，而是仅将其复制(yank)。在选择模式中，你不能执行对高亮文本执行普通模式的命令。</p>\n<p>我个人从未使用过选择模式，但是很高兴知道它的存在。</p>\n<h2 id=\"以聪明的方式学习可视模式\"><a href=\"#以聪明的方式学习可视模式\" class=\"headerlink\" title=\"以聪明的方式学习可视模式\"></a>以聪明的方式学习可视模式</h2><p>可视模式是Vim高亮显示文本的过程。</p>\n<p>如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。假设您需要删除一个内部单词(inner word，请回顾前面的文本对象)，如果可以只用三个按键(<code>diw</code>)，为什么要使用四个按键<code>viwd</code>（先<code>v</code>进入可视模式，然后<code>iw</code>高亮一个内部单词，最后<code>d</code>删除）呢？前者更为直接和简洁。当然，有时使用可视模式是合适的，但总的来说，更倾向于直接的方法。</p>\n"},{"title":"VIM-搜索和替换","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第12章 搜索和替换\n\n本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您得基于文本的共同模式搜索大量的内容。通过学习如何在搜索和替换中使用正则表达式而不是字面字符串，您将能够快速定位任何文本。\n\n附带说明一下，在本章中，当谈论搜索时，我将主要使用`/`。您使用`/`进行的所有操作也可以使用`?`完成。\n\n## 智能区分大小写\n\n尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本\"Learn Vim\"，则很容易把字母的大小写输错，从而得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项`ignorecase`闪亮的地方。只需在 vimrc 中添加`set ignorecase`，所有搜索词就不区分大小写。现在，您不必再执行`/Learn Vim`了。 `/learn vim`将起作用。\n\n但是，有时您需要搜索特定大小写的短语。一种方法是用 `set noignorecase` 关闭`ignorecase`选项，但是每次需要搜索区分大小写的短语时，都得反复地打开和关闭这个选项。\n\n为避免反复开关`ignorecase`选项，Vim 有一个`smartcase`选项。您可以将`ignorecase`和`smartcase`选项结合起来，当您输入的搜索词全部是小写时，进行大小写不敏感搜索；而当搜索词 **至少有1个大写字母时**，进行大小写敏感搜索。\n\n在您的 vimrc 中，添加:\n\n```\nset ignorecase smartcase\n```\n\n如果您有这些文字:\n\n```\nhello\nHELLO\nHello\n```\n\n- `/hello` 匹配\"hello\"，\"HELLO\"和\"Hello\"。\n- `/HELLO` 仅匹配\"HELLO\"。\n- `/Hello` 仅匹配\"Hello\"。\n\n有一个缺点。因为现在当您执行`/hello`时，Vim 将进行大小写不敏感搜索,那如果只需要搜索小写字符串怎么办？您可以在搜索词前使用`\\C`模式来告诉 Vim，后续搜索词将区分大小写。如果执行`/\\Chello`，它将严格匹配\"hello\"，而不是\"HELLO\"或\"Hello\"。\n\n## 一行中的第一个和最后一个字符\n\n您可以使用`^`匹配行中的第一个字符，并使用`$`匹配行中的最后一个字符。\n\n如果您有以下文字:\n\n```\nhello hello\n```\n\n您可以使用`/^hello`来定位第一个\"hello\"。 '^'后面的字符必须是一行中的第一个字符。 要定位最后一个\"hello\"，请运行`/hello$`。 '\\$' 之前的字符必须是一行中的最后一个字符。\n\n如果您有以下文字:\n\n```\nhello hello friend\n```\n\n运行`/hello$`将匹配不到任何内容，因为\"friend\"是该行的最后一项，而不是\"hello\"。\n\n## 重复搜索\n\n您可以使用`//`重复上一个搜索。如果您只是搜索`/hello`，则运行`//`等同于运行`/hello`。此快捷键可以为您节省一些按键操作，尤其是在您刚搜索了一个很长的字符串的情况下。另外，回想一下前面的章节，您还可以使用`n`和`N`分别以相同方向和相反方向重复上一次搜索。\n\n如果您想快速回忆起 第*n*个最近使用的搜索字怎么办？您可以先按`/`，然后按`up`/`down`方向键（或`Ctrl-N`/`Ctrl-P`），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行`:history /`。\n\n在搜索过程中到达文件末尾时，Vim 会抛出一个错误:`\"搜索到达底部,未找到匹配项:{your-search}\"`(`\"Search hit the BOTTOM without match for: {your-search}\"`)。有时这个特性能成为一个安全守卫，可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用`set wrapscan`选项使 Vim 在到达文件末尾时回到文件顶部进行搜索。要关闭此功能，请执行`set nowrapscan`。\n\n## 使用候选词搜索\n\n一次搜索多个单词属于日常操作。 如果您需要搜索\"hello vim\"或\"hola vim\"，而不是\"salve vim\"或\"bonjour vim\"，则可以使用`|`或运算符。\n\n给予这样一段文本:\n\n```\nhello vim\nhola vim\nsalve vim\nbonjour vim\n```\n\n要同时匹配\"hello\"和\"hola\"，可以执行`/hello\\|hola`。 您必须使用（`\\`）转义（`|`）或运算符，否则 Vim 将按字面意义搜索字符串\"|\"。\n\n如果您不想每次都输入`\\|`，则可以在搜索开始时使用`magic`语法（`\\v`）:`/\\vhello|hola`。 我不会在本章中详细介绍`magic`，但是有了`\\v`，您就不必再转义特殊字符了。 要了解有关`\\v`的更多信息，请随时查看`:h \\v`。\n\n## 设置模式匹配的开始位置和结束位置\n\n也许您需要搜索的文本是复合词的一部分。如果您有这些文字:\n\n```\n11vim22\nvim22\n11vim\nvim\n```\n\n如果您仅需要选择以\"11\"开始、以\"22\"结束的\"vim\"，您可以使用`\\zs`（开始匹配）和`\\ze`（结束匹配）运算符。 执行:\n\n```\n/11\\zsvim\\ze22\n```\n\nVim仍然会匹配整个模式\"11vim22\"，但是仅高亮显示介于`\\zs`和`\\ze`之间的内容。 另一个例子:\n\n```\nfoobar\nfoobaz\n```\n\n如果需要在\"foobaz\"中搜索\"foo\"，而不是在\"foobar\"中搜索，请运行:\n\n```\n/foo\\zebaz\n```\n\n## 搜索字符组\n\n到目前为止，您所有的搜索字都是字面内容。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符组`[ ]`。\n\n如果您需要搜索任何数字，则可能不想每一次都输入`/0\\|1\\|2\\|3\\|4\\|5\\|6\\|7\\|8\\|9\\|0`。相反，请使用`/[0-9]`来匹配一位数字。 `0-9`表达式表示 Vim 尝试匹配的数字范围是 0-9，因此，如果要查找 1 到 5 之间的数字，请使用`/[1-5]`。\n\n数字不是 Vim 可以查找的唯一数据类型。您也可以执行`/[a-z]`来搜索小写字母，而`/[A-Z]`来搜索大写字母。\n\n您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行`/[0-9a-fA-F]`。\n\n要进行否定搜索，可以在字符范围括号内添加`^`。要搜索非数字，请运行`/[^0-9]`，Vim会匹配任何字符，只要它不是数字即可。请注意，范围括号内的脱符号（`^`）与行首位置符号（例如:`/^hello`）不同。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示\"一行中的第一个字符\"。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 `/^abc`匹配行中的第一个\"abc\"，而`/[^abc]`匹配除\"a\"，\"b\"或\"c\"以外的任何字符。\n\n## 搜索重复字符\n\n如果需要在此文本中搜索两位数:\n\n```\n1aa\n11a\n111\n```\n\n您可以使用`/[0-9][0-9]`来匹配两位数字字符，但是该方法难以扩展。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个`count`参数。\n\n您可以将`count`传递给您的搜索。 它具有以下语法:\n\n```\n{n,m}\n```\n\n顺便说一句，当在 Vim 中使用它们时，这些`count`周围的花括号需要被转义。 `count` 运算符放在您要递增的单个字符之后。\n\n这是`count`语法的四种不同变体: \n- `{n}`是精确匹配。 `/[0-9]\\{2\\}`匹配两个数字:\"11\"，以及\"111\"中的\"11\"。\n- `{n,m}`是范围匹配。 `/[0-9]\\{2,3\\}`匹配 2 到 3 位数字:\"11\"和\"111\"。 \n- `{,m}`是上限匹配。 `/[0-9]\\{,3\\}`匹配最多 3 个数字:\"1\"，\"11\"和\"111\"。\n- `{n,}`是下限匹配。 `/[0-9]\\{2,\\}`匹配最少 2 个或多个数字:\"11\"和\"111\"。\n\n计数参数`\\{0,\\}`（零或多个）和`\\{1,\\}`（一个或多个）是最常见的搜索模式，Vim 为它们提供了特殊的操作符:`*`和`+`（ `+`需要被转义，而`*` 可以正常运行而无需转义）。 如果执行`/[0-9]*`，功能与`/[0-9]\\{0,\\}`相同。 它搜索零个或多个数字，会匹配\"\"，\"1\"，\"123\"。 顺便说一句，它也将匹配非数字，例如\"a\"，因为在技术上，字母\"a\"中的数字个数为零。 在使用\"\\*\"之前，请仔细考虑。 如果执行`/[0-9]\\+`，则与`/[0-9]\\{1,\\}`相同。 它搜索一个或多个数字，将匹配\"1\"和\"12\"。\n\n## 预定义的字符组\n\nVim 为常见字符组（例如数字和字母）提供了简写。 我不会在这里逐一介绍，但可以在`:h /character-classes`中找到完整列表。 下面是有用的部分:\n\n```\n\\d    数字[0-9]\n\\D    非数字[^ 0-9]\n\\s    空格字符（空格和制表符）\n\\S    非空白字符（除空格和制表符外的所有字符）\n\\w    单词字符[0-9A-Za-z_]\n\\l    小写字母[a-z]\n\\u    大写字符[A-Z]\n```\n\n您可以像使用普通字符组一样使用它们。 要搜索任何一位数字，可以使用`/\\d`以获得更简洁的语法，而不使用`/[0-9]`。\n\n## 搜索示例：在一对相似字符之间捕获文本\n\n如果要搜索由双引号引起来的短语:\n\n```\n\"Vim is awesome!\"\n```\n\n运行这个:\n\n```\n`/\"[^\"]\\+\"`\n```\n\n让我们分解一下:\n- `\"` 是字面双引号。它匹配第一个双引号。\n- `[^\"]` 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。\n- `\\+`表示一个或多个。因为它的前面是`[^\"]`，因此 Vim 查找一个或多个不是双引号的字符。\n- `\"` 是字面双引号。它与右双引号匹配。\n\n当看到第一个`\"`时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个`\"`模式并停止模式捕获。同时，两个双引号之间的所有非双引号字符都被`[^\"]\\+` 模式捕获，在这个例子中是短语\"Vim is awesome!\"。这是一个通用模式（其实就是正则表达式）用于捕获 **由一对类似的定界符包围的短语**。\n\n- 要捕获被单引号包围的短语，你可以使用`/'[^']\\+'`\n- 要捕获为0包围的短语，你可以使用`/0[^0]\\+0`\n\n## 搜索示例：捕获电话号码\n\n如果要匹配以连字符(`-`)分隔的美国电话号码，例如`123-456-7890`，则可以使用:\n\n```\n/\\d\\{3\\}-\\d\\{3\\}-\\d\\{4\\}\n```\n\n美国电话号码的组成是：首先是三位数字，其后是另外三位数字，最后是另外四位数字。 让我们分解一下:\n- `\\d\\{3\\}`与精确重复三次的数字匹配\n- `-`是字面的连字符\n\n为避免转义，可使用`\\v`:\n\n```\n/\\v\\d{3}-\\d{3}-\\d{4}\n```\n\n此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。\n\n这涵盖了本章的搜索部分。 现在开始讲替换。\n\n## 基本替换\n\nVim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:\n\n```\n:s/{old-pattern}/{new-pattern}/\n```\n\n让我们从一个基本用法开始。 如果您有以下文字:\n\n```\nvim is good\n```\n\n让我们用\"awesome\"代替\"good\"，因为 Vim 很棒。 运行`:s/good/awesome/.`您应该看到:\n\n```\nvim is awesome\n```\n\n## 重复最后一次替换\n\n您可以使用普通模式命令`&`或运行`:s`来重复最后一个替代命令。 如果您刚刚运行`:s/good/awesome/`，则运行`&`或`:s`将会重复执行。\n\n另外，在本章前面，我提到您可以使用`//`来重复先前的搜索模式。 此技巧可用于替代命令。 如果`/good`是最近被替换的单词，那么将第一个替换模式参数留为空白，例如在`:s//awesome/`中，则与运行`:s/good/awesome/`相同。\n\n## 替换范围\n\n就像许多 Ex 命令一样，您可以将范围参数传递给替换命令。 语法为:\n\n```\n:[range]s/old/new/\n```\n\n如果您有以下表达式:\n\n```\nlet one = 1;\nlet two = 2;\nlet three = 3;\nlet four = 4;\nlet five = 5;\n```\n\n要将第3行到第5行中的\"let\"替换为\"const\"，您可以执行以下操作:\n\n```\n:3,5s/let/const/\n```\n\n下面是一些你可以使用的范围参数的变体:\n\n- `:,3/let/const/` - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换到第 3 行。\n- `:1,s/let/const/` - 如果逗号后没有给出任何内容，它也代表当前行。 从第 1 行替换到当前行。\n- `:3s/let/const/` - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。\n\n在 Vim 中，`%`通常表示整个文件。 如果运行`:%s/let/const/`，它将在所有行上进行替换。请记住这个范围参数语法，在后面章节中很多命令行命令都遵循这个语法。\n\n## 模式匹配\n\n接下来的几节将介绍基本的正则表达式。 丰富的模式知识对于掌握替换命令至关重要。\n\n如果您具有以下表达式:\n\n```\nlet one = 1;\nlet two = 2;\nlet three = 3;\nlet four = 4;\nlet five = 5;\n```\n\n要在数字周围添加一对双引号:\n\n```\n:%s/\\d/\"\\0\"/\n```\n\n结果:\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\n```\n\n让我们分解一下命令:\n- `:%s` 定位整个文件以执行替换。\n- `\\d` 是 Vim 的预定义数字范围简写(类似使用`[0-9]`)。\n- `\"\\0\"` 双引号是双引号的字面值。 `\\0`是一个特殊字符，代表\"整个匹配的模式\"。 此处匹配的模式是单个数字`\\d`。\n\n另外，`&`也同样代表\"整个匹配的模式\"，就像`\\0`一样。 `:s/\\d/\"&\"/`也可以。\n\n让我们考虑另一个例子。 给出以下表达式，您需要将所有的\"let\"和变量名交换位置:\n\n```\none let = \"1\";\ntwo let = \"2\";\nthree let = \"3\";\nfour let = \"4\";\nfive let = \"5\";\n```\n\n为此，请运行:\n\n```\n:%s/\\(\\w\\+\\) \\(\\w\\+\\)/\\2 \\1/\n```\n\n上面的命令包含太多的反斜杠，很难阅读。 使用`\\v`运算符更方便:\n\n```\n:%s/\\v(\\w+) (\\w+)/\\2 \\1/\n```\n\n结果:\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\n```\n\n太好了！ 让我们分解该命令:\n- `:%s` 定位文件中的所有行以执行替换操作\n- `(\\w+) (\\w+)`对模式进行分组。`\\w`是 Vim 预定义的单词字符范围简写(`[0-9A-Za-z_]`)之一。 包围`\\w`的`()`将匹配的单词字符进行分组。 请注意两个分组之间的空间。 `(\\w+) (\\w+)` 捕获两个分组。 在第一行上，第一组捕获\"let\"，第二组捕获\"one\"。(英文版中，作者写成了：第一组捕获\"one\"，第二组捕获\"two\"，可能是作者不小心的错误)。\n- `\\2 \\1` 以相反的顺序返回捕获的组。 `\\2`包含捕获的字符串\"let\"，而`\\1`包含字符串\"one\"。 使`\\2 \\1`返回字符串\"let one\"。\n\n回想一下，`\\0`代表整个匹配的模式。 您可以使用`( )`将匹配的字符串分成较小的组。 每个组都由`\\1`, `\\2`, `\\3`等表示。\n\n让我们再举一个例子来巩固这一匹配分组的概念。 如果您有以下数字:\n\n```\n123\n456\n789\n```\n\n要颠倒顺序，请运行:\n\n```\n:%s/\\v(\\d)(\\d)(\\d)/\\3\\2\\1/\n```\n\n结果是:\n\n```\n321\n654\n987\n```\n\n每个`(\\d)`都匹配一个数字并创建一个分组。 在第一行上，第一个`(\\d)`的值为\"1\"，第二个`(\\d)`的值为\"2\"，第三个`(\\d)`的值为\"3\"。 它们存储在变量`\\1`，`\\2`和`\\3`中。 在替换的后半部分，新模式`\\3\\2\\1`在第一行上产生\"321\"值。\n\n相反，如果您运行下面的命令:\n\n```\n:%s/\\v(\\d\\d)(\\d)/\\2\\1/\n```\n您将获得不同的结果:\n\n```\n312\n645\n978\n```\n\n这是因为您现在只有两个组。 被`(\\d\\d)`捕获的第一组存储在`\\1`内，其值为\"12\"。 由`(\\d)`捕获的第二组存储在`\\2`内部，其值为\"3\"。 然后，`\\2\\1`返回\"312\"。\n\n## 替换标志\n\n如果您有以下句子:\n\n```\nchocolate pancake, strawberry pancake, blueberry pancake\n```\n\n要将所有 pancakes 替换为 donut，您不能只运行:\n\n```\n:s/pancake/donut\n```\n\n上面的命令将仅替换第一个匹配项，返回的结果是:\n\n```\nchocolate donut, strawberry pancake, blueberry pancake\n```\n\n有两种解决方法。 一，您可以再运行两次替代命令。 二，您可以向其传递全局(`g`)标志来替换一行中的所有匹配项。\n\n让我们谈谈全局标志。 运行:\n\n```\n:s/pancake/donut/g\n```\n\nVim 迅速将所有\"pancake\"替换为\"donut\"。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:\n\n```\n&    重用上一个替代命令中的标志。 必须作为第一个标志传递。\ng    替换行中的所有匹配项。\nc    要求替代确认。\ne    防止替换失败时显示错误消息。\ni    执行不区分大小写的替换\nI    执行区分大小写的替换\n```\n\n我上面没有列出更多标志。 要了解所有标志，请查看`:h s_flags`。\n\n顺便说一句，重复替换命令（`&`和`:s`）不保留标志。 运行`&`只会重复`:s/pancake/donut/`而没有`g`。 要使用所有标志快速重复最后一个替代命令，请运行`:&&`。\n\n## 更改定界符\n\n如果您需要用长路径替换 URL:\n\n```\nhttps://mysite.com/a/b/c/d/e\n```\n\n要用单词\"hello\"代替它，请运行:\n\n```\n:s/https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e/hello/\n```\n\n但是，很难说出哪些正斜杠（`/`）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或`\"`，`|`和`\\`之外的字符）来更改定界符。让我们将它们替换为`+`。上面的替换命令可以重写为 :\n\n```\n:s+https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e+hello+\n```\n\n现在，更容易看到分隔符在哪里。\n\n## 特殊替换\n\n您还可以修改要替换的文本的大小写。 给出以下表达式，您的任务是将所有变量名比如 \"one\", \"two\", \"three\"等，改成大写:\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\n```\n\n请运行:\n\n```\n%s/\\v(\\w+) (\\w+)/\\1 \\U\\2/\n```\n\n你会得到:\n\n```\nlet ONE = \"1\";\nlet TWO = \"2\";\nlet THREE = \"3\";\nlet FOUR = \"4\";\nlet FIVE = \"5\";\n```\n\n这是该命令的细分:\n- `(\\w+) (\\w+)`捕获前两个匹配的分组，例如\"let\"和\"one\"。\n- `\\1`返回第一个组的值\"let\"\n- `\\U\\2`大写(`\\U`)第二组(`\\2`)。\n\n该命令的窍门是表达式`\\U\\2`。`\\U`将后面跟着的字符变为大写。\n\n让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。\n\n```\nvim is the greatest text editor in the whole galaxy\n```\n\n您可以运行:\n\n```\n:s/\\<./\\U&/g\n```\n\n结果:\n\n```\nVim Is The Greatest Text Editor In The Whole Galaxy\n```\n\n细目如下:\n- `:s` 替换当前行\n- `\\<.` 由两部分组成:`\\<`匹配单词的开头，`.`匹配任何字符。 `\\<`运算符使后面跟着的字符表示单词的第一个字符。 由于`.`是下一个字符，因此它将匹配任意单词的第一个字符。\n- `\\U&` 将后续符号子序列`&`大写。 回想一下，`&`（或`\\0`）代表整个匹配。 这里它匹配单词的第一个字符。\n- `g`全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。\n\n要了解替换的特殊替换符号（如`\\u`和`\\U`）的更多信息，请查看`:h sub-replace-special`。\n\n## 候选模式\n\n有时您需要同时匹配多个模式。 如果您有以下问候:\n\n```\nhello vim\nhola vim\nsalve vim\nbonjour vim\n```\n\n您仅需在包含单词\"hello\"或\"hola\"的行上用\"friend\"代替\"vim\"。回想一想本章前面的知识点，你可以使用`|` 来分隔可选的模式:\n\n```\n:%s/\\v(hello|hola) vim)/\\1 friend/g\n```\n\n结果:\n\n```\nhello friend\nhola friend\nsalve vim\nbonjour vim\n```\n\n这是细分:\n- `%s` 在文件的每一行上运行替代命令。\n- `(hello|hola)` 匹配\\*\"hello\"或\"hola\"，并将其视为一个组。\n- `vim` 是字面意思\"vim\"。\n- `\\1` 是第一个匹配组，它是文本\"hello\"或\"hola\"。\n- `friend` 是字面的“朋友\"。\n\n## 指定替换模式的开始位置和结束位置\n\n回想一下，您可以使用`\\zs`和`\\ze`来指定一个匹配的开始位置和结束位置。这个技术在替换操作中同样有效，如果你有以下文本：\n\n```\nchocolate pancake\nstrawberry sweetcake\nblueberry hotcake\n```\n\n要想将\"hotcake\"中的\"cake\"替换为\"dog\"，得到\"hotdog\":\n\n```\n:%s/hot\\zscake/dog/g\n```\n\n结果是：\n\n```\nchocolate pancake\nstrawberry sweetcake\nblueberry hotdog\n```\n\n## 贪婪与非贪婪\n\n您可以使用下面技巧，在某行中替换第n个匹配：\n\n```\nOne Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.\n```\n\n要想将第3个\"Mississippi\"替换为 \"Arkansas\"，运行：\n\n```\n:s/\\v(.{-}\\zsMississippi){3}/Arkansas/g\n```\n\n命令分解：\n- `:s/` 替换命令。\n- `\\v` 魔术关键字，使您不必转义特殊字符。\n- `.` 匹配任意单个字符。\n- `{-}` 表示使用非贪婪模式匹配前面的0个或多个字符。\n- `\\zsMississippi` 使得从\"Mississippi\"开始捕获匹配。\n- `(...){3}` 查找第3个匹配\n\n在本章前面的内容中，你已经看到过`{3}`这样的语法。在本例中，`{3}`将精确匹配第3个匹配。这里的新技巧是`{-}`。它表示进行非贪婪匹配。它会找到符合给定模式的最短的匹配。在本例中，`(.{-}Mississippi)`匹配以任意字符开始、数量最少的\"Mississippi\"。对比`(.*Mississippi)`，后者会找到符合给定模式的最长匹配。\n\n如果您使用`(.{-}Mississippi)`，你会得到5个匹配：\"One Mississippi\", \"Two Mississippi\",等。如果您使用`(.*Mississippi)`，您只会得到1个匹配：最后一个 \"Mississippi\"。`*`表示贪婪匹配，而`{-}`表示非贪婪匹配。要想了解更多，可以查看 `:h /\\{-` 和 `:h non-greedy`。\n\n让我们看一个简单的例子。如果您有以下字符串：\n\n```\nabc1de1\n```\n\n用贪婪模式匹配 \"abc1de1\" ：\n\n```\n/a.*1\n```\n\n用非贪婪模式匹配 \"abc1\"：\n\n```\n/a.\\{-}1\n```\n\n因此，如果您需要将最长的匹配转为大写（贪婪模式），运行：\n\n```\n:s/a.*1/\\U&/g\n```\n\n会得到：\n\n```\nABC1DE1\n```\n\n如果您需要将最短的匹配转为大写（非贪婪模式），运行：\n\n```\n:s/a.\\{-}1/\\U&/g\n```\n\n会得到：\n\n```\nABC1de1\n```\n\n如果您是第一次接触贪婪模式与非贪婪模式这两个概念，可能会把你绕晕。围绕不同的组合去实验，知道您明白这两个概念。\n\n## 跨多个文件替换\n\n最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: `food.txt` 和 `animal.txt`.\n\n`food.txt`内:\n\n```\ncorn dog\nhot dog\nchili dog\n```\n\n`animal.txt`内:\n\n```\nlarge dog\nmedium dog\nsmall dog\n```\n\n假设您的目录结构如下所示:\n\n```\n├ food.txt\n├ animal.txt\n```\n\n首先，用`:args`同时捕获\"food.txt\"和\"animal.txt\"到参数列表中。回顾前面的章节，`:args`可用于创建文件名列表。在 Vim 中有几种方法可以做到这一点，其中一种方法是在Vim内部运行:\n\n```\n:args *.txt                  捕获当前位置的所有txt文件\n```\n\n测试一下，当您运行`:args`时，您应该会看到：\n\n```\n[food.txt] animal.txt\n```\n\n现在，所有的相关文件都已经存储在参数列表中，您可以用 `:argdo` 命令跨多文件替换，运行：\n\n```\n:argdo %s/dog/chicken/\n```\n\n这条命令对所有`:args`列表中的文件执行替换操作。最终，存储修改的文件：\n\n```\n:argdo update\n```\n\n`:args` 和 `:argdo` 是两个有用的工具，用于跨多文件执行命令行命令。可以用其他命令结合尝试一下！\n\n## 用宏跨多个文件替换\n\n另外，您也可以用宏跨多个文件运行替代命令。执行:\n\n```\n:args *.txt\nqq\n:%s/dog/chicken/g\n:wnext\nq\n99@q\n```\n\n以下是步骤的细分:\n- `:args *.txt` 会将相关文件列出到`:args`列表中。\n- `qq` 启动\"q\"寄存器中的宏。\n- `:%s/dog/chicken/g`在当前文件的所有行上用\"chicken\"替换\"dog\"。\n- `:wnext` 写入（保存）文件，然后转到`args`列表中的下一个文件。就像同时运行`:w`和`:next`一样。\n- `q` 停止宏录制。\n- `99@q` 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。\n\n## 以聪明的方式学习搜索和替换\n\n良好的搜索能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。要想掌握正则表达式，您必须在实践中去不断地使用它。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。\n\n一种提高模式匹配技能的好方法是，每当您需要搜索一个模式串时（例如\"hello 123\"），不要直接查询文字的字面值(`/hello 123`)，去尝试使用模式串来搜索它(比如`/\\v(\\l+) (\\d+)`)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。\n\n既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。\n","source":"_posts/Vim/ch12_search_and_substitute.md","raw":"---\ntitle: VIM-搜索和替换\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第12章 搜索和替换\n\n本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您得基于文本的共同模式搜索大量的内容。通过学习如何在搜索和替换中使用正则表达式而不是字面字符串，您将能够快速定位任何文本。\n\n附带说明一下，在本章中，当谈论搜索时，我将主要使用`/`。您使用`/`进行的所有操作也可以使用`?`完成。\n\n## 智能区分大小写\n\n尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本\"Learn Vim\"，则很容易把字母的大小写输错，从而得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项`ignorecase`闪亮的地方。只需在 vimrc 中添加`set ignorecase`，所有搜索词就不区分大小写。现在，您不必再执行`/Learn Vim`了。 `/learn vim`将起作用。\n\n但是，有时您需要搜索特定大小写的短语。一种方法是用 `set noignorecase` 关闭`ignorecase`选项，但是每次需要搜索区分大小写的短语时，都得反复地打开和关闭这个选项。\n\n为避免反复开关`ignorecase`选项，Vim 有一个`smartcase`选项。您可以将`ignorecase`和`smartcase`选项结合起来，当您输入的搜索词全部是小写时，进行大小写不敏感搜索；而当搜索词 **至少有1个大写字母时**，进行大小写敏感搜索。\n\n在您的 vimrc 中，添加:\n\n```\nset ignorecase smartcase\n```\n\n如果您有这些文字:\n\n```\nhello\nHELLO\nHello\n```\n\n- `/hello` 匹配\"hello\"，\"HELLO\"和\"Hello\"。\n- `/HELLO` 仅匹配\"HELLO\"。\n- `/Hello` 仅匹配\"Hello\"。\n\n有一个缺点。因为现在当您执行`/hello`时，Vim 将进行大小写不敏感搜索,那如果只需要搜索小写字符串怎么办？您可以在搜索词前使用`\\C`模式来告诉 Vim，后续搜索词将区分大小写。如果执行`/\\Chello`，它将严格匹配\"hello\"，而不是\"HELLO\"或\"Hello\"。\n\n## 一行中的第一个和最后一个字符\n\n您可以使用`^`匹配行中的第一个字符，并使用`$`匹配行中的最后一个字符。\n\n如果您有以下文字:\n\n```\nhello hello\n```\n\n您可以使用`/^hello`来定位第一个\"hello\"。 '^'后面的字符必须是一行中的第一个字符。 要定位最后一个\"hello\"，请运行`/hello$`。 '\\$' 之前的字符必须是一行中的最后一个字符。\n\n如果您有以下文字:\n\n```\nhello hello friend\n```\n\n运行`/hello$`将匹配不到任何内容，因为\"friend\"是该行的最后一项，而不是\"hello\"。\n\n## 重复搜索\n\n您可以使用`//`重复上一个搜索。如果您只是搜索`/hello`，则运行`//`等同于运行`/hello`。此快捷键可以为您节省一些按键操作，尤其是在您刚搜索了一个很长的字符串的情况下。另外，回想一下前面的章节，您还可以使用`n`和`N`分别以相同方向和相反方向重复上一次搜索。\n\n如果您想快速回忆起 第*n*个最近使用的搜索字怎么办？您可以先按`/`，然后按`up`/`down`方向键（或`Ctrl-N`/`Ctrl-P`），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行`:history /`。\n\n在搜索过程中到达文件末尾时，Vim 会抛出一个错误:`\"搜索到达底部,未找到匹配项:{your-search}\"`(`\"Search hit the BOTTOM without match for: {your-search}\"`)。有时这个特性能成为一个安全守卫，可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用`set wrapscan`选项使 Vim 在到达文件末尾时回到文件顶部进行搜索。要关闭此功能，请执行`set nowrapscan`。\n\n## 使用候选词搜索\n\n一次搜索多个单词属于日常操作。 如果您需要搜索\"hello vim\"或\"hola vim\"，而不是\"salve vim\"或\"bonjour vim\"，则可以使用`|`或运算符。\n\n给予这样一段文本:\n\n```\nhello vim\nhola vim\nsalve vim\nbonjour vim\n```\n\n要同时匹配\"hello\"和\"hola\"，可以执行`/hello\\|hola`。 您必须使用（`\\`）转义（`|`）或运算符，否则 Vim 将按字面意义搜索字符串\"|\"。\n\n如果您不想每次都输入`\\|`，则可以在搜索开始时使用`magic`语法（`\\v`）:`/\\vhello|hola`。 我不会在本章中详细介绍`magic`，但是有了`\\v`，您就不必再转义特殊字符了。 要了解有关`\\v`的更多信息，请随时查看`:h \\v`。\n\n## 设置模式匹配的开始位置和结束位置\n\n也许您需要搜索的文本是复合词的一部分。如果您有这些文字:\n\n```\n11vim22\nvim22\n11vim\nvim\n```\n\n如果您仅需要选择以\"11\"开始、以\"22\"结束的\"vim\"，您可以使用`\\zs`（开始匹配）和`\\ze`（结束匹配）运算符。 执行:\n\n```\n/11\\zsvim\\ze22\n```\n\nVim仍然会匹配整个模式\"11vim22\"，但是仅高亮显示介于`\\zs`和`\\ze`之间的内容。 另一个例子:\n\n```\nfoobar\nfoobaz\n```\n\n如果需要在\"foobaz\"中搜索\"foo\"，而不是在\"foobar\"中搜索，请运行:\n\n```\n/foo\\zebaz\n```\n\n## 搜索字符组\n\n到目前为止，您所有的搜索字都是字面内容。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符组`[ ]`。\n\n如果您需要搜索任何数字，则可能不想每一次都输入`/0\\|1\\|2\\|3\\|4\\|5\\|6\\|7\\|8\\|9\\|0`。相反，请使用`/[0-9]`来匹配一位数字。 `0-9`表达式表示 Vim 尝试匹配的数字范围是 0-9，因此，如果要查找 1 到 5 之间的数字，请使用`/[1-5]`。\n\n数字不是 Vim 可以查找的唯一数据类型。您也可以执行`/[a-z]`来搜索小写字母，而`/[A-Z]`来搜索大写字母。\n\n您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行`/[0-9a-fA-F]`。\n\n要进行否定搜索，可以在字符范围括号内添加`^`。要搜索非数字，请运行`/[^0-9]`，Vim会匹配任何字符，只要它不是数字即可。请注意，范围括号内的脱符号（`^`）与行首位置符号（例如:`/^hello`）不同。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示\"一行中的第一个字符\"。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 `/^abc`匹配行中的第一个\"abc\"，而`/[^abc]`匹配除\"a\"，\"b\"或\"c\"以外的任何字符。\n\n## 搜索重复字符\n\n如果需要在此文本中搜索两位数:\n\n```\n1aa\n11a\n111\n```\n\n您可以使用`/[0-9][0-9]`来匹配两位数字字符，但是该方法难以扩展。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个`count`参数。\n\n您可以将`count`传递给您的搜索。 它具有以下语法:\n\n```\n{n,m}\n```\n\n顺便说一句，当在 Vim 中使用它们时，这些`count`周围的花括号需要被转义。 `count` 运算符放在您要递增的单个字符之后。\n\n这是`count`语法的四种不同变体: \n- `{n}`是精确匹配。 `/[0-9]\\{2\\}`匹配两个数字:\"11\"，以及\"111\"中的\"11\"。\n- `{n,m}`是范围匹配。 `/[0-9]\\{2,3\\}`匹配 2 到 3 位数字:\"11\"和\"111\"。 \n- `{,m}`是上限匹配。 `/[0-9]\\{,3\\}`匹配最多 3 个数字:\"1\"，\"11\"和\"111\"。\n- `{n,}`是下限匹配。 `/[0-9]\\{2,\\}`匹配最少 2 个或多个数字:\"11\"和\"111\"。\n\n计数参数`\\{0,\\}`（零或多个）和`\\{1,\\}`（一个或多个）是最常见的搜索模式，Vim 为它们提供了特殊的操作符:`*`和`+`（ `+`需要被转义，而`*` 可以正常运行而无需转义）。 如果执行`/[0-9]*`，功能与`/[0-9]\\{0,\\}`相同。 它搜索零个或多个数字，会匹配\"\"，\"1\"，\"123\"。 顺便说一句，它也将匹配非数字，例如\"a\"，因为在技术上，字母\"a\"中的数字个数为零。 在使用\"\\*\"之前，请仔细考虑。 如果执行`/[0-9]\\+`，则与`/[0-9]\\{1,\\}`相同。 它搜索一个或多个数字，将匹配\"1\"和\"12\"。\n\n## 预定义的字符组\n\nVim 为常见字符组（例如数字和字母）提供了简写。 我不会在这里逐一介绍，但可以在`:h /character-classes`中找到完整列表。 下面是有用的部分:\n\n```\n\\d    数字[0-9]\n\\D    非数字[^ 0-9]\n\\s    空格字符（空格和制表符）\n\\S    非空白字符（除空格和制表符外的所有字符）\n\\w    单词字符[0-9A-Za-z_]\n\\l    小写字母[a-z]\n\\u    大写字符[A-Z]\n```\n\n您可以像使用普通字符组一样使用它们。 要搜索任何一位数字，可以使用`/\\d`以获得更简洁的语法，而不使用`/[0-9]`。\n\n## 搜索示例：在一对相似字符之间捕获文本\n\n如果要搜索由双引号引起来的短语:\n\n```\n\"Vim is awesome!\"\n```\n\n运行这个:\n\n```\n`/\"[^\"]\\+\"`\n```\n\n让我们分解一下:\n- `\"` 是字面双引号。它匹配第一个双引号。\n- `[^\"]` 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。\n- `\\+`表示一个或多个。因为它的前面是`[^\"]`，因此 Vim 查找一个或多个不是双引号的字符。\n- `\"` 是字面双引号。它与右双引号匹配。\n\n当看到第一个`\"`时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个`\"`模式并停止模式捕获。同时，两个双引号之间的所有非双引号字符都被`[^\"]\\+` 模式捕获，在这个例子中是短语\"Vim is awesome!\"。这是一个通用模式（其实就是正则表达式）用于捕获 **由一对类似的定界符包围的短语**。\n\n- 要捕获被单引号包围的短语，你可以使用`/'[^']\\+'`\n- 要捕获为0包围的短语，你可以使用`/0[^0]\\+0`\n\n## 搜索示例：捕获电话号码\n\n如果要匹配以连字符(`-`)分隔的美国电话号码，例如`123-456-7890`，则可以使用:\n\n```\n/\\d\\{3\\}-\\d\\{3\\}-\\d\\{4\\}\n```\n\n美国电话号码的组成是：首先是三位数字，其后是另外三位数字，最后是另外四位数字。 让我们分解一下:\n- `\\d\\{3\\}`与精确重复三次的数字匹配\n- `-`是字面的连字符\n\n为避免转义，可使用`\\v`:\n\n```\n/\\v\\d{3}-\\d{3}-\\d{4}\n```\n\n此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。\n\n这涵盖了本章的搜索部分。 现在开始讲替换。\n\n## 基本替换\n\nVim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:\n\n```\n:s/{old-pattern}/{new-pattern}/\n```\n\n让我们从一个基本用法开始。 如果您有以下文字:\n\n```\nvim is good\n```\n\n让我们用\"awesome\"代替\"good\"，因为 Vim 很棒。 运行`:s/good/awesome/.`您应该看到:\n\n```\nvim is awesome\n```\n\n## 重复最后一次替换\n\n您可以使用普通模式命令`&`或运行`:s`来重复最后一个替代命令。 如果您刚刚运行`:s/good/awesome/`，则运行`&`或`:s`将会重复执行。\n\n另外，在本章前面，我提到您可以使用`//`来重复先前的搜索模式。 此技巧可用于替代命令。 如果`/good`是最近被替换的单词，那么将第一个替换模式参数留为空白，例如在`:s//awesome/`中，则与运行`:s/good/awesome/`相同。\n\n## 替换范围\n\n就像许多 Ex 命令一样，您可以将范围参数传递给替换命令。 语法为:\n\n```\n:[range]s/old/new/\n```\n\n如果您有以下表达式:\n\n```\nlet one = 1;\nlet two = 2;\nlet three = 3;\nlet four = 4;\nlet five = 5;\n```\n\n要将第3行到第5行中的\"let\"替换为\"const\"，您可以执行以下操作:\n\n```\n:3,5s/let/const/\n```\n\n下面是一些你可以使用的范围参数的变体:\n\n- `:,3/let/const/` - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换到第 3 行。\n- `:1,s/let/const/` - 如果逗号后没有给出任何内容，它也代表当前行。 从第 1 行替换到当前行。\n- `:3s/let/const/` - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。\n\n在 Vim 中，`%`通常表示整个文件。 如果运行`:%s/let/const/`，它将在所有行上进行替换。请记住这个范围参数语法，在后面章节中很多命令行命令都遵循这个语法。\n\n## 模式匹配\n\n接下来的几节将介绍基本的正则表达式。 丰富的模式知识对于掌握替换命令至关重要。\n\n如果您具有以下表达式:\n\n```\nlet one = 1;\nlet two = 2;\nlet three = 3;\nlet four = 4;\nlet five = 5;\n```\n\n要在数字周围添加一对双引号:\n\n```\n:%s/\\d/\"\\0\"/\n```\n\n结果:\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\n```\n\n让我们分解一下命令:\n- `:%s` 定位整个文件以执行替换。\n- `\\d` 是 Vim 的预定义数字范围简写(类似使用`[0-9]`)。\n- `\"\\0\"` 双引号是双引号的字面值。 `\\0`是一个特殊字符，代表\"整个匹配的模式\"。 此处匹配的模式是单个数字`\\d`。\n\n另外，`&`也同样代表\"整个匹配的模式\"，就像`\\0`一样。 `:s/\\d/\"&\"/`也可以。\n\n让我们考虑另一个例子。 给出以下表达式，您需要将所有的\"let\"和变量名交换位置:\n\n```\none let = \"1\";\ntwo let = \"2\";\nthree let = \"3\";\nfour let = \"4\";\nfive let = \"5\";\n```\n\n为此，请运行:\n\n```\n:%s/\\(\\w\\+\\) \\(\\w\\+\\)/\\2 \\1/\n```\n\n上面的命令包含太多的反斜杠，很难阅读。 使用`\\v`运算符更方便:\n\n```\n:%s/\\v(\\w+) (\\w+)/\\2 \\1/\n```\n\n结果:\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\n```\n\n太好了！ 让我们分解该命令:\n- `:%s` 定位文件中的所有行以执行替换操作\n- `(\\w+) (\\w+)`对模式进行分组。`\\w`是 Vim 预定义的单词字符范围简写(`[0-9A-Za-z_]`)之一。 包围`\\w`的`()`将匹配的单词字符进行分组。 请注意两个分组之间的空间。 `(\\w+) (\\w+)` 捕获两个分组。 在第一行上，第一组捕获\"let\"，第二组捕获\"one\"。(英文版中，作者写成了：第一组捕获\"one\"，第二组捕获\"two\"，可能是作者不小心的错误)。\n- `\\2 \\1` 以相反的顺序返回捕获的组。 `\\2`包含捕获的字符串\"let\"，而`\\1`包含字符串\"one\"。 使`\\2 \\1`返回字符串\"let one\"。\n\n回想一下，`\\0`代表整个匹配的模式。 您可以使用`( )`将匹配的字符串分成较小的组。 每个组都由`\\1`, `\\2`, `\\3`等表示。\n\n让我们再举一个例子来巩固这一匹配分组的概念。 如果您有以下数字:\n\n```\n123\n456\n789\n```\n\n要颠倒顺序，请运行:\n\n```\n:%s/\\v(\\d)(\\d)(\\d)/\\3\\2\\1/\n```\n\n结果是:\n\n```\n321\n654\n987\n```\n\n每个`(\\d)`都匹配一个数字并创建一个分组。 在第一行上，第一个`(\\d)`的值为\"1\"，第二个`(\\d)`的值为\"2\"，第三个`(\\d)`的值为\"3\"。 它们存储在变量`\\1`，`\\2`和`\\3`中。 在替换的后半部分，新模式`\\3\\2\\1`在第一行上产生\"321\"值。\n\n相反，如果您运行下面的命令:\n\n```\n:%s/\\v(\\d\\d)(\\d)/\\2\\1/\n```\n您将获得不同的结果:\n\n```\n312\n645\n978\n```\n\n这是因为您现在只有两个组。 被`(\\d\\d)`捕获的第一组存储在`\\1`内，其值为\"12\"。 由`(\\d)`捕获的第二组存储在`\\2`内部，其值为\"3\"。 然后，`\\2\\1`返回\"312\"。\n\n## 替换标志\n\n如果您有以下句子:\n\n```\nchocolate pancake, strawberry pancake, blueberry pancake\n```\n\n要将所有 pancakes 替换为 donut，您不能只运行:\n\n```\n:s/pancake/donut\n```\n\n上面的命令将仅替换第一个匹配项，返回的结果是:\n\n```\nchocolate donut, strawberry pancake, blueberry pancake\n```\n\n有两种解决方法。 一，您可以再运行两次替代命令。 二，您可以向其传递全局(`g`)标志来替换一行中的所有匹配项。\n\n让我们谈谈全局标志。 运行:\n\n```\n:s/pancake/donut/g\n```\n\nVim 迅速将所有\"pancake\"替换为\"donut\"。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:\n\n```\n&    重用上一个替代命令中的标志。 必须作为第一个标志传递。\ng    替换行中的所有匹配项。\nc    要求替代确认。\ne    防止替换失败时显示错误消息。\ni    执行不区分大小写的替换\nI    执行区分大小写的替换\n```\n\n我上面没有列出更多标志。 要了解所有标志，请查看`:h s_flags`。\n\n顺便说一句，重复替换命令（`&`和`:s`）不保留标志。 运行`&`只会重复`:s/pancake/donut/`而没有`g`。 要使用所有标志快速重复最后一个替代命令，请运行`:&&`。\n\n## 更改定界符\n\n如果您需要用长路径替换 URL:\n\n```\nhttps://mysite.com/a/b/c/d/e\n```\n\n要用单词\"hello\"代替它，请运行:\n\n```\n:s/https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e/hello/\n```\n\n但是，很难说出哪些正斜杠（`/`）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或`\"`，`|`和`\\`之外的字符）来更改定界符。让我们将它们替换为`+`。上面的替换命令可以重写为 :\n\n```\n:s+https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e+hello+\n```\n\n现在，更容易看到分隔符在哪里。\n\n## 特殊替换\n\n您还可以修改要替换的文本的大小写。 给出以下表达式，您的任务是将所有变量名比如 \"one\", \"two\", \"three\"等，改成大写:\n\n```\nlet one = \"1\";\nlet two = \"2\";\nlet three = \"3\";\nlet four = \"4\";\nlet five = \"5\";\n```\n\n请运行:\n\n```\n%s/\\v(\\w+) (\\w+)/\\1 \\U\\2/\n```\n\n你会得到:\n\n```\nlet ONE = \"1\";\nlet TWO = \"2\";\nlet THREE = \"3\";\nlet FOUR = \"4\";\nlet FIVE = \"5\";\n```\n\n这是该命令的细分:\n- `(\\w+) (\\w+)`捕获前两个匹配的分组，例如\"let\"和\"one\"。\n- `\\1`返回第一个组的值\"let\"\n- `\\U\\2`大写(`\\U`)第二组(`\\2`)。\n\n该命令的窍门是表达式`\\U\\2`。`\\U`将后面跟着的字符变为大写。\n\n让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。\n\n```\nvim is the greatest text editor in the whole galaxy\n```\n\n您可以运行:\n\n```\n:s/\\<./\\U&/g\n```\n\n结果:\n\n```\nVim Is The Greatest Text Editor In The Whole Galaxy\n```\n\n细目如下:\n- `:s` 替换当前行\n- `\\<.` 由两部分组成:`\\<`匹配单词的开头，`.`匹配任何字符。 `\\<`运算符使后面跟着的字符表示单词的第一个字符。 由于`.`是下一个字符，因此它将匹配任意单词的第一个字符。\n- `\\U&` 将后续符号子序列`&`大写。 回想一下，`&`（或`\\0`）代表整个匹配。 这里它匹配单词的第一个字符。\n- `g`全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。\n\n要了解替换的特殊替换符号（如`\\u`和`\\U`）的更多信息，请查看`:h sub-replace-special`。\n\n## 候选模式\n\n有时您需要同时匹配多个模式。 如果您有以下问候:\n\n```\nhello vim\nhola vim\nsalve vim\nbonjour vim\n```\n\n您仅需在包含单词\"hello\"或\"hola\"的行上用\"friend\"代替\"vim\"。回想一想本章前面的知识点，你可以使用`|` 来分隔可选的模式:\n\n```\n:%s/\\v(hello|hola) vim)/\\1 friend/g\n```\n\n结果:\n\n```\nhello friend\nhola friend\nsalve vim\nbonjour vim\n```\n\n这是细分:\n- `%s` 在文件的每一行上运行替代命令。\n- `(hello|hola)` 匹配\\*\"hello\"或\"hola\"，并将其视为一个组。\n- `vim` 是字面意思\"vim\"。\n- `\\1` 是第一个匹配组，它是文本\"hello\"或\"hola\"。\n- `friend` 是字面的“朋友\"。\n\n## 指定替换模式的开始位置和结束位置\n\n回想一下，您可以使用`\\zs`和`\\ze`来指定一个匹配的开始位置和结束位置。这个技术在替换操作中同样有效，如果你有以下文本：\n\n```\nchocolate pancake\nstrawberry sweetcake\nblueberry hotcake\n```\n\n要想将\"hotcake\"中的\"cake\"替换为\"dog\"，得到\"hotdog\":\n\n```\n:%s/hot\\zscake/dog/g\n```\n\n结果是：\n\n```\nchocolate pancake\nstrawberry sweetcake\nblueberry hotdog\n```\n\n## 贪婪与非贪婪\n\n您可以使用下面技巧，在某行中替换第n个匹配：\n\n```\nOne Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.\n```\n\n要想将第3个\"Mississippi\"替换为 \"Arkansas\"，运行：\n\n```\n:s/\\v(.{-}\\zsMississippi){3}/Arkansas/g\n```\n\n命令分解：\n- `:s/` 替换命令。\n- `\\v` 魔术关键字，使您不必转义特殊字符。\n- `.` 匹配任意单个字符。\n- `{-}` 表示使用非贪婪模式匹配前面的0个或多个字符。\n- `\\zsMississippi` 使得从\"Mississippi\"开始捕获匹配。\n- `(...){3}` 查找第3个匹配\n\n在本章前面的内容中，你已经看到过`{3}`这样的语法。在本例中，`{3}`将精确匹配第3个匹配。这里的新技巧是`{-}`。它表示进行非贪婪匹配。它会找到符合给定模式的最短的匹配。在本例中，`(.{-}Mississippi)`匹配以任意字符开始、数量最少的\"Mississippi\"。对比`(.*Mississippi)`，后者会找到符合给定模式的最长匹配。\n\n如果您使用`(.{-}Mississippi)`，你会得到5个匹配：\"One Mississippi\", \"Two Mississippi\",等。如果您使用`(.*Mississippi)`，您只会得到1个匹配：最后一个 \"Mississippi\"。`*`表示贪婪匹配，而`{-}`表示非贪婪匹配。要想了解更多，可以查看 `:h /\\{-` 和 `:h non-greedy`。\n\n让我们看一个简单的例子。如果您有以下字符串：\n\n```\nabc1de1\n```\n\n用贪婪模式匹配 \"abc1de1\" ：\n\n```\n/a.*1\n```\n\n用非贪婪模式匹配 \"abc1\"：\n\n```\n/a.\\{-}1\n```\n\n因此，如果您需要将最长的匹配转为大写（贪婪模式），运行：\n\n```\n:s/a.*1/\\U&/g\n```\n\n会得到：\n\n```\nABC1DE1\n```\n\n如果您需要将最短的匹配转为大写（非贪婪模式），运行：\n\n```\n:s/a.\\{-}1/\\U&/g\n```\n\n会得到：\n\n```\nABC1de1\n```\n\n如果您是第一次接触贪婪模式与非贪婪模式这两个概念，可能会把你绕晕。围绕不同的组合去实验，知道您明白这两个概念。\n\n## 跨多个文件替换\n\n最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: `food.txt` 和 `animal.txt`.\n\n`food.txt`内:\n\n```\ncorn dog\nhot dog\nchili dog\n```\n\n`animal.txt`内:\n\n```\nlarge dog\nmedium dog\nsmall dog\n```\n\n假设您的目录结构如下所示:\n\n```\n├ food.txt\n├ animal.txt\n```\n\n首先，用`:args`同时捕获\"food.txt\"和\"animal.txt\"到参数列表中。回顾前面的章节，`:args`可用于创建文件名列表。在 Vim 中有几种方法可以做到这一点，其中一种方法是在Vim内部运行:\n\n```\n:args *.txt                  捕获当前位置的所有txt文件\n```\n\n测试一下，当您运行`:args`时，您应该会看到：\n\n```\n[food.txt] animal.txt\n```\n\n现在，所有的相关文件都已经存储在参数列表中，您可以用 `:argdo` 命令跨多文件替换，运行：\n\n```\n:argdo %s/dog/chicken/\n```\n\n这条命令对所有`:args`列表中的文件执行替换操作。最终，存储修改的文件：\n\n```\n:argdo update\n```\n\n`:args` 和 `:argdo` 是两个有用的工具，用于跨多文件执行命令行命令。可以用其他命令结合尝试一下！\n\n## 用宏跨多个文件替换\n\n另外，您也可以用宏跨多个文件运行替代命令。执行:\n\n```\n:args *.txt\nqq\n:%s/dog/chicken/g\n:wnext\nq\n99@q\n```\n\n以下是步骤的细分:\n- `:args *.txt` 会将相关文件列出到`:args`列表中。\n- `qq` 启动\"q\"寄存器中的宏。\n- `:%s/dog/chicken/g`在当前文件的所有行上用\"chicken\"替换\"dog\"。\n- `:wnext` 写入（保存）文件，然后转到`args`列表中的下一个文件。就像同时运行`:w`和`:next`一样。\n- `q` 停止宏录制。\n- `99@q` 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。\n\n## 以聪明的方式学习搜索和替换\n\n良好的搜索能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。要想掌握正则表达式，您必须在实践中去不断地使用它。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。\n\n一种提高模式匹配技能的好方法是，每当您需要搜索一个模式串时（例如\"hello 123\"），不要直接查询文字的字面值(`/hello 123`)，去尝试使用模式串来搜索它(比如`/\\v(\\l+) (\\d+)`)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。\n\n既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。\n","slug":"Vim/ch12_search_and_substitute","published":1,"updated":"2022-08-28T07:38:59.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i1z001tscvm9gdn4557","content":"<h1 id=\"第12章-搜索和替换\"><a href=\"#第12章-搜索和替换\" class=\"headerlink\" title=\"第12章 搜索和替换\"></a>第12章 搜索和替换</h1><p>本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您得基于文本的共同模式搜索大量的内容。通过学习如何在搜索和替换中使用正则表达式而不是字面字符串，您将能够快速定位任何文本。</p>\n<p>附带说明一下，在本章中，当谈论搜索时，我将主要使用<code>/</code>。您使用<code>/</code>进行的所有操作也可以使用<code>?</code>完成。</p>\n<h2 id=\"智能区分大小写\"><a href=\"#智能区分大小写\" class=\"headerlink\" title=\"智能区分大小写\"></a>智能区分大小写</h2><p>尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本”Learn Vim”，则很容易把字母的大小写输错，从而得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项<code>ignorecase</code>闪亮的地方。只需在 vimrc 中添加<code>set ignorecase</code>，所有搜索词就不区分大小写。现在，您不必再执行<code>/Learn Vim</code>了。 <code>/learn vim</code>将起作用。</p>\n<p>但是，有时您需要搜索特定大小写的短语。一种方法是用 <code>set noignorecase</code> 关闭<code>ignorecase</code>选项，但是每次需要搜索区分大小写的短语时，都得反复地打开和关闭这个选项。</p>\n<p>为避免反复开关<code>ignorecase</code>选项，Vim 有一个<code>smartcase</code>选项。您可以将<code>ignorecase</code>和<code>smartcase</code>选项结合起来，当您输入的搜索词全部是小写时，进行大小写不敏感搜索；而当搜索词 <strong>至少有1个大写字母时</strong>，进行大小写敏感搜索。</p>\n<p>在您的 vimrc 中，添加:</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-keyword\">set</span> ignorecase <span class=\"hljs-comment\">smartcase</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您有这些文字:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello</span><br><span class=\"hljs-attribute\">HELLO</span><br><span class=\"hljs-attribute\">Hello</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>/hello</code> 匹配”hello”，”HELLO”和”Hello”。</li>\n<li><code>/HELLO</code> 仅匹配”HELLO”。</li>\n<li><code>/Hello</code> 仅匹配”Hello”。</li>\n</ul>\n<p>有一个缺点。因为现在当您执行<code>/hello</code>时，Vim 将进行大小写不敏感搜索,那如果只需要搜索小写字符串怎么办？您可以在搜索词前使用<code>\\C</code>模式来告诉 Vim，后续搜索词将区分大小写。如果执行<code>/\\Chello</code>，它将严格匹配”hello”，而不是”HELLO”或”Hello”。</p>\n<h2 id=\"一行中的第一个和最后一个字符\"><a href=\"#一行中的第一个和最后一个字符\" class=\"headerlink\" title=\"一行中的第一个和最后一个字符\"></a>一行中的第一个和最后一个字符</h2><p>您可以使用<code>^</code>匹配行中的第一个字符，并使用<code>$</code>匹配行中的最后一个字符。</p>\n<p>如果您有以下文字:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello hello</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以使用<code>/^hello</code>来定位第一个”hello”。 ‘^’后面的字符必须是一行中的第一个字符。 要定位最后一个”hello”，请运行<code>/hello$</code>。 ‘$‘ 之前的字符必须是一行中的最后一个字符。</p>\n<p>如果您有以下文字:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">hello hello <span class=\"hljs-keyword\">friend</span><br></code></pre></td></tr></table></figure>\n\n<p>运行<code>/hello$</code>将匹配不到任何内容，因为”friend”是该行的最后一项，而不是”hello”。</p>\n<h2 id=\"重复搜索\"><a href=\"#重复搜索\" class=\"headerlink\" title=\"重复搜索\"></a>重复搜索</h2><p>您可以使用<code>//</code>重复上一个搜索。如果您只是搜索<code>/hello</code>，则运行<code>//</code>等同于运行<code>/hello</code>。此快捷键可以为您节省一些按键操作，尤其是在您刚搜索了一个很长的字符串的情况下。另外，回想一下前面的章节，您还可以使用<code>n</code>和<code>N</code>分别以相同方向和相反方向重复上一次搜索。</p>\n<p>如果您想快速回忆起 第<em>n</em>个最近使用的搜索字怎么办？您可以先按<code>/</code>，然后按<code>up</code>&#x2F;<code>down</code>方向键（或<code>Ctrl-N</code>&#x2F;<code>Ctrl-P</code>），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行<code>:history /</code>。</p>\n<p>在搜索过程中到达文件末尾时，Vim 会抛出一个错误:<code>&quot;搜索到达底部,未找到匹配项:&#123;your-search&#125;&quot;</code>(<code>&quot;Search hit the BOTTOM without match for: &#123;your-search&#125;&quot;</code>)。有时这个特性能成为一个安全守卫，可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用<code>set wrapscan</code>选项使 Vim 在到达文件末尾时回到文件顶部进行搜索。要关闭此功能，请执行<code>set nowrapscan</code>。</p>\n<h2 id=\"使用候选词搜索\"><a href=\"#使用候选词搜索\" class=\"headerlink\" title=\"使用候选词搜索\"></a>使用候选词搜索</h2><p>一次搜索多个单词属于日常操作。 如果您需要搜索”hello vim”或”hola vim”，而不是”salve vim”或”bonjour vim”，则可以使用<code>|</code>或运算符。</p>\n<p>给予这样一段文本:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hola <span class=\"hljs-keyword\">vim</span><br>salve <span class=\"hljs-keyword\">vim</span><br>bonjour <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>要同时匹配”hello”和”hola”，可以执行<code>/hello\\|hola</code>。 您必须使用（<code>\\</code>）转义（<code>|</code>）或运算符，否则 Vim 将按字面意义搜索字符串”|”。</p>\n<p>如果您不想每次都输入<code>\\|</code>，则可以在搜索开始时使用<code>magic</code>语法（<code>\\v</code>）:<code>/\\vhello|hola</code>。 我不会在本章中详细介绍<code>magic</code>，但是有了<code>\\v</code>，您就不必再转义特殊字符了。 要了解有关<code>\\v</code>的更多信息，请随时查看<code>:h \\v</code>。</p>\n<h2 id=\"设置模式匹配的开始位置和结束位置\"><a href=\"#设置模式匹配的开始位置和结束位置\" class=\"headerlink\" title=\"设置模式匹配的开始位置和结束位置\"></a>设置模式匹配的开始位置和结束位置</h2><p>也许您需要搜索的文本是复合词的一部分。如果您有这些文字:</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-number\">11</span>vi<span class=\"hljs-name\">m22</span><br>vi<span class=\"hljs-name\">m22</span><br><span class=\"hljs-number\">11</span>vim<br>vim<br></code></pre></td></tr></table></figure>\n\n<p>如果您仅需要选择以”11”开始、以”22”结束的”vim”，您可以使用<code>\\zs</code>（开始匹配）和<code>\\ze</code>（结束匹配）运算符。 执行:</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-string\">/11</span>\\zsvim\\ze22<br></code></pre></td></tr></table></figure>\n\n<p>Vim仍然会匹配整个模式”11vim22”，但是仅高亮显示介于<code>\\zs</code>和<code>\\ze</code>之间的内容。 另一个例子:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">foobar</span><br><span class=\"hljs-attribute\">foobaz</span><br></code></pre></td></tr></table></figure>\n\n<p>如果需要在”foobaz”中搜索”foo”，而不是在”foobar”中搜索，请运行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/foo\\zebaz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"搜索字符组\"><a href=\"#搜索字符组\" class=\"headerlink\" title=\"搜索字符组\"></a>搜索字符组</h2><p>到目前为止，您所有的搜索字都是字面内容。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符组<code>[ ]</code>。</p>\n<p>如果您需要搜索任何数字，则可能不想每一次都输入<code>/0\\|1\\|2\\|3\\|4\\|5\\|6\\|7\\|8\\|9\\|0</code>。相反，请使用<code>/[0-9]</code>来匹配一位数字。 <code>0-9</code>表达式表示 Vim 尝试匹配的数字范围是 0-9，因此，如果要查找 1 到 5 之间的数字，请使用<code>/[1-5]</code>。</p>\n<p>数字不是 Vim 可以查找的唯一数据类型。您也可以执行<code>/[a-z]</code>来搜索小写字母，而<code>/[A-Z]</code>来搜索大写字母。</p>\n<p>您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行<code>/[0-9a-fA-F]</code>。</p>\n<p>要进行否定搜索，可以在字符范围括号内添加<code>^</code>。要搜索非数字，请运行<code>/[^0-9]</code>，Vim会匹配任何字符，只要它不是数字即可。请注意，范围括号内的脱符号（<code>^</code>）与行首位置符号（例如:<code>/^hello</code>）不同。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示”一行中的第一个字符”。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 <code>/^abc</code>匹配行中的第一个”abc”，而<code>/[^abc]</code>匹配除”a”，”b”或”c”以外的任何字符。</p>\n<h2 id=\"搜索重复字符\"><a href=\"#搜索重复字符\" class=\"headerlink\" title=\"搜索重复字符\"></a>搜索重复字符</h2><p>如果需要在此文本中搜索两位数:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-number\">1</span>aa<br><span class=\"hljs-number\">11</span><span class=\"hljs-keyword\">a</span><br><span class=\"hljs-number\">111</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以使用<code>/[0-9][0-9]</code>来匹配两位数字字符，但是该方法难以扩展。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个<code>count</code>参数。</p>\n<p>您可以将<code>count</code>传递给您的搜索。 它具有以下语法:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;n,m&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>顺便说一句，当在 Vim 中使用它们时，这些<code>count</code>周围的花括号需要被转义。 <code>count</code> 运算符放在您要递增的单个字符之后。</p>\n<p>这是<code>count</code>语法的四种不同变体: </p>\n<ul>\n<li><code>&#123;n&#125;</code>是精确匹配。 <code>/[0-9]\\&#123;2\\&#125;</code>匹配两个数字:”11”，以及”111”中的”11”。</li>\n<li><code>&#123;n,m&#125;</code>是范围匹配。 <code>/[0-9]\\&#123;2,3\\&#125;</code>匹配 2 到 3 位数字:”11”和”111”。 </li>\n<li><code>&#123;,m&#125;</code>是上限匹配。 <code>/[0-9]\\&#123;,3\\&#125;</code>匹配最多 3 个数字:”1”，”11”和”111”。</li>\n<li><code>&#123;n,&#125;</code>是下限匹配。 <code>/[0-9]\\&#123;2,\\&#125;</code>匹配最少 2 个或多个数字:”11”和”111”。</li>\n</ul>\n<p>计数参数<code>\\&#123;0,\\&#125;</code>（零或多个）和<code>\\&#123;1,\\&#125;</code>（一个或多个）是最常见的搜索模式，Vim 为它们提供了特殊的操作符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）。 如果执行<code>/[0-9]*</code>，功能与<code>/[0-9]\\&#123;0,\\&#125;</code>相同。 它搜索零个或多个数字，会匹配””，”1”，”123”。 顺便说一句，它也将匹配非数字，例如”a”，因为在技术上，字母”a”中的数字个数为零。 在使用”*“之前，请仔细考虑。 如果执行<code>/[0-9]\\+</code>，则与<code>/[0-9]\\&#123;1,\\&#125;</code>相同。 它搜索一个或多个数字，将匹配”1”和”12”。</p>\n<h2 id=\"预定义的字符组\"><a href=\"#预定义的字符组\" class=\"headerlink\" title=\"预定义的字符组\"></a>预定义的字符组</h2><p>Vim 为常见字符组（例如数字和字母）提供了简写。 我不会在这里逐一介绍，但可以在<code>:h /character-classes</code>中找到完整列表。 下面是有用的部分:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\"><span class=\"hljs-string\">\\d</span>    数字[<span class=\"hljs-number\">0</span>-<span class=\"hljs-number\">9</span>]<br><span class=\"hljs-string\">\\D</span>    非数字[^ <span class=\"hljs-number\">0</span>-<span class=\"hljs-number\">9</span>]<br><span class=\"hljs-string\">\\s</span>    空格字符（空格和制表符）<br><span class=\"hljs-string\">\\S</span>    非空白字符（除空格和制表符外的所有字符）<br><span class=\"hljs-string\">\\w</span>    单词字符[<span class=\"hljs-number\">0</span>-<span class=\"hljs-number\">9</span>A-Za-z_]<br><span class=\"hljs-string\">\\l</span>    小写字母[a-z]<br><span class=\"hljs-string\">\\u</span>    大写字符[A-Z]<br></code></pre></td></tr></table></figure>\n\n<p>您可以像使用普通字符组一样使用它们。 要搜索任何一位数字，可以使用<code>/\\d</code>以获得更简洁的语法，而不使用<code>/[0-9]</code>。</p>\n<h2 id=\"搜索示例：在一对相似字符之间捕获文本\"><a href=\"#搜索示例：在一对相似字符之间捕获文本\" class=\"headerlink\" title=\"搜索示例：在一对相似字符之间捕获文本\"></a>搜索示例：在一对相似字符之间捕获文本</h2><p>如果要搜索由双引号引起来的短语:</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;Vim is awesome!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行这个:</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">`/<span class=\"hljs-string\">&quot;[^&quot;</span>]\\+<span class=\"hljs-string\">&quot;`</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下:</p>\n<ul>\n<li><code>&quot;</code> 是字面双引号。它匹配第一个双引号。</li>\n<li><code>[^&quot;]</code> 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。</li>\n<li><code>\\+</code>表示一个或多个。因为它的前面是<code>[^&quot;]</code>，因此 Vim 查找一个或多个不是双引号的字符。</li>\n<li><code>&quot;</code> 是字面双引号。它与右双引号匹配。</li>\n</ul>\n<p>当看到第一个<code>&quot;</code>时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个<code>&quot;</code>模式并停止模式捕获。同时，两个双引号之间的所有非双引号字符都被<code>[^&quot;]\\+</code> 模式捕获，在这个例子中是短语”Vim is awesome!”。这是一个通用模式（其实就是正则表达式）用于捕获 <strong>由一对类似的定界符包围的短语</strong>。</p>\n<ul>\n<li>要捕获被单引号包围的短语，你可以使用<code>/&#39;[^&#39;]\\+&#39;</code></li>\n<li>要捕获为0包围的短语，你可以使用<code>/0[^0]\\+0</code></li>\n</ul>\n<h2 id=\"搜索示例：捕获电话号码\"><a href=\"#搜索示例：捕获电话号码\" class=\"headerlink\" title=\"搜索示例：捕获电话号码\"></a>搜索示例：捕获电话号码</h2><p>如果要匹配以连字符(<code>-</code>)分隔的美国电话号码，例如<code>123-456-7890</code>，则可以使用:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">/\\d\\</span><span class=\"hljs-template-variable\">&#123;3\\&#125;</span><span class=\"language-xml\">-\\d\\</span><span class=\"hljs-template-variable\">&#123;3\\&#125;</span><span class=\"language-xml\">-\\d\\</span><span class=\"hljs-template-variable\">&#123;4\\&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>美国电话号码的组成是：首先是三位数字，其后是另外三位数字，最后是另外四位数字。 让我们分解一下:</p>\n<ul>\n<li><code>\\d\\&#123;3\\&#125;</code>与精确重复三次的数字匹配</li>\n<li><code>-</code>是字面的连字符</li>\n</ul>\n<p>为避免转义，可使用<code>\\v</code>:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">/\\v\\d</span><span class=\"hljs-template-variable\">&#123;3&#125;</span><span class=\"language-xml\">-\\d</span><span class=\"hljs-template-variable\">&#123;3&#125;</span><span class=\"language-xml\">-\\d</span><span class=\"hljs-template-variable\">&#123;4&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。</p>\n<p>这涵盖了本章的搜索部分。 现在开始讲替换。</p>\n<h2 id=\"基本替换\"><a href=\"#基本替换\" class=\"headerlink\" title=\"基本替换\"></a>基本替换</h2><p>Vim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:s<span class=\"hljs-regexp\">/&#123;old-pattern&#125;/</span>&#123;<span class=\"hljs-keyword\">new</span>-pattern&#125;/<br></code></pre></td></tr></table></figure>\n\n<p>让我们从一个基本用法开始。 如果您有以下文字:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> good<br></code></pre></td></tr></table></figure>\n\n<p>让我们用”awesome”代替”good”，因为 Vim 很棒。 运行<code>:s/good/awesome/.</code>您应该看到:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"重复最后一次替换\"><a href=\"#重复最后一次替换\" class=\"headerlink\" title=\"重复最后一次替换\"></a>重复最后一次替换</h2><p>您可以使用普通模式命令<code>&amp;</code>或运行<code>:s</code>来重复最后一个替代命令。 如果您刚刚运行<code>:s/good/awesome/</code>，则运行<code>&amp;</code>或<code>:s</code>将会重复执行。</p>\n<p>另外，在本章前面，我提到您可以使用<code>//</code>来重复先前的搜索模式。 此技巧可用于替代命令。 如果<code>/good</code>是最近被替换的单词，那么将第一个替换模式参数留为空白，例如在<code>:s//awesome/</code>中，则与运行<code>:s/good/awesome/</code>相同。</p>\n<h2 id=\"替换范围\"><a href=\"#替换范围\" class=\"headerlink\" title=\"替换范围\"></a>替换范围</h2><p>就像许多 Ex 命令一样，您可以将范围参数传递给替换命令。 语法为:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:[range]s<span class=\"hljs-regexp\">/old/</span><span class=\"hljs-keyword\">new</span>/<br></code></pre></td></tr></table></figure>\n\n<p>如果您有以下表达式:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">4</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>要将第3行到第5行中的”let”替换为”const”，您可以执行以下操作:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>s<span class=\"hljs-regexp\">/let/</span>const/<br></code></pre></td></tr></table></figure>\n\n<p>下面是一些你可以使用的范围参数的变体:</p>\n<ul>\n<li><code>:,3/let/const/</code> - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换到第 3 行。</li>\n<li><code>:1,s/let/const/</code> - 如果逗号后没有给出任何内容，它也代表当前行。 从第 1 行替换到当前行。</li>\n<li><code>:3s/let/const/</code> - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。</li>\n</ul>\n<p>在 Vim 中，<code>%</code>通常表示整个文件。 如果运行<code>:%s/let/const/</code>，它将在所有行上进行替换。请记住这个范围参数语法，在后面章节中很多命令行命令都遵循这个语法。</p>\n<h2 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h2><p>接下来的几节将介绍基本的正则表达式。 丰富的模式知识对于掌握替换命令至关重要。</p>\n<p>如果您具有以下表达式:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">4</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>要在数字周围添加一对双引号:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\d/<span class=\"hljs-string\">&quot;\\0&quot;</span>/<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下命令:</p>\n<ul>\n<li><code>:%s</code> 定位整个文件以执行替换。</li>\n<li><code>\\d</code> 是 Vim 的预定义数字范围简写(类似使用<code>[0-9]</code>)。</li>\n<li><code>&quot;\\0&quot;</code> 双引号是双引号的字面值。 <code>\\0</code>是一个特殊字符，代表”整个匹配的模式”。 此处匹配的模式是单个数字<code>\\d</code>。</li>\n</ul>\n<p>另外，<code>&amp;</code>也同样代表”整个匹配的模式”，就像<code>\\0</code>一样。 <code>:s/\\d/&quot;&amp;&quot;/</code>也可以。</p>\n<p>让我们考虑另一个例子。 给出以下表达式，您需要将所有的”let”和变量名交换位置:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">one let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>two let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>three let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>four let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>five let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>为此，请运行:</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs taggerscript\">:%s/<span class=\"hljs-symbol\">\\(</span>\\w\\+<span class=\"hljs-symbol\">\\)</span> <span class=\"hljs-symbol\">\\(</span>\\w\\+<span class=\"hljs-symbol\">\\)</span>/\\2 \\1/<br></code></pre></td></tr></table></figure>\n\n<p>上面的命令包含太多的反斜杠，很难阅读。 使用<code>\\v</code>运算符更方便:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\v(\\w+) (\\w+)/\\<span class=\"hljs-number\">2</span> \\<span class=\"hljs-number\">1</span>/<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>太好了！ 让我们分解该命令:</p>\n<ul>\n<li><code>:%s</code> 定位文件中的所有行以执行替换操作</li>\n<li><code>(\\w+) (\\w+)</code>对模式进行分组。<code>\\w</code>是 Vim 预定义的单词字符范围简写(<code>[0-9A-Za-z_]</code>)之一。 包围<code>\\w</code>的<code>()</code>将匹配的单词字符进行分组。 请注意两个分组之间的空间。 <code>(\\w+) (\\w+)</code> 捕获两个分组。 在第一行上，第一组捕获”let”，第二组捕获”one”。(英文版中，作者写成了：第一组捕获”one”，第二组捕获”two”，可能是作者不小心的错误)。</li>\n<li><code>\\2 \\1</code> 以相反的顺序返回捕获的组。 <code>\\2</code>包含捕获的字符串”let”，而<code>\\1</code>包含字符串”one”。 使<code>\\2 \\1</code>返回字符串”let one”。</li>\n</ul>\n<p>回想一下，<code>\\0</code>代表整个匹配的模式。 您可以使用<code>( )</code>将匹配的字符串分成较小的组。 每个组都由<code>\\1</code>, <code>\\2</code>, <code>\\3</code>等表示。</p>\n<p>让我们再举一个例子来巩固这一匹配分组的概念。 如果您有以下数字:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">123<br>456<br>789<br></code></pre></td></tr></table></figure>\n\n<p>要颠倒顺序，请运行:</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">:<span class=\"hljs-meta\">%</span>s/\\v<span class=\"hljs-comment\">(\\d)</span><span class=\"hljs-comment\">(\\d)</span><span class=\"hljs-comment\">(\\d)</span>/\\<span class=\"hljs-number\">3</span>\\<span class=\"hljs-number\">2</span>\\<span class=\"hljs-number\">1</span>/<br></code></pre></td></tr></table></figure>\n\n<p>结果是:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">321<br>654<br>987<br></code></pre></td></tr></table></figure>\n\n<p>每个<code>(\\d)</code>都匹配一个数字并创建一个分组。 在第一行上，第一个<code>(\\d)</code>的值为”1”，第二个<code>(\\d)</code>的值为”2”，第三个<code>(\\d)</code>的值为”3”。 它们存储在变量<code>\\1</code>，<code>\\2</code>和<code>\\3</code>中。 在替换的后半部分，新模式<code>\\3\\2\\1</code>在第一行上产生”321”值。</p>\n<p>相反，如果您运行下面的命令:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\v(\\d\\d)(\\d)/\\<span class=\"hljs-number\">2</span>\\<span class=\"hljs-number\">1</span>/<br></code></pre></td></tr></table></figure>\n<p>您将获得不同的结果:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">312<br>645<br>978<br></code></pre></td></tr></table></figure>\n\n<p>这是因为您现在只有两个组。 被<code>(\\d\\d)</code>捕获的第一组存储在<code>\\1</code>内，其值为”12”。 由<code>(\\d)</code>捕获的第二组存储在<code>\\2</code>内部，其值为”3”。 然后，<code>\\2\\1</code>返回”312”。</p>\n<h2 id=\"替换标志\"><a href=\"#替换标志\" class=\"headerlink\" title=\"替换标志\"></a>替换标志</h2><p>如果您有以下句子:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate pancake, strawberry pancake, <span class=\"hljs-keyword\">blueberry </span>pancake<br></code></pre></td></tr></table></figure>\n\n<p>要将所有 pancakes 替换为 donut，您不能只运行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/pancake/donut</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的命令将仅替换第一个匹配项，返回的结果是:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate donut, strawberry pancake, <span class=\"hljs-keyword\">blueberry </span>pancake<br></code></pre></td></tr></table></figure>\n\n<p>有两种解决方法。 一，您可以再运行两次替代命令。 二，您可以向其传递全局(<code>g</code>)标志来替换一行中的所有匹配项。</p>\n<p>让我们谈谈全局标志。 运行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/pancake/donut/g</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 迅速将所有”pancake”替换为”donut”。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&amp;    重用上一个替代命令中的标志。 必须作为第一个标志传递。<br>g    替换行中的所有匹配项。<br>c    要求替代确认。<br>e    防止替换失败时显示错误消息。<br><span class=\"hljs-selector-tag\">i</span>    执行不区分大小写的替换<br><span class=\"hljs-selector-tag\">I</span>    执行区分大小写的替换<br></code></pre></td></tr></table></figure>\n\n<p>我上面没有列出更多标志。 要了解所有标志，请查看<code>:h s_flags</code>。</p>\n<p>顺便说一句，重复替换命令（<code>&amp;</code>和<code>:s</code>）不保留标志。 运行<code>&amp;</code>只会重复<code>:s/pancake/donut/</code>而没有<code>g</code>。 要使用所有标志快速重复最后一个替代命令，请运行<code>:&amp;&amp;</code>。</p>\n<h2 id=\"更改定界符\"><a href=\"#更改定界符\" class=\"headerlink\" title=\"更改定界符\"></a>更改定界符</h2><p>如果您需要用长路径替换 URL:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">https:<span class=\"hljs-regexp\">//my</span>site.com<span class=\"hljs-regexp\">/a/</span>b<span class=\"hljs-regexp\">/c/</span>d/e<br></code></pre></td></tr></table></figure>\n\n<p>要用单词”hello”代替它，请运行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:s/https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e/hello/<br></code></pre></td></tr></table></figure>\n\n<p>但是，很难说出哪些正斜杠（<code>/</code>）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或<code>&quot;</code>，<code>|</code>和<code>\\</code>之外的字符）来更改定界符。让我们将它们替换为<code>+</code>。上面的替换命令可以重写为 :</p>\n<figure class=\"highlight mercury\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mercury\">:s+https:<span class=\"hljs-built_in\">\\/</span><span class=\"hljs-built_in\">\\/</span>mysite.com<span class=\"hljs-built_in\">\\/</span>a<span class=\"hljs-built_in\">\\/</span>b<span class=\"hljs-built_in\">\\/</span>c<span class=\"hljs-built_in\">\\/</span>d<span class=\"hljs-built_in\">\\/</span>e+hello+<br></code></pre></td></tr></table></figure>\n\n<p>现在，更容易看到分隔符在哪里。</p>\n<h2 id=\"特殊替换\"><a href=\"#特殊替换\" class=\"headerlink\" title=\"特殊替换\"></a>特殊替换</h2><p>您还可以修改要替换的文本的大小写。 给出以下表达式，您的任务是将所有变量名比如 “one”, “two”, “three”等，改成大写:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>请运行:</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-meta\">%</span>s/\\v<span class=\"hljs-comment\">(\\w+)</span> <span class=\"hljs-comment\">(\\w+)</span>/\\<span class=\"hljs-number\">1</span> \\U\\<span class=\"hljs-number\">2</span>/<br></code></pre></td></tr></table></figure>\n\n<p>你会得到:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let ONE <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let TWO <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let THREE <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let FOUR <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let FIVE <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>这是该命令的细分:</p>\n<ul>\n<li><code>(\\w+) (\\w+)</code>捕获前两个匹配的分组，例如”let”和”one”。</li>\n<li><code>\\1</code>返回第一个组的值”let”</li>\n<li><code>\\U\\2</code>大写(<code>\\U</code>)第二组(<code>\\2</code>)。</li>\n</ul>\n<p>该命令的窍门是表达式<code>\\U\\2</code>。<code>\\U</code>将后面跟着的字符变为大写。</p>\n<p>让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">vim is <span class=\"hljs-keyword\">the</span> greatest <span class=\"hljs-keyword\">text</span> editor <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">whole</span> galaxy<br></code></pre></td></tr></table></figure>\n\n<p>您可以运行:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:s<span class=\"hljs-regexp\">/\\&lt;./</span>\\U&amp;/g<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-variable\">Vim</span> <span class=\"hljs-variable\">Is</span> <span class=\"hljs-variable\">The</span> <span class=\"hljs-variable\">Greatest</span> <span class=\"hljs-built_in\">Text</span> <span class=\"hljs-variable\">Editor</span> <span class=\"hljs-built_in\">In</span> <span class=\"hljs-variable\">The</span> <span class=\"hljs-variable\">Whole</span> <span class=\"hljs-variable\">Galaxy</span><br></code></pre></td></tr></table></figure>\n\n<p>细目如下:</p>\n<ul>\n<li><code>:s</code> 替换当前行</li>\n<li><code>\\&lt;.</code> 由两部分组成:<code>\\&lt;</code>匹配单词的开头，<code>.</code>匹配任何字符。 <code>\\&lt;</code>运算符使后面跟着的字符表示单词的第一个字符。 由于<code>.</code>是下一个字符，因此它将匹配任意单词的第一个字符。</li>\n<li><code>\\U&amp;</code> 将后续符号子序列<code>&amp;</code>大写。 回想一下，<code>&amp;</code>（或<code>\\0</code>）代表整个匹配。 这里它匹配单词的第一个字符。</li>\n<li><code>g</code>全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。</li>\n</ul>\n<p>要了解替换的特殊替换符号（如<code>\\u</code>和<code>\\U</code>）的更多信息，请查看<code>:h sub-replace-special</code>。</p>\n<h2 id=\"候选模式\"><a href=\"#候选模式\" class=\"headerlink\" title=\"候选模式\"></a>候选模式</h2><p>有时您需要同时匹配多个模式。 如果您有以下问候:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hola <span class=\"hljs-keyword\">vim</span><br>salve <span class=\"hljs-keyword\">vim</span><br>bonjour <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>您仅需在包含单词”hello”或”hola”的行上用”friend”代替”vim”。回想一想本章前面的知识点，你可以使用<code>|</code> 来分隔可选的模式:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\v(hello|hola) vim)/\\<span class=\"hljs-number\">1</span> friend/g<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">hello <span class=\"hljs-keyword\">friend</span><br>hola <span class=\"hljs-keyword\">friend</span><br>salve vim<br>bonjour vim<br></code></pre></td></tr></table></figure>\n\n<p>这是细分:</p>\n<ul>\n<li><code>%s</code> 在文件的每一行上运行替代命令。</li>\n<li><code>(hello|hola)</code> 匹配*“hello”或”hola”，并将其视为一个组。</li>\n<li><code>vim</code> 是字面意思”vim”。</li>\n<li><code>\\1</code> 是第一个匹配组，它是文本”hello”或”hola”。</li>\n<li><code>friend</code> 是字面的“朋友”。</li>\n</ul>\n<h2 id=\"指定替换模式的开始位置和结束位置\"><a href=\"#指定替换模式的开始位置和结束位置\" class=\"headerlink\" title=\"指定替换模式的开始位置和结束位置\"></a>指定替换模式的开始位置和结束位置</h2><p>回想一下，您可以使用<code>\\zs</code>和<code>\\ze</code>来指定一个匹配的开始位置和结束位置。这个技术在替换操作中同样有效，如果你有以下文本：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate pancake<br>strawberry <span class=\"hljs-keyword\">sweetcake</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">blueberry </span>hotcake<br></code></pre></td></tr></table></figure>\n\n<p>要想将”hotcake”中的”cake”替换为”dog”，得到”hotdog”:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/hot</span>\\zscake/dog/g<br></code></pre></td></tr></table></figure>\n\n<p>结果是：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate pancake<br>strawberry <span class=\"hljs-keyword\">sweetcake</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">blueberry </span>hotdog<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h2><p>您可以使用下面技巧，在某行中替换第n个匹配：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">One Mississippi, <span class=\"hljs-literal\">two</span> Mississippi, <span class=\"hljs-literal\">three</span> Mississippi, <span class=\"hljs-literal\">four</span> Mississippi, <span class=\"hljs-literal\">five</span> Mississippi.<br></code></pre></td></tr></table></figure>\n\n<p>要想将第3个”Mississippi”替换为 “Arkansas”，运行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">:s/\\<span class=\"hljs-title function_\">v</span>(<span class=\"hljs-params\">.&#123;-&#125;\\zsMississippi</span>)&#123;<span class=\"hljs-number\">3</span>&#125;/<span class=\"hljs-title class_\">Arkansas</span>/g<br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>:s/</code> 替换命令。</li>\n<li><code>\\v</code> 魔术关键字，使您不必转义特殊字符。</li>\n<li><code>.</code> 匹配任意单个字符。</li>\n<li><code>&#123;-&#125;</code> 表示使用非贪婪模式匹配前面的0个或多个字符。</li>\n<li><code>\\zsMississippi</code> 使得从”Mississippi”开始捕获匹配。</li>\n<li><code>(...)&#123;3&#125;</code> 查找第3个匹配</li>\n</ul>\n<p>在本章前面的内容中，你已经看到过<code>&#123;3&#125;</code>这样的语法。在本例中，<code>&#123;3&#125;</code>将精确匹配第3个匹配。这里的新技巧是<code>&#123;-&#125;</code>。它表示进行非贪婪匹配。它会找到符合给定模式的最短的匹配。在本例中，<code>(.&#123;-&#125;Mississippi)</code>匹配以任意字符开始、数量最少的”Mississippi”。对比<code>(.*Mississippi)</code>，后者会找到符合给定模式的最长匹配。</p>\n<p>如果您使用<code>(.&#123;-&#125;Mississippi)</code>，你会得到5个匹配：”One Mississippi”, “Two Mississippi”,等。如果您使用<code>(.*Mississippi)</code>，您只会得到1个匹配：最后一个 “Mississippi”。<code>*</code>表示贪婪匹配，而<code>&#123;-&#125;</code>表示非贪婪匹配。要想了解更多，可以查看 <code>:h /\\&#123;-</code> 和 <code>:h non-greedy</code>。</p>\n<p>让我们看一个简单的例子。如果您有以下字符串：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">abc1de1<br></code></pre></td></tr></table></figure>\n\n<p>用贪婪模式匹配 “abc1de1” ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/a.*1<br></code></pre></td></tr></table></figure>\n\n<p>用非贪婪模式匹配 “abc1”：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/a.\\&#123;-&#125;1<br></code></pre></td></tr></table></figure>\n\n<p>因此，如果您需要将最长的匹配转为大写（贪婪模式），运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/a</span>.*<span class=\"hljs-number\">1</span>/\\U&amp;/g<br></code></pre></td></tr></table></figure>\n\n<p>会得到：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">ABC1DE1<br></code></pre></td></tr></table></figure>\n\n<p>如果您需要将最短的匹配转为大写（非贪婪模式），运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/a</span>.\\&#123;-&#125;<span class=\"hljs-number\">1</span>/\\U&amp;/g<br></code></pre></td></tr></table></figure>\n\n<p>会得到：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">ABC1de1<br></code></pre></td></tr></table></figure>\n\n<p>如果您是第一次接触贪婪模式与非贪婪模式这两个概念，可能会把你绕晕。围绕不同的组合去实验，知道您明白这两个概念。</p>\n<h2 id=\"跨多个文件替换\"><a href=\"#跨多个文件替换\" class=\"headerlink\" title=\"跨多个文件替换\"></a>跨多个文件替换</h2><p>最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: <code>food.txt</code> 和 <code>animal.txt</code>.</p>\n<p><code>food.txt</code>内:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">corn dog</span><br><span class=\"hljs-attribute\">hot dog</span><br><span class=\"hljs-attribute\">chili dog</span><br></code></pre></td></tr></table></figure>\n\n<p><code>animal.txt</code>内:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">large</span> dog<br><span class=\"hljs-keyword\">medium</span> dog<br><span class=\"hljs-keyword\">small</span> dog<br></code></pre></td></tr></table></figure>\n\n<p>假设您的目录结构如下所示:</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">├ food.txt<br>├ <span class=\"hljs-keyword\">animal</span>.txt<br></code></pre></td></tr></table></figure>\n\n<p>首先，用<code>:args</code>同时捕获”food.txt”和”animal.txt”到参数列表中。回顾前面的章节，<code>:args</code>可用于创建文件名列表。在 Vim 中有几种方法可以做到这一点，其中一种方法是在Vim内部运行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> *.txt                  捕获当前位置的所有txt文件<br></code></pre></td></tr></table></figure>\n\n<p>测试一下，当您运行<code>:args</code>时，您应该会看到：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"><span class=\"hljs-comment\">[food.txt]</span> <span class=\"hljs-keyword\">animal</span>.txt<br></code></pre></td></tr></table></figure>\n\n<p>现在，所有的相关文件都已经存储在参数列表中，您可以用 <code>:argdo</code> 命令跨多文件替换，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:argdo %s<span class=\"hljs-regexp\">/dog/</span>chicken/<br></code></pre></td></tr></table></figure>\n\n<p>这条命令对所有<code>:args</code>列表中的文件执行替换操作。最终，存储修改的文件：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">argdo</span> <span class=\"hljs-keyword\">update</span><br></code></pre></td></tr></table></figure>\n\n<p><code>:args</code> 和 <code>:argdo</code> 是两个有用的工具，用于跨多文件执行命令行命令。可以用其他命令结合尝试一下！</p>\n<h2 id=\"用宏跨多个文件替换\"><a href=\"#用宏跨多个文件替换\" class=\"headerlink\" title=\"用宏跨多个文件替换\"></a>用宏跨多个文件替换</h2><p>另外，您也可以用宏跨多个文件运行替代命令。执行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> *.txt<br>qq<br><span class=\"hljs-symbol\">:%s/dog/chicken/g</span><br><span class=\"hljs-symbol\">:wnext</span><br>q<br><span class=\"hljs-number\">99</span><span class=\"hljs-variable\">@q</span><br></code></pre></td></tr></table></figure>\n\n<p>以下是步骤的细分:</p>\n<ul>\n<li><code>:args *.txt</code> 会将相关文件列出到<code>:args</code>列表中。</li>\n<li><code>qq</code> 启动”q”寄存器中的宏。</li>\n<li><code>:%s/dog/chicken/g</code>在当前文件的所有行上用”chicken”替换”dog”。</li>\n<li><code>:wnext</code> 写入（保存）文件，然后转到<code>args</code>列表中的下一个文件。就像同时运行<code>:w</code>和<code>:next</code>一样。</li>\n<li><code>q</code> 停止宏录制。</li>\n<li><code>99@q</code> 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。</li>\n</ul>\n<h2 id=\"以聪明的方式学习搜索和替换\"><a href=\"#以聪明的方式学习搜索和替换\" class=\"headerlink\" title=\"以聪明的方式学习搜索和替换\"></a>以聪明的方式学习搜索和替换</h2><p>良好的搜索能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。要想掌握正则表达式，您必须在实践中去不断地使用它。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。</p>\n<p>一种提高模式匹配技能的好方法是，每当您需要搜索一个模式串时（例如”hello 123”），不要直接查询文字的字面值(<code>/hello 123</code>)，去尝试使用模式串来搜索它(比如<code>/\\v(\\l+) (\\d+)</code>)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。</p>\n<p>既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。</p>\n","site":{"data":{}},"wordcount":11129,"excerpt":"","more":"<h1 id=\"第12章-搜索和替换\"><a href=\"#第12章-搜索和替换\" class=\"headerlink\" title=\"第12章 搜索和替换\"></a>第12章 搜索和替换</h1><p>本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您得基于文本的共同模式搜索大量的内容。通过学习如何在搜索和替换中使用正则表达式而不是字面字符串，您将能够快速定位任何文本。</p>\n<p>附带说明一下，在本章中，当谈论搜索时，我将主要使用<code>/</code>。您使用<code>/</code>进行的所有操作也可以使用<code>?</code>完成。</p>\n<h2 id=\"智能区分大小写\"><a href=\"#智能区分大小写\" class=\"headerlink\" title=\"智能区分大小写\"></a>智能区分大小写</h2><p>尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本”Learn Vim”，则很容易把字母的大小写输错，从而得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项<code>ignorecase</code>闪亮的地方。只需在 vimrc 中添加<code>set ignorecase</code>，所有搜索词就不区分大小写。现在，您不必再执行<code>/Learn Vim</code>了。 <code>/learn vim</code>将起作用。</p>\n<p>但是，有时您需要搜索特定大小写的短语。一种方法是用 <code>set noignorecase</code> 关闭<code>ignorecase</code>选项，但是每次需要搜索区分大小写的短语时，都得反复地打开和关闭这个选项。</p>\n<p>为避免反复开关<code>ignorecase</code>选项，Vim 有一个<code>smartcase</code>选项。您可以将<code>ignorecase</code>和<code>smartcase</code>选项结合起来，当您输入的搜索词全部是小写时，进行大小写不敏感搜索；而当搜索词 <strong>至少有1个大写字母时</strong>，进行大小写敏感搜索。</p>\n<p>在您的 vimrc 中，添加:</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-keyword\">set</span> ignorecase <span class=\"hljs-comment\">smartcase</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您有这些文字:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello</span><br><span class=\"hljs-attribute\">HELLO</span><br><span class=\"hljs-attribute\">Hello</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>/hello</code> 匹配”hello”，”HELLO”和”Hello”。</li>\n<li><code>/HELLO</code> 仅匹配”HELLO”。</li>\n<li><code>/Hello</code> 仅匹配”Hello”。</li>\n</ul>\n<p>有一个缺点。因为现在当您执行<code>/hello</code>时，Vim 将进行大小写不敏感搜索,那如果只需要搜索小写字符串怎么办？您可以在搜索词前使用<code>\\C</code>模式来告诉 Vim，后续搜索词将区分大小写。如果执行<code>/\\Chello</code>，它将严格匹配”hello”，而不是”HELLO”或”Hello”。</p>\n<h2 id=\"一行中的第一个和最后一个字符\"><a href=\"#一行中的第一个和最后一个字符\" class=\"headerlink\" title=\"一行中的第一个和最后一个字符\"></a>一行中的第一个和最后一个字符</h2><p>您可以使用<code>^</code>匹配行中的第一个字符，并使用<code>$</code>匹配行中的最后一个字符。</p>\n<p>如果您有以下文字:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello hello</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以使用<code>/^hello</code>来定位第一个”hello”。 ‘^’后面的字符必须是一行中的第一个字符。 要定位最后一个”hello”，请运行<code>/hello$</code>。 ‘$‘ 之前的字符必须是一行中的最后一个字符。</p>\n<p>如果您有以下文字:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">hello hello <span class=\"hljs-keyword\">friend</span><br></code></pre></td></tr></table></figure>\n\n<p>运行<code>/hello$</code>将匹配不到任何内容，因为”friend”是该行的最后一项，而不是”hello”。</p>\n<h2 id=\"重复搜索\"><a href=\"#重复搜索\" class=\"headerlink\" title=\"重复搜索\"></a>重复搜索</h2><p>您可以使用<code>//</code>重复上一个搜索。如果您只是搜索<code>/hello</code>，则运行<code>//</code>等同于运行<code>/hello</code>。此快捷键可以为您节省一些按键操作，尤其是在您刚搜索了一个很长的字符串的情况下。另外，回想一下前面的章节，您还可以使用<code>n</code>和<code>N</code>分别以相同方向和相反方向重复上一次搜索。</p>\n<p>如果您想快速回忆起 第<em>n</em>个最近使用的搜索字怎么办？您可以先按<code>/</code>，然后按<code>up</code>&#x2F;<code>down</code>方向键（或<code>Ctrl-N</code>&#x2F;<code>Ctrl-P</code>），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行<code>:history /</code>。</p>\n<p>在搜索过程中到达文件末尾时，Vim 会抛出一个错误:<code>&quot;搜索到达底部,未找到匹配项:&#123;your-search&#125;&quot;</code>(<code>&quot;Search hit the BOTTOM without match for: &#123;your-search&#125;&quot;</code>)。有时这个特性能成为一个安全守卫，可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用<code>set wrapscan</code>选项使 Vim 在到达文件末尾时回到文件顶部进行搜索。要关闭此功能，请执行<code>set nowrapscan</code>。</p>\n<h2 id=\"使用候选词搜索\"><a href=\"#使用候选词搜索\" class=\"headerlink\" title=\"使用候选词搜索\"></a>使用候选词搜索</h2><p>一次搜索多个单词属于日常操作。 如果您需要搜索”hello vim”或”hola vim”，而不是”salve vim”或”bonjour vim”，则可以使用<code>|</code>或运算符。</p>\n<p>给予这样一段文本:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hola <span class=\"hljs-keyword\">vim</span><br>salve <span class=\"hljs-keyword\">vim</span><br>bonjour <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>要同时匹配”hello”和”hola”，可以执行<code>/hello\\|hola</code>。 您必须使用（<code>\\</code>）转义（<code>|</code>）或运算符，否则 Vim 将按字面意义搜索字符串”|”。</p>\n<p>如果您不想每次都输入<code>\\|</code>，则可以在搜索开始时使用<code>magic</code>语法（<code>\\v</code>）:<code>/\\vhello|hola</code>。 我不会在本章中详细介绍<code>magic</code>，但是有了<code>\\v</code>，您就不必再转义特殊字符了。 要了解有关<code>\\v</code>的更多信息，请随时查看<code>:h \\v</code>。</p>\n<h2 id=\"设置模式匹配的开始位置和结束位置\"><a href=\"#设置模式匹配的开始位置和结束位置\" class=\"headerlink\" title=\"设置模式匹配的开始位置和结束位置\"></a>设置模式匹配的开始位置和结束位置</h2><p>也许您需要搜索的文本是复合词的一部分。如果您有这些文字:</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-number\">11</span>vi<span class=\"hljs-name\">m22</span><br>vi<span class=\"hljs-name\">m22</span><br><span class=\"hljs-number\">11</span>vim<br>vim<br></code></pre></td></tr></table></figure>\n\n<p>如果您仅需要选择以”11”开始、以”22”结束的”vim”，您可以使用<code>\\zs</code>（开始匹配）和<code>\\ze</code>（结束匹配）运算符。 执行:</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-string\">/11</span>\\zsvim\\ze22<br></code></pre></td></tr></table></figure>\n\n<p>Vim仍然会匹配整个模式”11vim22”，但是仅高亮显示介于<code>\\zs</code>和<code>\\ze</code>之间的内容。 另一个例子:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">foobar</span><br><span class=\"hljs-attribute\">foobaz</span><br></code></pre></td></tr></table></figure>\n\n<p>如果需要在”foobaz”中搜索”foo”，而不是在”foobar”中搜索，请运行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/foo\\zebaz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"搜索字符组\"><a href=\"#搜索字符组\" class=\"headerlink\" title=\"搜索字符组\"></a>搜索字符组</h2><p>到目前为止，您所有的搜索字都是字面内容。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符组<code>[ ]</code>。</p>\n<p>如果您需要搜索任何数字，则可能不想每一次都输入<code>/0\\|1\\|2\\|3\\|4\\|5\\|6\\|7\\|8\\|9\\|0</code>。相反，请使用<code>/[0-9]</code>来匹配一位数字。 <code>0-9</code>表达式表示 Vim 尝试匹配的数字范围是 0-9，因此，如果要查找 1 到 5 之间的数字，请使用<code>/[1-5]</code>。</p>\n<p>数字不是 Vim 可以查找的唯一数据类型。您也可以执行<code>/[a-z]</code>来搜索小写字母，而<code>/[A-Z]</code>来搜索大写字母。</p>\n<p>您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行<code>/[0-9a-fA-F]</code>。</p>\n<p>要进行否定搜索，可以在字符范围括号内添加<code>^</code>。要搜索非数字，请运行<code>/[^0-9]</code>，Vim会匹配任何字符，只要它不是数字即可。请注意，范围括号内的脱符号（<code>^</code>）与行首位置符号（例如:<code>/^hello</code>）不同。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示”一行中的第一个字符”。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 <code>/^abc</code>匹配行中的第一个”abc”，而<code>/[^abc]</code>匹配除”a”，”b”或”c”以外的任何字符。</p>\n<h2 id=\"搜索重复字符\"><a href=\"#搜索重复字符\" class=\"headerlink\" title=\"搜索重复字符\"></a>搜索重复字符</h2><p>如果需要在此文本中搜索两位数:</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-number\">1</span>aa<br><span class=\"hljs-number\">11</span><span class=\"hljs-keyword\">a</span><br><span class=\"hljs-number\">111</span><br></code></pre></td></tr></table></figure>\n\n<p>您可以使用<code>/[0-9][0-9]</code>来匹配两位数字字符，但是该方法难以扩展。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个<code>count</code>参数。</p>\n<p>您可以将<code>count</code>传递给您的搜索。 它具有以下语法:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"hljs-template-variable\">&#123;n,m&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>顺便说一句，当在 Vim 中使用它们时，这些<code>count</code>周围的花括号需要被转义。 <code>count</code> 运算符放在您要递增的单个字符之后。</p>\n<p>这是<code>count</code>语法的四种不同变体: </p>\n<ul>\n<li><code>&#123;n&#125;</code>是精确匹配。 <code>/[0-9]\\&#123;2\\&#125;</code>匹配两个数字:”11”，以及”111”中的”11”。</li>\n<li><code>&#123;n,m&#125;</code>是范围匹配。 <code>/[0-9]\\&#123;2,3\\&#125;</code>匹配 2 到 3 位数字:”11”和”111”。 </li>\n<li><code>&#123;,m&#125;</code>是上限匹配。 <code>/[0-9]\\&#123;,3\\&#125;</code>匹配最多 3 个数字:”1”，”11”和”111”。</li>\n<li><code>&#123;n,&#125;</code>是下限匹配。 <code>/[0-9]\\&#123;2,\\&#125;</code>匹配最少 2 个或多个数字:”11”和”111”。</li>\n</ul>\n<p>计数参数<code>\\&#123;0,\\&#125;</code>（零或多个）和<code>\\&#123;1,\\&#125;</code>（一个或多个）是最常见的搜索模式，Vim 为它们提供了特殊的操作符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）。 如果执行<code>/[0-9]*</code>，功能与<code>/[0-9]\\&#123;0,\\&#125;</code>相同。 它搜索零个或多个数字，会匹配””，”1”，”123”。 顺便说一句，它也将匹配非数字，例如”a”，因为在技术上，字母”a”中的数字个数为零。 在使用”*“之前，请仔细考虑。 如果执行<code>/[0-9]\\+</code>，则与<code>/[0-9]\\&#123;1,\\&#125;</code>相同。 它搜索一个或多个数字，将匹配”1”和”12”。</p>\n<h2 id=\"预定义的字符组\"><a href=\"#预定义的字符组\" class=\"headerlink\" title=\"预定义的字符组\"></a>预定义的字符组</h2><p>Vim 为常见字符组（例如数字和字母）提供了简写。 我不会在这里逐一介绍，但可以在<code>:h /character-classes</code>中找到完整列表。 下面是有用的部分:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\"><span class=\"hljs-string\">\\d</span>    数字[<span class=\"hljs-number\">0</span>-<span class=\"hljs-number\">9</span>]<br><span class=\"hljs-string\">\\D</span>    非数字[^ <span class=\"hljs-number\">0</span>-<span class=\"hljs-number\">9</span>]<br><span class=\"hljs-string\">\\s</span>    空格字符（空格和制表符）<br><span class=\"hljs-string\">\\S</span>    非空白字符（除空格和制表符外的所有字符）<br><span class=\"hljs-string\">\\w</span>    单词字符[<span class=\"hljs-number\">0</span>-<span class=\"hljs-number\">9</span>A-Za-z_]<br><span class=\"hljs-string\">\\l</span>    小写字母[a-z]<br><span class=\"hljs-string\">\\u</span>    大写字符[A-Z]<br></code></pre></td></tr></table></figure>\n\n<p>您可以像使用普通字符组一样使用它们。 要搜索任何一位数字，可以使用<code>/\\d</code>以获得更简洁的语法，而不使用<code>/[0-9]</code>。</p>\n<h2 id=\"搜索示例：在一对相似字符之间捕获文本\"><a href=\"#搜索示例：在一对相似字符之间捕获文本\" class=\"headerlink\" title=\"搜索示例：在一对相似字符之间捕获文本\"></a>搜索示例：在一对相似字符之间捕获文本</h2><p>如果要搜索由双引号引起来的短语:</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;Vim is awesome!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行这个:</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\">`/<span class=\"hljs-string\">&quot;[^&quot;</span>]\\+<span class=\"hljs-string\">&quot;`</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下:</p>\n<ul>\n<li><code>&quot;</code> 是字面双引号。它匹配第一个双引号。</li>\n<li><code>[^&quot;]</code> 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。</li>\n<li><code>\\+</code>表示一个或多个。因为它的前面是<code>[^&quot;]</code>，因此 Vim 查找一个或多个不是双引号的字符。</li>\n<li><code>&quot;</code> 是字面双引号。它与右双引号匹配。</li>\n</ul>\n<p>当看到第一个<code>&quot;</code>时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个<code>&quot;</code>模式并停止模式捕获。同时，两个双引号之间的所有非双引号字符都被<code>[^&quot;]\\+</code> 模式捕获，在这个例子中是短语”Vim is awesome!”。这是一个通用模式（其实就是正则表达式）用于捕获 <strong>由一对类似的定界符包围的短语</strong>。</p>\n<ul>\n<li>要捕获被单引号包围的短语，你可以使用<code>/&#39;[^&#39;]\\+&#39;</code></li>\n<li>要捕获为0包围的短语，你可以使用<code>/0[^0]\\+0</code></li>\n</ul>\n<h2 id=\"搜索示例：捕获电话号码\"><a href=\"#搜索示例：捕获电话号码\" class=\"headerlink\" title=\"搜索示例：捕获电话号码\"></a>搜索示例：捕获电话号码</h2><p>如果要匹配以连字符(<code>-</code>)分隔的美国电话号码，例如<code>123-456-7890</code>，则可以使用:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">/\\d\\</span><span class=\"hljs-template-variable\">&#123;3\\&#125;</span><span class=\"language-xml\">-\\d\\</span><span class=\"hljs-template-variable\">&#123;3\\&#125;</span><span class=\"language-xml\">-\\d\\</span><span class=\"hljs-template-variable\">&#123;4\\&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>美国电话号码的组成是：首先是三位数字，其后是另外三位数字，最后是另外四位数字。 让我们分解一下:</p>\n<ul>\n<li><code>\\d\\&#123;3\\&#125;</code>与精确重复三次的数字匹配</li>\n<li><code>-</code>是字面的连字符</li>\n</ul>\n<p>为避免转义，可使用<code>\\v</code>:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">/\\v\\d</span><span class=\"hljs-template-variable\">&#123;3&#125;</span><span class=\"language-xml\">-\\d</span><span class=\"hljs-template-variable\">&#123;3&#125;</span><span class=\"language-xml\">-\\d</span><span class=\"hljs-template-variable\">&#123;4&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。</p>\n<p>这涵盖了本章的搜索部分。 现在开始讲替换。</p>\n<h2 id=\"基本替换\"><a href=\"#基本替换\" class=\"headerlink\" title=\"基本替换\"></a>基本替换</h2><p>Vim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:s<span class=\"hljs-regexp\">/&#123;old-pattern&#125;/</span>&#123;<span class=\"hljs-keyword\">new</span>-pattern&#125;/<br></code></pre></td></tr></table></figure>\n\n<p>让我们从一个基本用法开始。 如果您有以下文字:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> good<br></code></pre></td></tr></table></figure>\n\n<p>让我们用”awesome”代替”good”，因为 Vim 很棒。 运行<code>:s/good/awesome/.</code>您应该看到:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"重复最后一次替换\"><a href=\"#重复最后一次替换\" class=\"headerlink\" title=\"重复最后一次替换\"></a>重复最后一次替换</h2><p>您可以使用普通模式命令<code>&amp;</code>或运行<code>:s</code>来重复最后一个替代命令。 如果您刚刚运行<code>:s/good/awesome/</code>，则运行<code>&amp;</code>或<code>:s</code>将会重复执行。</p>\n<p>另外，在本章前面，我提到您可以使用<code>//</code>来重复先前的搜索模式。 此技巧可用于替代命令。 如果<code>/good</code>是最近被替换的单词，那么将第一个替换模式参数留为空白，例如在<code>:s//awesome/</code>中，则与运行<code>:s/good/awesome/</code>相同。</p>\n<h2 id=\"替换范围\"><a href=\"#替换范围\" class=\"headerlink\" title=\"替换范围\"></a>替换范围</h2><p>就像许多 Ex 命令一样，您可以将范围参数传递给替换命令。 语法为:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:[range]s<span class=\"hljs-regexp\">/old/</span><span class=\"hljs-keyword\">new</span>/<br></code></pre></td></tr></table></figure>\n\n<p>如果您有以下表达式:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">4</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>要将第3行到第5行中的”let”替换为”const”，您可以执行以下操作:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>s<span class=\"hljs-regexp\">/let/</span>const/<br></code></pre></td></tr></table></figure>\n\n<p>下面是一些你可以使用的范围参数的变体:</p>\n<ul>\n<li><code>:,3/let/const/</code> - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换到第 3 行。</li>\n<li><code>:1,s/let/const/</code> - 如果逗号后没有给出任何内容，它也代表当前行。 从第 1 行替换到当前行。</li>\n<li><code>:3s/let/const/</code> - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。</li>\n</ul>\n<p>在 Vim 中，<code>%</code>通常表示整个文件。 如果运行<code>:%s/let/const/</code>，它将在所有行上进行替换。请记住这个范围参数语法，在后面章节中很多命令行命令都遵循这个语法。</p>\n<h2 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h2><p>接下来的几节将介绍基本的正则表达式。 丰富的模式知识对于掌握替换命令至关重要。</p>\n<p>如果您具有以下表达式:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">4</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>要在数字周围添加一对双引号:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\d/<span class=\"hljs-string\">&quot;\\0&quot;</span>/<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下命令:</p>\n<ul>\n<li><code>:%s</code> 定位整个文件以执行替换。</li>\n<li><code>\\d</code> 是 Vim 的预定义数字范围简写(类似使用<code>[0-9]</code>)。</li>\n<li><code>&quot;\\0&quot;</code> 双引号是双引号的字面值。 <code>\\0</code>是一个特殊字符，代表”整个匹配的模式”。 此处匹配的模式是单个数字<code>\\d</code>。</li>\n</ul>\n<p>另外，<code>&amp;</code>也同样代表”整个匹配的模式”，就像<code>\\0</code>一样。 <code>:s/\\d/&quot;&amp;&quot;/</code>也可以。</p>\n<p>让我们考虑另一个例子。 给出以下表达式，您需要将所有的”let”和变量名交换位置:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">one let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>two let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>three let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>four let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>five let <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>为此，请运行:</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs taggerscript\">:%s/<span class=\"hljs-symbol\">\\(</span>\\w\\+<span class=\"hljs-symbol\">\\)</span> <span class=\"hljs-symbol\">\\(</span>\\w\\+<span class=\"hljs-symbol\">\\)</span>/\\2 \\1/<br></code></pre></td></tr></table></figure>\n\n<p>上面的命令包含太多的反斜杠，很难阅读。 使用<code>\\v</code>运算符更方便:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\v(\\w+) (\\w+)/\\<span class=\"hljs-number\">2</span> \\<span class=\"hljs-number\">1</span>/<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>太好了！ 让我们分解该命令:</p>\n<ul>\n<li><code>:%s</code> 定位文件中的所有行以执行替换操作</li>\n<li><code>(\\w+) (\\w+)</code>对模式进行分组。<code>\\w</code>是 Vim 预定义的单词字符范围简写(<code>[0-9A-Za-z_]</code>)之一。 包围<code>\\w</code>的<code>()</code>将匹配的单词字符进行分组。 请注意两个分组之间的空间。 <code>(\\w+) (\\w+)</code> 捕获两个分组。 在第一行上，第一组捕获”let”，第二组捕获”one”。(英文版中，作者写成了：第一组捕获”one”，第二组捕获”two”，可能是作者不小心的错误)。</li>\n<li><code>\\2 \\1</code> 以相反的顺序返回捕获的组。 <code>\\2</code>包含捕获的字符串”let”，而<code>\\1</code>包含字符串”one”。 使<code>\\2 \\1</code>返回字符串”let one”。</li>\n</ul>\n<p>回想一下，<code>\\0</code>代表整个匹配的模式。 您可以使用<code>( )</code>将匹配的字符串分成较小的组。 每个组都由<code>\\1</code>, <code>\\2</code>, <code>\\3</code>等表示。</p>\n<p>让我们再举一个例子来巩固这一匹配分组的概念。 如果您有以下数字:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">123<br>456<br>789<br></code></pre></td></tr></table></figure>\n\n<p>要颠倒顺序，请运行:</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">:<span class=\"hljs-meta\">%</span>s/\\v<span class=\"hljs-comment\">(\\d)</span><span class=\"hljs-comment\">(\\d)</span><span class=\"hljs-comment\">(\\d)</span>/\\<span class=\"hljs-number\">3</span>\\<span class=\"hljs-number\">2</span>\\<span class=\"hljs-number\">1</span>/<br></code></pre></td></tr></table></figure>\n\n<p>结果是:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">321<br>654<br>987<br></code></pre></td></tr></table></figure>\n\n<p>每个<code>(\\d)</code>都匹配一个数字并创建一个分组。 在第一行上，第一个<code>(\\d)</code>的值为”1”，第二个<code>(\\d)</code>的值为”2”，第三个<code>(\\d)</code>的值为”3”。 它们存储在变量<code>\\1</code>，<code>\\2</code>和<code>\\3</code>中。 在替换的后半部分，新模式<code>\\3\\2\\1</code>在第一行上产生”321”值。</p>\n<p>相反，如果您运行下面的命令:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\v(\\d\\d)(\\d)/\\<span class=\"hljs-number\">2</span>\\<span class=\"hljs-number\">1</span>/<br></code></pre></td></tr></table></figure>\n<p>您将获得不同的结果:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">312<br>645<br>978<br></code></pre></td></tr></table></figure>\n\n<p>这是因为您现在只有两个组。 被<code>(\\d\\d)</code>捕获的第一组存储在<code>\\1</code>内，其值为”12”。 由<code>(\\d)</code>捕获的第二组存储在<code>\\2</code>内部，其值为”3”。 然后，<code>\\2\\1</code>返回”312”。</p>\n<h2 id=\"替换标志\"><a href=\"#替换标志\" class=\"headerlink\" title=\"替换标志\"></a>替换标志</h2><p>如果您有以下句子:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate pancake, strawberry pancake, <span class=\"hljs-keyword\">blueberry </span>pancake<br></code></pre></td></tr></table></figure>\n\n<p>要将所有 pancakes 替换为 donut，您不能只运行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/pancake/donut</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的命令将仅替换第一个匹配项，返回的结果是:</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate donut, strawberry pancake, <span class=\"hljs-keyword\">blueberry </span>pancake<br></code></pre></td></tr></table></figure>\n\n<p>有两种解决方法。 一，您可以再运行两次替代命令。 二，您可以向其传递全局(<code>g</code>)标志来替换一行中的所有匹配项。</p>\n<p>让我们谈谈全局标志。 运行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/pancake/donut/g</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 迅速将所有”pancake”替换为”donut”。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&amp;    重用上一个替代命令中的标志。 必须作为第一个标志传递。<br>g    替换行中的所有匹配项。<br>c    要求替代确认。<br>e    防止替换失败时显示错误消息。<br><span class=\"hljs-selector-tag\">i</span>    执行不区分大小写的替换<br><span class=\"hljs-selector-tag\">I</span>    执行区分大小写的替换<br></code></pre></td></tr></table></figure>\n\n<p>我上面没有列出更多标志。 要了解所有标志，请查看<code>:h s_flags</code>。</p>\n<p>顺便说一句，重复替换命令（<code>&amp;</code>和<code>:s</code>）不保留标志。 运行<code>&amp;</code>只会重复<code>:s/pancake/donut/</code>而没有<code>g</code>。 要使用所有标志快速重复最后一个替代命令，请运行<code>:&amp;&amp;</code>。</p>\n<h2 id=\"更改定界符\"><a href=\"#更改定界符\" class=\"headerlink\" title=\"更改定界符\"></a>更改定界符</h2><p>如果您需要用长路径替换 URL:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">https:<span class=\"hljs-regexp\">//my</span>site.com<span class=\"hljs-regexp\">/a/</span>b<span class=\"hljs-regexp\">/c/</span>d/e<br></code></pre></td></tr></table></figure>\n\n<p>要用单词”hello”代替它，请运行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:s/https:\\/\\/mysite.com\\/a\\/b\\/c\\/d\\/e/hello/<br></code></pre></td></tr></table></figure>\n\n<p>但是，很难说出哪些正斜杠（<code>/</code>）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或<code>&quot;</code>，<code>|</code>和<code>\\</code>之外的字符）来更改定界符。让我们将它们替换为<code>+</code>。上面的替换命令可以重写为 :</p>\n<figure class=\"highlight mercury\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mercury\">:s+https:<span class=\"hljs-built_in\">\\/</span><span class=\"hljs-built_in\">\\/</span>mysite.com<span class=\"hljs-built_in\">\\/</span>a<span class=\"hljs-built_in\">\\/</span>b<span class=\"hljs-built_in\">\\/</span>c<span class=\"hljs-built_in\">\\/</span>d<span class=\"hljs-built_in\">\\/</span>e+hello+<br></code></pre></td></tr></table></figure>\n\n<p>现在，更容易看到分隔符在哪里。</p>\n<h2 id=\"特殊替换\"><a href=\"#特殊替换\" class=\"headerlink\" title=\"特殊替换\"></a>特殊替换</h2><p>您还可以修改要替换的文本的大小写。 给出以下表达式，您的任务是将所有变量名比如 “one”, “two”, “three”等，改成大写:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let one <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let two <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let three <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let four <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let five <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>请运行:</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-meta\">%</span>s/\\v<span class=\"hljs-comment\">(\\w+)</span> <span class=\"hljs-comment\">(\\w+)</span>/\\<span class=\"hljs-number\">1</span> \\U\\<span class=\"hljs-number\">2</span>/<br></code></pre></td></tr></table></figure>\n\n<p>你会得到:</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let ONE <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;1&quot;</span><span class=\"hljs-comment\">;</span><br>let TWO <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;2&quot;</span><span class=\"hljs-comment\">;</span><br>let THREE <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;3&quot;</span><span class=\"hljs-comment\">;</span><br>let FOUR <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;4&quot;</span><span class=\"hljs-comment\">;</span><br>let FIVE <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;5&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>这是该命令的细分:</p>\n<ul>\n<li><code>(\\w+) (\\w+)</code>捕获前两个匹配的分组，例如”let”和”one”。</li>\n<li><code>\\1</code>返回第一个组的值”let”</li>\n<li><code>\\U\\2</code>大写(<code>\\U</code>)第二组(<code>\\2</code>)。</li>\n</ul>\n<p>该命令的窍门是表达式<code>\\U\\2</code>。<code>\\U</code>将后面跟着的字符变为大写。</p>\n<p>让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">vim is <span class=\"hljs-keyword\">the</span> greatest <span class=\"hljs-keyword\">text</span> editor <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">whole</span> galaxy<br></code></pre></td></tr></table></figure>\n\n<p>您可以运行:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:s<span class=\"hljs-regexp\">/\\&lt;./</span>\\U&amp;/g<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-variable\">Vim</span> <span class=\"hljs-variable\">Is</span> <span class=\"hljs-variable\">The</span> <span class=\"hljs-variable\">Greatest</span> <span class=\"hljs-built_in\">Text</span> <span class=\"hljs-variable\">Editor</span> <span class=\"hljs-built_in\">In</span> <span class=\"hljs-variable\">The</span> <span class=\"hljs-variable\">Whole</span> <span class=\"hljs-variable\">Galaxy</span><br></code></pre></td></tr></table></figure>\n\n<p>细目如下:</p>\n<ul>\n<li><code>:s</code> 替换当前行</li>\n<li><code>\\&lt;.</code> 由两部分组成:<code>\\&lt;</code>匹配单词的开头，<code>.</code>匹配任何字符。 <code>\\&lt;</code>运算符使后面跟着的字符表示单词的第一个字符。 由于<code>.</code>是下一个字符，因此它将匹配任意单词的第一个字符。</li>\n<li><code>\\U&amp;</code> 将后续符号子序列<code>&amp;</code>大写。 回想一下，<code>&amp;</code>（或<code>\\0</code>）代表整个匹配。 这里它匹配单词的第一个字符。</li>\n<li><code>g</code>全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。</li>\n</ul>\n<p>要了解替换的特殊替换符号（如<code>\\u</code>和<code>\\U</code>）的更多信息，请查看<code>:h sub-replace-special</code>。</p>\n<h2 id=\"候选模式\"><a href=\"#候选模式\" class=\"headerlink\" title=\"候选模式\"></a>候选模式</h2><p>有时您需要同时匹配多个模式。 如果您有以下问候:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hola <span class=\"hljs-keyword\">vim</span><br>salve <span class=\"hljs-keyword\">vim</span><br>bonjour <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>您仅需在包含单词”hello”或”hola”的行上用”friend”代替”vim”。回想一想本章前面的知识点，你可以使用<code>|</code> 来分隔可选的模式:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/</span>\\v(hello|hola) vim)/\\<span class=\"hljs-number\">1</span> friend/g<br></code></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">hello <span class=\"hljs-keyword\">friend</span><br>hola <span class=\"hljs-keyword\">friend</span><br>salve vim<br>bonjour vim<br></code></pre></td></tr></table></figure>\n\n<p>这是细分:</p>\n<ul>\n<li><code>%s</code> 在文件的每一行上运行替代命令。</li>\n<li><code>(hello|hola)</code> 匹配*“hello”或”hola”，并将其视为一个组。</li>\n<li><code>vim</code> 是字面意思”vim”。</li>\n<li><code>\\1</code> 是第一个匹配组，它是文本”hello”或”hola”。</li>\n<li><code>friend</code> 是字面的“朋友”。</li>\n</ul>\n<h2 id=\"指定替换模式的开始位置和结束位置\"><a href=\"#指定替换模式的开始位置和结束位置\" class=\"headerlink\" title=\"指定替换模式的开始位置和结束位置\"></a>指定替换模式的开始位置和结束位置</h2><p>回想一下，您可以使用<code>\\zs</code>和<code>\\ze</code>来指定一个匹配的开始位置和结束位置。这个技术在替换操作中同样有效，如果你有以下文本：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate pancake<br>strawberry <span class=\"hljs-keyword\">sweetcake</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">blueberry </span>hotcake<br></code></pre></td></tr></table></figure>\n\n<p>要想将”hotcake”中的”cake”替换为”dog”，得到”hotdog”:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:%s/hot</span>\\zscake/dog/g<br></code></pre></td></tr></table></figure>\n\n<p>结果是：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">chocolate pancake<br>strawberry <span class=\"hljs-keyword\">sweetcake</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">blueberry </span>hotdog<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h2><p>您可以使用下面技巧，在某行中替换第n个匹配：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">One Mississippi, <span class=\"hljs-literal\">two</span> Mississippi, <span class=\"hljs-literal\">three</span> Mississippi, <span class=\"hljs-literal\">four</span> Mississippi, <span class=\"hljs-literal\">five</span> Mississippi.<br></code></pre></td></tr></table></figure>\n\n<p>要想将第3个”Mississippi”替换为 “Arkansas”，运行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">:s/\\<span class=\"hljs-title function_\">v</span>(<span class=\"hljs-params\">.&#123;-&#125;\\zsMississippi</span>)&#123;<span class=\"hljs-number\">3</span>&#125;/<span class=\"hljs-title class_\">Arkansas</span>/g<br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>:s/</code> 替换命令。</li>\n<li><code>\\v</code> 魔术关键字，使您不必转义特殊字符。</li>\n<li><code>.</code> 匹配任意单个字符。</li>\n<li><code>&#123;-&#125;</code> 表示使用非贪婪模式匹配前面的0个或多个字符。</li>\n<li><code>\\zsMississippi</code> 使得从”Mississippi”开始捕获匹配。</li>\n<li><code>(...)&#123;3&#125;</code> 查找第3个匹配</li>\n</ul>\n<p>在本章前面的内容中，你已经看到过<code>&#123;3&#125;</code>这样的语法。在本例中，<code>&#123;3&#125;</code>将精确匹配第3个匹配。这里的新技巧是<code>&#123;-&#125;</code>。它表示进行非贪婪匹配。它会找到符合给定模式的最短的匹配。在本例中，<code>(.&#123;-&#125;Mississippi)</code>匹配以任意字符开始、数量最少的”Mississippi”。对比<code>(.*Mississippi)</code>，后者会找到符合给定模式的最长匹配。</p>\n<p>如果您使用<code>(.&#123;-&#125;Mississippi)</code>，你会得到5个匹配：”One Mississippi”, “Two Mississippi”,等。如果您使用<code>(.*Mississippi)</code>，您只会得到1个匹配：最后一个 “Mississippi”。<code>*</code>表示贪婪匹配，而<code>&#123;-&#125;</code>表示非贪婪匹配。要想了解更多，可以查看 <code>:h /\\&#123;-</code> 和 <code>:h non-greedy</code>。</p>\n<p>让我们看一个简单的例子。如果您有以下字符串：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">abc1de1<br></code></pre></td></tr></table></figure>\n\n<p>用贪婪模式匹配 “abc1de1” ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/a.*1<br></code></pre></td></tr></table></figure>\n\n<p>用非贪婪模式匹配 “abc1”：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/a.\\&#123;-&#125;1<br></code></pre></td></tr></table></figure>\n\n<p>因此，如果您需要将最长的匹配转为大写（贪婪模式），运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/a</span>.*<span class=\"hljs-number\">1</span>/\\U&amp;/g<br></code></pre></td></tr></table></figure>\n\n<p>会得到：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">ABC1DE1<br></code></pre></td></tr></table></figure>\n\n<p>如果您需要将最短的匹配转为大写（非贪婪模式），运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:s/a</span>.\\&#123;-&#125;<span class=\"hljs-number\">1</span>/\\U&amp;/g<br></code></pre></td></tr></table></figure>\n\n<p>会得到：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">ABC1de1<br></code></pre></td></tr></table></figure>\n\n<p>如果您是第一次接触贪婪模式与非贪婪模式这两个概念，可能会把你绕晕。围绕不同的组合去实验，知道您明白这两个概念。</p>\n<h2 id=\"跨多个文件替换\"><a href=\"#跨多个文件替换\" class=\"headerlink\" title=\"跨多个文件替换\"></a>跨多个文件替换</h2><p>最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: <code>food.txt</code> 和 <code>animal.txt</code>.</p>\n<p><code>food.txt</code>内:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">corn dog</span><br><span class=\"hljs-attribute\">hot dog</span><br><span class=\"hljs-attribute\">chili dog</span><br></code></pre></td></tr></table></figure>\n\n<p><code>animal.txt</code>内:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">large</span> dog<br><span class=\"hljs-keyword\">medium</span> dog<br><span class=\"hljs-keyword\">small</span> dog<br></code></pre></td></tr></table></figure>\n\n<p>假设您的目录结构如下所示:</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">├ food.txt<br>├ <span class=\"hljs-keyword\">animal</span>.txt<br></code></pre></td></tr></table></figure>\n\n<p>首先，用<code>:args</code>同时捕获”food.txt”和”animal.txt”到参数列表中。回顾前面的章节，<code>:args</code>可用于创建文件名列表。在 Vim 中有几种方法可以做到这一点，其中一种方法是在Vim内部运行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> *.txt                  捕获当前位置的所有txt文件<br></code></pre></td></tr></table></figure>\n\n<p>测试一下，当您运行<code>:args</code>时，您应该会看到：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"><span class=\"hljs-comment\">[food.txt]</span> <span class=\"hljs-keyword\">animal</span>.txt<br></code></pre></td></tr></table></figure>\n\n<p>现在，所有的相关文件都已经存储在参数列表中，您可以用 <code>:argdo</code> 命令跨多文件替换，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:argdo %s<span class=\"hljs-regexp\">/dog/</span>chicken/<br></code></pre></td></tr></table></figure>\n\n<p>这条命令对所有<code>:args</code>列表中的文件执行替换操作。最终，存储修改的文件：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">argdo</span> <span class=\"hljs-keyword\">update</span><br></code></pre></td></tr></table></figure>\n\n<p><code>:args</code> 和 <code>:argdo</code> 是两个有用的工具，用于跨多文件执行命令行命令。可以用其他命令结合尝试一下！</p>\n<h2 id=\"用宏跨多个文件替换\"><a href=\"#用宏跨多个文件替换\" class=\"headerlink\" title=\"用宏跨多个文件替换\"></a>用宏跨多个文件替换</h2><p>另外，您也可以用宏跨多个文件运行替代命令。执行:</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> *.txt<br>qq<br><span class=\"hljs-symbol\">:%s/dog/chicken/g</span><br><span class=\"hljs-symbol\">:wnext</span><br>q<br><span class=\"hljs-number\">99</span><span class=\"hljs-variable\">@q</span><br></code></pre></td></tr></table></figure>\n\n<p>以下是步骤的细分:</p>\n<ul>\n<li><code>:args *.txt</code> 会将相关文件列出到<code>:args</code>列表中。</li>\n<li><code>qq</code> 启动”q”寄存器中的宏。</li>\n<li><code>:%s/dog/chicken/g</code>在当前文件的所有行上用”chicken”替换”dog”。</li>\n<li><code>:wnext</code> 写入（保存）文件，然后转到<code>args</code>列表中的下一个文件。就像同时运行<code>:w</code>和<code>:next</code>一样。</li>\n<li><code>q</code> 停止宏录制。</li>\n<li><code>99@q</code> 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。</li>\n</ul>\n<h2 id=\"以聪明的方式学习搜索和替换\"><a href=\"#以聪明的方式学习搜索和替换\" class=\"headerlink\" title=\"以聪明的方式学习搜索和替换\"></a>以聪明的方式学习搜索和替换</h2><p>良好的搜索能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。要想掌握正则表达式，您必须在实践中去不断地使用它。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。</p>\n<p>一种提高模式匹配技能的好方法是，每当您需要搜索一个模式串时（例如”hello 123”），不要直接查询文字的字面值(<code>/hello 123</code>)，去尝试使用模式串来搜索它(比如<code>/\\v(\\l+) (\\d+)</code>)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。</p>\n<p>既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。</p>\n"},{"title":"VIM-全局命令","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 全局命令\n\n到目前为止，您已经了解了如何使用点命令(`.`)重复上一次更改，如何使用宏(`q`)重复动作以及将文本存储在寄存器中(`\"`)。\n\n在本章中，您将学习如何在全局命令中重复命令行命令。\n\n## 全局命令概述\n\nVim的全局命令用于同时在多行上运行命令行命令。\n\n顺便说一句，您之前可能已经听说过 \"Ex命令\" 一词。在本书中，我将它们称为命令行命令，但Ex命令和命令行命令是相同的。它们是以冒号（`:`）开头的命令。在上一章中，您了解了替代命令。这是一个Ex命令的示例。它们之所以称为Ex，是因为它们最初来自Ex文本编辑器。在本书中，我将继续将它们称为命令行命令。有关Ex命令的完整列表，请查看`:h ex-cmd-index`。\n\n全局命令具有以下语法：\n\n```\n:g/pattern/command\n```\n\n`pattern`匹配包含该模式串的所有行，类似于替代命令中的模式串。`command`可以是任何命令行命令。全局命令通过对与`pattern`匹配的每一行执行`command`来工作。\n\n如果您具有以下表达式：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n要删除所有包含\"console\"的行，可以运行：\n\n```\n:g/console/d\n```\n\n结果：\n\n```\nconst one = 1;\n\nconst two = 2;\n\nconst three = 3;\n```\n\n全局命令在与\"console\"模式串匹配的所有行上执行删除命令(`d`)。\n\n运行`g`命令时，Vim对文件进行两次扫描。在第一次运行时，它将扫描每行并标记与`/console/`模式传教匹配的行。一旦所有匹配的行都被标记，它将进行第二次运行，并在标记的行上执行d命令。\n\n如果要删除所有包含\"const\"的行，请运行：\n\n```\n:g/const/d\n```\n\n结果：\n\n```\nconsole.log(\"one: \", one);\n\nconsole.log(\"two: \", two);\n\nconsole.log(\"three: \", three);\n```\n\n## 逆向匹配\n\n要在不匹配的行上运行全局命令，可以运行：\n\n```\n:g!/{pattern}/{command}\n```\n\n或者\n\n```\n:v/{pattern}/{command}\n```\n\n如果运行`:v/console/d`，它将删除 **不** 包含\"console\"的所有行。\n\n## 模式串\n\n全局命令使用与替代命令相同的模式串系统，因此本节将作为更新。随意跳到下一部分或继续阅读！\n\n如果您具有以下表达式：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n要删除包含\"one\"或\"two\"的行，请运行：\n\n```\n:g/one\\|two/d\n```\n\n要删除包含任何一位数字的行，请运行以下任一命令：\n\n```\n:g/[0-9]/d\n```\n\n或者\n\n```\n:g/\\d/d\n```\n\n如果您有表达式：\n\n```\nconst oneMillion = 1000000;\nconst oneThousand = 1000;\nconst one = 1;\n```\n\n要匹配包含三到六个零的行，请运行：\n\n```\n:g/0\\{3,6\\}/d\n```\n\n## 传递范围参数\n\n您可以在`g`命令之前传递一个范围。您可以通过以下几种方法来做到这一点：\n\n- `:1,5/g/console/d`  删除第1行和第5行之间匹配字符串\"console\"的行。\n- `:,5/g/console/d` 如果逗号前没有地址，则从当前行开始。它在当前行和第5行之间寻找字符串\"console\"并将该行删除。\n- `:3,/g/console/d` 如果逗号后没有地址，则在当前行结束。它在第3行和当前行之间寻找字符串\"console\"并将该行删除。\n- `:3g/console/d` 如果只传递一个地址而不带逗号，则仅在第3行执行命令。在第3行查找，如果包含字符串\"console\"，则将其删除。\n\n除了数字，您还可以将这些符号用作范围：\n- `.` 表示当前行。范围`.,3`表示当前行和第3行之间。\n- `$` 表示文件的最后一行。 `3,$`范围表示在第3行和最后一行之间。\n- `+n` 表示当前行之后的n行。您可以将其与`.`结合使用，也可以不结合使用。  `3,+1`或`3,.+1`表示在第3行和当前行之后的行之间。\n\n如果您不给它任何范围，默认情况下它将影响整个文件。这实际上不是常态。如果您不传递任何范围，Vim的大多数命令行命令仅在当前行上运行(两个值得注意的例外是：这里介绍的全局命令(`:g`)和save(`:w`)命令)。\n\n## 普通模式命令\n\n您可以将全局命令和`:normal`命令行命令一起运行。\n\n如果您有以下文字：\n```\nconst one = 1\nconsole.log(\"one: \", one)\n\nconst two = 2\nconsole.log(\"two: \", two)\n\nconst three = 3\nconsole.log(\"three: \", three)\n\n```\n要添加\";\"运行到每一行的末尾：\n```\n:g/./normal A;\n```\n\n让我们分解一下：\n- `:g` 是全局命令。\n- `/./` 是“非空行”的模式。它匹配至少包含1个字符的行。因此将与包含“const”和“console”的行匹配。它不匹配空行。\n- `normal A;` 运行`:normal`命令行命令。 `A;` 是普通模式命令，用于在该行的末尾插入\";\"。\n\n## 执行宏\n\n您也可以使用全局命令执行宏。宏只是普通模式下的操作，因此可以使用`:normal`来执行宏。如果您有以下表达式：\n\n```\nconst one = 1\nconsole.log(\"one: \", one);\n\nconst two = 2\nconsole.log(\"two: \", two);\n\nconst three = 3\nconsole.log(\"three: \", three);\n```\n\n请注意，带有\"const\"的行没有分号。让我们创建一个宏，以在寄存器\"a\"的这些行的末尾添加逗号：\n\n```\nqa0A;<esc>q\n```\n\n如果您需要复习，请查看有关宏的章节。现在运行：\n\n```\n:g/const/normal @a\n```\n\n现在，所有带有\"const\"的行的末尾将带有\";\"。\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n如果您一步一步按照示例做，您将会在第一行末尾看到两个分号。为避免这种情况，使用全局命令时，给一个范围参数，从第2行到最后一行, `:2,$g/const/normal @a`。\n\n## 递归全局命令\n\n全局命令本身是命令行命令的一种，因此您可以从技术上在全局命令中运行全局命令。\n\n给定表达式：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n如果您运行：\n\n```\n:g/console/g/two/d\n```\n\n首先，`g`将查找包含模式\"console\"的行，并找到3个匹配项。然后，第二个\"g\"将从那三个匹配项中查找包含模式\"two\"的行。最后，它将删除该匹配项。\n\n您也可以将`g`与`v`结合使用以找到正负模式。例如：\n\n```\n:g/console/v/two/d\n```\n\n与前面的命令不同，它将查找 **不** 包含\"two\"的行。\n\n## 更改定界符\n\n您可以像替代命令一样更改全局命令的定界符。规则是相同的：您可以使用任何单字节字符，但字母，数字，`\"`, `|`, 和 `\\`除外。\n\n要删除包含\"console\"的行：\n\n```\n:g@console@d\n```\n\n如果在全局命令中使用替代命令，则可以有两个不同的定界符：\n\n```\ng@one@s+const+let+g\n```\n\n此处，全局命令将查找包含\"one\"的所有行。 替换命令将从这些匹配项中将字符串\"const\"替换为\"let\"。\n\n## 默认命令\n\n如果在全局命令中未指定任何命令行命令，会发生什么？\n\n全局命令将使用打印(`:p`)命令来打印当前行的文本。如果您运行：\n\n```\n:g/console\n```\n\n它将在屏幕底部打印所有包含\"console\"的行。\n\n顺便说一下，这是一个有趣的事实。因为全局命令使用的默认命令是`p`，所以这使`g`语法为：\n\n```\n:g/re/p\n```\n- `g` = 全局命令\n- `re` = 正则表达式模式\n- `p` = 打印命令\n\n这三个元素连起来拼写为 **\"grep\"**，与命令行中的`grep` 相同。但这 **不** 是巧合。 `g/re/p`命令最初来自Ed编辑器（一个行文本编辑器）。 `grep`命令的名称来自Ed。\n\n您的计算机可能仍具有Ed编辑器。从终端运行`ed`（提示：要退出，请键入`q`）。\n\n## 反转整个缓冲区\n\n要翻转整个文件，请运行：\n\n```\n:g/^/m 0 \n```\n\n`^`表示行的开始。使用`^`匹配所有行，包括空行。\n\n如果只需要反转几行，请将其传递一个范围。要将第5行到第10行之间的行反转，请运行：\n\n```\n:5,10g/^/m 0\n```\n\n要了解有关move命令的更多信息，请查看`:h :move`。\n\n## 汇总所有待办事项\n\n当我编码时，有时我会想到一个随机的绝妙主意。不想失去专注，我通常将它们写在我正在编辑的文件中，例如：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n// TODO: 喂小狗\n\nconst two = 2;\n// TODO：自动喂小狗\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n// TODO：创建一家销售自动小狗喂食器的初创公司\n```\n\n跟踪所有已创建的TODO可能很困难。 Vim有一个`:t`（copy）方法来将所有匹配项复制到一个地址。要了解有关复制方法的更多信息，请查看`:h :copy`。\n\n要将所有TODO复制到文件末尾以便于自省，请运行：\n\n```\n:g/TODO/t $\n```\n\n结果：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n// TODO：喂小狗\n\nconst two = 2;\n// TODO：自动喂小狗\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n// TODO：创建一家销售自动小狗喂食器的初创公司\n\n// TODO：喂小狗\n// TODO：自动喂小狗\n// TODO：创建一家销售自动小狗喂食器的初创公司\n```\n\n现在，我可以查看我创建的所有TODO，另外找个时间来完成它们，或将它们委托给其他人，然后继续执行下一个任务。\n\n如果不想复制，而是将所有的 TODO 移动到末尾，可以使用移动命令 `m`：\n\n```\n:g/TODO/m $\n```\n\n结果：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n\n// TODO：喂小狗\n// TODO：自动喂小狗\n// TODO：创建一家销售自动小狗喂食器的初创公司\n```\n\n## 黑洞删除\n\n回想一下寄存器那一章，已删除的文本存储在编号寄存器中（允许它们足够大）。每当运行`:g/console/d`时，Vim都会将删除的行存储在编号寄存器中。如果删除多行，所有编号的寄存器将很快被填满。为了避免这种情况，您可以使用黑洞寄存器（`\"_`） **不** 将删除的行存储到寄存器中。\n\n```\n:g/console/d _\n```\n\n通过在`d`之后传递`_`，Vim不会将删除的行保存到任何寄存器中。\n\n## 将多条空行减少为一条空行\n\n如果您的文件带有多个空行，如下所示：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\n\n\n\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n您可以快速将多个空行减少为一条空行。运行：\n\n```\n:g/^$/,/./-1j\n```\n\n结果：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n一般情况下全局命令遵循下列格式：`:g/pattern/command`。但是，您也可以使用下面的格式：`:g/pattern1/,/pattern2/command`。用这种格式，Vim将会使`command`作用在`pattern1`和`pattern2`上。\n\n记住上面说的格式，让我们根据`:g/pattern1/,/pattern2/command`这个格式分解一下命令`:g/^$/,/./-1j`：\n- `/pattern1/` 就是 `/^$/` 。它表示一个空行（一个没有任何字符的行）。\n- `/pattern2/` 就是 `/./`（用-1作为行修正）。`/./`表示一个非空行（一个含有至少1个字符的行）。这里的 `-1` 意思是向上偏移1行。\n- `command` 就是 `j`，一个联接命令(`:j`)。在这个示例中，该全局命令联接所有给定的行。\n\n顺便说一句，如果您想要将多个空行全部删去，运行下面的命令：\n\n```\n:g/^$/,/./j\n```\n\n或者：\n\n```\n:g/^$/-j\n```\n\n您的文本将会减少为：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\nconst two = 2;\nconsole.log(\"two: \", two);\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n（译者补充：`j`连接命令的格式是：`:[range]j`。比如：`:1,5j`将连接第1至5行。在前面的命令中`:g/pattern1/,/pattern2/-1j`，`/pattern1/`和`/pattern2`都是`j`命令的范围参数，表示连接空行至非空行上方一行，这样就会保留1个空行。在早前的英文版本中有关于`j`命令的介绍，不知为何在后面的更新中，原作者删除了关于`j`命令的介绍）\n\n## 高级排序\n\nVim有一个`:sort`命令来对一个范围内的行进行排序。例如：\n\n```\nd\nb\na\ne\nc\n```\n\n您可以通过运行`:sort`对它们进行排序。如果给它一个范围，它将只对该范围内的行进行排序。例如，`:3,5sort`仅在第三和第五行之间排序。\n\n如果您具有以下表达式：\n\n```\nconst arrayB = [\n  \"i\",\n  \"g\",\n  \"h\",\n  \"b\",\n  \"f\",\n  \"d\",\n  \"e\",\n  \"c\",\n  \"a\",\n]\n\nconst arrayA = [\n  \"h\",\n  \"b\",\n  \"f\",\n  \"d\",\n  \"e\",\n  \"a\",\n  \"c\",\n]\n```\n\n如果需要排序数组中的元素，而不是数组本身，可以运行以下命令：\n\n```\n:g/\\[/+1,/\\]/-1sort\n```\n\n结果：\n```\nconst arrayB = [\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n]\n\nconst arrayA = [\n  \"a\"\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"h\",\n]\n```\n\n这很棒！但是命令看起来很复杂。让我们分解一下。该命令依然遵循 `:g/pattern1/,/pattern2/command`这个格式。\n\n- `:g` 是全局命令\n- `/\\[/+1` 是第一个模式串，它匹配左方括号\"[\"。`+1`表示匹配行的下面1行。\n- `/\\[/-1` 是第二个模式串，它匹配右方括号\"]\"。`-1`表示匹配行的上面1行。\n- `/\\[/+1,/\\]/-1` 表示在\"[\"和\"]\"之间的行。\n- `sort` 是命令行命令：排序。\n\n## 聪明地学习全局命令\n\n全局命令针对所有匹配的行执行命令行命令。有了它，您只需要运行一次命令，Vim就会为您完成其余的工作。要精通全局命令，需要做两件事：良好的命令行命令词汇表和正则表达式知识。随着您花费更多的时间使用Vim，您自然会学到更多的命令行命令。正则表达式知识需要更多的实际操作。但是一旦您适应了使用正则表达式，您将领先于很多其他人。\n\n这里的一些例子很复杂。不要被吓到。真正花时间了解它们。认真阅读每个模式串，不要放弃。\n\n每当需要在多个位置应用命令时，请暂停并查看是否可以使用`g`命令。寻找最适合工作的命令，并编写一个模式串以同时定位多个目标。\n\n既然您已经知道全局命令的功能强大，那么让我们学习如何使用外部命令来增加工具库。\n","source":"_posts/Vim/ch13_the_global_command.md","raw":"---\ntitle: VIM-全局命令\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 全局命令\n\n到目前为止，您已经了解了如何使用点命令(`.`)重复上一次更改，如何使用宏(`q`)重复动作以及将文本存储在寄存器中(`\"`)。\n\n在本章中，您将学习如何在全局命令中重复命令行命令。\n\n## 全局命令概述\n\nVim的全局命令用于同时在多行上运行命令行命令。\n\n顺便说一句，您之前可能已经听说过 \"Ex命令\" 一词。在本书中，我将它们称为命令行命令，但Ex命令和命令行命令是相同的。它们是以冒号（`:`）开头的命令。在上一章中，您了解了替代命令。这是一个Ex命令的示例。它们之所以称为Ex，是因为它们最初来自Ex文本编辑器。在本书中，我将继续将它们称为命令行命令。有关Ex命令的完整列表，请查看`:h ex-cmd-index`。\n\n全局命令具有以下语法：\n\n```\n:g/pattern/command\n```\n\n`pattern`匹配包含该模式串的所有行，类似于替代命令中的模式串。`command`可以是任何命令行命令。全局命令通过对与`pattern`匹配的每一行执行`command`来工作。\n\n如果您具有以下表达式：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n要删除所有包含\"console\"的行，可以运行：\n\n```\n:g/console/d\n```\n\n结果：\n\n```\nconst one = 1;\n\nconst two = 2;\n\nconst three = 3;\n```\n\n全局命令在与\"console\"模式串匹配的所有行上执行删除命令(`d`)。\n\n运行`g`命令时，Vim对文件进行两次扫描。在第一次运行时，它将扫描每行并标记与`/console/`模式传教匹配的行。一旦所有匹配的行都被标记，它将进行第二次运行，并在标记的行上执行d命令。\n\n如果要删除所有包含\"const\"的行，请运行：\n\n```\n:g/const/d\n```\n\n结果：\n\n```\nconsole.log(\"one: \", one);\n\nconsole.log(\"two: \", two);\n\nconsole.log(\"three: \", three);\n```\n\n## 逆向匹配\n\n要在不匹配的行上运行全局命令，可以运行：\n\n```\n:g!/{pattern}/{command}\n```\n\n或者\n\n```\n:v/{pattern}/{command}\n```\n\n如果运行`:v/console/d`，它将删除 **不** 包含\"console\"的所有行。\n\n## 模式串\n\n全局命令使用与替代命令相同的模式串系统，因此本节将作为更新。随意跳到下一部分或继续阅读！\n\n如果您具有以下表达式：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n要删除包含\"one\"或\"two\"的行，请运行：\n\n```\n:g/one\\|two/d\n```\n\n要删除包含任何一位数字的行，请运行以下任一命令：\n\n```\n:g/[0-9]/d\n```\n\n或者\n\n```\n:g/\\d/d\n```\n\n如果您有表达式：\n\n```\nconst oneMillion = 1000000;\nconst oneThousand = 1000;\nconst one = 1;\n```\n\n要匹配包含三到六个零的行，请运行：\n\n```\n:g/0\\{3,6\\}/d\n```\n\n## 传递范围参数\n\n您可以在`g`命令之前传递一个范围。您可以通过以下几种方法来做到这一点：\n\n- `:1,5/g/console/d`  删除第1行和第5行之间匹配字符串\"console\"的行。\n- `:,5/g/console/d` 如果逗号前没有地址，则从当前行开始。它在当前行和第5行之间寻找字符串\"console\"并将该行删除。\n- `:3,/g/console/d` 如果逗号后没有地址，则在当前行结束。它在第3行和当前行之间寻找字符串\"console\"并将该行删除。\n- `:3g/console/d` 如果只传递一个地址而不带逗号，则仅在第3行执行命令。在第3行查找，如果包含字符串\"console\"，则将其删除。\n\n除了数字，您还可以将这些符号用作范围：\n- `.` 表示当前行。范围`.,3`表示当前行和第3行之间。\n- `$` 表示文件的最后一行。 `3,$`范围表示在第3行和最后一行之间。\n- `+n` 表示当前行之后的n行。您可以将其与`.`结合使用，也可以不结合使用。  `3,+1`或`3,.+1`表示在第3行和当前行之后的行之间。\n\n如果您不给它任何范围，默认情况下它将影响整个文件。这实际上不是常态。如果您不传递任何范围，Vim的大多数命令行命令仅在当前行上运行(两个值得注意的例外是：这里介绍的全局命令(`:g`)和save(`:w`)命令)。\n\n## 普通模式命令\n\n您可以将全局命令和`:normal`命令行命令一起运行。\n\n如果您有以下文字：\n```\nconst one = 1\nconsole.log(\"one: \", one)\n\nconst two = 2\nconsole.log(\"two: \", two)\n\nconst three = 3\nconsole.log(\"three: \", three)\n\n```\n要添加\";\"运行到每一行的末尾：\n```\n:g/./normal A;\n```\n\n让我们分解一下：\n- `:g` 是全局命令。\n- `/./` 是“非空行”的模式。它匹配至少包含1个字符的行。因此将与包含“const”和“console”的行匹配。它不匹配空行。\n- `normal A;` 运行`:normal`命令行命令。 `A;` 是普通模式命令，用于在该行的末尾插入\";\"。\n\n## 执行宏\n\n您也可以使用全局命令执行宏。宏只是普通模式下的操作，因此可以使用`:normal`来执行宏。如果您有以下表达式：\n\n```\nconst one = 1\nconsole.log(\"one: \", one);\n\nconst two = 2\nconsole.log(\"two: \", two);\n\nconst three = 3\nconsole.log(\"three: \", three);\n```\n\n请注意，带有\"const\"的行没有分号。让我们创建一个宏，以在寄存器\"a\"的这些行的末尾添加逗号：\n\n```\nqa0A;<esc>q\n```\n\n如果您需要复习，请查看有关宏的章节。现在运行：\n\n```\n:g/const/normal @a\n```\n\n现在，所有带有\"const\"的行的末尾将带有\";\"。\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n如果您一步一步按照示例做，您将会在第一行末尾看到两个分号。为避免这种情况，使用全局命令时，给一个范围参数，从第2行到最后一行, `:2,$g/const/normal @a`。\n\n## 递归全局命令\n\n全局命令本身是命令行命令的一种，因此您可以从技术上在全局命令中运行全局命令。\n\n给定表达式：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n如果您运行：\n\n```\n:g/console/g/two/d\n```\n\n首先，`g`将查找包含模式\"console\"的行，并找到3个匹配项。然后，第二个\"g\"将从那三个匹配项中查找包含模式\"two\"的行。最后，它将删除该匹配项。\n\n您也可以将`g`与`v`结合使用以找到正负模式。例如：\n\n```\n:g/console/v/two/d\n```\n\n与前面的命令不同，它将查找 **不** 包含\"two\"的行。\n\n## 更改定界符\n\n您可以像替代命令一样更改全局命令的定界符。规则是相同的：您可以使用任何单字节字符，但字母，数字，`\"`, `|`, 和 `\\`除外。\n\n要删除包含\"console\"的行：\n\n```\n:g@console@d\n```\n\n如果在全局命令中使用替代命令，则可以有两个不同的定界符：\n\n```\ng@one@s+const+let+g\n```\n\n此处，全局命令将查找包含\"one\"的所有行。 替换命令将从这些匹配项中将字符串\"const\"替换为\"let\"。\n\n## 默认命令\n\n如果在全局命令中未指定任何命令行命令，会发生什么？\n\n全局命令将使用打印(`:p`)命令来打印当前行的文本。如果您运行：\n\n```\n:g/console\n```\n\n它将在屏幕底部打印所有包含\"console\"的行。\n\n顺便说一下，这是一个有趣的事实。因为全局命令使用的默认命令是`p`，所以这使`g`语法为：\n\n```\n:g/re/p\n```\n- `g` = 全局命令\n- `re` = 正则表达式模式\n- `p` = 打印命令\n\n这三个元素连起来拼写为 **\"grep\"**，与命令行中的`grep` 相同。但这 **不** 是巧合。 `g/re/p`命令最初来自Ed编辑器（一个行文本编辑器）。 `grep`命令的名称来自Ed。\n\n您的计算机可能仍具有Ed编辑器。从终端运行`ed`（提示：要退出，请键入`q`）。\n\n## 反转整个缓冲区\n\n要翻转整个文件，请运行：\n\n```\n:g/^/m 0 \n```\n\n`^`表示行的开始。使用`^`匹配所有行，包括空行。\n\n如果只需要反转几行，请将其传递一个范围。要将第5行到第10行之间的行反转，请运行：\n\n```\n:5,10g/^/m 0\n```\n\n要了解有关move命令的更多信息，请查看`:h :move`。\n\n## 汇总所有待办事项\n\n当我编码时，有时我会想到一个随机的绝妙主意。不想失去专注，我通常将它们写在我正在编辑的文件中，例如：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n// TODO: 喂小狗\n\nconst two = 2;\n// TODO：自动喂小狗\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n// TODO：创建一家销售自动小狗喂食器的初创公司\n```\n\n跟踪所有已创建的TODO可能很困难。 Vim有一个`:t`（copy）方法来将所有匹配项复制到一个地址。要了解有关复制方法的更多信息，请查看`:h :copy`。\n\n要将所有TODO复制到文件末尾以便于自省，请运行：\n\n```\n:g/TODO/t $\n```\n\n结果：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n// TODO：喂小狗\n\nconst two = 2;\n// TODO：自动喂小狗\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n// TODO：创建一家销售自动小狗喂食器的初创公司\n\n// TODO：喂小狗\n// TODO：自动喂小狗\n// TODO：创建一家销售自动小狗喂食器的初创公司\n```\n\n现在，我可以查看我创建的所有TODO，另外找个时间来完成它们，或将它们委托给其他人，然后继续执行下一个任务。\n\n如果不想复制，而是将所有的 TODO 移动到末尾，可以使用移动命令 `m`：\n\n```\n:g/TODO/m $\n```\n\n结果：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n\n// TODO：喂小狗\n// TODO：自动喂小狗\n// TODO：创建一家销售自动小狗喂食器的初创公司\n```\n\n## 黑洞删除\n\n回想一下寄存器那一章，已删除的文本存储在编号寄存器中（允许它们足够大）。每当运行`:g/console/d`时，Vim都会将删除的行存储在编号寄存器中。如果删除多行，所有编号的寄存器将很快被填满。为了避免这种情况，您可以使用黑洞寄存器（`\"_`） **不** 将删除的行存储到寄存器中。\n\n```\n:g/console/d _\n```\n\n通过在`d`之后传递`_`，Vim不会将删除的行保存到任何寄存器中。\n\n## 将多条空行减少为一条空行\n\n如果您的文件带有多个空行，如下所示：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\n\n\n\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n您可以快速将多个空行减少为一条空行。运行：\n\n```\n:g/^$/,/./-1j\n```\n\n结果：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\n\nconst two = 2;\nconsole.log(\"two: \", two);\n\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n一般情况下全局命令遵循下列格式：`:g/pattern/command`。但是，您也可以使用下面的格式：`:g/pattern1/,/pattern2/command`。用这种格式，Vim将会使`command`作用在`pattern1`和`pattern2`上。\n\n记住上面说的格式，让我们根据`:g/pattern1/,/pattern2/command`这个格式分解一下命令`:g/^$/,/./-1j`：\n- `/pattern1/` 就是 `/^$/` 。它表示一个空行（一个没有任何字符的行）。\n- `/pattern2/` 就是 `/./`（用-1作为行修正）。`/./`表示一个非空行（一个含有至少1个字符的行）。这里的 `-1` 意思是向上偏移1行。\n- `command` 就是 `j`，一个联接命令(`:j`)。在这个示例中，该全局命令联接所有给定的行。\n\n顺便说一句，如果您想要将多个空行全部删去，运行下面的命令：\n\n```\n:g/^$/,/./j\n```\n\n或者：\n\n```\n:g/^$/-j\n```\n\n您的文本将会减少为：\n\n```\nconst one = 1;\nconsole.log(\"one: \", one);\nconst two = 2;\nconsole.log(\"two: \", two);\nconst three = 3;\nconsole.log(\"three: \", three);\n```\n\n（译者补充：`j`连接命令的格式是：`:[range]j`。比如：`:1,5j`将连接第1至5行。在前面的命令中`:g/pattern1/,/pattern2/-1j`，`/pattern1/`和`/pattern2`都是`j`命令的范围参数，表示连接空行至非空行上方一行，这样就会保留1个空行。在早前的英文版本中有关于`j`命令的介绍，不知为何在后面的更新中，原作者删除了关于`j`命令的介绍）\n\n## 高级排序\n\nVim有一个`:sort`命令来对一个范围内的行进行排序。例如：\n\n```\nd\nb\na\ne\nc\n```\n\n您可以通过运行`:sort`对它们进行排序。如果给它一个范围，它将只对该范围内的行进行排序。例如，`:3,5sort`仅在第三和第五行之间排序。\n\n如果您具有以下表达式：\n\n```\nconst arrayB = [\n  \"i\",\n  \"g\",\n  \"h\",\n  \"b\",\n  \"f\",\n  \"d\",\n  \"e\",\n  \"c\",\n  \"a\",\n]\n\nconst arrayA = [\n  \"h\",\n  \"b\",\n  \"f\",\n  \"d\",\n  \"e\",\n  \"a\",\n  \"c\",\n]\n```\n\n如果需要排序数组中的元素，而不是数组本身，可以运行以下命令：\n\n```\n:g/\\[/+1,/\\]/-1sort\n```\n\n结果：\n```\nconst arrayB = [\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n]\n\nconst arrayA = [\n  \"a\"\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"h\",\n]\n```\n\n这很棒！但是命令看起来很复杂。让我们分解一下。该命令依然遵循 `:g/pattern1/,/pattern2/command`这个格式。\n\n- `:g` 是全局命令\n- `/\\[/+1` 是第一个模式串，它匹配左方括号\"[\"。`+1`表示匹配行的下面1行。\n- `/\\[/-1` 是第二个模式串，它匹配右方括号\"]\"。`-1`表示匹配行的上面1行。\n- `/\\[/+1,/\\]/-1` 表示在\"[\"和\"]\"之间的行。\n- `sort` 是命令行命令：排序。\n\n## 聪明地学习全局命令\n\n全局命令针对所有匹配的行执行命令行命令。有了它，您只需要运行一次命令，Vim就会为您完成其余的工作。要精通全局命令，需要做两件事：良好的命令行命令词汇表和正则表达式知识。随着您花费更多的时间使用Vim，您自然会学到更多的命令行命令。正则表达式知识需要更多的实际操作。但是一旦您适应了使用正则表达式，您将领先于很多其他人。\n\n这里的一些例子很复杂。不要被吓到。真正花时间了解它们。认真阅读每个模式串，不要放弃。\n\n每当需要在多个位置应用命令时，请暂停并查看是否可以使用`g`命令。寻找最适合工作的命令，并编写一个模式串以同时定位多个目标。\n\n既然您已经知道全局命令的功能强大，那么让我们学习如何使用外部命令来增加工具库。\n","slug":"Vim/ch13_the_global_command","published":1,"updated":"2022-08-28T07:38:59.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i20001xscvm34qwede1","content":"<h1 id=\"全局命令\"><a href=\"#全局命令\" class=\"headerlink\" title=\"全局命令\"></a>全局命令</h1><p>到目前为止，您已经了解了如何使用点命令(<code>.</code>)重复上一次更改，如何使用宏(<code>q</code>)重复动作以及将文本存储在寄存器中(<code>&quot;</code>)。</p>\n<p>在本章中，您将学习如何在全局命令中重复命令行命令。</p>\n<h2 id=\"全局命令概述\"><a href=\"#全局命令概述\" class=\"headerlink\" title=\"全局命令概述\"></a>全局命令概述</h2><p>Vim的全局命令用于同时在多行上运行命令行命令。</p>\n<p>顺便说一句，您之前可能已经听说过 “Ex命令” 一词。在本书中，我将它们称为命令行命令，但Ex命令和命令行命令是相同的。它们是以冒号（<code>:</code>）开头的命令。在上一章中，您了解了替代命令。这是一个Ex命令的示例。它们之所以称为Ex，是因为它们最初来自Ex文本编辑器。在本书中，我将继续将它们称为命令行命令。有关Ex命令的完整列表，请查看<code>:h ex-cmd-index</code>。</p>\n<p>全局命令具有以下语法：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/pattern/command</span><br></code></pre></td></tr></table></figure>\n\n<p><code>pattern</code>匹配包含该模式串的所有行，类似于替代命令中的模式串。<code>command</code>可以是任何命令行命令。全局命令通过对与<code>pattern</code>匹配的每一行执行<code>command</code>来工作。</p>\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>要删除所有包含”console”的行，可以运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/d</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br><br>const two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br><br>const three <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>全局命令在与”console”模式串匹配的所有行上执行删除命令(<code>d</code>)。</p>\n<p>运行<code>g</code>命令时，Vim对文件进行两次扫描。在第一次运行时，它将扫描每行并标记与<code>/console/</code>模式传教匹配的行。一旦所有匹配的行都被标记，它将进行第二次运行，并在标记的行上执行d命令。</p>\n<p>如果要删除所有包含”const”的行，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/const/d</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, one);<br><br><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, two);<br><br><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"逆向匹配\"><a href=\"#逆向匹配\" class=\"headerlink\" title=\"逆向匹配\"></a>逆向匹配</h2><p>要在不匹配的行上运行全局命令，可以运行：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">:g!<span class=\"hljs-regexp\">/&#123;pattern&#125;/</span>&#123;command&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:v<span class=\"hljs-regexp\">/&#123;pattern&#125;/</span>&#123;command&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果运行<code>:v/console/d</code>，它将删除 <strong>不</strong> 包含”console”的所有行。</p>\n<h2 id=\"模式串\"><a href=\"#模式串\" class=\"headerlink\" title=\"模式串\"></a>模式串</h2><p>全局命令使用与替代命令相同的模式串系统，因此本节将作为更新。随意跳到下一部分或继续阅读！</p>\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>要删除包含”one”或”two”的行，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/one</span>\\|two/d<br></code></pre></td></tr></table></figure>\n\n<p>要删除包含任何一位数字的行，请运行以下任一命令：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/[0-9]/</span>d<br></code></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/\\d/</span>d<br></code></pre></td></tr></table></figure>\n\n<p>如果您有表达式：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const oneMillion <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000000</span><span class=\"hljs-comment\">;</span><br>const oneThousand <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000</span><span class=\"hljs-comment\">;</span><br>const one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>要匹配包含三到六个零的行，请运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/0\\&#123;3,6\\&#125;/</span>d<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"传递范围参数\"><a href=\"#传递范围参数\" class=\"headerlink\" title=\"传递范围参数\"></a>传递范围参数</h2><p>您可以在<code>g</code>命令之前传递一个范围。您可以通过以下几种方法来做到这一点：</p>\n<ul>\n<li><code>:1,5/g/console/d</code>  删除第1行和第5行之间匹配字符串”console”的行。</li>\n<li><code>:,5/g/console/d</code> 如果逗号前没有地址，则从当前行开始。它在当前行和第5行之间寻找字符串”console”并将该行删除。</li>\n<li><code>:3,/g/console/d</code> 如果逗号后没有地址，则在当前行结束。它在第3行和当前行之间寻找字符串”console”并将该行删除。</li>\n<li><code>:3g/console/d</code> 如果只传递一个地址而不带逗号，则仅在第3行执行命令。在第3行查找，如果包含字符串”console”，则将其删除。</li>\n</ul>\n<p>除了数字，您还可以将这些符号用作范围：</p>\n<ul>\n<li><code>.</code> 表示当前行。范围<code>.,3</code>表示当前行和第3行之间。</li>\n<li><code>$</code> 表示文件的最后一行。 <code>3,$</code>范围表示在第3行和最后一行之间。</li>\n<li><code>+n</code> 表示当前行之后的n行。您可以将其与<code>.</code>结合使用，也可以不结合使用。  <code>3,+1</code>或<code>3,.+1</code>表示在第3行和当前行之后的行之间。</li>\n</ul>\n<p>如果您不给它任何范围，默认情况下它将影响整个文件。这实际上不是常态。如果您不传递任何范围，Vim的大多数命令行命令仅在当前行上运行(两个值得注意的例外是：这里介绍的全局命令(<code>:g</code>)和save(<code>:w</code>)命令)。</p>\n<h2 id=\"普通模式命令\"><a href=\"#普通模式命令\" class=\"headerlink\" title=\"普通模式命令\"></a>普通模式命令</h2><p>您可以将全局命令和<code>:normal</code>命令行命令一起运行。</p>\n<p>如果您有以下文字：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>)<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>)<br><br><span class=\"hljs-keyword\">const</span> three = 3<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three)<br><br></code></pre></td></tr></table></figure>\n<p>要添加”;”运行到每一行的末尾：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/./</span>normal A;<br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下：</p>\n<ul>\n<li><code>:g</code> 是全局命令。</li>\n<li><code>/./</code> 是“非空行”的模式。它匹配至少包含1个字符的行。因此将与包含“const”和“console”的行匹配。它不匹配空行。</li>\n<li><code>normal A;</code> 运行<code>:normal</code>命令行命令。 <code>A;</code> 是普通模式命令，用于在该行的末尾插入”;”。</li>\n</ul>\n<h2 id=\"执行宏\"><a href=\"#执行宏\" class=\"headerlink\" title=\"执行宏\"></a>执行宏</h2><p>您也可以使用全局命令执行宏。宏只是普通模式下的操作，因此可以使用<code>:normal</code>来执行宏。如果您有以下表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>请注意，带有”const”的行没有分号。让我们创建一个宏，以在寄存器”a”的这些行的末尾添加逗号：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">qa0A<span class=\"hljs-comment\">;&lt;esc&gt;q</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您需要复习，请查看有关宏的章节。现在运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/const/normal</span> <span class=\"hljs-variable\">@a</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，所有带有”const”的行的末尾将带有”;”。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>如果您一步一步按照示例做，您将会在第一行末尾看到两个分号。为避免这种情况，使用全局命令时，给一个范围参数，从第2行到最后一行, <code>:2,$g/const/normal @a</code>。</p>\n<h2 id=\"递归全局命令\"><a href=\"#递归全局命令\" class=\"headerlink\" title=\"递归全局命令\"></a>递归全局命令</h2><p>全局命令本身是命令行命令的一种，因此您可以从技术上在全局命令中运行全局命令。</p>\n<p>给定表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>如果您运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/g/two/d</span><br></code></pre></td></tr></table></figure>\n\n<p>首先，<code>g</code>将查找包含模式”console”的行，并找到3个匹配项。然后，第二个”g”将从那三个匹配项中查找包含模式”two”的行。最后，它将删除该匹配项。</p>\n<p>您也可以将<code>g</code>与<code>v</code>结合使用以找到正负模式。例如：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/v/two/d</span><br></code></pre></td></tr></table></figure>\n\n<p>与前面的命令不同，它将查找 <strong>不</strong> 包含”two”的行。</p>\n<h2 id=\"更改定界符\"><a href=\"#更改定界符\" class=\"headerlink\" title=\"更改定界符\"></a>更改定界符</h2><p>您可以像替代命令一样更改全局命令的定界符。规则是相同的：您可以使用任何单字节字符，但字母，数字，<code>&quot;</code>, <code>|</code>, 和 <code>\\</code>除外。</p>\n<p>要删除包含”console”的行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g</span><span class=\"hljs-variable\">@console</span><span class=\"hljs-variable\">@d</span><br></code></pre></td></tr></table></figure>\n\n<p>如果在全局命令中使用替代命令，则可以有两个不同的定界符：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs julia\">g<span class=\"hljs-meta\">@one</span><span class=\"hljs-meta\">@s</span>+<span class=\"hljs-keyword\">const</span>+<span class=\"hljs-keyword\">let</span>+g<br></code></pre></td></tr></table></figure>\n\n<p>此处，全局命令将查找包含”one”的所有行。 替换命令将从这些匹配项中将字符串”const”替换为”let”。</p>\n<h2 id=\"默认命令\"><a href=\"#默认命令\" class=\"headerlink\" title=\"默认命令\"></a>默认命令</h2><p>如果在全局命令中未指定任何命令行命令，会发生什么？</p>\n<p>全局命令将使用打印(<code>:p</code>)命令来打印当前行的文本。如果您运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console</span><br></code></pre></td></tr></table></figure>\n\n<p>它将在屏幕底部打印所有包含”console”的行。</p>\n<p>顺便说一下，这是一个有趣的事实。因为全局命令使用的默认命令是<code>p</code>，所以这使<code>g</code>语法为：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/re/p</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>g</code> &#x3D; 全局命令</li>\n<li><code>re</code> &#x3D; 正则表达式模式</li>\n<li><code>p</code> &#x3D; 打印命令</li>\n</ul>\n<p>这三个元素连起来拼写为 **”grep”**，与命令行中的<code>grep</code> 相同。但这 <strong>不</strong> 是巧合。 <code>g/re/p</code>命令最初来自Ed编辑器（一个行文本编辑器）。 <code>grep</code>命令的名称来自Ed。</p>\n<p>您的计算机可能仍具有Ed编辑器。从终端运行<code>ed</code>（提示：要退出，请键入<code>q</code>）。</p>\n<h2 id=\"反转整个缓冲区\"><a href=\"#反转整个缓冲区\" class=\"headerlink\" title=\"反转整个缓冲区\"></a>反转整个缓冲区</h2><p>要翻转整个文件，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/^/m</span> <span class=\"hljs-number\">0</span> <br></code></pre></td></tr></table></figure>\n\n<p><code>^</code>表示行的开始。使用<code>^</code>匹配所有行，包括空行。</p>\n<p>如果只需要反转几行，请将其传递一个范围。要将第5行到第10行之间的行反转，请运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">10</span>g<span class=\"hljs-regexp\">/^/m</span> <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>要了解有关move命令的更多信息，请查看<code>:h :move</code>。</p>\n<h2 id=\"汇总所有待办事项\"><a href=\"#汇总所有待办事项\" class=\"headerlink\" title=\"汇总所有待办事项\"></a>汇总所有待办事项</h2><p>当我编码时，有时我会想到一个随机的绝妙主意。不想失去专注，我通常将它们写在我正在编辑的文件中，例如：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> 喂小狗</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></code></pre></td></tr></table></figure>\n\n<p>跟踪所有已创建的TODO可能很困难。 Vim有一个<code>:t</code>（copy）方法来将所有匹配项复制到一个地址。要了解有关复制方法的更多信息，请查看<code>:h :copy</code>。</p>\n<p>要将所有TODO复制到文件末尾以便于自省，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/TODO/t</span> $<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><span class=\"hljs-comment\">// TODO：喂小狗</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br><br><span class=\"hljs-comment\">// TODO：喂小狗</span><br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，我可以查看我创建的所有TODO，另外找个时间来完成它们，或将它们委托给其他人，然后继续执行下一个任务。</p>\n<p>如果不想复制，而是将所有的 TODO 移动到末尾，可以使用移动命令 <code>m</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/TODO/m</span> $<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br><br><span class=\"hljs-comment\">// TODO：喂小狗</span><br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"黑洞删除\"><a href=\"#黑洞删除\" class=\"headerlink\" title=\"黑洞删除\"></a>黑洞删除</h2><p>回想一下寄存器那一章，已删除的文本存储在编号寄存器中（允许它们足够大）。每当运行<code>:g/console/d</code>时，Vim都会将删除的行存储在编号寄存器中。如果删除多行，所有编号的寄存器将很快被填满。为了避免这种情况，您可以使用黑洞寄存器（<code>&quot;_</code>） <strong>不</strong> 将删除的行存储到寄存器中。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/d</span> _<br></code></pre></td></tr></table></figure>\n\n<p>通过在<code>d</code>之后传递<code>_</code>，Vim不会将删除的行保存到任何寄存器中。</p>\n<h2 id=\"将多条空行减少为一条空行\"><a href=\"#将多条空行减少为一条空行\" class=\"headerlink\" title=\"将多条空行减少为一条空行\"></a>将多条空行减少为一条空行</h2><p>如果您的文件带有多个空行，如下所示：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><br><br><br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>您可以快速将多个空行减少为一条空行。运行：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-symbol\">:g/^</span><span class=\"hljs-variable\">$/</span>,<span class=\"hljs-regexp\">/./</span>-1j<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>一般情况下全局命令遵循下列格式：<code>:g/pattern/command</code>。但是，您也可以使用下面的格式：<code>:g/pattern1/,/pattern2/command</code>。用这种格式，Vim将会使<code>command</code>作用在<code>pattern1</code>和<code>pattern2</code>上。</p>\n<p>记住上面说的格式，让我们根据<code>:g/pattern1/,/pattern2/command</code>这个格式分解一下命令<code>:g/^$/,/./-1j</code>：</p>\n<ul>\n<li><code>/pattern1/</code> 就是 <code>/^$/</code> 。它表示一个空行（一个没有任何字符的行）。</li>\n<li><code>/pattern2/</code> 就是 <code>/./</code>（用-1作为行修正）。<code>/./</code>表示一个非空行（一个含有至少1个字符的行）。这里的 <code>-1</code> 意思是向上偏移1行。</li>\n<li><code>command</code> 就是 <code>j</code>，一个联接命令(<code>:j</code>)。在这个示例中，该全局命令联接所有给定的行。</li>\n</ul>\n<p>顺便说一句，如果您想要将多个空行全部删去，运行下面的命令：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-symbol\">:g/^</span><span class=\"hljs-variable\">$/</span>,<span class=\"hljs-regexp\">/./j</span><br></code></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/^</span><span class=\"hljs-variable\">$/</span>-j<br></code></pre></td></tr></table></figure>\n\n<p>您的文本将会减少为：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>（译者补充：<code>j</code>连接命令的格式是：<code>:[range]j</code>。比如：<code>:1,5j</code>将连接第1至5行。在前面的命令中<code>:g/pattern1/,/pattern2/-1j</code>，<code>/pattern1/</code>和<code>/pattern2</code>都是<code>j</code>命令的范围参数，表示连接空行至非空行上方一行，这样就会保留1个空行。在早前的英文版本中有关于<code>j</code>命令的介绍，不知为何在后面的更新中，原作者删除了关于<code>j</code>命令的介绍）</p>\n<h2 id=\"高级排序\"><a href=\"#高级排序\" class=\"headerlink\" title=\"高级排序\"></a>高级排序</h2><p>Vim有一个<code>:sort</code>命令来对一个范围内的行进行排序。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">d<br><span class=\"hljs-selector-tag\">b</span><br><span class=\"hljs-selector-tag\">a</span><br>e<br>c<br></code></pre></td></tr></table></figure>\n\n<p>您可以通过运行<code>:sort</code>对它们进行排序。如果给它一个范围，它将只对该范围内的行进行排序。例如，<code>:3,5sort</code>仅在第三和第五行之间排序。</p>\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">const</span> arrayB = [<br>  <span class=\"hljs-string\">&quot;i&quot;</span>,<br>  <span class=\"hljs-string\">&quot;g&quot;</span>,<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>  <span class=\"hljs-string\">&quot;a&quot;</span>,<br>]<br><br><span class=\"hljs-keyword\">const</span> arrayA = [<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;a&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<p>如果需要排序数组中的元素，而不是数组本身，可以运行以下命令：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:g<span class=\"hljs-regexp\">/\\[/</span>+<span class=\"hljs-number\">1</span>,<span class=\"hljs-regexp\">/\\]/</span>-<span class=\"hljs-number\">1</span><span class=\"hljs-keyword\">sort</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">const</span> arrayB = [<br>  <span class=\"hljs-string\">&quot;a&quot;</span>,<br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;g&quot;</span>,<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>  <span class=\"hljs-string\">&quot;i&quot;</span>,<br>]<br><br><span class=\"hljs-keyword\">const</span> arrayA = [<br>  <span class=\"hljs-string\">&quot;a&quot;</span><br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<p>这很棒！但是命令看起来很复杂。让我们分解一下。该命令依然遵循 <code>:g/pattern1/,/pattern2/command</code>这个格式。</p>\n<ul>\n<li><code>:g</code> 是全局命令</li>\n<li><code>/\\[/+1</code> 是第一个模式串，它匹配左方括号”[“。<code>+1</code>表示匹配行的下面1行。</li>\n<li><code>/\\[/-1</code> 是第二个模式串，它匹配右方括号”]”。<code>-1</code>表示匹配行的上面1行。</li>\n<li><code>/\\[/+1,/\\]/-1</code> 表示在”[“和”]”之间的行。</li>\n<li><code>sort</code> 是命令行命令：排序。</li>\n</ul>\n<h2 id=\"聪明地学习全局命令\"><a href=\"#聪明地学习全局命令\" class=\"headerlink\" title=\"聪明地学习全局命令\"></a>聪明地学习全局命令</h2><p>全局命令针对所有匹配的行执行命令行命令。有了它，您只需要运行一次命令，Vim就会为您完成其余的工作。要精通全局命令，需要做两件事：良好的命令行命令词汇表和正则表达式知识。随着您花费更多的时间使用Vim，您自然会学到更多的命令行命令。正则表达式知识需要更多的实际操作。但是一旦您适应了使用正则表达式，您将领先于很多其他人。</p>\n<p>这里的一些例子很复杂。不要被吓到。真正花时间了解它们。认真阅读每个模式串，不要放弃。</p>\n<p>每当需要在多个位置应用命令时，请暂停并查看是否可以使用<code>g</code>命令。寻找最适合工作的命令，并编写一个模式串以同时定位多个目标。</p>\n<p>既然您已经知道全局命令的功能强大，那么让我们学习如何使用外部命令来增加工具库。</p>\n","site":{"data":{}},"wordcount":7371,"excerpt":"","more":"<h1 id=\"全局命令\"><a href=\"#全局命令\" class=\"headerlink\" title=\"全局命令\"></a>全局命令</h1><p>到目前为止，您已经了解了如何使用点命令(<code>.</code>)重复上一次更改，如何使用宏(<code>q</code>)重复动作以及将文本存储在寄存器中(<code>&quot;</code>)。</p>\n<p>在本章中，您将学习如何在全局命令中重复命令行命令。</p>\n<h2 id=\"全局命令概述\"><a href=\"#全局命令概述\" class=\"headerlink\" title=\"全局命令概述\"></a>全局命令概述</h2><p>Vim的全局命令用于同时在多行上运行命令行命令。</p>\n<p>顺便说一句，您之前可能已经听说过 “Ex命令” 一词。在本书中，我将它们称为命令行命令，但Ex命令和命令行命令是相同的。它们是以冒号（<code>:</code>）开头的命令。在上一章中，您了解了替代命令。这是一个Ex命令的示例。它们之所以称为Ex，是因为它们最初来自Ex文本编辑器。在本书中，我将继续将它们称为命令行命令。有关Ex命令的完整列表，请查看<code>:h ex-cmd-index</code>。</p>\n<p>全局命令具有以下语法：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/pattern/command</span><br></code></pre></td></tr></table></figure>\n\n<p><code>pattern</code>匹配包含该模式串的所有行，类似于替代命令中的模式串。<code>command</code>可以是任何命令行命令。全局命令通过对与<code>pattern</code>匹配的每一行执行<code>command</code>来工作。</p>\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>要删除所有包含”console”的行，可以运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/d</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br><br>const two <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br><br>const three <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>全局命令在与”console”模式串匹配的所有行上执行删除命令(<code>d</code>)。</p>\n<p>运行<code>g</code>命令时，Vim对文件进行两次扫描。在第一次运行时，它将扫描每行并标记与<code>/console/</code>模式传教匹配的行。一旦所有匹配的行都被标记，它将进行第二次运行，并在标记的行上执行d命令。</p>\n<p>如果要删除所有包含”const”的行，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/const/d</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, one);<br><br><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, two);<br><br><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"逆向匹配\"><a href=\"#逆向匹配\" class=\"headerlink\" title=\"逆向匹配\"></a>逆向匹配</h2><p>要在不匹配的行上运行全局命令，可以运行：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">:g!<span class=\"hljs-regexp\">/&#123;pattern&#125;/</span>&#123;command&#125;<br></code></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:v<span class=\"hljs-regexp\">/&#123;pattern&#125;/</span>&#123;command&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果运行<code>:v/console/d</code>，它将删除 <strong>不</strong> 包含”console”的所有行。</p>\n<h2 id=\"模式串\"><a href=\"#模式串\" class=\"headerlink\" title=\"模式串\"></a>模式串</h2><p>全局命令使用与替代命令相同的模式串系统，因此本节将作为更新。随意跳到下一部分或继续阅读！</p>\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>要删除包含”one”或”two”的行，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/one</span>\\|two/d<br></code></pre></td></tr></table></figure>\n\n<p>要删除包含任何一位数字的行，请运行以下任一命令：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/[0-9]/</span>d<br></code></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/\\d/</span>d<br></code></pre></td></tr></table></figure>\n\n<p>如果您有表达式：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const oneMillion <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000000</span><span class=\"hljs-comment\">;</span><br>const oneThousand <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000</span><span class=\"hljs-comment\">;</span><br>const one <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>要匹配包含三到六个零的行，请运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/0\\&#123;3,6\\&#125;/</span>d<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"传递范围参数\"><a href=\"#传递范围参数\" class=\"headerlink\" title=\"传递范围参数\"></a>传递范围参数</h2><p>您可以在<code>g</code>命令之前传递一个范围。您可以通过以下几种方法来做到这一点：</p>\n<ul>\n<li><code>:1,5/g/console/d</code>  删除第1行和第5行之间匹配字符串”console”的行。</li>\n<li><code>:,5/g/console/d</code> 如果逗号前没有地址，则从当前行开始。它在当前行和第5行之间寻找字符串”console”并将该行删除。</li>\n<li><code>:3,/g/console/d</code> 如果逗号后没有地址，则在当前行结束。它在第3行和当前行之间寻找字符串”console”并将该行删除。</li>\n<li><code>:3g/console/d</code> 如果只传递一个地址而不带逗号，则仅在第3行执行命令。在第3行查找，如果包含字符串”console”，则将其删除。</li>\n</ul>\n<p>除了数字，您还可以将这些符号用作范围：</p>\n<ul>\n<li><code>.</code> 表示当前行。范围<code>.,3</code>表示当前行和第3行之间。</li>\n<li><code>$</code> 表示文件的最后一行。 <code>3,$</code>范围表示在第3行和最后一行之间。</li>\n<li><code>+n</code> 表示当前行之后的n行。您可以将其与<code>.</code>结合使用，也可以不结合使用。  <code>3,+1</code>或<code>3,.+1</code>表示在第3行和当前行之后的行之间。</li>\n</ul>\n<p>如果您不给它任何范围，默认情况下它将影响整个文件。这实际上不是常态。如果您不传递任何范围，Vim的大多数命令行命令仅在当前行上运行(两个值得注意的例外是：这里介绍的全局命令(<code>:g</code>)和save(<code>:w</code>)命令)。</p>\n<h2 id=\"普通模式命令\"><a href=\"#普通模式命令\" class=\"headerlink\" title=\"普通模式命令\"></a>普通模式命令</h2><p>您可以将全局命令和<code>:normal</code>命令行命令一起运行。</p>\n<p>如果您有以下文字：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>)<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>)<br><br><span class=\"hljs-keyword\">const</span> three = 3<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three)<br><br></code></pre></td></tr></table></figure>\n<p>要添加”;”运行到每一行的末尾：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:g<span class=\"hljs-regexp\">/./</span>normal A;<br></code></pre></td></tr></table></figure>\n\n<p>让我们分解一下：</p>\n<ul>\n<li><code>:g</code> 是全局命令。</li>\n<li><code>/./</code> 是“非空行”的模式。它匹配至少包含1个字符的行。因此将与包含“const”和“console”的行匹配。它不匹配空行。</li>\n<li><code>normal A;</code> 运行<code>:normal</code>命令行命令。 <code>A;</code> 是普通模式命令，用于在该行的末尾插入”;”。</li>\n</ul>\n<h2 id=\"执行宏\"><a href=\"#执行宏\" class=\"headerlink\" title=\"执行宏\"></a>执行宏</h2><p>您也可以使用全局命令执行宏。宏只是普通模式下的操作，因此可以使用<code>:normal</code>来执行宏。如果您有以下表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>请注意，带有”const”的行没有分号。让我们创建一个宏，以在寄存器”a”的这些行的末尾添加逗号：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">qa0A<span class=\"hljs-comment\">;&lt;esc&gt;q</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您需要复习，请查看有关宏的章节。现在运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/const/normal</span> <span class=\"hljs-variable\">@a</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，所有带有”const”的行的末尾将带有”;”。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>如果您一步一步按照示例做，您将会在第一行末尾看到两个分号。为避免这种情况，使用全局命令时，给一个范围参数，从第2行到最后一行, <code>:2,$g/const/normal @a</code>。</p>\n<h2 id=\"递归全局命令\"><a href=\"#递归全局命令\" class=\"headerlink\" title=\"递归全局命令\"></a>递归全局命令</h2><p>全局命令本身是命令行命令的一种，因此您可以从技术上在全局命令中运行全局命令。</p>\n<p>给定表达式：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>如果您运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/g/two/d</span><br></code></pre></td></tr></table></figure>\n\n<p>首先，<code>g</code>将查找包含模式”console”的行，并找到3个匹配项。然后，第二个”g”将从那三个匹配项中查找包含模式”two”的行。最后，它将删除该匹配项。</p>\n<p>您也可以将<code>g</code>与<code>v</code>结合使用以找到正负模式。例如：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/v/two/d</span><br></code></pre></td></tr></table></figure>\n\n<p>与前面的命令不同，它将查找 <strong>不</strong> 包含”two”的行。</p>\n<h2 id=\"更改定界符\"><a href=\"#更改定界符\" class=\"headerlink\" title=\"更改定界符\"></a>更改定界符</h2><p>您可以像替代命令一样更改全局命令的定界符。规则是相同的：您可以使用任何单字节字符，但字母，数字，<code>&quot;</code>, <code>|</code>, 和 <code>\\</code>除外。</p>\n<p>要删除包含”console”的行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g</span><span class=\"hljs-variable\">@console</span><span class=\"hljs-variable\">@d</span><br></code></pre></td></tr></table></figure>\n\n<p>如果在全局命令中使用替代命令，则可以有两个不同的定界符：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs julia\">g<span class=\"hljs-meta\">@one</span><span class=\"hljs-meta\">@s</span>+<span class=\"hljs-keyword\">const</span>+<span class=\"hljs-keyword\">let</span>+g<br></code></pre></td></tr></table></figure>\n\n<p>此处，全局命令将查找包含”one”的所有行。 替换命令将从这些匹配项中将字符串”const”替换为”let”。</p>\n<h2 id=\"默认命令\"><a href=\"#默认命令\" class=\"headerlink\" title=\"默认命令\"></a>默认命令</h2><p>如果在全局命令中未指定任何命令行命令，会发生什么？</p>\n<p>全局命令将使用打印(<code>:p</code>)命令来打印当前行的文本。如果您运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console</span><br></code></pre></td></tr></table></figure>\n\n<p>它将在屏幕底部打印所有包含”console”的行。</p>\n<p>顺便说一下，这是一个有趣的事实。因为全局命令使用的默认命令是<code>p</code>，所以这使<code>g</code>语法为：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/re/p</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>g</code> &#x3D; 全局命令</li>\n<li><code>re</code> &#x3D; 正则表达式模式</li>\n<li><code>p</code> &#x3D; 打印命令</li>\n</ul>\n<p>这三个元素连起来拼写为 **”grep”**，与命令行中的<code>grep</code> 相同。但这 <strong>不</strong> 是巧合。 <code>g/re/p</code>命令最初来自Ed编辑器（一个行文本编辑器）。 <code>grep</code>命令的名称来自Ed。</p>\n<p>您的计算机可能仍具有Ed编辑器。从终端运行<code>ed</code>（提示：要退出，请键入<code>q</code>）。</p>\n<h2 id=\"反转整个缓冲区\"><a href=\"#反转整个缓冲区\" class=\"headerlink\" title=\"反转整个缓冲区\"></a>反转整个缓冲区</h2><p>要翻转整个文件，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/^/m</span> <span class=\"hljs-number\">0</span> <br></code></pre></td></tr></table></figure>\n\n<p><code>^</code>表示行的开始。使用<code>^</code>匹配所有行，包括空行。</p>\n<p>如果只需要反转几行，请将其传递一个范围。要将第5行到第10行之间的行反转，请运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">10</span>g<span class=\"hljs-regexp\">/^/m</span> <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n<p>要了解有关move命令的更多信息，请查看<code>:h :move</code>。</p>\n<h2 id=\"汇总所有待办事项\"><a href=\"#汇总所有待办事项\" class=\"headerlink\" title=\"汇总所有待办事项\"></a>汇总所有待办事项</h2><p>当我编码时，有时我会想到一个随机的绝妙主意。不想失去专注，我通常将它们写在我正在编辑的文件中，例如：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> 喂小狗</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></code></pre></td></tr></table></figure>\n\n<p>跟踪所有已创建的TODO可能很困难。 Vim有一个<code>:t</code>（copy）方法来将所有匹配项复制到一个地址。要了解有关复制方法的更多信息，请查看<code>:h :copy</code>。</p>\n<p>要将所有TODO复制到文件末尾以便于自省，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/TODO/t</span> $<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><span class=\"hljs-comment\">// TODO：喂小狗</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br><br><span class=\"hljs-comment\">// TODO：喂小狗</span><br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，我可以查看我创建的所有TODO，另外找个时间来完成它们，或将它们委托给其他人，然后继续执行下一个任务。</p>\n<p>如果不想复制，而是将所有的 TODO 移动到末尾，可以使用移动命令 <code>m</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/TODO/m</span> $<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br><br><span class=\"hljs-comment\">// TODO：喂小狗</span><br><span class=\"hljs-comment\">// TODO：自动喂小狗</span><br><span class=\"hljs-comment\">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"黑洞删除\"><a href=\"#黑洞删除\" class=\"headerlink\" title=\"黑洞删除\"></a>黑洞删除</h2><p>回想一下寄存器那一章，已删除的文本存储在编号寄存器中（允许它们足够大）。每当运行<code>:g/console/d</code>时，Vim都会将删除的行存储在编号寄存器中。如果删除多行，所有编号的寄存器将很快被填满。为了避免这种情况，您可以使用黑洞寄存器（<code>&quot;_</code>） <strong>不</strong> 将删除的行存储到寄存器中。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/console/d</span> _<br></code></pre></td></tr></table></figure>\n\n<p>通过在<code>d</code>之后传递<code>_</code>，Vim不会将删除的行保存到任何寄存器中。</p>\n<h2 id=\"将多条空行减少为一条空行\"><a href=\"#将多条空行减少为一条空行\" class=\"headerlink\" title=\"将多条空行减少为一条空行\"></a>将多条空行减少为一条空行</h2><p>如果您的文件带有多个空行，如下所示：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><br><br><br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>您可以快速将多个空行减少为一条空行。运行：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-symbol\">:g/^</span><span class=\"hljs-variable\">$/</span>,<span class=\"hljs-regexp\">/./</span>-1j<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>一般情况下全局命令遵循下列格式：<code>:g/pattern/command</code>。但是，您也可以使用下面的格式：<code>:g/pattern1/,/pattern2/command</code>。用这种格式，Vim将会使<code>command</code>作用在<code>pattern1</code>和<code>pattern2</code>上。</p>\n<p>记住上面说的格式，让我们根据<code>:g/pattern1/,/pattern2/command</code>这个格式分解一下命令<code>:g/^$/,/./-1j</code>：</p>\n<ul>\n<li><code>/pattern1/</code> 就是 <code>/^$/</code> 。它表示一个空行（一个没有任何字符的行）。</li>\n<li><code>/pattern2/</code> 就是 <code>/./</code>（用-1作为行修正）。<code>/./</code>表示一个非空行（一个含有至少1个字符的行）。这里的 <code>-1</code> 意思是向上偏移1行。</li>\n<li><code>command</code> 就是 <code>j</code>，一个联接命令(<code>:j</code>)。在这个示例中，该全局命令联接所有给定的行。</li>\n</ul>\n<p>顺便说一句，如果您想要将多个空行全部删去，运行下面的命令：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\"><span class=\"hljs-symbol\">:g/^</span><span class=\"hljs-variable\">$/</span>,<span class=\"hljs-regexp\">/./j</span><br></code></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:g/^</span><span class=\"hljs-variable\">$/</span>-j<br></code></pre></td></tr></table></figure>\n\n<p>您的文本将会减少为：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">one</span> = 1;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;one: &quot;</span>, <span class=\"hljs-keyword\">one</span>);<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">two</span> = 2;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;two: &quot;</span>, <span class=\"hljs-keyword\">two</span>);<br><span class=\"hljs-keyword\">const</span> three = 3;<br>console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;three: &quot;</span>, three);<br></code></pre></td></tr></table></figure>\n\n<p>（译者补充：<code>j</code>连接命令的格式是：<code>:[range]j</code>。比如：<code>:1,5j</code>将连接第1至5行。在前面的命令中<code>:g/pattern1/,/pattern2/-1j</code>，<code>/pattern1/</code>和<code>/pattern2</code>都是<code>j</code>命令的范围参数，表示连接空行至非空行上方一行，这样就会保留1个空行。在早前的英文版本中有关于<code>j</code>命令的介绍，不知为何在后面的更新中，原作者删除了关于<code>j</code>命令的介绍）</p>\n<h2 id=\"高级排序\"><a href=\"#高级排序\" class=\"headerlink\" title=\"高级排序\"></a>高级排序</h2><p>Vim有一个<code>:sort</code>命令来对一个范围内的行进行排序。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">d<br><span class=\"hljs-selector-tag\">b</span><br><span class=\"hljs-selector-tag\">a</span><br>e<br>c<br></code></pre></td></tr></table></figure>\n\n<p>您可以通过运行<code>:sort</code>对它们进行排序。如果给它一个范围，它将只对该范围内的行进行排序。例如，<code>:3,5sort</code>仅在第三和第五行之间排序。</p>\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">const</span> arrayB = [<br>  <span class=\"hljs-string\">&quot;i&quot;</span>,<br>  <span class=\"hljs-string\">&quot;g&quot;</span>,<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>  <span class=\"hljs-string\">&quot;a&quot;</span>,<br>]<br><br><span class=\"hljs-keyword\">const</span> arrayA = [<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;a&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<p>如果需要排序数组中的元素，而不是数组本身，可以运行以下命令：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">:g<span class=\"hljs-regexp\">/\\[/</span>+<span class=\"hljs-number\">1</span>,<span class=\"hljs-regexp\">/\\]/</span>-<span class=\"hljs-number\">1</span><span class=\"hljs-keyword\">sort</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">const</span> arrayB = [<br>  <span class=\"hljs-string\">&quot;a&quot;</span>,<br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;g&quot;</span>,<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>  <span class=\"hljs-string\">&quot;i&quot;</span>,<br>]<br><br><span class=\"hljs-keyword\">const</span> arrayA = [<br>  <span class=\"hljs-string\">&quot;a&quot;</span><br>  <span class=\"hljs-string\">&quot;b&quot;</span>,<br>  <span class=\"hljs-string\">&quot;c&quot;</span>,<br>  <span class=\"hljs-string\">&quot;d&quot;</span>,<br>  <span class=\"hljs-string\">&quot;e&quot;</span>,<br>  <span class=\"hljs-string\">&quot;f&quot;</span>,<br>  <span class=\"hljs-string\">&quot;h&quot;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<p>这很棒！但是命令看起来很复杂。让我们分解一下。该命令依然遵循 <code>:g/pattern1/,/pattern2/command</code>这个格式。</p>\n<ul>\n<li><code>:g</code> 是全局命令</li>\n<li><code>/\\[/+1</code> 是第一个模式串，它匹配左方括号”[“。<code>+1</code>表示匹配行的下面1行。</li>\n<li><code>/\\[/-1</code> 是第二个模式串，它匹配右方括号”]”。<code>-1</code>表示匹配行的上面1行。</li>\n<li><code>/\\[/+1,/\\]/-1</code> 表示在”[“和”]”之间的行。</li>\n<li><code>sort</code> 是命令行命令：排序。</li>\n</ul>\n<h2 id=\"聪明地学习全局命令\"><a href=\"#聪明地学习全局命令\" class=\"headerlink\" title=\"聪明地学习全局命令\"></a>聪明地学习全局命令</h2><p>全局命令针对所有匹配的行执行命令行命令。有了它，您只需要运行一次命令，Vim就会为您完成其余的工作。要精通全局命令，需要做两件事：良好的命令行命令词汇表和正则表达式知识。随着您花费更多的时间使用Vim，您自然会学到更多的命令行命令。正则表达式知识需要更多的实际操作。但是一旦您适应了使用正则表达式，您将领先于很多其他人。</p>\n<p>这里的一些例子很复杂。不要被吓到。真正花时间了解它们。认真阅读每个模式串，不要放弃。</p>\n<p>每当需要在多个位置应用命令时，请暂停并查看是否可以使用<code>g</code>命令。寻找最适合工作的命令，并编写一个模式串以同时定位多个目标。</p>\n<p>既然您已经知道全局命令的功能强大，那么让我们学习如何使用外部命令来增加工具库。</p>\n"},{"title":"VIM-输入模式","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第06章 输入模式\n\n输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。\n\n尽管如此，这并不代表输入模式没什么好学的。Vim的输入模式包含许多有用功能。在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。\n\n## 进入输入模式的方法\n\n我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：\n\n```\ni    从光标之前的位置开始输入文本\nI    从当前行第一个非空字符之前的位置之前开始输入文本\na    在光标之后的位置追加文本\nA    在当前行的末尾追加文本\no    在光标位置下方新起一行并开始输入文本\nO    在光标位置的上方新起一行并开始输入文本\ns    删除当前光标位置的字符并开始输入文本\nS    删除当前行并开始输入文本\ngi   从当前缓冲区上次结束输入模式的地方开始输入文本\ngI   在当前行的第一列的位置开始输入文本\n```\n\n值得注意的是这些命令的小写/大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 `i` 和 `a`两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。\n\n## 退出输入模式的方法\n\n下面列出了一些从输入模式退出到普通模式的方法：\n\n```\n<esc>     退出输入模式进入普通模式\nCtrl-[    退出输入模式进入普通模式\nCtrl-c    与 Ctrl-[ 和 <esc>功能相同, 但是不检查缩写\n```\n\n我发现` esc`键在键盘上太远了，很难够到，所以我在我的机器上将` caps lock` 映射成了`esc`键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现`esc`键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在`q`键的左边，所以我认为将`caps lock` 映射成`esc`键是合理的。\n\n另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把`esc`映射到`jj`或者`jk`。\n\n```\ninoremap jj <esc>\ninoremap jk <esc>\n```\n\n## 重复输入模式\n\n你可以在进入输入模式之前传递一个计数参数. 比如：\n\n```\n10i\n```\n\n如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：`10I`, `11a`, `12o`）\n\n## 在输入模式中删除大块文本\n\n当你输入过程中出现一些输入错误时，一直重复地用`backspace`来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用`d`来删除错误。或者，你能用以下命令在输入模式下就删除一个或者多个字符：\n\n```\nCtrl-h    删除一个字符\nCtrl-w    删除一个单词\nCtrl-u    删除一整行\n```\n\n此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）\n\n## 用寄存器进行输入\n\n寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键`Ctrl-r`加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。\n\n让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：\n\n```\n\"ayiw\n```\n\n- `\"a` 告诉Vim你下一个动作的目标地址是寄存器a\n- `yiw` 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。\n\n现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：\n\n```\nCtrl-r a\n```\n\nVim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。\n\n## 页面滚动\n\n你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键`Ctrl-x`进入`Ctrl-x`子模式，你可以进行一些额外操作，页面滚动正是其中之一。\n\n```\nCtrl-x Ctrl-y    向上滚动页面\nCtrl-x Ctrl-e    向下滚动页面\n```\n\n## 自动补全\n\nVim在进入`Ctrl-x`子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。\n\n下面列出了一些适合入门时学习的自动补全命令：\n\n```\nCtrl-x Ctrl-l\t   补全一整行\nCtrl-x Ctrl-n\t   从当前文件中补全文本\nCtrl-x Ctrl-i\t   从引用（include）的文件中补全文本\nCtrl-x Ctrl-f\t   补全一个文件名\n```\n\n当你出发自动补全时，Vim会显示一个选项弹窗，可以使用`Ctrl-n`和`Ctrl-p`来分别向上和向下浏览选项。\n\nVim也提供了两条不需要进入`Ctrl-x`模式就能使用的命令：\n\n```\nCtrl-n             使用下一个匹配的单词进行补全\nCtrl-p             使用上一个匹配的单词进行补全\n```\n\n通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是\"Chocolate donuts are the best\"：\n\n- 当你输入\"Choco\"然后使用快捷键`Ctrl-x Ctrl-l`， Vim会进行匹配并输出这一整行的文本。\n- 当你输入\"Choco\"然后使用快捷键`Ctrl-p`，Vim会进行匹配并输出\"Chocolate\"这个单词。\n\nVim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用`:h ins-completion`命令进行查看。\n\n## 执行普通模式下的命令\n\n你知道Vim可以在输入模式下执行普通模式的命令吗？\n\n在输入模式下， 如果你按下`Ctrl-o`，你就会进入到`insert-normal`（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到`-- INSERT --` ，但是按下`Ctrl-o`后就会变为`-- (insert) --`。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：\n\n**设置居中以及跳转**\n\n```\nCtrl-o zz       居中窗口\nCtrl-o H/M/L    跳转到窗口的顶部/中部/底部\nCtrl-o 'a       跳转到标志'a处\n```\n\n**重复文本**\n\n```\nCtrl-o 100ihello    输入 \"hello\" 100 次\n```\n\n**执行终端命令**\n\n```\nCtrl-o !! curl https://google.com    运行curl命令\nCtrl-o !! pwd                        运行pwd命令\n```\n\n**快速删除**\n\n```\nCtrl-o dtz    从当前位置开始删除文本，直到遇到字母\"z\"\nCtrl-o D      从当前位置开始删除文本，直到行末\n```\n\n## 聪明地学习输入模式\n\n如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。\n\n当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。\n","source":"_posts/Vim/ch06_insert_mode.md","raw":"---\ntitle: VIM-输入模式\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第06章 输入模式\n\n输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。\n\n尽管如此，这并不代表输入模式没什么好学的。Vim的输入模式包含许多有用功能。在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。\n\n## 进入输入模式的方法\n\n我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：\n\n```\ni    从光标之前的位置开始输入文本\nI    从当前行第一个非空字符之前的位置之前开始输入文本\na    在光标之后的位置追加文本\nA    在当前行的末尾追加文本\no    在光标位置下方新起一行并开始输入文本\nO    在光标位置的上方新起一行并开始输入文本\ns    删除当前光标位置的字符并开始输入文本\nS    删除当前行并开始输入文本\ngi   从当前缓冲区上次结束输入模式的地方开始输入文本\ngI   在当前行的第一列的位置开始输入文本\n```\n\n值得注意的是这些命令的小写/大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 `i` 和 `a`两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。\n\n## 退出输入模式的方法\n\n下面列出了一些从输入模式退出到普通模式的方法：\n\n```\n<esc>     退出输入模式进入普通模式\nCtrl-[    退出输入模式进入普通模式\nCtrl-c    与 Ctrl-[ 和 <esc>功能相同, 但是不检查缩写\n```\n\n我发现` esc`键在键盘上太远了，很难够到，所以我在我的机器上将` caps lock` 映射成了`esc`键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现`esc`键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在`q`键的左边，所以我认为将`caps lock` 映射成`esc`键是合理的。\n\n另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把`esc`映射到`jj`或者`jk`。\n\n```\ninoremap jj <esc>\ninoremap jk <esc>\n```\n\n## 重复输入模式\n\n你可以在进入输入模式之前传递一个计数参数. 比如：\n\n```\n10i\n```\n\n如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：`10I`, `11a`, `12o`）\n\n## 在输入模式中删除大块文本\n\n当你输入过程中出现一些输入错误时，一直重复地用`backspace`来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用`d`来删除错误。或者，你能用以下命令在输入模式下就删除一个或者多个字符：\n\n```\nCtrl-h    删除一个字符\nCtrl-w    删除一个单词\nCtrl-u    删除一整行\n```\n\n此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）\n\n## 用寄存器进行输入\n\n寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键`Ctrl-r`加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。\n\n让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：\n\n```\n\"ayiw\n```\n\n- `\"a` 告诉Vim你下一个动作的目标地址是寄存器a\n- `yiw` 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。\n\n现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：\n\n```\nCtrl-r a\n```\n\nVim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。\n\n## 页面滚动\n\n你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键`Ctrl-x`进入`Ctrl-x`子模式，你可以进行一些额外操作，页面滚动正是其中之一。\n\n```\nCtrl-x Ctrl-y    向上滚动页面\nCtrl-x Ctrl-e    向下滚动页面\n```\n\n## 自动补全\n\nVim在进入`Ctrl-x`子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。\n\n下面列出了一些适合入门时学习的自动补全命令：\n\n```\nCtrl-x Ctrl-l\t   补全一整行\nCtrl-x Ctrl-n\t   从当前文件中补全文本\nCtrl-x Ctrl-i\t   从引用（include）的文件中补全文本\nCtrl-x Ctrl-f\t   补全一个文件名\n```\n\n当你出发自动补全时，Vim会显示一个选项弹窗，可以使用`Ctrl-n`和`Ctrl-p`来分别向上和向下浏览选项。\n\nVim也提供了两条不需要进入`Ctrl-x`模式就能使用的命令：\n\n```\nCtrl-n             使用下一个匹配的单词进行补全\nCtrl-p             使用上一个匹配的单词进行补全\n```\n\n通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是\"Chocolate donuts are the best\"：\n\n- 当你输入\"Choco\"然后使用快捷键`Ctrl-x Ctrl-l`， Vim会进行匹配并输出这一整行的文本。\n- 当你输入\"Choco\"然后使用快捷键`Ctrl-p`，Vim会进行匹配并输出\"Chocolate\"这个单词。\n\nVim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用`:h ins-completion`命令进行查看。\n\n## 执行普通模式下的命令\n\n你知道Vim可以在输入模式下执行普通模式的命令吗？\n\n在输入模式下， 如果你按下`Ctrl-o`，你就会进入到`insert-normal`（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到`-- INSERT --` ，但是按下`Ctrl-o`后就会变为`-- (insert) --`。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：\n\n**设置居中以及跳转**\n\n```\nCtrl-o zz       居中窗口\nCtrl-o H/M/L    跳转到窗口的顶部/中部/底部\nCtrl-o 'a       跳转到标志'a处\n```\n\n**重复文本**\n\n```\nCtrl-o 100ihello    输入 \"hello\" 100 次\n```\n\n**执行终端命令**\n\n```\nCtrl-o !! curl https://google.com    运行curl命令\nCtrl-o !! pwd                        运行pwd命令\n```\n\n**快速删除**\n\n```\nCtrl-o dtz    从当前位置开始删除文本，直到遇到字母\"z\"\nCtrl-o D      从当前位置开始删除文本，直到行末\n```\n\n## 聪明地学习输入模式\n\n如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。\n\n当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。\n","slug":"Vim/ch06_insert_mode","published":1,"updated":"2022-08-28T07:38:59.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i200020scvm75dg668h","content":"<h1 id=\"第06章-输入模式\"><a href=\"#第06章-输入模式\" class=\"headerlink\" title=\"第06章 输入模式\"></a>第06章 输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。</p>\n<p>尽管如此，这并不代表输入模式没什么好学的。Vim的输入模式包含许多有用功能。在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。</p>\n<h2 id=\"进入输入模式的方法\"><a href=\"#进入输入模式的方法\" class=\"headerlink\" title=\"进入输入模式的方法\"></a>进入输入模式的方法</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">i</span>    从光标之前的位置开始输入文本<br><span class=\"hljs-selector-tag\">I</span>    从当前行第一个非空字符之前的位置之前开始输入文本<br><span class=\"hljs-selector-tag\">a</span>    在光标之后的位置追加文本<br><span class=\"hljs-selector-tag\">A</span>    在当前行的末尾追加文本<br>o    在光标位置下方新起一行并开始输入文本<br>O    在光标位置的上方新起一行并开始输入文本<br>s    删除当前光标位置的字符并开始输入文本<br>S    删除当前行并开始输入文本<br>gi   从当前缓冲区上次结束输入模式的地方开始输入文本<br>gI   在当前行的第一列的位置开始输入文本<br></code></pre></td></tr></table></figure>\n\n<p>值得注意的是这些命令的小写&#x2F;大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。</p>\n<h2 id=\"退出输入模式的方法\"><a href=\"#退出输入模式的方法\" class=\"headerlink\" title=\"退出输入模式的方法\"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">esc</span>&gt;</span>     退出输入模式进入普通模式<br>Ctrl-[    退出输入模式进入普通模式<br>Ctrl-c    与 Ctrl-[ 和 <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">esc</span>&gt;</span>功能相同, 但是不检查缩写<br></code></pre></td></tr></table></figure>\n\n<p>我发现<code> esc</code>键在键盘上太远了，很难够到，所以我在我的机器上将<code> caps lock</code> 映射成了<code>esc</code>键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现<code>esc</code>键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在<code>q</code>键的左边，所以我认为将<code>caps lock</code> 映射成<code>esc</code>键是合理的。</p>\n<p>另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> jj <span class=\"hljs-symbol\">&lt;esc&gt;</span><br><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"重复输入模式\"><a href=\"#重复输入模式\" class=\"headerlink\" title=\"重复输入模式\"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">10i</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p>\n<h2 id=\"在输入模式中删除大块文本\"><a href=\"#在输入模式中删除大块文本\" class=\"headerlink\" title=\"在输入模式中删除大块文本\"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用<code>d</code>来删除错误。或者，你能用以下命令在输入模式下就删除一个或者多个字符：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">Ctrl-h    删除一个字符<br>Ctrl-w    删除一个单词<br>Ctrl-u    删除一整行<br></code></pre></td></tr></table></figure>\n\n<p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）</p>\n<h2 id=\"用寄存器进行输入\"><a href=\"#用寄存器进行输入\" class=\"headerlink\" title=\"用寄存器进行输入\"></a>用寄存器进行输入</h2><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键<code>Ctrl-r</code>加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。</p>\n<p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;ayiw</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a</li>\n<li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。</li>\n</ul>\n<p>现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">Ctrl-r <span class=\"hljs-selector-tag\">a</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。</p>\n<h2 id=\"页面滚动\"><a href=\"#页面滚动\" class=\"headerlink\" title=\"页面滚动\"></a>页面滚动</h2><p>你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键<code>Ctrl-x</code>进入<code>Ctrl-x</code>子模式，你可以进行一些额外操作，页面滚动正是其中之一。</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-y    向上滚动页面<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-e    向下滚动页面<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自动补全\"><a href=\"#自动补全\" class=\"headerlink\" title=\"自动补全\"></a>自动补全</h2><p>Vim在进入<code>Ctrl-x</code>子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。</p>\n<p>下面列出了一些适合入门时学习的自动补全命令：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-l\t   补全一整行<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-n\t   从当前文件中补全文本<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-i\t   从引用（include）的文件中补全文本<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-f\t   补全一个文件名<br></code></pre></td></tr></table></figure>\n\n<p>当你出发自动补全时，Vim会显示一个选项弹窗，可以使用<code>Ctrl-n</code>和<code>Ctrl-p</code>来分别向上和向下浏览选项。</p>\n<p>Vim也提供了两条不需要进入<code>Ctrl-x</code>模式就能使用的命令：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">Ctrl-n             使用下一个匹配的单词进行补全<br>Ctrl-<span class=\"hljs-selector-tag\">p</span>             使用上一个匹配的单词进行补全<br></code></pre></td></tr></table></figure>\n\n<p>通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是”Chocolate donuts are the best”：</p>\n<ul>\n<li>当你输入”Choco”然后使用快捷键<code>Ctrl-x Ctrl-l</code>， Vim会进行匹配并输出这一整行的文本。</li>\n<li>当你输入”Choco”然后使用快捷键<code>Ctrl-p</code>，Vim会进行匹配并输出”Chocolate”这个单词。</li>\n</ul>\n<p>Vim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看。</p>\n<h2 id=\"执行普通模式下的命令\"><a href=\"#执行普通模式下的命令\" class=\"headerlink\" title=\"执行普通模式下的命令\"></a>执行普通模式下的命令</h2><p>你知道Vim可以在输入模式下执行普通模式的命令吗？</p>\n<p>在输入模式下， 如果你按下<code>Ctrl-o</code>，你就会进入到<code>insert-normal</code>（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下<code>Ctrl-o</code>后就会变为<code>-- (insert) --</code>。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：</p>\n<p><strong>设置居中以及跳转</strong></p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">Ctrl-o zz       居中窗口<br>Ctrl-o H<span class=\"hljs-regexp\">/M/</span>L    跳转到窗口的顶部<span class=\"hljs-regexp\">/中部/</span>底部<br>Ctrl-o <span class=\"hljs-string\">&#x27;a       跳转到标志&#x27;</span>a处<br></code></pre></td></tr></table></figure>\n\n<p><strong>重复文本</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Ctrl</span>-o <span class=\"hljs-number\">100</span>ihello    输入 <span class=\"hljs-string\">&quot;hello&quot;</span> <span class=\"hljs-number\">100</span> 次<br></code></pre></td></tr></table></figure>\n\n<p><strong>执行终端命令</strong></p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">Ctrl-o !! curl https://google.com    运行curl命令<br>Ctrl-o !! pwd                        运行pwd命令<br></code></pre></td></tr></table></figure>\n\n<p><strong>快速删除</strong></p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-variable\">Ctrl</span><span class=\"hljs-operator\">-</span><span class=\"hljs-variable\">o</span> <span class=\"hljs-variable\">dtz</span>    从当前位置开始删除文本，直到遇到字母<span class=\"hljs-string\">&quot;z&quot;</span><br><span class=\"hljs-variable\">Ctrl</span><span class=\"hljs-operator\">-</span><span class=\"hljs-variable\">o</span> <span class=\"hljs-built_in\">D</span>      从当前位置开始删除文本，直到行末<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地学习输入模式\"><a href=\"#聪明地学习输入模式\" class=\"headerlink\" title=\"聪明地学习输入模式\"></a>聪明地学习输入模式</h2><p>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。</p>\n<p>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。</p>\n","site":{"data":{}},"wordcount":2817,"excerpt":"","more":"<h1 id=\"第06章-输入模式\"><a href=\"#第06章-输入模式\" class=\"headerlink\" title=\"第06章 输入模式\"></a>第06章 输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。</p>\n<p>尽管如此，这并不代表输入模式没什么好学的。Vim的输入模式包含许多有用功能。在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。</p>\n<h2 id=\"进入输入模式的方法\"><a href=\"#进入输入模式的方法\" class=\"headerlink\" title=\"进入输入模式的方法\"></a>进入输入模式的方法</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">i</span>    从光标之前的位置开始输入文本<br><span class=\"hljs-selector-tag\">I</span>    从当前行第一个非空字符之前的位置之前开始输入文本<br><span class=\"hljs-selector-tag\">a</span>    在光标之后的位置追加文本<br><span class=\"hljs-selector-tag\">A</span>    在当前行的末尾追加文本<br>o    在光标位置下方新起一行并开始输入文本<br>O    在光标位置的上方新起一行并开始输入文本<br>s    删除当前光标位置的字符并开始输入文本<br>S    删除当前行并开始输入文本<br>gi   从当前缓冲区上次结束输入模式的地方开始输入文本<br>gI   在当前行的第一列的位置开始输入文本<br></code></pre></td></tr></table></figure>\n\n<p>值得注意的是这些命令的小写&#x2F;大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。</p>\n<h2 id=\"退出输入模式的方法\"><a href=\"#退出输入模式的方法\" class=\"headerlink\" title=\"退出输入模式的方法\"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">esc</span>&gt;</span>     退出输入模式进入普通模式<br>Ctrl-[    退出输入模式进入普通模式<br>Ctrl-c    与 Ctrl-[ 和 <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">esc</span>&gt;</span>功能相同, 但是不检查缩写<br></code></pre></td></tr></table></figure>\n\n<p>我发现<code> esc</code>键在键盘上太远了，很难够到，所以我在我的机器上将<code> caps lock</code> 映射成了<code>esc</code>键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现<code>esc</code>键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在<code>q</code>键的左边，所以我认为将<code>caps lock</code> 映射成<code>esc</code>键是合理的。</p>\n<p>另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> jj <span class=\"hljs-symbol\">&lt;esc&gt;</span><br><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"重复输入模式\"><a href=\"#重复输入模式\" class=\"headerlink\" title=\"重复输入模式\"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">10i</span><br></code></pre></td></tr></table></figure>\n\n<p>如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p>\n<h2 id=\"在输入模式中删除大块文本\"><a href=\"#在输入模式中删除大块文本\" class=\"headerlink\" title=\"在输入模式中删除大块文本\"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用<code>d</code>来删除错误。或者，你能用以下命令在输入模式下就删除一个或者多个字符：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">Ctrl-h    删除一个字符<br>Ctrl-w    删除一个单词<br>Ctrl-u    删除一整行<br></code></pre></td></tr></table></figure>\n\n<p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）</p>\n<h2 id=\"用寄存器进行输入\"><a href=\"#用寄存器进行输入\" class=\"headerlink\" title=\"用寄存器进行输入\"></a>用寄存器进行输入</h2><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键<code>Ctrl-r</code>加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。</p>\n<p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-string\">&quot;ayiw</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a</li>\n<li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。</li>\n</ul>\n<p>现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">Ctrl-r <span class=\"hljs-selector-tag\">a</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。</p>\n<h2 id=\"页面滚动\"><a href=\"#页面滚动\" class=\"headerlink\" title=\"页面滚动\"></a>页面滚动</h2><p>你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键<code>Ctrl-x</code>进入<code>Ctrl-x</code>子模式，你可以进行一些额外操作，页面滚动正是其中之一。</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-y    向上滚动页面<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-e    向下滚动页面<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自动补全\"><a href=\"#自动补全\" class=\"headerlink\" title=\"自动补全\"></a>自动补全</h2><p>Vim在进入<code>Ctrl-x</code>子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。</p>\n<p>下面列出了一些适合入门时学习的自动补全命令：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-l\t   补全一整行<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-n\t   从当前文件中补全文本<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-i\t   从引用（include）的文件中补全文本<br>Ctrl-<span class=\"hljs-keyword\">x</span> Ctrl-f\t   补全一个文件名<br></code></pre></td></tr></table></figure>\n\n<p>当你出发自动补全时，Vim会显示一个选项弹窗，可以使用<code>Ctrl-n</code>和<code>Ctrl-p</code>来分别向上和向下浏览选项。</p>\n<p>Vim也提供了两条不需要进入<code>Ctrl-x</code>模式就能使用的命令：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">Ctrl-n             使用下一个匹配的单词进行补全<br>Ctrl-<span class=\"hljs-selector-tag\">p</span>             使用上一个匹配的单词进行补全<br></code></pre></td></tr></table></figure>\n\n<p>通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是”Chocolate donuts are the best”：</p>\n<ul>\n<li>当你输入”Choco”然后使用快捷键<code>Ctrl-x Ctrl-l</code>， Vim会进行匹配并输出这一整行的文本。</li>\n<li>当你输入”Choco”然后使用快捷键<code>Ctrl-p</code>，Vim会进行匹配并输出”Chocolate”这个单词。</li>\n</ul>\n<p>Vim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看。</p>\n<h2 id=\"执行普通模式下的命令\"><a href=\"#执行普通模式下的命令\" class=\"headerlink\" title=\"执行普通模式下的命令\"></a>执行普通模式下的命令</h2><p>你知道Vim可以在输入模式下执行普通模式的命令吗？</p>\n<p>在输入模式下， 如果你按下<code>Ctrl-o</code>，你就会进入到<code>insert-normal</code>（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下<code>Ctrl-o</code>后就会变为<code>-- (insert) --</code>。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：</p>\n<p><strong>设置居中以及跳转</strong></p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">Ctrl-o zz       居中窗口<br>Ctrl-o H<span class=\"hljs-regexp\">/M/</span>L    跳转到窗口的顶部<span class=\"hljs-regexp\">/中部/</span>底部<br>Ctrl-o <span class=\"hljs-string\">&#x27;a       跳转到标志&#x27;</span>a处<br></code></pre></td></tr></table></figure>\n\n<p><strong>重复文本</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Ctrl</span>-o <span class=\"hljs-number\">100</span>ihello    输入 <span class=\"hljs-string\">&quot;hello&quot;</span> <span class=\"hljs-number\">100</span> 次<br></code></pre></td></tr></table></figure>\n\n<p><strong>执行终端命令</strong></p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">Ctrl-o !! curl https://google.com    运行curl命令<br>Ctrl-o !! pwd                        运行pwd命令<br></code></pre></td></tr></table></figure>\n\n<p><strong>快速删除</strong></p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-variable\">Ctrl</span><span class=\"hljs-operator\">-</span><span class=\"hljs-variable\">o</span> <span class=\"hljs-variable\">dtz</span>    从当前位置开始删除文本，直到遇到字母<span class=\"hljs-string\">&quot;z&quot;</span><br><span class=\"hljs-variable\">Ctrl</span><span class=\"hljs-operator\">-</span><span class=\"hljs-variable\">o</span> <span class=\"hljs-built_in\">D</span>      从当前位置开始删除文本，直到行末<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地学习输入模式\"><a href=\"#聪明地学习输入模式\" class=\"headerlink\" title=\"聪明地学习输入模式\"></a>聪明地学习输入模式</h2><p>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。</p>\n<p>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。</p>\n"},{"title":"VIM-外部命令","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 外部命令\n\n在Unix系统内部，您会发现许多小型的，超专业化命令，每个命令只做一件事（而且能很好地完成）。您可以将这些命令链接在一起以共同解决一个复杂的问题。如果可以从Vim内部使用这些命令，那不是很好吗？\n\n答案是肯定的!在本章中，您将学习如何扩展Vim以使其与外部命令无缝协作。\n\n## Bang 命令\n\nVim有一个Bang(`!`)命令，可以执行三件事：\n\n1.将外部命令的STDOUT读入当前缓冲区。\n2.将缓冲区的内容作为STDIN写入外部命令。\n3.从Vim内部执行外部命令。\n\n让我们一个个认真看一下。\n\n## 将外部命令的标准输出STDOUT读入Vim\n\n将外部命令的STDOUT读入当前缓冲区的语法为：\n\n```\n:r !{cmd}\n```\n\n`:r`是Vim的读命令。如果不带`!`使用它，则可以使用它来获取文件的内容。如果当前目录中有文件`file1.txt`，运行：\n\n```\n:r file1.txt\n```\n\nVim会将`file1.txt`的内容放入当前缓冲区。\n\n如果您运行的`:r`命令后面跟一个`!`和外部命令，则该命令的输出将插入到当前缓冲区中。要获取`ls`命令的结果，请运行：\n\n```\n:r !ls\n```\n\n它返回类似下列的文本：\n\n```\nfile1.txt\nfile2.txt\nfile3.txt\n```\n\n您可以从`curl`命令读取数据：\n\n```\n:r !curl -s 'https://jsonplaceholder.typicode.com/todos/1'\n```\n\nr命令也接受一个地址：\n\n```\n:10r !cat file1.txt\n```\n\n现在，将在第10行之后插入来自运行`cat file.txt`的STDOUT。\n\n## 将缓冲区内容写入外部命令\n\n`:w`命令除了保存文件，还可以用来将当前缓冲区中的文本作为作为STDIN传递给外部命令。语法为：\n\n```\n:w !cmd\n```\n\n如果您具有以下表达式：\n\n```\nconsole.log(\"Hello Vim\");\nconsole.log(\"Vim is awesome\");\n```\n\n确保在计算机中安装了[node](https://nodejs.org/en/)，然后运行：\n\n```\n:w !node\n```\n\nVim将使用`node`执行Javascript表达式来打印\"Hello Vim\"和\"Vim is awesome\"。\n\n当使用`：w`命令时，Vim使用当前缓冲区中的所有文本，与global命令类似（大多数命令行命令，如果不给它传递范围，则仅对当前行执行该命令）。如果您通过`：w`来指定地址：\n\n```\n:2w !node\n```\n\n\"Vim\"只使用第二行中的文本到`node`解释器中。\n\n`:w !node`和`:w! node`形式上区别很小，但功能上相隔千里。使用`:w !node`，您是将当前缓冲区中的文本\"写入\"到外部命令`node`中。用`:w! node`，则您将强制保存文件并将其命名为\"node\"。\n\n## 执行外部命令\n\n您可以使用bang命令从Vim内部执行外部命令。语法为：\n\n```\n:!cmd\n```\n\n要以长格式查看当前目录的内容，请运行：\n\n```\n:!ls -ls\n```\n\n要终止在PID 3456上运行的进程，可以运行：\n\n```\n:!kill -9 3456\n```\n\n您可以在不离开Vim的情况下运行任何外部命令，因此您可以专注于自己的任务。\n\n## 过滤文本\n\n如果给`!`范围，则可用于过滤文本。假设您有：\n\n```\nhello vim\nhello vim\n```\n\n让我们使用`tr` (translate)命令将当前行大写。运行：\n\n```\n:.!tr '[:lower:]' '[:upper:]'\n```\n\n结果：\n\n```\nHELLO VIM\nhello vim\n```\n\n命令分解：\n- `.!` 在当前行执行filter命令。\n- `!tr '[:lower:]' '[:upper:]'` 调用`tr`外部命令将所有小写字符替换为大写字符。\n\n必须传递范围以运行外部命令作为过滤器。如果您尝试在没有`.`的情况下运行上述命令(`:!tr '[:lower:]' '[:upper:]'`)，则会看到错误。\n\n假设您需要使用awk命令删除两行的第二列：\n\n```\n:%!awk \"{print $1}\"\n```\n\n结果：\n\n```\nhello\nhello\n```\n\n命令分解：\n- `:%!`  在所有行(`%`)上执行filter命令。\n- `awk \"{print $1}\"` 仅打印匹配项的第一列。\n\n您可以使用管道运算符（`|`）链接多个命令，就像在终端中一样。假设您有一个包含这些美味早餐的文件：\n\n```\nname price\nchocolate pancake 10\nbuttermilk pancake 9\nblueberry pancake 12\n```\n\n如果您需要根据价格对它们进行排序，并且仅以均匀的间距显示菜单，则可以运行：\n\n```\n:%!awk 'NR > 1' | sort -nk 3 | column -t\n```\n\n结果：\n```\nbuttermilk pancake 9\nchocolate pancake 10\nblueberry pancake 12\n```\n\n命令分解：\n- `:%!` 将过滤器应用于所有行(`%`)。\n- `awk 'NR > 1'` 仅从第二行开始显示文本。\n- `|`链接下一个命令。\n- `sort -nk 3`使用列3（`k 3`）中的值对数字进行排序（`n`）。\n- `column -t`以均匀的间距组织文本。\n\n## 普通模式命令\n\n在普通模式下，Vim有一个过滤运算符（`!`）。如果您有以下问候：\n\n```\nhello vim\nhola vim\nbonjour vim\nsalve vim\n```\n\n要大写当前行和下面的行，可以运行：\n```\n!jtr '[a-z]' '[A-Z]'\n```\n\n命令分解：\n- `!j` 运行常规命令过滤器运算符（`!`），目标是当前行及其下方的行。回想一下，因为它是普通模式运算符，所以适用语法规则\"动词+名词\"。\n- `tr '[a-z]' '[A-Z]'`将小写字母替换为大写字母。\n\nfilter normal命令仅适用于至少一行以上的motion或至少一行以上的文本对象。如果您尝试运行`!iwtr'[az]''[AZ]'`（在内部单词上执行`tr`），您会发现它在整个行上都应用了tr命令，而不是光标所在的单词。\n\n## 聪明地学习外部命令\n\nVim不是IDE。它是一种轻量级的模式编辑器，通过设计可以高度扩展。由于这种可扩展性，您可以轻松访问系统中的任何外部命令。这样，Vim离成为IDE仅一步之遥。有人说Unix系统是有史以来的第一个IDE。\n\nBang 命令的有用程度与您知道多少个外部命令相关。如果您的外部命令知识有限，请不要担心。我还有很多东西要学。以此作为持续学习的动力。每当您需要过滤文本时，请查看是否存在可以解决问题的外部命令。不必担心掌握所有的命令。只需学习完成当前任务所需的内容即可。\n","source":"_posts/Vim/ch14_external_commands.md","raw":"---\ntitle: VIM-外部命令\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 外部命令\n\n在Unix系统内部，您会发现许多小型的，超专业化命令，每个命令只做一件事（而且能很好地完成）。您可以将这些命令链接在一起以共同解决一个复杂的问题。如果可以从Vim内部使用这些命令，那不是很好吗？\n\n答案是肯定的!在本章中，您将学习如何扩展Vim以使其与外部命令无缝协作。\n\n## Bang 命令\n\nVim有一个Bang(`!`)命令，可以执行三件事：\n\n1.将外部命令的STDOUT读入当前缓冲区。\n2.将缓冲区的内容作为STDIN写入外部命令。\n3.从Vim内部执行外部命令。\n\n让我们一个个认真看一下。\n\n## 将外部命令的标准输出STDOUT读入Vim\n\n将外部命令的STDOUT读入当前缓冲区的语法为：\n\n```\n:r !{cmd}\n```\n\n`:r`是Vim的读命令。如果不带`!`使用它，则可以使用它来获取文件的内容。如果当前目录中有文件`file1.txt`，运行：\n\n```\n:r file1.txt\n```\n\nVim会将`file1.txt`的内容放入当前缓冲区。\n\n如果您运行的`:r`命令后面跟一个`!`和外部命令，则该命令的输出将插入到当前缓冲区中。要获取`ls`命令的结果，请运行：\n\n```\n:r !ls\n```\n\n它返回类似下列的文本：\n\n```\nfile1.txt\nfile2.txt\nfile3.txt\n```\n\n您可以从`curl`命令读取数据：\n\n```\n:r !curl -s 'https://jsonplaceholder.typicode.com/todos/1'\n```\n\nr命令也接受一个地址：\n\n```\n:10r !cat file1.txt\n```\n\n现在，将在第10行之后插入来自运行`cat file.txt`的STDOUT。\n\n## 将缓冲区内容写入外部命令\n\n`:w`命令除了保存文件，还可以用来将当前缓冲区中的文本作为作为STDIN传递给外部命令。语法为：\n\n```\n:w !cmd\n```\n\n如果您具有以下表达式：\n\n```\nconsole.log(\"Hello Vim\");\nconsole.log(\"Vim is awesome\");\n```\n\n确保在计算机中安装了[node](https://nodejs.org/en/)，然后运行：\n\n```\n:w !node\n```\n\nVim将使用`node`执行Javascript表达式来打印\"Hello Vim\"和\"Vim is awesome\"。\n\n当使用`：w`命令时，Vim使用当前缓冲区中的所有文本，与global命令类似（大多数命令行命令，如果不给它传递范围，则仅对当前行执行该命令）。如果您通过`：w`来指定地址：\n\n```\n:2w !node\n```\n\n\"Vim\"只使用第二行中的文本到`node`解释器中。\n\n`:w !node`和`:w! node`形式上区别很小，但功能上相隔千里。使用`:w !node`，您是将当前缓冲区中的文本\"写入\"到外部命令`node`中。用`:w! node`，则您将强制保存文件并将其命名为\"node\"。\n\n## 执行外部命令\n\n您可以使用bang命令从Vim内部执行外部命令。语法为：\n\n```\n:!cmd\n```\n\n要以长格式查看当前目录的内容，请运行：\n\n```\n:!ls -ls\n```\n\n要终止在PID 3456上运行的进程，可以运行：\n\n```\n:!kill -9 3456\n```\n\n您可以在不离开Vim的情况下运行任何外部命令，因此您可以专注于自己的任务。\n\n## 过滤文本\n\n如果给`!`范围，则可用于过滤文本。假设您有：\n\n```\nhello vim\nhello vim\n```\n\n让我们使用`tr` (translate)命令将当前行大写。运行：\n\n```\n:.!tr '[:lower:]' '[:upper:]'\n```\n\n结果：\n\n```\nHELLO VIM\nhello vim\n```\n\n命令分解：\n- `.!` 在当前行执行filter命令。\n- `!tr '[:lower:]' '[:upper:]'` 调用`tr`外部命令将所有小写字符替换为大写字符。\n\n必须传递范围以运行外部命令作为过滤器。如果您尝试在没有`.`的情况下运行上述命令(`:!tr '[:lower:]' '[:upper:]'`)，则会看到错误。\n\n假设您需要使用awk命令删除两行的第二列：\n\n```\n:%!awk \"{print $1}\"\n```\n\n结果：\n\n```\nhello\nhello\n```\n\n命令分解：\n- `:%!`  在所有行(`%`)上执行filter命令。\n- `awk \"{print $1}\"` 仅打印匹配项的第一列。\n\n您可以使用管道运算符（`|`）链接多个命令，就像在终端中一样。假设您有一个包含这些美味早餐的文件：\n\n```\nname price\nchocolate pancake 10\nbuttermilk pancake 9\nblueberry pancake 12\n```\n\n如果您需要根据价格对它们进行排序，并且仅以均匀的间距显示菜单，则可以运行：\n\n```\n:%!awk 'NR > 1' | sort -nk 3 | column -t\n```\n\n结果：\n```\nbuttermilk pancake 9\nchocolate pancake 10\nblueberry pancake 12\n```\n\n命令分解：\n- `:%!` 将过滤器应用于所有行(`%`)。\n- `awk 'NR > 1'` 仅从第二行开始显示文本。\n- `|`链接下一个命令。\n- `sort -nk 3`使用列3（`k 3`）中的值对数字进行排序（`n`）。\n- `column -t`以均匀的间距组织文本。\n\n## 普通模式命令\n\n在普通模式下，Vim有一个过滤运算符（`!`）。如果您有以下问候：\n\n```\nhello vim\nhola vim\nbonjour vim\nsalve vim\n```\n\n要大写当前行和下面的行，可以运行：\n```\n!jtr '[a-z]' '[A-Z]'\n```\n\n命令分解：\n- `!j` 运行常规命令过滤器运算符（`!`），目标是当前行及其下方的行。回想一下，因为它是普通模式运算符，所以适用语法规则\"动词+名词\"。\n- `tr '[a-z]' '[A-Z]'`将小写字母替换为大写字母。\n\nfilter normal命令仅适用于至少一行以上的motion或至少一行以上的文本对象。如果您尝试运行`!iwtr'[az]''[AZ]'`（在内部单词上执行`tr`），您会发现它在整个行上都应用了tr命令，而不是光标所在的单词。\n\n## 聪明地学习外部命令\n\nVim不是IDE。它是一种轻量级的模式编辑器，通过设计可以高度扩展。由于这种可扩展性，您可以轻松访问系统中的任何外部命令。这样，Vim离成为IDE仅一步之遥。有人说Unix系统是有史以来的第一个IDE。\n\nBang 命令的有用程度与您知道多少个外部命令相关。如果您的外部命令知识有限，请不要担心。我还有很多东西要学。以此作为持续学习的动力。每当您需要过滤文本时，请查看是否存在可以解决问题的外部命令。不必担心掌握所有的命令。只需学习完成当前任务所需的内容即可。\n","slug":"Vim/ch14_external_commands","published":1,"updated":"2022-08-28T07:38:59.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i210022scvm0ffv3irp","content":"<h1 id=\"外部命令\"><a href=\"#外部命令\" class=\"headerlink\" title=\"外部命令\"></a>外部命令</h1><p>在Unix系统内部，您会发现许多小型的，超专业化命令，每个命令只做一件事（而且能很好地完成）。您可以将这些命令链接在一起以共同解决一个复杂的问题。如果可以从Vim内部使用这些命令，那不是很好吗？</p>\n<p>答案是肯定的!在本章中，您将学习如何扩展Vim以使其与外部命令无缝协作。</p>\n<h2 id=\"Bang-命令\"><a href=\"#Bang-命令\" class=\"headerlink\" title=\"Bang 命令\"></a>Bang 命令</h2><p>Vim有一个Bang(<code>!</code>)命令，可以执行三件事：</p>\n<p>1.将外部命令的STDOUT读入当前缓冲区。<br>2.将缓冲区的内容作为STDIN写入外部命令。<br>3.从Vim内部执行外部命令。</p>\n<p>让我们一个个认真看一下。</p>\n<h2 id=\"将外部命令的标准输出STDOUT读入Vim\"><a href=\"#将外部命令的标准输出STDOUT读入Vim\" class=\"headerlink\" title=\"将外部命令的标准输出STDOUT读入Vim\"></a>将外部命令的标准输出STDOUT读入Vim</h2><p>将外部命令的STDOUT读入当前缓冲区的语法为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs css\">:r !&#123;cmd&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>:r</code>是Vim的读命令。如果不带<code>!</code>使用它，则可以使用它来获取文件的内容。如果当前目录中有文件<code>file1.txt</code>，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:r</span> file1.txt<br></code></pre></td></tr></table></figure>\n\n<p>Vim会将<code>file1.txt</code>的内容放入当前缓冲区。</p>\n<p>如果您运行的<code>:r</code>命令后面跟一个<code>!</code>和外部命令，则该命令的输出将插入到当前缓冲区中。要获取<code>ls</code>命令的结果，请运行：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">:<span class=\"hljs-built_in\">r</span> !<span class=\"hljs-built_in\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>它返回类似下列的文本：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">file1<span class=\"hljs-selector-class\">.txt</span><br>file2<span class=\"hljs-selector-class\">.txt</span><br>file3.txt<br></code></pre></td></tr></table></figure>\n\n<p>您可以从<code>curl</code>命令读取数据：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">:<span class=\"hljs-built_in\">r</span> !<span class=\"hljs-built_in\">curl</span> <span class=\"hljs-literal\">-s</span> <span class=\"hljs-string\">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>r命令也接受一个地址：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">:<span class=\"hljs-number\">10</span><span class=\"hljs-built_in\">r</span> !<span class=\"hljs-built_in\">cat</span> file1.txt<br></code></pre></td></tr></table></figure>\n\n<p>现在，将在第10行之后插入来自运行<code>cat file.txt</code>的STDOUT。</p>\n<h2 id=\"将缓冲区内容写入外部命令\"><a href=\"#将缓冲区内容写入外部命令\" class=\"headerlink\" title=\"将缓冲区内容写入外部命令\"></a>将缓冲区内容写入外部命令</h2><p><code>:w</code>命令除了保存文件，还可以用来将当前缓冲区中的文本作为作为STDIN传递给外部命令。语法为：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">:w !<span class=\"hljs-keyword\">cmd</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Hello Vim&quot;</span>);<br><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Vim is awesome&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>确保在计算机中安装了<a href=\"https://nodejs.org/en/\">node</a>，然后运行：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:w !<span class=\"hljs-keyword\">node</span><span class=\"hljs-title\"></span><br></code></pre></td></tr></table></figure>\n\n<p>Vim将使用<code>node</code>执行Javascript表达式来打印”Hello Vim”和”Vim is awesome”。</p>\n<p>当使用<code>：w</code>命令时，Vim使用当前缓冲区中的所有文本，与global命令类似（大多数命令行命令，如果不给它传递范围，则仅对当前行执行该命令）。如果您通过<code>：w</code>来指定地址：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:<span class=\"hljs-number\">2</span>w !<span class=\"hljs-keyword\">node</span><span class=\"hljs-title\"></span><br></code></pre></td></tr></table></figure>\n\n<p>“Vim”只使用第二行中的文本到<code>node</code>解释器中。</p>\n<p><code>:w !node</code>和<code>:w! node</code>形式上区别很小，但功能上相隔千里。使用<code>:w !node</code>，您是将当前缓冲区中的文本”写入”到外部命令<code>node</code>中。用<code>:w! node</code>，则您将强制保存文件并将其命名为”node”。</p>\n<h2 id=\"执行外部命令\"><a href=\"#执行外部命令\" class=\"headerlink\" title=\"执行外部命令\"></a>执行外部命令</h2><p>您可以使用bang命令从Vim内部执行外部命令。语法为：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:!cmd</span><br></code></pre></td></tr></table></figure>\n\n<p>要以长格式查看当前目录的内容，请运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:!<span class=\"hljs-built_in\">ls</span> -<span class=\"hljs-built_in\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>要终止在PID 3456上运行的进程，可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:!<span class=\"hljs-built_in\">kill</span> -9 3456<br></code></pre></td></tr></table></figure>\n\n<p>您可以在不离开Vim的情况下运行任何外部命令，因此您可以专注于自己的任务。</p>\n<h2 id=\"过滤文本\"><a href=\"#过滤文本\" class=\"headerlink\" title=\"过滤文本\"></a>过滤文本</h2><p>如果给<code>!</code>范围，则可用于过滤文本。假设您有：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hello <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们使用<code>tr</code> (translate)命令将当前行大写。运行：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-meta\">:.!tr &#x27;[:lower:]&#x27;</span> <span class=\"hljs-emphasis\">&#x27;[:upper:]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">HELLO VIM</span><br><span class=\"hljs-attribute\">hello vim</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>.!</code> 在当前行执行filter命令。</li>\n<li><code>!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code> 调用<code>tr</code>外部命令将所有小写字符替换为大写字符。</li>\n</ul>\n<p>必须传递范围以运行外部命令作为过滤器。如果您尝试在没有<code>.</code>的情况下运行上述命令(<code>:!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code>)，则会看到错误。</p>\n<p>假设您需要使用awk命令删除两行的第二列：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:%!awk <span class=\"hljs-string\">&quot;&#123;print <span class=\"hljs-variable\">$1</span>&#125;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello</span><br><span class=\"hljs-attribute\">hello</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>:%!</code>  在所有行(<code>%</code>)上执行filter命令。</li>\n<li><code>awk &quot;&#123;print $1&#125;&quot;</code> 仅打印匹配项的第一列。</li>\n</ul>\n<p>您可以使用管道运算符（<code>|</code>）链接多个命令，就像在终端中一样。假设您有一个包含这些美味早餐的文件：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">name</span> price<br><span class=\"hljs-attribute\">chocolate</span> pancake <span class=\"hljs-number\">10</span><br><span class=\"hljs-attribute\">buttermilk</span> pancake <span class=\"hljs-number\">9</span><br><span class=\"hljs-attribute\">blueberry</span> pancake <span class=\"hljs-number\">12</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您需要根据价格对它们进行排序，并且仅以均匀的间距显示菜单，则可以运行：</p>\n<figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mel\">:%!awk <span class=\"hljs-string\">&#x27;NR &gt; 1&#x27;</span> | <span class=\"hljs-keyword\">sort</span> -nk <span class=\"hljs-number\">3</span> | column -t<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">buttermilk</span> pancake <span class=\"hljs-number\">9</span><br><span class=\"hljs-attribute\">chocolate</span> pancake <span class=\"hljs-number\">10</span><br><span class=\"hljs-attribute\">blueberry</span> pancake <span class=\"hljs-number\">12</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>:%!</code> 将过滤器应用于所有行(<code>%</code>)。</li>\n<li><code>awk &#39;NR &gt; 1&#39;</code> 仅从第二行开始显示文本。</li>\n<li><code>|</code>链接下一个命令。</li>\n<li><code>sort -nk 3</code>使用列3（<code>k 3</code>）中的值对数字进行排序（<code>n</code>）。</li>\n<li><code>column -t</code>以均匀的间距组织文本。</li>\n</ul>\n<h2 id=\"普通模式命令\"><a href=\"#普通模式命令\" class=\"headerlink\" title=\"普通模式命令\"></a>普通模式命令</h2><p>在普通模式下，Vim有一个过滤运算符（<code>!</code>）。如果您有以下问候：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hola <span class=\"hljs-keyword\">vim</span><br>bonjour <span class=\"hljs-keyword\">vim</span><br>salve <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>要大写当前行和下面的行，可以运行：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">!jtr <span class=\"hljs-string\">&#x27;[a-z]&#x27;</span> <span class=\"hljs-string\">&#x27;[A-Z]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>!j</code> 运行常规命令过滤器运算符（<code>!</code>），目标是当前行及其下方的行。回想一下，因为它是普通模式运算符，所以适用语法规则”动词+名词”。</li>\n<li><code>tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>将小写字母替换为大写字母。</li>\n</ul>\n<p>filter normal命令仅适用于至少一行以上的motion或至少一行以上的文本对象。如果您尝试运行<code>!iwtr&#39;[az]&#39;&#39;[AZ]&#39;</code>（在内部单词上执行<code>tr</code>），您会发现它在整个行上都应用了tr命令，而不是光标所在的单词。</p>\n<h2 id=\"聪明地学习外部命令\"><a href=\"#聪明地学习外部命令\" class=\"headerlink\" title=\"聪明地学习外部命令\"></a>聪明地学习外部命令</h2><p>Vim不是IDE。它是一种轻量级的模式编辑器，通过设计可以高度扩展。由于这种可扩展性，您可以轻松访问系统中的任何外部命令。这样，Vim离成为IDE仅一步之遥。有人说Unix系统是有史以来的第一个IDE。</p>\n<p>Bang 命令的有用程度与您知道多少个外部命令相关。如果您的外部命令知识有限，请不要担心。我还有很多东西要学。以此作为持续学习的动力。每当您需要过滤文本时，请查看是否存在可以解决问题的外部命令。不必担心掌握所有的命令。只需学习完成当前任务所需的内容即可。</p>\n","site":{"data":{}},"wordcount":2674,"excerpt":"","more":"<h1 id=\"外部命令\"><a href=\"#外部命令\" class=\"headerlink\" title=\"外部命令\"></a>外部命令</h1><p>在Unix系统内部，您会发现许多小型的，超专业化命令，每个命令只做一件事（而且能很好地完成）。您可以将这些命令链接在一起以共同解决一个复杂的问题。如果可以从Vim内部使用这些命令，那不是很好吗？</p>\n<p>答案是肯定的!在本章中，您将学习如何扩展Vim以使其与外部命令无缝协作。</p>\n<h2 id=\"Bang-命令\"><a href=\"#Bang-命令\" class=\"headerlink\" title=\"Bang 命令\"></a>Bang 命令</h2><p>Vim有一个Bang(<code>!</code>)命令，可以执行三件事：</p>\n<p>1.将外部命令的STDOUT读入当前缓冲区。<br>2.将缓冲区的内容作为STDIN写入外部命令。<br>3.从Vim内部执行外部命令。</p>\n<p>让我们一个个认真看一下。</p>\n<h2 id=\"将外部命令的标准输出STDOUT读入Vim\"><a href=\"#将外部命令的标准输出STDOUT读入Vim\" class=\"headerlink\" title=\"将外部命令的标准输出STDOUT读入Vim\"></a>将外部命令的标准输出STDOUT读入Vim</h2><p>将外部命令的STDOUT读入当前缓冲区的语法为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">:r !&#123;cmd&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>:r</code>是Vim的读命令。如果不带<code>!</code>使用它，则可以使用它来获取文件的内容。如果当前目录中有文件<code>file1.txt</code>，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:r</span> file1.txt<br></code></pre></td></tr></table></figure>\n\n<p>Vim会将<code>file1.txt</code>的内容放入当前缓冲区。</p>\n<p>如果您运行的<code>:r</code>命令后面跟一个<code>!</code>和外部命令，则该命令的输出将插入到当前缓冲区中。要获取<code>ls</code>命令的结果，请运行：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">:<span class=\"hljs-built_in\">r</span> !<span class=\"hljs-built_in\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>它返回类似下列的文本：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">file1<span class=\"hljs-selector-class\">.txt</span><br>file2<span class=\"hljs-selector-class\">.txt</span><br>file3.txt<br></code></pre></td></tr></table></figure>\n\n<p>您可以从<code>curl</code>命令读取数据：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">:<span class=\"hljs-built_in\">r</span> !<span class=\"hljs-built_in\">curl</span> <span class=\"hljs-literal\">-s</span> <span class=\"hljs-string\">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>r命令也接受一个地址：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">:<span class=\"hljs-number\">10</span><span class=\"hljs-built_in\">r</span> !<span class=\"hljs-built_in\">cat</span> file1.txt<br></code></pre></td></tr></table></figure>\n\n<p>现在，将在第10行之后插入来自运行<code>cat file.txt</code>的STDOUT。</p>\n<h2 id=\"将缓冲区内容写入外部命令\"><a href=\"#将缓冲区内容写入外部命令\" class=\"headerlink\" title=\"将缓冲区内容写入外部命令\"></a>将缓冲区内容写入外部命令</h2><p><code>:w</code>命令除了保存文件，还可以用来将当前缓冲区中的文本作为作为STDIN传递给外部命令。语法为：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">:w !<span class=\"hljs-keyword\">cmd</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您具有以下表达式：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Hello Vim&quot;</span>);<br><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Vim is awesome&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>确保在计算机中安装了<a href=\"https://nodejs.org/en/\">node</a>，然后运行：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:w !<span class=\"hljs-keyword\">node</span><span class=\"hljs-title\"></span><br></code></pre></td></tr></table></figure>\n\n<p>Vim将使用<code>node</code>执行Javascript表达式来打印”Hello Vim”和”Vim is awesome”。</p>\n<p>当使用<code>：w</code>命令时，Vim使用当前缓冲区中的所有文本，与global命令类似（大多数命令行命令，如果不给它传递范围，则仅对当前行执行该命令）。如果您通过<code>：w</code>来指定地址：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:<span class=\"hljs-number\">2</span>w !<span class=\"hljs-keyword\">node</span><span class=\"hljs-title\"></span><br></code></pre></td></tr></table></figure>\n\n<p>“Vim”只使用第二行中的文本到<code>node</code>解释器中。</p>\n<p><code>:w !node</code>和<code>:w! node</code>形式上区别很小，但功能上相隔千里。使用<code>:w !node</code>，您是将当前缓冲区中的文本”写入”到外部命令<code>node</code>中。用<code>:w! node</code>，则您将强制保存文件并将其命名为”node”。</p>\n<h2 id=\"执行外部命令\"><a href=\"#执行外部命令\" class=\"headerlink\" title=\"执行外部命令\"></a>执行外部命令</h2><p>您可以使用bang命令从Vim内部执行外部命令。语法为：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:!cmd</span><br></code></pre></td></tr></table></figure>\n\n<p>要以长格式查看当前目录的内容，请运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:!<span class=\"hljs-built_in\">ls</span> -<span class=\"hljs-built_in\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>要终止在PID 3456上运行的进程，可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:!<span class=\"hljs-built_in\">kill</span> -9 3456<br></code></pre></td></tr></table></figure>\n\n<p>您可以在不离开Vim的情况下运行任何外部命令，因此您可以专注于自己的任务。</p>\n<h2 id=\"过滤文本\"><a href=\"#过滤文本\" class=\"headerlink\" title=\"过滤文本\"></a>过滤文本</h2><p>如果给<code>!</code>范围，则可用于过滤文本。假设您有：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hello <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们使用<code>tr</code> (translate)命令将当前行大写。运行：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-meta\">:.!tr &#x27;[:lower:]&#x27;</span> <span class=\"hljs-emphasis\">&#x27;[:upper:]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">HELLO VIM</span><br><span class=\"hljs-attribute\">hello vim</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>.!</code> 在当前行执行filter命令。</li>\n<li><code>!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code> 调用<code>tr</code>外部命令将所有小写字符替换为大写字符。</li>\n</ul>\n<p>必须传递范围以运行外部命令作为过滤器。如果您尝试在没有<code>.</code>的情况下运行上述命令(<code>:!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code>)，则会看到错误。</p>\n<p>假设您需要使用awk命令删除两行的第二列：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:%!awk <span class=\"hljs-string\">&quot;&#123;print <span class=\"hljs-variable\">$1</span>&#125;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">hello</span><br><span class=\"hljs-attribute\">hello</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>:%!</code>  在所有行(<code>%</code>)上执行filter命令。</li>\n<li><code>awk &quot;&#123;print $1&#125;&quot;</code> 仅打印匹配项的第一列。</li>\n</ul>\n<p>您可以使用管道运算符（<code>|</code>）链接多个命令，就像在终端中一样。假设您有一个包含这些美味早餐的文件：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">name</span> price<br><span class=\"hljs-attribute\">chocolate</span> pancake <span class=\"hljs-number\">10</span><br><span class=\"hljs-attribute\">buttermilk</span> pancake <span class=\"hljs-number\">9</span><br><span class=\"hljs-attribute\">blueberry</span> pancake <span class=\"hljs-number\">12</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您需要根据价格对它们进行排序，并且仅以均匀的间距显示菜单，则可以运行：</p>\n<figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mel\">:%!awk <span class=\"hljs-string\">&#x27;NR &gt; 1&#x27;</span> | <span class=\"hljs-keyword\">sort</span> -nk <span class=\"hljs-number\">3</span> | column -t<br></code></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">buttermilk</span> pancake <span class=\"hljs-number\">9</span><br><span class=\"hljs-attribute\">chocolate</span> pancake <span class=\"hljs-number\">10</span><br><span class=\"hljs-attribute\">blueberry</span> pancake <span class=\"hljs-number\">12</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>:%!</code> 将过滤器应用于所有行(<code>%</code>)。</li>\n<li><code>awk &#39;NR &gt; 1&#39;</code> 仅从第二行开始显示文本。</li>\n<li><code>|</code>链接下一个命令。</li>\n<li><code>sort -nk 3</code>使用列3（<code>k 3</code>）中的值对数字进行排序（<code>n</code>）。</li>\n<li><code>column -t</code>以均匀的间距组织文本。</li>\n</ul>\n<h2 id=\"普通模式命令\"><a href=\"#普通模式命令\" class=\"headerlink\" title=\"普通模式命令\"></a>普通模式命令</h2><p>在普通模式下，Vim有一个过滤运算符（<code>!</code>）。如果您有以下问候：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">hello <span class=\"hljs-keyword\">vim</span><br>hola <span class=\"hljs-keyword\">vim</span><br>bonjour <span class=\"hljs-keyword\">vim</span><br>salve <span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>要大写当前行和下面的行，可以运行：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">!jtr <span class=\"hljs-string\">&#x27;[a-z]&#x27;</span> <span class=\"hljs-string\">&#x27;[A-Z]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>命令分解：</p>\n<ul>\n<li><code>!j</code> 运行常规命令过滤器运算符（<code>!</code>），目标是当前行及其下方的行。回想一下，因为它是普通模式运算符，所以适用语法规则”动词+名词”。</li>\n<li><code>tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>将小写字母替换为大写字母。</li>\n</ul>\n<p>filter normal命令仅适用于至少一行以上的motion或至少一行以上的文本对象。如果您尝试运行<code>!iwtr&#39;[az]&#39;&#39;[AZ]&#39;</code>（在内部单词上执行<code>tr</code>），您会发现它在整个行上都应用了tr命令，而不是光标所在的单词。</p>\n<h2 id=\"聪明地学习外部命令\"><a href=\"#聪明地学习外部命令\" class=\"headerlink\" title=\"聪明地学习外部命令\"></a>聪明地学习外部命令</h2><p>Vim不是IDE。它是一种轻量级的模式编辑器，通过设计可以高度扩展。由于这种可扩展性，您可以轻松访问系统中的任何外部命令。这样，Vim离成为IDE仅一步之遥。有人说Unix系统是有史以来的第一个IDE。</p>\n<p>Bang 命令的有用程度与您知道多少个外部命令相关。如果您的外部命令知识有限，请不要担心。我还有很多东西要学。以此作为持续学习的动力。每当您需要过滤文本时，请查看是否存在可以解决问题的外部命令。不必担心掌握所有的命令。只需学习完成当前任务所需的内容即可。</p>\n"},{"title":"VIM-命令行模式","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第15章 命令行模式\n\n在前三章中，您已经学习了如何使用搜索命令(`/`, `?`)、替换命令(`:s`)、全局命令(`:g`)，以及外部命令(`!`)。这些都是命令行模式命令的一些例子。\n\n在本章中，您将学习命令行模式的更多技巧。\n\n## 进入和退出命令行模式\n\n命令行模式本身也是一种模式，就像普通模式、输入模式、可视模式一样。在这种模式中，光标将转到屏幕底部，此时您可以输入不同的命令。\n\n有 4 种进入命令行模式的方式：\n- 搜索命令 (`/`, `?`)\n- 命令行指令 (`:`)\n- 外部命令 (`!`)\n\n您可以从正常模式或可视模式进入命令行模式。\n\n若要离开命令行模式，您可以使用 `<esc>`、`Ctrl-c`、`Ctrl-[`。\n\n**有时其他资料可能会将\"命令行指令\"称为\"Ex 命令\"，将\"外部命令\"称为\"过滤命令\"或者\"叹号运算符\"。**\n\n## 重复上一个命令\n\n您可以用 `@:` 来重复上一个命令行指令或外部命令。\n\n如果您刚运行 `:s/foo/bar/g`，执行 `@:` 将重复该替换。如果您刚运行 `:.!tr '[a-z]' '[A-Z]'`，执行 `@:` 将重复上一次外部命令转换过滤。\n\n## 命令行模式快捷键\n\n在命令行模式中，您可以使用 `Left` 或 `Right` 方向键，来左右移动一个字符。\n\n如果需要移动一个单词，使用 `Shift-Left` 或 `Shift-Right` (在某些操作系统中，您需要使用 `Ctrl` 而不是 `Shift`)。\n\n使用 `Ctrl-b`移动到该行的开始，使用 `Ctrl-e`移动到该行的结束。\n\n和输入模式类似，在命令行模式中，有三种方法可以删除字符：\n\n```\nCtrl-h    删除一个字符\nCtrl-w    删除一个单词\nCtrl-u    删除一整行\n```\n最后，如果您想像编辑文本文件一样来编辑命令，可以使用 `Ctrl-f`。\n\n这样还可以查看过往的命令，并在这种\"命令行编辑的普通模式\"中编辑它们，同时还能按下 `Enter` 来运行它们。\n\n## 寄存器和自动补全\n\n当处于命令行模式时，您可以像在插入模式中一样使用 `Ctrl-r` 从Vim寄存器中插入文本。如果您在寄存器 a 中存储了字符串 \"foo\" ，您可以执行 `Ctrl-r a` 从寄存器a中插入该文本。任何在插入模式中您可以从寄存器中获取的内容，在命令行模式中您也可以获取。\n\n另外，您也可以按 `Ctrl-r Ctrl-w` 获取当前光标下的单词（按 `Ctrl-r Ctrl-A` 获取当前光标下的词组）。还可以按 `Ctrl-r Ctlr-l` 获取当前光标所在行。按 `Ctrl-r Ctrl-f` 获取光标下的文件名。\n\n您也可以对已存在的命令使用自动补全。要自动补全 `echo` 命令，当处于命令行模式时，首先输入 \"ec\"，接着按下 `<Tab>`，此时您应该能在左下角看到一些 \"ec\" 开头的 Vim 命令（例如：`echo echoerr echohl echomsg econ`）。按下 `<Tab>` 或 `Ctrl-n` 可以跳到下一个选项。按下 `<Shift-Tab>` 或 `Ctrl-p` 可以回到上一个选项。\n\n一些命令行指令接受文件名作为参数。`edit` 就是一个例子，这时候您也可以使用自动补全。当输入 `:e ` 后（不要忘记空格了），按下 `<Tab>`，Vim 将列出所有相关的文件名，这样您就可以进行选择而不必完整的输入它们。\n\n## 历史记录窗口\n\n您可以查看命令行指令和搜索项的历史记录（要确保在运行 `vim --version` 时，Vim 的编译选项中含有`+cmdline_hist`）。\n\n运行 `:his :` 来查看命令行指令的历史记录：\n\n```\n##  cmd History\n2  e file1.txt\n3  g/foo/d\n4  s/foo/bar/g\n```\n\nVim 列出了您运行的所有 `:` 命令。默认情况下，Vim 存储最后 50 个命令。运行 `:set history=100` 可以将 Vim 记住的条目总数更改为 100。\n\n一个更有用的做法是使用命令行历史记录窗口，按`q:`将会打开一个可搜索、可编辑的历史记录窗口。假设按下`q:`后您有如下的表达式：\n\n```\n51  s/verylongsubstitutionpattern/pancake/g\n52  his :\n53  wq\n```\n\n如果您当前任务是执行 `s/verylongsubstitutionpattern/donut/g`（\"pancake\"换成了\"donut\"），为什么不复用 `s/verylongsubstitutionpattern/pancake/g` 呢？毕竟，两条命令唯一不同的是替换的单词，\"donut\" vs \"pancake\" ，所有其他的内容都是相同的。\n\n当您运行 `q:`后，在历史记录中找到 `s/verylongsubstitutionpattern/pancake/g`（在这个环境中，您可以使用Vim导航），然后直接编辑它！ 在历史记录窗口中将 \"pancake\" 改为 \"donut\" ，然后按 `<Enter`。Vim立刻执行 `s/verylongsubstitutionpattern/donut/g` 命令，超级方便！\n\n类似地，运行 `:his /` 或 `:his ?` 可以查看搜索记录。要想打开您可以直接搜索和编辑的搜索历史记录窗口，您可以运行 `q/` 和 `q?`。\n\n要退出这个窗口，按 `Ctrl-c`, `Ctrl-w c`, 或输入 `:quit`。\n\n## 更多命令行指令\n\nVim有几百个内置指令，要查看Vim的所有指令，执行 `:h ex-cmd-index` 或 `:h :index`。\n\n## 聪明地学习命令行模式\n\n对比其他三种模式，命令行模式就像是文本编辑中的瑞士军刀。寥举几例，您可以编辑文本、修改文件和执行命令。本章是命令行模式的零碎知识的集合。同时，Vim 模式的介绍也走向尾声。现在，您已经知道如何使用普通、输入、可视以及命令行模式，您可以比以往更快地使用 Vim 来编辑文本了。\n\n是时候离开 Vim 模式，来了解如何使用 Vim 标记进行更快的导航了。\n","source":"_posts/Vim/ch15_command-line_mode.md","raw":"---\ntitle: VIM-命令行模式\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第15章 命令行模式\n\n在前三章中，您已经学习了如何使用搜索命令(`/`, `?`)、替换命令(`:s`)、全局命令(`:g`)，以及外部命令(`!`)。这些都是命令行模式命令的一些例子。\n\n在本章中，您将学习命令行模式的更多技巧。\n\n## 进入和退出命令行模式\n\n命令行模式本身也是一种模式，就像普通模式、输入模式、可视模式一样。在这种模式中，光标将转到屏幕底部，此时您可以输入不同的命令。\n\n有 4 种进入命令行模式的方式：\n- 搜索命令 (`/`, `?`)\n- 命令行指令 (`:`)\n- 外部命令 (`!`)\n\n您可以从正常模式或可视模式进入命令行模式。\n\n若要离开命令行模式，您可以使用 `<esc>`、`Ctrl-c`、`Ctrl-[`。\n\n**有时其他资料可能会将\"命令行指令\"称为\"Ex 命令\"，将\"外部命令\"称为\"过滤命令\"或者\"叹号运算符\"。**\n\n## 重复上一个命令\n\n您可以用 `@:` 来重复上一个命令行指令或外部命令。\n\n如果您刚运行 `:s/foo/bar/g`，执行 `@:` 将重复该替换。如果您刚运行 `:.!tr '[a-z]' '[A-Z]'`，执行 `@:` 将重复上一次外部命令转换过滤。\n\n## 命令行模式快捷键\n\n在命令行模式中，您可以使用 `Left` 或 `Right` 方向键，来左右移动一个字符。\n\n如果需要移动一个单词，使用 `Shift-Left` 或 `Shift-Right` (在某些操作系统中，您需要使用 `Ctrl` 而不是 `Shift`)。\n\n使用 `Ctrl-b`移动到该行的开始，使用 `Ctrl-e`移动到该行的结束。\n\n和输入模式类似，在命令行模式中，有三种方法可以删除字符：\n\n```\nCtrl-h    删除一个字符\nCtrl-w    删除一个单词\nCtrl-u    删除一整行\n```\n最后，如果您想像编辑文本文件一样来编辑命令，可以使用 `Ctrl-f`。\n\n这样还可以查看过往的命令，并在这种\"命令行编辑的普通模式\"中编辑它们，同时还能按下 `Enter` 来运行它们。\n\n## 寄存器和自动补全\n\n当处于命令行模式时，您可以像在插入模式中一样使用 `Ctrl-r` 从Vim寄存器中插入文本。如果您在寄存器 a 中存储了字符串 \"foo\" ，您可以执行 `Ctrl-r a` 从寄存器a中插入该文本。任何在插入模式中您可以从寄存器中获取的内容，在命令行模式中您也可以获取。\n\n另外，您也可以按 `Ctrl-r Ctrl-w` 获取当前光标下的单词（按 `Ctrl-r Ctrl-A` 获取当前光标下的词组）。还可以按 `Ctrl-r Ctlr-l` 获取当前光标所在行。按 `Ctrl-r Ctrl-f` 获取光标下的文件名。\n\n您也可以对已存在的命令使用自动补全。要自动补全 `echo` 命令，当处于命令行模式时，首先输入 \"ec\"，接着按下 `<Tab>`，此时您应该能在左下角看到一些 \"ec\" 开头的 Vim 命令（例如：`echo echoerr echohl echomsg econ`）。按下 `<Tab>` 或 `Ctrl-n` 可以跳到下一个选项。按下 `<Shift-Tab>` 或 `Ctrl-p` 可以回到上一个选项。\n\n一些命令行指令接受文件名作为参数。`edit` 就是一个例子，这时候您也可以使用自动补全。当输入 `:e ` 后（不要忘记空格了），按下 `<Tab>`，Vim 将列出所有相关的文件名，这样您就可以进行选择而不必完整的输入它们。\n\n## 历史记录窗口\n\n您可以查看命令行指令和搜索项的历史记录（要确保在运行 `vim --version` 时，Vim 的编译选项中含有`+cmdline_hist`）。\n\n运行 `:his :` 来查看命令行指令的历史记录：\n\n```\n##  cmd History\n2  e file1.txt\n3  g/foo/d\n4  s/foo/bar/g\n```\n\nVim 列出了您运行的所有 `:` 命令。默认情况下，Vim 存储最后 50 个命令。运行 `:set history=100` 可以将 Vim 记住的条目总数更改为 100。\n\n一个更有用的做法是使用命令行历史记录窗口，按`q:`将会打开一个可搜索、可编辑的历史记录窗口。假设按下`q:`后您有如下的表达式：\n\n```\n51  s/verylongsubstitutionpattern/pancake/g\n52  his :\n53  wq\n```\n\n如果您当前任务是执行 `s/verylongsubstitutionpattern/donut/g`（\"pancake\"换成了\"donut\"），为什么不复用 `s/verylongsubstitutionpattern/pancake/g` 呢？毕竟，两条命令唯一不同的是替换的单词，\"donut\" vs \"pancake\" ，所有其他的内容都是相同的。\n\n当您运行 `q:`后，在历史记录中找到 `s/verylongsubstitutionpattern/pancake/g`（在这个环境中，您可以使用Vim导航），然后直接编辑它！ 在历史记录窗口中将 \"pancake\" 改为 \"donut\" ，然后按 `<Enter`。Vim立刻执行 `s/verylongsubstitutionpattern/donut/g` 命令，超级方便！\n\n类似地，运行 `:his /` 或 `:his ?` 可以查看搜索记录。要想打开您可以直接搜索和编辑的搜索历史记录窗口，您可以运行 `q/` 和 `q?`。\n\n要退出这个窗口，按 `Ctrl-c`, `Ctrl-w c`, 或输入 `:quit`。\n\n## 更多命令行指令\n\nVim有几百个内置指令，要查看Vim的所有指令，执行 `:h ex-cmd-index` 或 `:h :index`。\n\n## 聪明地学习命令行模式\n\n对比其他三种模式，命令行模式就像是文本编辑中的瑞士军刀。寥举几例，您可以编辑文本、修改文件和执行命令。本章是命令行模式的零碎知识的集合。同时，Vim 模式的介绍也走向尾声。现在，您已经知道如何使用普通、输入、可视以及命令行模式，您可以比以往更快地使用 Vim 来编辑文本了。\n\n是时候离开 Vim 模式，来了解如何使用 Vim 标记进行更快的导航了。\n","slug":"Vim/ch15_command-line_mode","published":1,"updated":"2022-08-28T07:38:59.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i220026scvm2842gvi2","content":"<h1 id=\"第15章-命令行模式\"><a href=\"#第15章-命令行模式\" class=\"headerlink\" title=\"第15章 命令行模式\"></a>第15章 命令行模式</h1><p>在前三章中，您已经学习了如何使用搜索命令(<code>/</code>, <code>?</code>)、替换命令(<code>:s</code>)、全局命令(<code>:g</code>)，以及外部命令(<code>!</code>)。这些都是命令行模式命令的一些例子。</p>\n<p>在本章中，您将学习命令行模式的更多技巧。</p>\n<h2 id=\"进入和退出命令行模式\"><a href=\"#进入和退出命令行模式\" class=\"headerlink\" title=\"进入和退出命令行模式\"></a>进入和退出命令行模式</h2><p>命令行模式本身也是一种模式，就像普通模式、输入模式、可视模式一样。在这种模式中，光标将转到屏幕底部，此时您可以输入不同的命令。</p>\n<p>有 4 种进入命令行模式的方式：</p>\n<ul>\n<li>搜索命令 (<code>/</code>, <code>?</code>)</li>\n<li>命令行指令 (<code>:</code>)</li>\n<li>外部命令 (<code>!</code>)</li>\n</ul>\n<p>您可以从正常模式或可视模式进入命令行模式。</p>\n<p>若要离开命令行模式，您可以使用 <code>&lt;esc&gt;</code>、<code>Ctrl-c</code>、<code>Ctrl-[</code>。</p>\n<p><strong>有时其他资料可能会将”命令行指令”称为”Ex 命令”，将”外部命令”称为”过滤命令”或者”叹号运算符”。</strong></p>\n<h2 id=\"重复上一个命令\"><a href=\"#重复上一个命令\" class=\"headerlink\" title=\"重复上一个命令\"></a>重复上一个命令</h2><p>您可以用 <code>@:</code> 来重复上一个命令行指令或外部命令。</p>\n<p>如果您刚运行 <code>:s/foo/bar/g</code>，执行 <code>@:</code> 将重复该替换。如果您刚运行 <code>:.!tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>，执行 <code>@:</code> 将重复上一次外部命令转换过滤。</p>\n<h2 id=\"命令行模式快捷键\"><a href=\"#命令行模式快捷键\" class=\"headerlink\" title=\"命令行模式快捷键\"></a>命令行模式快捷键</h2><p>在命令行模式中，您可以使用 <code>Left</code> 或 <code>Right</code> 方向键，来左右移动一个字符。</p>\n<p>如果需要移动一个单词，使用 <code>Shift-Left</code> 或 <code>Shift-Right</code> (在某些操作系统中，您需要使用 <code>Ctrl</code> 而不是 <code>Shift</code>)。</p>\n<p>使用 <code>Ctrl-b</code>移动到该行的开始，使用 <code>Ctrl-e</code>移动到该行的结束。</p>\n<p>和输入模式类似，在命令行模式中，有三种方法可以删除字符：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs\">Ctrl-h    删除一个字符<br>Ctrl-w    删除一个单词<br>Ctrl-u    删除一整行<br></code></pre></td></tr></table></figure>\n<p>最后，如果您想像编辑文本文件一样来编辑命令，可以使用 <code>Ctrl-f</code>。</p>\n<p>这样还可以查看过往的命令，并在这种”命令行编辑的普通模式”中编辑它们，同时还能按下 <code>Enter</code> 来运行它们。</p>\n<h2 id=\"寄存器和自动补全\"><a href=\"#寄存器和自动补全\" class=\"headerlink\" title=\"寄存器和自动补全\"></a>寄存器和自动补全</h2><p>当处于命令行模式时，您可以像在插入模式中一样使用 <code>Ctrl-r</code> 从Vim寄存器中插入文本。如果您在寄存器 a 中存储了字符串 “foo” ，您可以执行 <code>Ctrl-r a</code> 从寄存器a中插入该文本。任何在插入模式中您可以从寄存器中获取的内容，在命令行模式中您也可以获取。</p>\n<p>另外，您也可以按 <code>Ctrl-r Ctrl-w</code> 获取当前光标下的单词（按 <code>Ctrl-r Ctrl-A</code> 获取当前光标下的词组）。还可以按 <code>Ctrl-r Ctlr-l</code> 获取当前光标所在行。按 <code>Ctrl-r Ctrl-f</code> 获取光标下的文件名。</p>\n<p>您也可以对已存在的命令使用自动补全。要自动补全 <code>echo</code> 命令，当处于命令行模式时，首先输入 “ec”，接着按下 <code>&lt;Tab&gt;</code>，此时您应该能在左下角看到一些 “ec” 开头的 Vim 命令（例如：<code>echo echoerr echohl echomsg econ</code>）。按下 <code>&lt;Tab&gt;</code> 或 <code>Ctrl-n</code> 可以跳到下一个选项。按下 <code>&lt;Shift-Tab&gt;</code> 或 <code>Ctrl-p</code> 可以回到上一个选项。</p>\n<p>一些命令行指令接受文件名作为参数。<code>edit</code> 就是一个例子，这时候您也可以使用自动补全。当输入 <code>:e </code> 后（不要忘记空格了），按下 <code>&lt;Tab&gt;</code>，Vim 将列出所有相关的文件名，这样您就可以进行选择而不必完整的输入它们。</p>\n<h2 id=\"历史记录窗口\"><a href=\"#历史记录窗口\" class=\"headerlink\" title=\"历史记录窗口\"></a>历史记录窗口</h2><p>您可以查看命令行指令和搜索项的历史记录（要确保在运行 <code>vim --version</code> 时，Vim 的编译选项中含有<code>+cmdline_hist</code>）。</p>\n<p>运行 <code>:his :</code> 来查看命令行指令的历史记录：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">##  cmd History</span><br><span class=\"hljs-number\">2</span>  e file1.txt<br><span class=\"hljs-number\">3</span>  g<span class=\"hljs-regexp\">/foo/</span>d<br><span class=\"hljs-number\">4</span>  s<span class=\"hljs-regexp\">/foo/</span>bar/g<br></code></pre></td></tr></table></figure>\n\n<p>Vim 列出了您运行的所有 <code>:</code> 命令。默认情况下，Vim 存储最后 50 个命令。运行 <code>:set history=100</code> 可以将 Vim 记住的条目总数更改为 100。</p>\n<p>一个更有用的做法是使用命令行历史记录窗口，按<code>q:</code>将会打开一个可搜索、可编辑的历史记录窗口。假设按下<code>q:</code>后您有如下的表达式：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">51 </span> s/verylongsubstitutionpattern/pancake/g<br><span class=\"hljs-symbol\">52 </span> his :<br><span class=\"hljs-symbol\">53 </span> wq<br></code></pre></td></tr></table></figure>\n\n<p>如果您当前任务是执行 <code>s/verylongsubstitutionpattern/donut/g</code>（”pancake”换成了”donut”），为什么不复用 <code>s/verylongsubstitutionpattern/pancake/g</code> 呢？毕竟，两条命令唯一不同的是替换的单词，”donut” vs “pancake” ，所有其他的内容都是相同的。</p>\n<p>当您运行 <code>q:</code>后，在历史记录中找到 <code>s/verylongsubstitutionpattern/pancake/g</code>（在这个环境中，您可以使用Vim导航），然后直接编辑它！ 在历史记录窗口中将 “pancake” 改为 “donut” ，然后按 <code>&lt;Enter</code>。Vim立刻执行 <code>s/verylongsubstitutionpattern/donut/g</code> 命令，超级方便！</p>\n<p>类似地，运行 <code>:his /</code> 或 <code>:his ?</code> 可以查看搜索记录。要想打开您可以直接搜索和编辑的搜索历史记录窗口，您可以运行 <code>q/</code> 和 <code>q?</code>。</p>\n<p>要退出这个窗口，按 <code>Ctrl-c</code>, <code>Ctrl-w c</code>, 或输入 <code>:quit</code>。</p>\n<h2 id=\"更多命令行指令\"><a href=\"#更多命令行指令\" class=\"headerlink\" title=\"更多命令行指令\"></a>更多命令行指令</h2><p>Vim有几百个内置指令，要查看Vim的所有指令，执行 <code>:h ex-cmd-index</code> 或 <code>:h :index</code>。</p>\n<h2 id=\"聪明地学习命令行模式\"><a href=\"#聪明地学习命令行模式\" class=\"headerlink\" title=\"聪明地学习命令行模式\"></a>聪明地学习命令行模式</h2><p>对比其他三种模式，命令行模式就像是文本编辑中的瑞士军刀。寥举几例，您可以编辑文本、修改文件和执行命令。本章是命令行模式的零碎知识的集合。同时，Vim 模式的介绍也走向尾声。现在，您已经知道如何使用普通、输入、可视以及命令行模式，您可以比以往更快地使用 Vim 来编辑文本了。</p>\n<p>是时候离开 Vim 模式，来了解如何使用 Vim 标记进行更快的导航了。</p>\n","site":{"data":{}},"wordcount":2272,"excerpt":"","more":"<h1 id=\"第15章-命令行模式\"><a href=\"#第15章-命令行模式\" class=\"headerlink\" title=\"第15章 命令行模式\"></a>第15章 命令行模式</h1><p>在前三章中，您已经学习了如何使用搜索命令(<code>/</code>, <code>?</code>)、替换命令(<code>:s</code>)、全局命令(<code>:g</code>)，以及外部命令(<code>!</code>)。这些都是命令行模式命令的一些例子。</p>\n<p>在本章中，您将学习命令行模式的更多技巧。</p>\n<h2 id=\"进入和退出命令行模式\"><a href=\"#进入和退出命令行模式\" class=\"headerlink\" title=\"进入和退出命令行模式\"></a>进入和退出命令行模式</h2><p>命令行模式本身也是一种模式，就像普通模式、输入模式、可视模式一样。在这种模式中，光标将转到屏幕底部，此时您可以输入不同的命令。</p>\n<p>有 4 种进入命令行模式的方式：</p>\n<ul>\n<li>搜索命令 (<code>/</code>, <code>?</code>)</li>\n<li>命令行指令 (<code>:</code>)</li>\n<li>外部命令 (<code>!</code>)</li>\n</ul>\n<p>您可以从正常模式或可视模式进入命令行模式。</p>\n<p>若要离开命令行模式，您可以使用 <code>&lt;esc&gt;</code>、<code>Ctrl-c</code>、<code>Ctrl-[</code>。</p>\n<p><strong>有时其他资料可能会将”命令行指令”称为”Ex 命令”，将”外部命令”称为”过滤命令”或者”叹号运算符”。</strong></p>\n<h2 id=\"重复上一个命令\"><a href=\"#重复上一个命令\" class=\"headerlink\" title=\"重复上一个命令\"></a>重复上一个命令</h2><p>您可以用 <code>@:</code> 来重复上一个命令行指令或外部命令。</p>\n<p>如果您刚运行 <code>:s/foo/bar/g</code>，执行 <code>@:</code> 将重复该替换。如果您刚运行 <code>:.!tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>，执行 <code>@:</code> 将重复上一次外部命令转换过滤。</p>\n<h2 id=\"命令行模式快捷键\"><a href=\"#命令行模式快捷键\" class=\"headerlink\" title=\"命令行模式快捷键\"></a>命令行模式快捷键</h2><p>在命令行模式中，您可以使用 <code>Left</code> 或 <code>Right</code> 方向键，来左右移动一个字符。</p>\n<p>如果需要移动一个单词，使用 <code>Shift-Left</code> 或 <code>Shift-Right</code> (在某些操作系统中，您需要使用 <code>Ctrl</code> 而不是 <code>Shift</code>)。</p>\n<p>使用 <code>Ctrl-b</code>移动到该行的开始，使用 <code>Ctrl-e</code>移动到该行的结束。</p>\n<p>和输入模式类似，在命令行模式中，有三种方法可以删除字符：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">Ctrl-h    删除一个字符<br>Ctrl-w    删除一个单词<br>Ctrl-u    删除一整行<br></code></pre></td></tr></table></figure>\n<p>最后，如果您想像编辑文本文件一样来编辑命令，可以使用 <code>Ctrl-f</code>。</p>\n<p>这样还可以查看过往的命令，并在这种”命令行编辑的普通模式”中编辑它们，同时还能按下 <code>Enter</code> 来运行它们。</p>\n<h2 id=\"寄存器和自动补全\"><a href=\"#寄存器和自动补全\" class=\"headerlink\" title=\"寄存器和自动补全\"></a>寄存器和自动补全</h2><p>当处于命令行模式时，您可以像在插入模式中一样使用 <code>Ctrl-r</code> 从Vim寄存器中插入文本。如果您在寄存器 a 中存储了字符串 “foo” ，您可以执行 <code>Ctrl-r a</code> 从寄存器a中插入该文本。任何在插入模式中您可以从寄存器中获取的内容，在命令行模式中您也可以获取。</p>\n<p>另外，您也可以按 <code>Ctrl-r Ctrl-w</code> 获取当前光标下的单词（按 <code>Ctrl-r Ctrl-A</code> 获取当前光标下的词组）。还可以按 <code>Ctrl-r Ctlr-l</code> 获取当前光标所在行。按 <code>Ctrl-r Ctrl-f</code> 获取光标下的文件名。</p>\n<p>您也可以对已存在的命令使用自动补全。要自动补全 <code>echo</code> 命令，当处于命令行模式时，首先输入 “ec”，接着按下 <code>&lt;Tab&gt;</code>，此时您应该能在左下角看到一些 “ec” 开头的 Vim 命令（例如：<code>echo echoerr echohl echomsg econ</code>）。按下 <code>&lt;Tab&gt;</code> 或 <code>Ctrl-n</code> 可以跳到下一个选项。按下 <code>&lt;Shift-Tab&gt;</code> 或 <code>Ctrl-p</code> 可以回到上一个选项。</p>\n<p>一些命令行指令接受文件名作为参数。<code>edit</code> 就是一个例子，这时候您也可以使用自动补全。当输入 <code>:e </code> 后（不要忘记空格了），按下 <code>&lt;Tab&gt;</code>，Vim 将列出所有相关的文件名，这样您就可以进行选择而不必完整的输入它们。</p>\n<h2 id=\"历史记录窗口\"><a href=\"#历史记录窗口\" class=\"headerlink\" title=\"历史记录窗口\"></a>历史记录窗口</h2><p>您可以查看命令行指令和搜索项的历史记录（要确保在运行 <code>vim --version</code> 时，Vim 的编译选项中含有<code>+cmdline_hist</code>）。</p>\n<p>运行 <code>:his :</code> 来查看命令行指令的历史记录：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">##  cmd History</span><br><span class=\"hljs-number\">2</span>  e file1.txt<br><span class=\"hljs-number\">3</span>  g<span class=\"hljs-regexp\">/foo/</span>d<br><span class=\"hljs-number\">4</span>  s<span class=\"hljs-regexp\">/foo/</span>bar/g<br></code></pre></td></tr></table></figure>\n\n<p>Vim 列出了您运行的所有 <code>:</code> 命令。默认情况下，Vim 存储最后 50 个命令。运行 <code>:set history=100</code> 可以将 Vim 记住的条目总数更改为 100。</p>\n<p>一个更有用的做法是使用命令行历史记录窗口，按<code>q:</code>将会打开一个可搜索、可编辑的历史记录窗口。假设按下<code>q:</code>后您有如下的表达式：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">51 </span> s/verylongsubstitutionpattern/pancake/g<br><span class=\"hljs-symbol\">52 </span> his :<br><span class=\"hljs-symbol\">53 </span> wq<br></code></pre></td></tr></table></figure>\n\n<p>如果您当前任务是执行 <code>s/verylongsubstitutionpattern/donut/g</code>（”pancake”换成了”donut”），为什么不复用 <code>s/verylongsubstitutionpattern/pancake/g</code> 呢？毕竟，两条命令唯一不同的是替换的单词，”donut” vs “pancake” ，所有其他的内容都是相同的。</p>\n<p>当您运行 <code>q:</code>后，在历史记录中找到 <code>s/verylongsubstitutionpattern/pancake/g</code>（在这个环境中，您可以使用Vim导航），然后直接编辑它！ 在历史记录窗口中将 “pancake” 改为 “donut” ，然后按 <code>&lt;Enter</code>。Vim立刻执行 <code>s/verylongsubstitutionpattern/donut/g</code> 命令，超级方便！</p>\n<p>类似地，运行 <code>:his /</code> 或 <code>:his ?</code> 可以查看搜索记录。要想打开您可以直接搜索和编辑的搜索历史记录窗口，您可以运行 <code>q/</code> 和 <code>q?</code>。</p>\n<p>要退出这个窗口，按 <code>Ctrl-c</code>, <code>Ctrl-w c</code>, 或输入 <code>:quit</code>。</p>\n<h2 id=\"更多命令行指令\"><a href=\"#更多命令行指令\" class=\"headerlink\" title=\"更多命令行指令\"></a>更多命令行指令</h2><p>Vim有几百个内置指令，要查看Vim的所有指令，执行 <code>:h ex-cmd-index</code> 或 <code>:h :index</code>。</p>\n<h2 id=\"聪明地学习命令行模式\"><a href=\"#聪明地学习命令行模式\" class=\"headerlink\" title=\"聪明地学习命令行模式\"></a>聪明地学习命令行模式</h2><p>对比其他三种模式，命令行模式就像是文本编辑中的瑞士军刀。寥举几例，您可以编辑文本、修改文件和执行命令。本章是命令行模式的零碎知识的集合。同时，Vim 模式的介绍也走向尾声。现在，您已经知道如何使用普通、输入、可视以及命令行模式，您可以比以往更快地使用 Vim 来编辑文本了。</p>\n<p>是时候离开 Vim 模式，来了解如何使用 Vim 标记进行更快的导航了。</p>\n"},{"title":"VIM-标签","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第16章 标签\n\n快速转到任意定义处，是文本编辑中一个非常有用的特性。在本章中，您将学习如何使用 Vim 标签来做到这一点。\n\n## 标签概述\n\n假设有人给了您一个新的代码库：\n\n```\none = One.new\none.donut\n```\n\n`One`？`donut`？呃，对于当时编写代码的开发者而言，这些代码的含义可能显而易见。问题是当时的开发者已经不在了，现在要由您来理解这些费解的代码。而跟随有`One` 和 `donut`定义的源代码，是帮助您理解的一个有效方法。\n\n您可以使用`fzf` 或 `grep`来搜索它们，但这种情况下，但使用标签将更快。\n\n把标签想象成地址簿：\n\n```\nName    Address\nIggy1   1234 Cool St, 11111\nIggy2   9876 Awesome Ave, 2222\n```\n\n当然，标签可不是存储着“姓名-地址”对，而是“定义-地址”对。\n\n假设您在一个目录中有两个 Ruby 文件：\n\n```\n## one.rb\nclass One\n  def initialize\n    puts \"Initialized\"\n  end\n\n  def donut\n    puts \"Bar\"\n  end\nend\n```\n\n以及\n\n```\n## two.rb\nrequire './one'\n\none = One.new\none.donut\n```\n\n在普通模式下，您可以使用`Ctrl-]`跳转到定义。在`two.rb`中，转到`one.donut`所在行，将光标移到`donut`处，按下`Ctrl-]`。\n\n哦豁，Vim 找不到标签文件，您需要先生成它。\n\n## 标签生成器\n\n现代 Vim 不自带标签生成器，您需要额外下载它。有几个选项可供选择：\n\n- ctags = 仅用于 C，基本随处可见。\n- exuberant ctags = 最流行的标签生成器之一，支持许多语言。\n- universal ctags = 和 exuberant ctags 类似，但比它更新。\n- etags = 用于 Emacs，嗯……\n- JTags = Java\n- ptags.py = Python\n- ptags = Perl\n- gnatxref = Ada\n\n如果您查看 Vim 在线教程，您会发现许多都会推荐 [exuberant ctags](http://ctags.sourceforge.net/)，它支持 [41 种编程语言](http://ctags.sourceforge.net/languages.html)，我用过它，挺不错的。但自2009年以来一直没有维护，因此 Universal ctags 更好些，它和 exuberant ctags 相似，并仍在维护。\n\n我不打算详细介绍如何安装 Universal ctags，您可以在 [universal ctags](https://github.com/universal-ctags/ctags) 仓库了解更多说明。\n\n假设您已经安装好了ctags，接下来，生成一个基本的标签文件。运行：\n\n```\nctags -R .\n```\n\n `R` 选项告诉 `ctags` 从当前位置 (`.`) 递归扫描文件。稍后，您应该在当前文件夹看到一个`tags` 文件，里面您将看到类似这样的内容：\n\n```\n!_TAG_FILE_FORMAT\t2\t/extended format; --format=1 will not append ;\" to lines/\n!_TAG_FILE_SORTED\t1\t/0=unsorted, 1=sorted, 2=foldcase/\n!_TAG_OUTPUT_FILESEP\tslash\t/slash or backslash/\n!_TAG_OUTPUT_MODE\tu-ctags\t/u-ctags or e-ctags/\n!_TAG_PATTERN_LENGTH_LIMIT\t96\t/0 for no limit/\n!_TAG_PROGRAM_AUTHOR\tUniversal Ctags Team\t//\n!_TAG_PROGRAM_NAME\tUniversal Ctags\t/Derived from Exuberant Ctags/\n!_TAG_PROGRAM_URL\t<https://ctags.io/>\t/official site/\n!_TAG_PROGRAM_VERSION\t0.0.0\t/b43eb39/\nOne\tone.rb\t/^class One$/;\"\tc\ndonut\tone.rb\t/^  def donut$/;\"\tf\tclass:One\ninitialize\tone.rb\t/^  def initialize$/;\"\tf\tclass:One\n```\n\n根据 Vim 设置和 ctag 生成器的不同，您的`tags` 文件可能会有些不同。一个标签文件由两部分组成：标签元数据和标签列表。那些标签元数据 (`!TAG_FILE...`) 通常由 ctags 生成器控制。这里我不打算介绍它们，您可以随意查阅文档。标签列表是一个由所有定义组成的列表，由ctags建立索引。\n\n现在回到 `two.rb`，将光标移至 `donut`，再输入`Ctrl-]`，Vim 将带您转到 `one.rb` 文件里`def donut` 所在的行上。成功啦！但 Vim 怎么做到的呢？\n\n## 解剖标签文件\n\n来看看`donut` 标签项：\n\n```\ndonut\tone.rb\t/^  def donut$/;\"\tf\tclass:One\n```\n\n上面的标签项由四个部分组成：一个`tagname`、一个`tagfile`、一个`tagaddress`，以及标签选项。\n\n- `donut` 是 `tagname`。当光标在 \"donut\" 时，Vim 搜索标签文件里含有 \"donut\" 字符串的一行。\n- `one.rb` 是 `tagfile`。Vim 会搜寻 `one.rb` 文件。\n- `/^ def donut$/` 是 `tagaddress`。`/.../` 是模式指示器。`^` 代表一行中第一个元素，后面跟着两个空格，然后是`def donut`字符串，最后 `$` 代表一行中最后一个元素。\n- `f class:One` 是标签选项，它告诉 Vim，`donut` 是一种函数 (`f`)，并且是 `One` 类的一部分。\n\n再看看另一个标签项：\n\n```\nOne\tone.rb\t/^class One$/;\"\tc\n```\n\n这一行和 `donut`也是一样的：\n\n- `One` 是 `tagname`。注意，对于标签，第一次扫描区分大小写。如果列表中有 `One` 和 `one`， Vim 会优先考虑 `One` 而不是 `one`。\n- `one.rb` 是 `tagfile`。Vim 会搜寻 `one.rb` 文件。\n- `/^class One$/` 是 `tagaddress` 。Vim 会查找以 `class` 开头 (`^`) 、以 `One` 结尾 (`$`) 的行。\n- `c` 是可用标签选项之一。由于 `One` 是一个 ruby 类而不是过程，因此被标签为 `c`。\n\n标签文件的内容可能不尽相同，根据您使用的标签生成器而定。但至少，标签文件必须具有以下格式之一：\n\n```\n1.  {tagname} {TAB} {tagfile} {TAB} {tagaddress}\n2.  {tagname} {TAB} {tagfile} {TAB} {tagaddress} {term} {field} ..\n```\n\n## 标签文件\n\n您知道，在运行 `ctags -R .` 后，一个新 `tags` 文件会被创建。但是，Vim 是如何知道在哪儿查找标签文件的呢？\n\n如果运行 `:set tags?`，您可能会看见 `tags=./tags,tags`（根据您的 Vim 设置，内容可能有所不同）。对于 `./tags`，Vim 会在当前文件所在路径查找所有标签；对于 `tags`，Vim 会在当前目录（您的项目根路径）中查找。\n\n此外，对于 `./tags`，Vim 会在当前文件所在路径内查找一个标签文件，无论它被嵌套得有多深。接下来，Vim 会在当前目录（项目根路径）查找。Vim 在找到第一个匹配项后会停止搜索。\n\n如果您的 `'tags'` 文件是 `tags=./tags,tags,/user/iggy/mytags/tags`，那么 Vim 在搜索完 `./tags` 和 `tags` 目录后，还会在 `/user/iggy/mytags` 目录内查找。所以您可以分开存放标签文件，不必将它们置于项目文件夹中。\n\n要添加标签文件位置，只需要运行：\n\n```\n:set tags+=path/to/my/tags/file\n```\n\n## 为大型项目生成标签：\n\n如果您尝试在大型项目中运行 ctag，则可能需要很长时间，因为 Vim 也会查看每个嵌套目录。如果您是 Javascript 开发者，您会知道 `node_modules` 非常大。假设您有五个子项目，每个都包含自己的 `node_modules` 目录。一旦运行 `ctags -R .`，ctags 将尝试扫描这5个 `node_modules`。但您可能不需要为 `node_modules` 运行 ctag。\n\n如果要排除 `node_modules` 后执行 ctags，可以运行：\n\n```\n ctags -R --exclude=node_modules .\n```\n\n这次应该只需要不到一秒钟的时间。另外，您还可以多次使用 `exclude` 选项：\n\n```\nctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log .\n```\n\n## 标签导航\n\n仅使用 `Ctrl-]` 也挺好，但我们还可以多学几个技巧。其实，标签跳转键 `Ctrl-]` 还有命令行模式：`:tag my-tag`。如果您运行：\n\n```\n:tag donut\n```\n\nVim 就会跳转至 `donut` 方法，就像在 \"donut\" 字符串上按 `Ctrl-]` 一样。您还可以使用 `<Tab>` 来自动补全参数：\n\n```\n:tag d<Tab>\n```\n\nVim 会列出所有以 \"d\" 开头的标签。对于上面的命令，结果则是 \"donut\"。\n\n在实际项目中，您可能会遇到多个同名的方法。我们来更新下这两个文件。先是 `one.rb`：\n\n```\n## one.rb\nclass One\n  def initialize\n    puts \"Initialized\"\n  end\n\n  def donut\n    puts \"one donut\"\n  end\n\n  def pancake\n    puts \"one pancake\"\n  end\nend\n```\n\n然后 `two.rb`：\n\n```\n## two.rb\nrequire './one.rb'\n\ndef pancake\n  \"Two pancakes\"\nend\n\none = One.new\none.donut\nputs pancake\n```\n\n由于新添加了一些过程，因此编写完代码后，不要忘记运行 `ctags -R .`。现在，您有了两个 `pancake` 过程。如果您在 `two.rb` 内按下 `Ctrl-]`，会发生什么呢？\n\nVim 会跳转到 `two.rb` 内的 `def pancake`，而不是 `one.rb` 的 `def pancake`。这是因为 Vim 认为 `two.rb` 内部的 `pancake` 过程比其他的`pancake` 过程具有更高优先级。\n\n## 标签优先级\n\n并非所有的标签都有着相同的地位。一些标签有着更高的优先级。如果有重复的标签项，Vim 会检查关键词的优先级。顺序是：\n\n1. 当前文件中完全匹配的静态标签。\n2. 当前文件中完全匹配的全局标签。\n3. 其他文件中完全匹配的全局标签。\n4. 其他文件中完全匹配的静态标签。\n5. 当前文件中不区分大小写匹配的静态标签。\n6. 当前文件中不区分大小写匹配的全局标签。\n7. 其他文件中区分大小写匹配的全局标签。\n8. 当前文件中不区分大小写匹配的静态标签。\n\n根据优先级列表，Vim 会对在同一个文件上找到的精确匹配项进行优先级排序。这就是为什么 Vim 会选择 `two.rb` 里的 `pancake` 过程而不是 `one.rb` 里的。但是，上述优先级列表有些例外，取决于您的`'tagcase'`、`'ignorecase'`、`'smartcase'` 设置。我不打算介绍它们，您可以自行查阅 `:h tag-priority`。\n\n## 选择性跳转标签\n\n如果可以选择要跳转到哪个标签，而不是始终转到优先级最高的，那就太好了。因为您可能想跳转到 `one.rb` 里的 `pancake` 方法，而不是 `two.rb` 里的。现在您可以使用 `:tselect` 做到它！运行：\n\n```\n:tselect pancake\n```\n\n您可以在屏幕底部看到：\n\n```\n## pri kind tag               file\n1 F C f    pancake           two.rb\n             def pancake\n2 F   f    pancake           one.rb\n             class:One\n             def pancake\n```\n\n如果输入`2` 后再 `<Return>`，Vim 将跳转到 `one.rb` 里的`pancake` 过程。如果输入`1` 后再 `<Return>`，Vim 将跳转到 `two.rb` 里的。\n\n注意`pri` 列，第一个匹配中该列是`F C`，第二个匹配中则是`F`。这就是 Vim 用来确定标签优先级的凭据。`F C`表示在当前 (`C`) 文件中完全匹配 (`F`) 的全局标签。`F` 表示仅完全匹配 (`F`) 的全局标签。`F C` 的优先级永远比 `F` 高。*（译注：`F`是`Fully-matched`，`C`是`Current file`）*\n\n如果运行`:tselect donut`，即使只有一个标签可选，Vim 也会提示您选择跳转到哪一个。有没有什么方法可以让 Vim 仅在有多个匹配项时才提示标签列表，而只找到一个标签时就立即跳转呢？\n\n当然！Vim 有一个 `:tjump` 方法。运行：\n\n```\n:tjump donut\n```\n\nVim 将立即跳转到 `one.rb` 里的`donut` 过程，就像在运行 `:tag donut` 一样。现在试试：\n\n```\n:tjump pancake\n```\n\nVim 将提示您从标签选项中选择一个，就像在运行`:tselect pancake`。`tjump` 能两全其美。\n\n`tjump` 在普通模式下有一个快捷键：`g Ctrl-]`。我个人喜欢`g Ctrl-]`胜过 `Ctrl-]`。\n\n## 标签的自动补全\n\n标签能有助于自动补全。回想下第6章“插入模式”，您可以使用 `Ctrl-x` 子模式来进行各式自动补全。其中有一个我没有提到过的自动补全子模式便是 `Ctrl-]`。如果您在插入模式中输入`Ctrl-x Ctrl-]`，Vim 将使用标签文件来自动补全。\n\n在插入模式下输入`Ctrl-x Ctrl-]`，您会看到：\n\n```\nOne\ndonut\ninitialize\npancake\n```\n\n## 标签堆栈\n\nVim 维持着一个标签堆栈，上面记录着所有您从哪儿来、跳哪儿去的标签列表。使用 `:tags` 可以看到这个堆栈。如果您首先跳转到`pancake`，紧接着是`donut`，此时运行`:tags`，您将看到：\n\n```\n  # TO tag         FROM line  in file/text\n  1  1 pancake            10  ch16_tags/two.rb\n  2  1 donut               9  ch16_tags/two.rb\n>\n```\n\n注意上面的 `>` 符号，它代表着您当前在堆栈中的位置。要“弹出”堆栈，从而回到上一次的状态，您可以运行`:pop`。试试它，再运行`:tags`看看：\n\n```\n  # TO tag         FROM line  in file/text\n  1  1 pancake            10  puts pancake\n> 2  1 donut               9  one.donut\n\n```\n\n注意现在 `>` 符号位于 `donut` 所在的第二行了。再 `pop` 一次，然后运行`:tags`：\n\n```\n  # TO tag         FROM line  in file/text\n> 1  1 pancake            10  puts pancake\n  2  1 donut               9  one.donut\n```\n\n在普通模式下，您可以按下 `Ctrl-t` 来达到和 `:pop` 一样的效果。\n\n## 自动生成标签\n\nVim 标签最大的缺点之一是，每当进行重大改变时，您需要重新生成标签文件。如果您将`pancake` 过程重命名为 `waffle`，标签文件不知道 `pancake` 被重命名了，标签列表仍旧存储着 `pancake` 过程。运行`ctags -R .` 可以创建更新的标签文件，但这可能会很缓慢。\n\n幸运的是，有几种可以自动生成标签的方法。这一小节不打算介绍一个简单明了的过程，而是提出一些想法，以便您可以扩展它们。\n\n## 在保存时生成标签\n\nVim 有一个自动命令 (`autocmd`) 方法，可以在触发事件时执行任意命令。您可以使用这个方法，以便在每次保存时生成标签。运行：\n\n```\n:autocmd BufWritePost *.rb silent !ctags -R .\n```\n\n上面命令的分解如下：\n\n- `autocmd` 是 Vim 的自动命令方法，它接受一个事件名称、文件和一个命令。\n- `BufWritePost` 是保存缓冲区时的一个事件。每次保存文件时将触发一次 `BufWritePost` 事件。\n- `.rb` 是 ruby (`rb`) 文件的一种文件模式。\n- `silent` 是您传递的命令的一部分。如果不输入它，每次触发自动命令时，Vim 都会提示  `press ENTER or type command to continue`。\n- `!ctags -R .` 是要执行的命令。回想一下，`!cmd` 从 Vim 内部执行终端命令。\n\n现在，每次您保存一个 ruby 文件时，Vim 都会运行`ctags -R .`。\n\n## 使用插件\n\n有几种插件可以自动生成 ctags：\n\n- [vim-gutentags](https://github.com/ludovicchabant/vim-gutentags)\n- [vim-tags](https://github.com/szw/vim-tags)\n- [vim-easytags](https://github.com/xolox/vim-easytags)\n- [vim-autotag](https://github.com/craigemery/vim-autotag)\n\n我使用 vim-gutentags。它的使用方法很简单，而且装上就可以直接使用。\n\n## Ctags 以及 Git 钩子\n\nTim Pope 是一个写了很多非常棒的 Vim 插件的作者，他写了一篇博客，建议使用 git 钩子。[可以看一看](https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html)。\n\n## 聪明地学习标签\n\n只要配置得当，标签是非常有用的。假设在一个新的代码库中，您想要搞清楚 `functionFood` 干了什么，您可以通过跳转到它的定义来搞懂它们。在那儿可以看到，它又调用了 `functionBreakfast`。继续跟踪，发现还调用了 `functionPancake`。现在您明白了，函数调用路径图长这样：\n\n```\nfunctionFood -> functionBreakfast -> functionPancake\n```\n\n进一步可以知道，这段代码和早餐吃煎饼有关。\n\n现在您已经知道如何使用标签，通过 `:h tags` 可以学习更多有关标签的知识。接下来让我们一起来探索另一个功能：折叠。\n","source":"_posts/Vim/ch16_tags.md","raw":"---\ntitle: VIM-标签\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第16章 标签\n\n快速转到任意定义处，是文本编辑中一个非常有用的特性。在本章中，您将学习如何使用 Vim 标签来做到这一点。\n\n## 标签概述\n\n假设有人给了您一个新的代码库：\n\n```\none = One.new\none.donut\n```\n\n`One`？`donut`？呃，对于当时编写代码的开发者而言，这些代码的含义可能显而易见。问题是当时的开发者已经不在了，现在要由您来理解这些费解的代码。而跟随有`One` 和 `donut`定义的源代码，是帮助您理解的一个有效方法。\n\n您可以使用`fzf` 或 `grep`来搜索它们，但这种情况下，但使用标签将更快。\n\n把标签想象成地址簿：\n\n```\nName    Address\nIggy1   1234 Cool St, 11111\nIggy2   9876 Awesome Ave, 2222\n```\n\n当然，标签可不是存储着“姓名-地址”对，而是“定义-地址”对。\n\n假设您在一个目录中有两个 Ruby 文件：\n\n```\n## one.rb\nclass One\n  def initialize\n    puts \"Initialized\"\n  end\n\n  def donut\n    puts \"Bar\"\n  end\nend\n```\n\n以及\n\n```\n## two.rb\nrequire './one'\n\none = One.new\none.donut\n```\n\n在普通模式下，您可以使用`Ctrl-]`跳转到定义。在`two.rb`中，转到`one.donut`所在行，将光标移到`donut`处，按下`Ctrl-]`。\n\n哦豁，Vim 找不到标签文件，您需要先生成它。\n\n## 标签生成器\n\n现代 Vim 不自带标签生成器，您需要额外下载它。有几个选项可供选择：\n\n- ctags = 仅用于 C，基本随处可见。\n- exuberant ctags = 最流行的标签生成器之一，支持许多语言。\n- universal ctags = 和 exuberant ctags 类似，但比它更新。\n- etags = 用于 Emacs，嗯……\n- JTags = Java\n- ptags.py = Python\n- ptags = Perl\n- gnatxref = Ada\n\n如果您查看 Vim 在线教程，您会发现许多都会推荐 [exuberant ctags](http://ctags.sourceforge.net/)，它支持 [41 种编程语言](http://ctags.sourceforge.net/languages.html)，我用过它，挺不错的。但自2009年以来一直没有维护，因此 Universal ctags 更好些，它和 exuberant ctags 相似，并仍在维护。\n\n我不打算详细介绍如何安装 Universal ctags，您可以在 [universal ctags](https://github.com/universal-ctags/ctags) 仓库了解更多说明。\n\n假设您已经安装好了ctags，接下来，生成一个基本的标签文件。运行：\n\n```\nctags -R .\n```\n\n `R` 选项告诉 `ctags` 从当前位置 (`.`) 递归扫描文件。稍后，您应该在当前文件夹看到一个`tags` 文件，里面您将看到类似这样的内容：\n\n```\n!_TAG_FILE_FORMAT\t2\t/extended format; --format=1 will not append ;\" to lines/\n!_TAG_FILE_SORTED\t1\t/0=unsorted, 1=sorted, 2=foldcase/\n!_TAG_OUTPUT_FILESEP\tslash\t/slash or backslash/\n!_TAG_OUTPUT_MODE\tu-ctags\t/u-ctags or e-ctags/\n!_TAG_PATTERN_LENGTH_LIMIT\t96\t/0 for no limit/\n!_TAG_PROGRAM_AUTHOR\tUniversal Ctags Team\t//\n!_TAG_PROGRAM_NAME\tUniversal Ctags\t/Derived from Exuberant Ctags/\n!_TAG_PROGRAM_URL\t<https://ctags.io/>\t/official site/\n!_TAG_PROGRAM_VERSION\t0.0.0\t/b43eb39/\nOne\tone.rb\t/^class One$/;\"\tc\ndonut\tone.rb\t/^  def donut$/;\"\tf\tclass:One\ninitialize\tone.rb\t/^  def initialize$/;\"\tf\tclass:One\n```\n\n根据 Vim 设置和 ctag 生成器的不同，您的`tags` 文件可能会有些不同。一个标签文件由两部分组成：标签元数据和标签列表。那些标签元数据 (`!TAG_FILE...`) 通常由 ctags 生成器控制。这里我不打算介绍它们，您可以随意查阅文档。标签列表是一个由所有定义组成的列表，由ctags建立索引。\n\n现在回到 `two.rb`，将光标移至 `donut`，再输入`Ctrl-]`，Vim 将带您转到 `one.rb` 文件里`def donut` 所在的行上。成功啦！但 Vim 怎么做到的呢？\n\n## 解剖标签文件\n\n来看看`donut` 标签项：\n\n```\ndonut\tone.rb\t/^  def donut$/;\"\tf\tclass:One\n```\n\n上面的标签项由四个部分组成：一个`tagname`、一个`tagfile`、一个`tagaddress`，以及标签选项。\n\n- `donut` 是 `tagname`。当光标在 \"donut\" 时，Vim 搜索标签文件里含有 \"donut\" 字符串的一行。\n- `one.rb` 是 `tagfile`。Vim 会搜寻 `one.rb` 文件。\n- `/^ def donut$/` 是 `tagaddress`。`/.../` 是模式指示器。`^` 代表一行中第一个元素，后面跟着两个空格，然后是`def donut`字符串，最后 `$` 代表一行中最后一个元素。\n- `f class:One` 是标签选项，它告诉 Vim，`donut` 是一种函数 (`f`)，并且是 `One` 类的一部分。\n\n再看看另一个标签项：\n\n```\nOne\tone.rb\t/^class One$/;\"\tc\n```\n\n这一行和 `donut`也是一样的：\n\n- `One` 是 `tagname`。注意，对于标签，第一次扫描区分大小写。如果列表中有 `One` 和 `one`， Vim 会优先考虑 `One` 而不是 `one`。\n- `one.rb` 是 `tagfile`。Vim 会搜寻 `one.rb` 文件。\n- `/^class One$/` 是 `tagaddress` 。Vim 会查找以 `class` 开头 (`^`) 、以 `One` 结尾 (`$`) 的行。\n- `c` 是可用标签选项之一。由于 `One` 是一个 ruby 类而不是过程，因此被标签为 `c`。\n\n标签文件的内容可能不尽相同，根据您使用的标签生成器而定。但至少，标签文件必须具有以下格式之一：\n\n```\n1.  {tagname} {TAB} {tagfile} {TAB} {tagaddress}\n2.  {tagname} {TAB} {tagfile} {TAB} {tagaddress} {term} {field} ..\n```\n\n## 标签文件\n\n您知道，在运行 `ctags -R .` 后，一个新 `tags` 文件会被创建。但是，Vim 是如何知道在哪儿查找标签文件的呢？\n\n如果运行 `:set tags?`，您可能会看见 `tags=./tags,tags`（根据您的 Vim 设置，内容可能有所不同）。对于 `./tags`，Vim 会在当前文件所在路径查找所有标签；对于 `tags`，Vim 会在当前目录（您的项目根路径）中查找。\n\n此外，对于 `./tags`，Vim 会在当前文件所在路径内查找一个标签文件，无论它被嵌套得有多深。接下来，Vim 会在当前目录（项目根路径）查找。Vim 在找到第一个匹配项后会停止搜索。\n\n如果您的 `'tags'` 文件是 `tags=./tags,tags,/user/iggy/mytags/tags`，那么 Vim 在搜索完 `./tags` 和 `tags` 目录后，还会在 `/user/iggy/mytags` 目录内查找。所以您可以分开存放标签文件，不必将它们置于项目文件夹中。\n\n要添加标签文件位置，只需要运行：\n\n```\n:set tags+=path/to/my/tags/file\n```\n\n## 为大型项目生成标签：\n\n如果您尝试在大型项目中运行 ctag，则可能需要很长时间，因为 Vim 也会查看每个嵌套目录。如果您是 Javascript 开发者，您会知道 `node_modules` 非常大。假设您有五个子项目，每个都包含自己的 `node_modules` 目录。一旦运行 `ctags -R .`，ctags 将尝试扫描这5个 `node_modules`。但您可能不需要为 `node_modules` 运行 ctag。\n\n如果要排除 `node_modules` 后执行 ctags，可以运行：\n\n```\n ctags -R --exclude=node_modules .\n```\n\n这次应该只需要不到一秒钟的时间。另外，您还可以多次使用 `exclude` 选项：\n\n```\nctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log .\n```\n\n## 标签导航\n\n仅使用 `Ctrl-]` 也挺好，但我们还可以多学几个技巧。其实，标签跳转键 `Ctrl-]` 还有命令行模式：`:tag my-tag`。如果您运行：\n\n```\n:tag donut\n```\n\nVim 就会跳转至 `donut` 方法，就像在 \"donut\" 字符串上按 `Ctrl-]` 一样。您还可以使用 `<Tab>` 来自动补全参数：\n\n```\n:tag d<Tab>\n```\n\nVim 会列出所有以 \"d\" 开头的标签。对于上面的命令，结果则是 \"donut\"。\n\n在实际项目中，您可能会遇到多个同名的方法。我们来更新下这两个文件。先是 `one.rb`：\n\n```\n## one.rb\nclass One\n  def initialize\n    puts \"Initialized\"\n  end\n\n  def donut\n    puts \"one donut\"\n  end\n\n  def pancake\n    puts \"one pancake\"\n  end\nend\n```\n\n然后 `two.rb`：\n\n```\n## two.rb\nrequire './one.rb'\n\ndef pancake\n  \"Two pancakes\"\nend\n\none = One.new\none.donut\nputs pancake\n```\n\n由于新添加了一些过程，因此编写完代码后，不要忘记运行 `ctags -R .`。现在，您有了两个 `pancake` 过程。如果您在 `two.rb` 内按下 `Ctrl-]`，会发生什么呢？\n\nVim 会跳转到 `two.rb` 内的 `def pancake`，而不是 `one.rb` 的 `def pancake`。这是因为 Vim 认为 `two.rb` 内部的 `pancake` 过程比其他的`pancake` 过程具有更高优先级。\n\n## 标签优先级\n\n并非所有的标签都有着相同的地位。一些标签有着更高的优先级。如果有重复的标签项，Vim 会检查关键词的优先级。顺序是：\n\n1. 当前文件中完全匹配的静态标签。\n2. 当前文件中完全匹配的全局标签。\n3. 其他文件中完全匹配的全局标签。\n4. 其他文件中完全匹配的静态标签。\n5. 当前文件中不区分大小写匹配的静态标签。\n6. 当前文件中不区分大小写匹配的全局标签。\n7. 其他文件中区分大小写匹配的全局标签。\n8. 当前文件中不区分大小写匹配的静态标签。\n\n根据优先级列表，Vim 会对在同一个文件上找到的精确匹配项进行优先级排序。这就是为什么 Vim 会选择 `two.rb` 里的 `pancake` 过程而不是 `one.rb` 里的。但是，上述优先级列表有些例外，取决于您的`'tagcase'`、`'ignorecase'`、`'smartcase'` 设置。我不打算介绍它们，您可以自行查阅 `:h tag-priority`。\n\n## 选择性跳转标签\n\n如果可以选择要跳转到哪个标签，而不是始终转到优先级最高的，那就太好了。因为您可能想跳转到 `one.rb` 里的 `pancake` 方法，而不是 `two.rb` 里的。现在您可以使用 `:tselect` 做到它！运行：\n\n```\n:tselect pancake\n```\n\n您可以在屏幕底部看到：\n\n```\n## pri kind tag               file\n1 F C f    pancake           two.rb\n             def pancake\n2 F   f    pancake           one.rb\n             class:One\n             def pancake\n```\n\n如果输入`2` 后再 `<Return>`，Vim 将跳转到 `one.rb` 里的`pancake` 过程。如果输入`1` 后再 `<Return>`，Vim 将跳转到 `two.rb` 里的。\n\n注意`pri` 列，第一个匹配中该列是`F C`，第二个匹配中则是`F`。这就是 Vim 用来确定标签优先级的凭据。`F C`表示在当前 (`C`) 文件中完全匹配 (`F`) 的全局标签。`F` 表示仅完全匹配 (`F`) 的全局标签。`F C` 的优先级永远比 `F` 高。*（译注：`F`是`Fully-matched`，`C`是`Current file`）*\n\n如果运行`:tselect donut`，即使只有一个标签可选，Vim 也会提示您选择跳转到哪一个。有没有什么方法可以让 Vim 仅在有多个匹配项时才提示标签列表，而只找到一个标签时就立即跳转呢？\n\n当然！Vim 有一个 `:tjump` 方法。运行：\n\n```\n:tjump donut\n```\n\nVim 将立即跳转到 `one.rb` 里的`donut` 过程，就像在运行 `:tag donut` 一样。现在试试：\n\n```\n:tjump pancake\n```\n\nVim 将提示您从标签选项中选择一个，就像在运行`:tselect pancake`。`tjump` 能两全其美。\n\n`tjump` 在普通模式下有一个快捷键：`g Ctrl-]`。我个人喜欢`g Ctrl-]`胜过 `Ctrl-]`。\n\n## 标签的自动补全\n\n标签能有助于自动补全。回想下第6章“插入模式”，您可以使用 `Ctrl-x` 子模式来进行各式自动补全。其中有一个我没有提到过的自动补全子模式便是 `Ctrl-]`。如果您在插入模式中输入`Ctrl-x Ctrl-]`，Vim 将使用标签文件来自动补全。\n\n在插入模式下输入`Ctrl-x Ctrl-]`，您会看到：\n\n```\nOne\ndonut\ninitialize\npancake\n```\n\n## 标签堆栈\n\nVim 维持着一个标签堆栈，上面记录着所有您从哪儿来、跳哪儿去的标签列表。使用 `:tags` 可以看到这个堆栈。如果您首先跳转到`pancake`，紧接着是`donut`，此时运行`:tags`，您将看到：\n\n```\n  # TO tag         FROM line  in file/text\n  1  1 pancake            10  ch16_tags/two.rb\n  2  1 donut               9  ch16_tags/two.rb\n>\n```\n\n注意上面的 `>` 符号，它代表着您当前在堆栈中的位置。要“弹出”堆栈，从而回到上一次的状态，您可以运行`:pop`。试试它，再运行`:tags`看看：\n\n```\n  # TO tag         FROM line  in file/text\n  1  1 pancake            10  puts pancake\n> 2  1 donut               9  one.donut\n\n```\n\n注意现在 `>` 符号位于 `donut` 所在的第二行了。再 `pop` 一次，然后运行`:tags`：\n\n```\n  # TO tag         FROM line  in file/text\n> 1  1 pancake            10  puts pancake\n  2  1 donut               9  one.donut\n```\n\n在普通模式下，您可以按下 `Ctrl-t` 来达到和 `:pop` 一样的效果。\n\n## 自动生成标签\n\nVim 标签最大的缺点之一是，每当进行重大改变时，您需要重新生成标签文件。如果您将`pancake` 过程重命名为 `waffle`，标签文件不知道 `pancake` 被重命名了，标签列表仍旧存储着 `pancake` 过程。运行`ctags -R .` 可以创建更新的标签文件，但这可能会很缓慢。\n\n幸运的是，有几种可以自动生成标签的方法。这一小节不打算介绍一个简单明了的过程，而是提出一些想法，以便您可以扩展它们。\n\n## 在保存时生成标签\n\nVim 有一个自动命令 (`autocmd`) 方法，可以在触发事件时执行任意命令。您可以使用这个方法，以便在每次保存时生成标签。运行：\n\n```\n:autocmd BufWritePost *.rb silent !ctags -R .\n```\n\n上面命令的分解如下：\n\n- `autocmd` 是 Vim 的自动命令方法，它接受一个事件名称、文件和一个命令。\n- `BufWritePost` 是保存缓冲区时的一个事件。每次保存文件时将触发一次 `BufWritePost` 事件。\n- `.rb` 是 ruby (`rb`) 文件的一种文件模式。\n- `silent` 是您传递的命令的一部分。如果不输入它，每次触发自动命令时，Vim 都会提示  `press ENTER or type command to continue`。\n- `!ctags -R .` 是要执行的命令。回想一下，`!cmd` 从 Vim 内部执行终端命令。\n\n现在，每次您保存一个 ruby 文件时，Vim 都会运行`ctags -R .`。\n\n## 使用插件\n\n有几种插件可以自动生成 ctags：\n\n- [vim-gutentags](https://github.com/ludovicchabant/vim-gutentags)\n- [vim-tags](https://github.com/szw/vim-tags)\n- [vim-easytags](https://github.com/xolox/vim-easytags)\n- [vim-autotag](https://github.com/craigemery/vim-autotag)\n\n我使用 vim-gutentags。它的使用方法很简单，而且装上就可以直接使用。\n\n## Ctags 以及 Git 钩子\n\nTim Pope 是一个写了很多非常棒的 Vim 插件的作者，他写了一篇博客，建议使用 git 钩子。[可以看一看](https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html)。\n\n## 聪明地学习标签\n\n只要配置得当，标签是非常有用的。假设在一个新的代码库中，您想要搞清楚 `functionFood` 干了什么，您可以通过跳转到它的定义来搞懂它们。在那儿可以看到，它又调用了 `functionBreakfast`。继续跟踪，发现还调用了 `functionPancake`。现在您明白了，函数调用路径图长这样：\n\n```\nfunctionFood -> functionBreakfast -> functionPancake\n```\n\n进一步可以知道，这段代码和早餐吃煎饼有关。\n\n现在您已经知道如何使用标签，通过 `:h tags` 可以学习更多有关标签的知识。接下来让我们一起来探索另一个功能：折叠。\n","slug":"Vim/ch16_tags","published":1,"updated":"2022-08-28T07:38:59.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i220028scvmd9508wrz","content":"<h1 id=\"第16章-标签\"><a href=\"#第16章-标签\" class=\"headerlink\" title=\"第16章 标签\"></a>第16章 标签</h1><p>快速转到任意定义处，是文本编辑中一个非常有用的特性。在本章中，您将学习如何使用 Vim 标签来做到这一点。</p>\n<h2 id=\"标签概述\"><a href=\"#标签概述\" class=\"headerlink\" title=\"标签概述\"></a>标签概述</h2><p>假设有人给了您一个新的代码库：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span> = One.<span class=\"hljs-built_in\">new</span><br><span class=\"hljs-literal\">one</span>.donut<br></code></pre></td></tr></table></figure>\n\n<p><code>One</code>？<code>donut</code>？呃，对于当时编写代码的开发者而言，这些代码的含义可能显而易见。问题是当时的开发者已经不在了，现在要由您来理解这些费解的代码。而跟随有<code>One</code> 和 <code>donut</code>定义的源代码，是帮助您理解的一个有效方法。</p>\n<p>您可以使用<code>fzf</code> 或 <code>grep</code>来搜索它们，但这种情况下，但使用标签将更快。</p>\n<p>把标签想象成地址簿：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Name</span>    Address<br><span class=\"hljs-attribute\">Iggy1</span>   <span class=\"hljs-number\">1234</span> Cool St, <span class=\"hljs-number\">11111</span><br><span class=\"hljs-attribute\">Iggy2</span>   <span class=\"hljs-number\">9876</span> Awesome Ave, <span class=\"hljs-number\">2222</span><br></code></pre></td></tr></table></figure>\n\n<p>当然，标签可不是存储着“姓名-地址”对，而是“定义-地址”对。</p>\n<p>假设您在一个目录中有两个 Ruby 文件：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">## one.rb<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">One</span><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">initialize</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">Initialized</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">donut</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">Bar</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><span class=\"hljs-symbol\">end</span><br></code></pre></td></tr></table></figure>\n\n<p>以及</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-comment\">## two.rb</span><br><span class=\"hljs-built_in\">require</span> <span class=\"hljs-string\">&#x27;./one&#x27;</span><br><br><span class=\"hljs-literal\">one</span> = One.<span class=\"hljs-built_in\">new</span><br><span class=\"hljs-literal\">one</span>.donut<br></code></pre></td></tr></table></figure>\n\n<p>在普通模式下，您可以使用<code>Ctrl-]</code>跳转到定义。在<code>two.rb</code>中，转到<code>one.donut</code>所在行，将光标移到<code>donut</code>处，按下<code>Ctrl-]</code>。</p>\n<p>哦豁，Vim 找不到标签文件，您需要先生成它。</p>\n<h2 id=\"标签生成器\"><a href=\"#标签生成器\" class=\"headerlink\" title=\"标签生成器\"></a>标签生成器</h2><p>现代 Vim 不自带标签生成器，您需要额外下载它。有几个选项可供选择：</p>\n<ul>\n<li>ctags &#x3D; 仅用于 C，基本随处可见。</li>\n<li>exuberant ctags &#x3D; 最流行的标签生成器之一，支持许多语言。</li>\n<li>universal ctags &#x3D; 和 exuberant ctags 类似，但比它更新。</li>\n<li>etags &#x3D; 用于 Emacs，嗯……</li>\n<li>JTags &#x3D; Java</li>\n<li>ptags.py &#x3D; Python</li>\n<li>ptags &#x3D; Perl</li>\n<li>gnatxref &#x3D; Ada</li>\n</ul>\n<p>如果您查看 Vim 在线教程，您会发现许多都会推荐 <a href=\"http://ctags.sourceforge.net/\">exuberant ctags</a>，它支持 <a href=\"http://ctags.sourceforge.net/languages.html\">41 种编程语言</a>，我用过它，挺不错的。但自2009年以来一直没有维护，因此 Universal ctags 更好些，它和 exuberant ctags 相似，并仍在维护。</p>\n<p>我不打算详细介绍如何安装 Universal ctags，您可以在 <a href=\"https://github.com/universal-ctags/ctags\">universal ctags</a> 仓库了解更多说明。</p>\n<p>假设您已经安装好了ctags，接下来，生成一个基本的标签文件。运行：</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang\">ctags -R .<br></code></pre></td></tr></table></figure>\n\n<p> <code>R</code> 选项告诉 <code>ctags</code> 从当前位置 (<code>.</code>) 递归扫描文件。稍后，您应该在当前文件夹看到一个<code>tags</code> 文件，里面您将看到类似这样的内容：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><span class=\"hljs-title\">!_TAG_FILE_FORMAT</span>\t<span class=\"hljs-number\">2</span>\t/extended format<span class=\"hljs-comment\">; --format=1 will not append ;&quot; to lines/</span><br><span class=\"hljs-title\">!_TAG_FILE_SORTED</span>\t<span class=\"hljs-number\">1</span>\t/<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">=</span>unsorted<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">=</span>sorted<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">2</span><span class=\"hljs-operator\">=</span>foldcase/<br><span class=\"hljs-title\">!_TAG_OUTPUT_FILESEP</span>\tslash\t/slash <span class=\"hljs-keyword\">or</span> backslash/<br><span class=\"hljs-title\">!_TAG_OUTPUT_MODE</span>\tu-ctags\t/u-ctags <span class=\"hljs-keyword\">or</span> e-ctags/<br><span class=\"hljs-title\">!_TAG_PATTERN_LENGTH_LIMIT</span>\t<span class=\"hljs-number\">96</span>\t/<span class=\"hljs-number\">0</span> for no limit/<br><span class=\"hljs-title\">!_TAG_PROGRAM_AUTHOR</span>\tUniversal Ctags Team\t//<br><span class=\"hljs-title\">!_TAG_PROGRAM_NAME</span>\tUniversal Ctags\t/Derived from Exuberant Ctags/<br><span class=\"hljs-title\">!_TAG_PROGRAM_URL</span>\t&lt;https://ctags.io/&gt;\t/official site/<br><span class=\"hljs-title\">!_TAG_PROGRAM_VERSION</span>\t<span class=\"hljs-number\">0.0</span>.<span class=\"hljs-number\">0</span>\t/b<span class=\"hljs-number\">43</span>eb<span class=\"hljs-number\">39</span>/<br>One\t<span class=\"hljs-keyword\">one</span>.rb\t/^class One$/<span class=\"hljs-comment\">;&quot;\tc</span><br>donut\t<span class=\"hljs-keyword\">one</span>.rb\t/^  def donut$/<span class=\"hljs-comment\">;&quot;\tf\tclass:One</span><br>initialize\t<span class=\"hljs-keyword\">one</span>.rb\t/^  def initialize$/<span class=\"hljs-comment\">;&quot;\tf\tclass:One</span><br></code></pre></td></tr></table></figure>\n\n<p>根据 Vim 设置和 ctag 生成器的不同，您的<code>tags</code> 文件可能会有些不同。一个标签文件由两部分组成：标签元数据和标签列表。那些标签元数据 (<code>!TAG_FILE...</code>) 通常由 ctags 生成器控制。这里我不打算介绍它们，您可以随意查阅文档。标签列表是一个由所有定义组成的列表，由ctags建立索引。</p>\n<p>现在回到 <code>two.rb</code>，将光标移至 <code>donut</code>，再输入<code>Ctrl-]</code>，Vim 将带您转到 <code>one.rb</code> 文件里<code>def donut</code> 所在的行上。成功啦！但 Vim 怎么做到的呢？</p>\n<h2 id=\"解剖标签文件\"><a href=\"#解剖标签文件\" class=\"headerlink\" title=\"解剖标签文件\"></a>解剖标签文件</h2><p>来看看<code>donut</code> 标签项：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">donut\t<span class=\"hljs-keyword\">one</span>.rb\t/^  def donut$/;&quot;\tf\t<span class=\"hljs-keyword\">class</span>:<span class=\"hljs-keyword\">One</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的标签项由四个部分组成：一个<code>tagname</code>、一个<code>tagfile</code>、一个<code>tagaddress</code>，以及标签选项。</p>\n<ul>\n<li><code>donut</code> 是 <code>tagname</code>。当光标在 “donut” 时，Vim 搜索标签文件里含有 “donut” 字符串的一行。</li>\n<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>\n<li><code>/^ def donut$/</code> 是 <code>tagaddress</code>。<code>/.../</code> 是模式指示器。<code>^</code> 代表一行中第一个元素，后面跟着两个空格，然后是<code>def donut</code>字符串，最后 <code>$</code> 代表一行中最后一个元素。</li>\n<li><code>f class:One</code> 是标签选项，它告诉 Vim，<code>donut</code> 是一种函数 (<code>f</code>)，并且是 <code>One</code> 类的一部分。</li>\n</ul>\n<p>再看看另一个标签项：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span>\t<span class=\"hljs-keyword\">one</span>.rb\t/^<span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">One</span>$/;&quot;\tc<br></code></pre></td></tr></table></figure>\n\n<p>这一行和 <code>donut</code>也是一样的：</p>\n<ul>\n<li><code>One</code> 是 <code>tagname</code>。注意，对于标签，第一次扫描区分大小写。如果列表中有 <code>One</code> 和 <code>one</code>， Vim 会优先考虑 <code>One</code> 而不是 <code>one</code>。</li>\n<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>\n<li><code>/^class One$/</code> 是 <code>tagaddress</code> 。Vim 会查找以 <code>class</code> 开头 (<code>^</code>) 、以 <code>One</code> 结尾 (<code>$</code>) 的行。</li>\n<li><code>c</code> 是可用标签选项之一。由于 <code>One</code> 是一个 ruby 类而不是过程，因此被标签为 <code>c</code>。</li>\n</ul>\n<p>标签文件的内容可能不尽相同，根据您使用的标签生成器而定。但至少，标签文件必须具有以下格式之一：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">1.  </span><span class=\"hljs-template-variable\">&#123;tagname&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagfile&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagaddress&#125;</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">2.  </span><span class=\"hljs-template-variable\">&#123;tagname&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagfile&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagaddress&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;term&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;field&#125;</span><span class=\"language-xml\"> ..</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"标签文件\"><a href=\"#标签文件\" class=\"headerlink\" title=\"标签文件\"></a>标签文件</h2><p>您知道，在运行 <code>ctags -R .</code> 后，一个新 <code>tags</code> 文件会被创建。但是，Vim 是如何知道在哪儿查找标签文件的呢？</p>\n<p>如果运行 <code>:set tags?</code>，您可能会看见 <code>tags=./tags,tags</code>（根据您的 Vim 设置，内容可能有所不同）。对于 <code>./tags</code>，Vim 会在当前文件所在路径查找所有标签；对于 <code>tags</code>，Vim 会在当前目录（您的项目根路径）中查找。</p>\n<p>此外，对于 <code>./tags</code>，Vim 会在当前文件所在路径内查找一个标签文件，无论它被嵌套得有多深。接下来，Vim 会在当前目录（项目根路径）查找。Vim 在找到第一个匹配项后会停止搜索。</p>\n<p>如果您的 <code>&#39;tags&#39;</code> 文件是 <code>tags=./tags,tags,/user/iggy/mytags/tags</code>，那么 Vim 在搜索完 <code>./tags</code> 和 <code>tags</code> 目录后，还会在 <code>/user/iggy/mytags</code> 目录内查找。所以您可以分开存放标签文件，不必将它们置于项目文件夹中。</p>\n<p>要添加标签文件位置，只需要运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">tags</span>+=path/<span class=\"hljs-keyword\">to</span>/my/<span class=\"hljs-keyword\">tags</span>/<span class=\"hljs-keyword\">file</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"为大型项目生成标签：\"><a href=\"#为大型项目生成标签：\" class=\"headerlink\" title=\"为大型项目生成标签：\"></a>为大型项目生成标签：</h2><p>如果您尝试在大型项目中运行 ctag，则可能需要很长时间，因为 Vim 也会查看每个嵌套目录。如果您是 Javascript 开发者，您会知道 <code>node_modules</code> 非常大。假设您有五个子项目，每个都包含自己的 <code>node_modules</code> 目录。一旦运行 <code>ctags -R .</code>，ctags 将尝试扫描这5个 <code>node_modules</code>。但您可能不需要为 <code>node_modules</code> 运行 ctag。</p>\n<p>如果要排除 <code>node_modules</code> 后执行 ctags，可以运行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">ctags -R --exclude</span>=node_modules .<br></code></pre></td></tr></table></figure>\n\n<p>这次应该只需要不到一秒钟的时间。另外，您还可以多次使用 <code>exclude</code> 选项：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">ctags -R <span class=\"hljs-attribute\">--exclude</span>=.git <span class=\"hljs-attribute\">--exclude</span>=vendor <span class=\"hljs-attribute\">--exclude</span>=node_modules <span class=\"hljs-attribute\">--exclude</span>=db <span class=\"hljs-attribute\">--exclude</span>=log .<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"标签导航\"><a href=\"#标签导航\" class=\"headerlink\" title=\"标签导航\"></a>标签导航</h2><p>仅使用 <code>Ctrl-]</code> 也挺好，但我们还可以多学几个技巧。其实，标签跳转键 <code>Ctrl-]</code> 还有命令行模式：<code>:tag my-tag</code>。如果您运行：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:<span class=\"hljs-keyword\">tag</span> <span class=\"hljs-title\">donut</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 就会跳转至 <code>donut</code> 方法，就像在 “donut” 字符串上按 <code>Ctrl-]</code> 一样。您还可以使用 <code>&lt;Tab&gt;</code> 来自动补全参数：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:<span class=\"hljs-keyword\">tag</span> <span class=\"hljs-title\">d</span><span class=\"hljs-tag\">&lt;Tab&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 会列出所有以 “d” 开头的标签。对于上面的命令，结果则是 “donut”。</p>\n<p>在实际项目中，您可能会遇到多个同名的方法。我们来更新下这两个文件。先是 <code>one.rb</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">## one.rb<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">One</span><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">initialize</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">Initialized</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">donut</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">one</span> <span class=\"hljs-symbol\">donut</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">pancake</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">one</span> <span class=\"hljs-symbol\">pancake</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><span class=\"hljs-symbol\">end</span><br></code></pre></td></tr></table></figure>\n\n<p>然后 <code>two.rb</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-comment\">## two.rb</span><br><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;./one.rb&#x27;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pancake</span></span><br>  <span class=\"hljs-string\">&quot;Two pancakes&quot;</span><br><span class=\"hljs-keyword\">end</span><br><br>one = <span class=\"hljs-title class_\">One</span>.new<br>one.donut<br>puts pancake<br></code></pre></td></tr></table></figure>\n\n<p>由于新添加了一些过程，因此编写完代码后，不要忘记运行 <code>ctags -R .</code>。现在，您有了两个 <code>pancake</code> 过程。如果您在 <code>two.rb</code> 内按下 <code>Ctrl-]</code>，会发生什么呢？</p>\n<p>Vim 会跳转到 <code>two.rb</code> 内的 <code>def pancake</code>，而不是 <code>one.rb</code> 的 <code>def pancake</code>。这是因为 Vim 认为 <code>two.rb</code> 内部的 <code>pancake</code> 过程比其他的<code>pancake</code> 过程具有更高优先级。</p>\n<h2 id=\"标签优先级\"><a href=\"#标签优先级\" class=\"headerlink\" title=\"标签优先级\"></a>标签优先级</h2><p>并非所有的标签都有着相同的地位。一些标签有着更高的优先级。如果有重复的标签项，Vim 会检查关键词的优先级。顺序是：</p>\n<ol>\n<li>当前文件中完全匹配的静态标签。</li>\n<li>当前文件中完全匹配的全局标签。</li>\n<li>其他文件中完全匹配的全局标签。</li>\n<li>其他文件中完全匹配的静态标签。</li>\n<li>当前文件中不区分大小写匹配的静态标签。</li>\n<li>当前文件中不区分大小写匹配的全局标签。</li>\n<li>其他文件中区分大小写匹配的全局标签。</li>\n<li>当前文件中不区分大小写匹配的静态标签。</li>\n</ol>\n<p>根据优先级列表，Vim 会对在同一个文件上找到的精确匹配项进行优先级排序。这就是为什么 Vim 会选择 <code>two.rb</code> 里的 <code>pancake</code> 过程而不是 <code>one.rb</code> 里的。但是，上述优先级列表有些例外，取决于您的<code>&#39;tagcase&#39;</code>、<code>&#39;ignorecase&#39;</code>、<code>&#39;smartcase&#39;</code> 设置。我不打算介绍它们，您可以自行查阅 <code>:h tag-priority</code>。</p>\n<h2 id=\"选择性跳转标签\"><a href=\"#选择性跳转标签\" class=\"headerlink\" title=\"选择性跳转标签\"></a>选择性跳转标签</h2><p>如果可以选择要跳转到哪个标签，而不是始终转到优先级最高的，那就太好了。因为您可能想跳转到 <code>one.rb</code> 里的 <code>pancake</code> 方法，而不是 <code>two.rb</code> 里的。现在您可以使用 <code>:tselect</code> 做到它！运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tselect</span> pancake<br></code></pre></td></tr></table></figure>\n\n<p>您可以在屏幕底部看到：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\">## pri kind tag               file</span><br><span class=\"hljs-number\">1</span> F C f    pancake           two.rb<br>             <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pancake</span></span><br><span class=\"hljs-number\">2</span> F   f    pancake           one.rb<br>             <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>:<span class=\"hljs-title\">One</span></span><br>             <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pancake</span></span><br></code></pre></td></tr></table></figure>\n\n<p>如果输入<code>2</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>one.rb</code> 里的<code>pancake</code> 过程。如果输入<code>1</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>two.rb</code> 里的。</p>\n<p>注意<code>pri</code> 列，第一个匹配中该列是<code>F C</code>，第二个匹配中则是<code>F</code>。这就是 Vim 用来确定标签优先级的凭据。<code>F C</code>表示在当前 (<code>C</code>) 文件中完全匹配 (<code>F</code>) 的全局标签。<code>F</code> 表示仅完全匹配 (<code>F</code>) 的全局标签。<code>F C</code> 的优先级永远比 <code>F</code> 高。<em>（译注：<code>F</code>是<code>Fully-matched</code>，<code>C</code>是<code>Current file</code>）</em></p>\n<p>如果运行<code>:tselect donut</code>，即使只有一个标签可选，Vim 也会提示您选择跳转到哪一个。有没有什么方法可以让 Vim 仅在有多个匹配项时才提示标签列表，而只找到一个标签时就立即跳转呢？</p>\n<p>当然！Vim 有一个 <code>:tjump</code> 方法。运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tjump</span> donut<br></code></pre></td></tr></table></figure>\n\n<p>Vim 将立即跳转到 <code>one.rb</code> 里的<code>donut</code> 过程，就像在运行 <code>:tag donut</code> 一样。现在试试：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tjump</span> pancake<br></code></pre></td></tr></table></figure>\n\n<p>Vim 将提示您从标签选项中选择一个，就像在运行<code>:tselect pancake</code>。<code>tjump</code> 能两全其美。</p>\n<p><code>tjump</code> 在普通模式下有一个快捷键：<code>g Ctrl-]</code>。我个人喜欢<code>g Ctrl-]</code>胜过 <code>Ctrl-]</code>。</p>\n<h2 id=\"标签的自动补全\"><a href=\"#标签的自动补全\" class=\"headerlink\" title=\"标签的自动补全\"></a>标签的自动补全</h2><p>标签能有助于自动补全。回想下第6章“插入模式”，您可以使用 <code>Ctrl-x</code> 子模式来进行各式自动补全。其中有一个我没有提到过的自动补全子模式便是 <code>Ctrl-]</code>。如果您在插入模式中输入<code>Ctrl-x Ctrl-]</code>，Vim 将使用标签文件来自动补全。</p>\n<p>在插入模式下输入<code>Ctrl-x Ctrl-]</code>，您会看到：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">One</span><br><span class=\"hljs-attribute\">donut</span><br><span class=\"hljs-attribute\">initialize</span><br><span class=\"hljs-attribute\">pancake</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"标签堆栈\"><a href=\"#标签堆栈\" class=\"headerlink\" title=\"标签堆栈\"></a>标签堆栈</h2><p>Vim 维持着一个标签堆栈，上面记录着所有您从哪儿来、跳哪儿去的标签列表。使用 <code>:tags</code> 可以看到这个堆栈。如果您首先跳转到<code>pancake</code>，紧接着是<code>donut</code>，此时运行<code>:tags</code>，您将看到：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  <span class=\"hljs-comment\"># TO tag         FROM line  in file/text</span><br> <span class=\"hljs-number\"> 1 </span><span class=\"hljs-number\"> 1 </span>pancake           <span class=\"hljs-number\"> 10 </span> ch16_tags/two.rb<br> <span class=\"hljs-number\"> 2 </span><span class=\"hljs-number\"> 1 </span>donut              <span class=\"hljs-number\"> 9 </span> ch16_tags/two.rb<br>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>注意上面的 <code>&gt;</code> 符号，它代表着您当前在堆栈中的位置。要“弹出”堆栈，从而回到上一次的状态，您可以运行<code>:pop</code>。试试它，再运行<code>:tags</code>看看：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  <span class=\"hljs-comment\"># TO tag         FROM line  in file/text</span><br> <span class=\"hljs-number\"> 1 </span><span class=\"hljs-number\"> 1 </span>pancake           <span class=\"hljs-number\"> 10 </span> puts pancake<br>&gt;<span class=\"hljs-number\"> 2 </span><span class=\"hljs-number\"> 1 </span>donut              <span class=\"hljs-number\"> 9 </span> one.donut<br><br></code></pre></td></tr></table></figure>\n\n<p>注意现在 <code>&gt;</code> 符号位于 <code>donut</code> 所在的第二行了。再 <code>pop</code> 一次，然后运行<code>:tags</code>：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  <span class=\"hljs-comment\"># TO tag         FROM line  in file/text</span><br>&gt;<span class=\"hljs-number\"> 1 </span><span class=\"hljs-number\"> 1 </span>pancake           <span class=\"hljs-number\"> 10 </span> puts pancake<br> <span class=\"hljs-number\"> 2 </span><span class=\"hljs-number\"> 1 </span>donut              <span class=\"hljs-number\"> 9 </span> one.donut<br></code></pre></td></tr></table></figure>\n\n<p>在普通模式下，您可以按下 <code>Ctrl-t</code> 来达到和 <code>:pop</code> 一样的效果。</p>\n<h2 id=\"自动生成标签\"><a href=\"#自动生成标签\" class=\"headerlink\" title=\"自动生成标签\"></a>自动生成标签</h2><p>Vim 标签最大的缺点之一是，每当进行重大改变时，您需要重新生成标签文件。如果您将<code>pancake</code> 过程重命名为 <code>waffle</code>，标签文件不知道 <code>pancake</code> 被重命名了，标签列表仍旧存储着 <code>pancake</code> 过程。运行<code>ctags -R .</code> 可以创建更新的标签文件，但这可能会很缓慢。</p>\n<p>幸运的是，有几种可以自动生成标签的方法。这一小节不打算介绍一个简单明了的过程，而是提出一些想法，以便您可以扩展它们。</p>\n<h2 id=\"在保存时生成标签\"><a href=\"#在保存时生成标签\" class=\"headerlink\" title=\"在保存时生成标签\"></a>在保存时生成标签</h2><p>Vim 有一个自动命令 (<code>autocmd</code>) 方法，可以在触发事件时执行任意命令。您可以使用这个方法，以便在每次保存时生成标签。运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">autocmd</span> BufWritePost *.rb <span class=\"hljs-keyword\">silent</span> !ctags -R .<br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>autocmd</code> 是 Vim 的自动命令方法，它接受一个事件名称、文件和一个命令。</li>\n<li><code>BufWritePost</code> 是保存缓冲区时的一个事件。每次保存文件时将触发一次 <code>BufWritePost</code> 事件。</li>\n<li><code>.rb</code> 是 ruby (<code>rb</code>) 文件的一种文件模式。</li>\n<li><code>silent</code> 是您传递的命令的一部分。如果不输入它，每次触发自动命令时，Vim 都会提示  <code>press ENTER or type command to continue</code>。</li>\n<li><code>!ctags -R .</code> 是要执行的命令。回想一下，<code>!cmd</code> 从 Vim 内部执行终端命令。</li>\n</ul>\n<p>现在，每次您保存一个 ruby 文件时，Vim 都会运行<code>ctags -R .</code>。</p>\n<h2 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h2><p>有几种插件可以自动生成 ctags：</p>\n<ul>\n<li><a href=\"https://github.com/ludovicchabant/vim-gutentags\">vim-gutentags</a></li>\n<li><a href=\"https://github.com/szw/vim-tags\">vim-tags</a></li>\n<li><a href=\"https://github.com/xolox/vim-easytags\">vim-easytags</a></li>\n<li><a href=\"https://github.com/craigemery/vim-autotag\">vim-autotag</a></li>\n</ul>\n<p>我使用 vim-gutentags。它的使用方法很简单，而且装上就可以直接使用。</p>\n<h2 id=\"Ctags-以及-Git-钩子\"><a href=\"#Ctags-以及-Git-钩子\" class=\"headerlink\" title=\"Ctags 以及 Git 钩子\"></a>Ctags 以及 Git 钩子</h2><p>Tim Pope 是一个写了很多非常棒的 Vim 插件的作者，他写了一篇博客，建议使用 git 钩子。<a href=\"https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html\">可以看一看</a>。</p>\n<h2 id=\"聪明地学习标签\"><a href=\"#聪明地学习标签\" class=\"headerlink\" title=\"聪明地学习标签\"></a>聪明地学习标签</h2><p>只要配置得当，标签是非常有用的。假设在一个新的代码库中，您想要搞清楚 <code>functionFood</code> 干了什么，您可以通过跳转到它的定义来搞懂它们。在那儿可以看到，它又调用了 <code>functionBreakfast</code>。继续跟踪，发现还调用了 <code>functionPancake</code>。现在您明白了，函数调用路径图长这样：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-function\"><span class=\"hljs-title\">functionFood</span> -&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-title\">functionBreakfast</span> -&gt;</span> functionPancake<br></code></pre></td></tr></table></figure>\n\n<p>进一步可以知道，这段代码和早餐吃煎饼有关。</p>\n<p>现在您已经知道如何使用标签，通过 <code>:h tags</code> 可以学习更多有关标签的知识。接下来让我们一起来探索另一个功能：折叠。</p>\n","site":{"data":{}},"wordcount":7051,"excerpt":"","more":"<h1 id=\"第16章-标签\"><a href=\"#第16章-标签\" class=\"headerlink\" title=\"第16章 标签\"></a>第16章 标签</h1><p>快速转到任意定义处，是文本编辑中一个非常有用的特性。在本章中，您将学习如何使用 Vim 标签来做到这一点。</p>\n<h2 id=\"标签概述\"><a href=\"#标签概述\" class=\"headerlink\" title=\"标签概述\"></a>标签概述</h2><p>假设有人给了您一个新的代码库：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span> = One.<span class=\"hljs-built_in\">new</span><br><span class=\"hljs-literal\">one</span>.donut<br></code></pre></td></tr></table></figure>\n\n<p><code>One</code>？<code>donut</code>？呃，对于当时编写代码的开发者而言，这些代码的含义可能显而易见。问题是当时的开发者已经不在了，现在要由您来理解这些费解的代码。而跟随有<code>One</code> 和 <code>donut</code>定义的源代码，是帮助您理解的一个有效方法。</p>\n<p>您可以使用<code>fzf</code> 或 <code>grep</code>来搜索它们，但这种情况下，但使用标签将更快。</p>\n<p>把标签想象成地址簿：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Name</span>    Address<br><span class=\"hljs-attribute\">Iggy1</span>   <span class=\"hljs-number\">1234</span> Cool St, <span class=\"hljs-number\">11111</span><br><span class=\"hljs-attribute\">Iggy2</span>   <span class=\"hljs-number\">9876</span> Awesome Ave, <span class=\"hljs-number\">2222</span><br></code></pre></td></tr></table></figure>\n\n<p>当然，标签可不是存储着“姓名-地址”对，而是“定义-地址”对。</p>\n<p>假设您在一个目录中有两个 Ruby 文件：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">## one.rb<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">One</span><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">initialize</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">Initialized</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">donut</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">Bar</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><span class=\"hljs-symbol\">end</span><br></code></pre></td></tr></table></figure>\n\n<p>以及</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-comment\">## two.rb</span><br><span class=\"hljs-built_in\">require</span> <span class=\"hljs-string\">&#x27;./one&#x27;</span><br><br><span class=\"hljs-literal\">one</span> = One.<span class=\"hljs-built_in\">new</span><br><span class=\"hljs-literal\">one</span>.donut<br></code></pre></td></tr></table></figure>\n\n<p>在普通模式下，您可以使用<code>Ctrl-]</code>跳转到定义。在<code>two.rb</code>中，转到<code>one.donut</code>所在行，将光标移到<code>donut</code>处，按下<code>Ctrl-]</code>。</p>\n<p>哦豁，Vim 找不到标签文件，您需要先生成它。</p>\n<h2 id=\"标签生成器\"><a href=\"#标签生成器\" class=\"headerlink\" title=\"标签生成器\"></a>标签生成器</h2><p>现代 Vim 不自带标签生成器，您需要额外下载它。有几个选项可供选择：</p>\n<ul>\n<li>ctags &#x3D; 仅用于 C，基本随处可见。</li>\n<li>exuberant ctags &#x3D; 最流行的标签生成器之一，支持许多语言。</li>\n<li>universal ctags &#x3D; 和 exuberant ctags 类似，但比它更新。</li>\n<li>etags &#x3D; 用于 Emacs，嗯……</li>\n<li>JTags &#x3D; Java</li>\n<li>ptags.py &#x3D; Python</li>\n<li>ptags &#x3D; Perl</li>\n<li>gnatxref &#x3D; Ada</li>\n</ul>\n<p>如果您查看 Vim 在线教程，您会发现许多都会推荐 <a href=\"http://ctags.sourceforge.net/\">exuberant ctags</a>，它支持 <a href=\"http://ctags.sourceforge.net/languages.html\">41 种编程语言</a>，我用过它，挺不错的。但自2009年以来一直没有维护，因此 Universal ctags 更好些，它和 exuberant ctags 相似，并仍在维护。</p>\n<p>我不打算详细介绍如何安装 Universal ctags，您可以在 <a href=\"https://github.com/universal-ctags/ctags\">universal ctags</a> 仓库了解更多说明。</p>\n<p>假设您已经安装好了ctags，接下来，生成一个基本的标签文件。运行：</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang\">ctags -R .<br></code></pre></td></tr></table></figure>\n\n<p> <code>R</code> 选项告诉 <code>ctags</code> 从当前位置 (<code>.</code>) 递归扫描文件。稍后，您应该在当前文件夹看到一个<code>tags</code> 文件，里面您将看到类似这样的内容：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><span class=\"hljs-title\">!_TAG_FILE_FORMAT</span>\t<span class=\"hljs-number\">2</span>\t/extended format<span class=\"hljs-comment\">; --format=1 will not append ;&quot; to lines/</span><br><span class=\"hljs-title\">!_TAG_FILE_SORTED</span>\t<span class=\"hljs-number\">1</span>\t/<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">=</span>unsorted<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">=</span>sorted<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">2</span><span class=\"hljs-operator\">=</span>foldcase/<br><span class=\"hljs-title\">!_TAG_OUTPUT_FILESEP</span>\tslash\t/slash <span class=\"hljs-keyword\">or</span> backslash/<br><span class=\"hljs-title\">!_TAG_OUTPUT_MODE</span>\tu-ctags\t/u-ctags <span class=\"hljs-keyword\">or</span> e-ctags/<br><span class=\"hljs-title\">!_TAG_PATTERN_LENGTH_LIMIT</span>\t<span class=\"hljs-number\">96</span>\t/<span class=\"hljs-number\">0</span> for no limit/<br><span class=\"hljs-title\">!_TAG_PROGRAM_AUTHOR</span>\tUniversal Ctags Team\t//<br><span class=\"hljs-title\">!_TAG_PROGRAM_NAME</span>\tUniversal Ctags\t/Derived from Exuberant Ctags/<br><span class=\"hljs-title\">!_TAG_PROGRAM_URL</span>\t&lt;https://ctags.io/&gt;\t/official site/<br><span class=\"hljs-title\">!_TAG_PROGRAM_VERSION</span>\t<span class=\"hljs-number\">0.0</span>.<span class=\"hljs-number\">0</span>\t/b<span class=\"hljs-number\">43</span>eb<span class=\"hljs-number\">39</span>/<br>One\t<span class=\"hljs-keyword\">one</span>.rb\t/^class One$/<span class=\"hljs-comment\">;&quot;\tc</span><br>donut\t<span class=\"hljs-keyword\">one</span>.rb\t/^  def donut$/<span class=\"hljs-comment\">;&quot;\tf\tclass:One</span><br>initialize\t<span class=\"hljs-keyword\">one</span>.rb\t/^  def initialize$/<span class=\"hljs-comment\">;&quot;\tf\tclass:One</span><br></code></pre></td></tr></table></figure>\n\n<p>根据 Vim 设置和 ctag 生成器的不同，您的<code>tags</code> 文件可能会有些不同。一个标签文件由两部分组成：标签元数据和标签列表。那些标签元数据 (<code>!TAG_FILE...</code>) 通常由 ctags 生成器控制。这里我不打算介绍它们，您可以随意查阅文档。标签列表是一个由所有定义组成的列表，由ctags建立索引。</p>\n<p>现在回到 <code>two.rb</code>，将光标移至 <code>donut</code>，再输入<code>Ctrl-]</code>，Vim 将带您转到 <code>one.rb</code> 文件里<code>def donut</code> 所在的行上。成功啦！但 Vim 怎么做到的呢？</p>\n<h2 id=\"解剖标签文件\"><a href=\"#解剖标签文件\" class=\"headerlink\" title=\"解剖标签文件\"></a>解剖标签文件</h2><p>来看看<code>donut</code> 标签项：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">donut\t<span class=\"hljs-keyword\">one</span>.rb\t/^  def donut$/;&quot;\tf\t<span class=\"hljs-keyword\">class</span>:<span class=\"hljs-keyword\">One</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的标签项由四个部分组成：一个<code>tagname</code>、一个<code>tagfile</code>、一个<code>tagaddress</code>，以及标签选项。</p>\n<ul>\n<li><code>donut</code> 是 <code>tagname</code>。当光标在 “donut” 时，Vim 搜索标签文件里含有 “donut” 字符串的一行。</li>\n<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>\n<li><code>/^ def donut$/</code> 是 <code>tagaddress</code>。<code>/.../</code> 是模式指示器。<code>^</code> 代表一行中第一个元素，后面跟着两个空格，然后是<code>def donut</code>字符串，最后 <code>$</code> 代表一行中最后一个元素。</li>\n<li><code>f class:One</code> 是标签选项，它告诉 Vim，<code>donut</code> 是一种函数 (<code>f</code>)，并且是 <code>One</code> 类的一部分。</li>\n</ul>\n<p>再看看另一个标签项：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span>\t<span class=\"hljs-keyword\">one</span>.rb\t/^<span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">One</span>$/;&quot;\tc<br></code></pre></td></tr></table></figure>\n\n<p>这一行和 <code>donut</code>也是一样的：</p>\n<ul>\n<li><code>One</code> 是 <code>tagname</code>。注意，对于标签，第一次扫描区分大小写。如果列表中有 <code>One</code> 和 <code>one</code>， Vim 会优先考虑 <code>One</code> 而不是 <code>one</code>。</li>\n<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>\n<li><code>/^class One$/</code> 是 <code>tagaddress</code> 。Vim 会查找以 <code>class</code> 开头 (<code>^</code>) 、以 <code>One</code> 结尾 (<code>$</code>) 的行。</li>\n<li><code>c</code> 是可用标签选项之一。由于 <code>One</code> 是一个 ruby 类而不是过程，因此被标签为 <code>c</code>。</li>\n</ul>\n<p>标签文件的内容可能不尽相同，根据您使用的标签生成器而定。但至少，标签文件必须具有以下格式之一：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">1.  </span><span class=\"hljs-template-variable\">&#123;tagname&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagfile&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagaddress&#125;</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">2.  </span><span class=\"hljs-template-variable\">&#123;tagname&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagfile&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;TAB&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;tagaddress&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;term&#125;</span><span class=\"language-xml\"> </span><span class=\"hljs-template-variable\">&#123;field&#125;</span><span class=\"language-xml\"> ..</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"标签文件\"><a href=\"#标签文件\" class=\"headerlink\" title=\"标签文件\"></a>标签文件</h2><p>您知道，在运行 <code>ctags -R .</code> 后，一个新 <code>tags</code> 文件会被创建。但是，Vim 是如何知道在哪儿查找标签文件的呢？</p>\n<p>如果运行 <code>:set tags?</code>，您可能会看见 <code>tags=./tags,tags</code>（根据您的 Vim 设置，内容可能有所不同）。对于 <code>./tags</code>，Vim 会在当前文件所在路径查找所有标签；对于 <code>tags</code>，Vim 会在当前目录（您的项目根路径）中查找。</p>\n<p>此外，对于 <code>./tags</code>，Vim 会在当前文件所在路径内查找一个标签文件，无论它被嵌套得有多深。接下来，Vim 会在当前目录（项目根路径）查找。Vim 在找到第一个匹配项后会停止搜索。</p>\n<p>如果您的 <code>&#39;tags&#39;</code> 文件是 <code>tags=./tags,tags,/user/iggy/mytags/tags</code>，那么 Vim 在搜索完 <code>./tags</code> 和 <code>tags</code> 目录后，还会在 <code>/user/iggy/mytags</code> 目录内查找。所以您可以分开存放标签文件，不必将它们置于项目文件夹中。</p>\n<p>要添加标签文件位置，只需要运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">tags</span>+=path/<span class=\"hljs-keyword\">to</span>/my/<span class=\"hljs-keyword\">tags</span>/<span class=\"hljs-keyword\">file</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"为大型项目生成标签：\"><a href=\"#为大型项目生成标签：\" class=\"headerlink\" title=\"为大型项目生成标签：\"></a>为大型项目生成标签：</h2><p>如果您尝试在大型项目中运行 ctag，则可能需要很长时间，因为 Vim 也会查看每个嵌套目录。如果您是 Javascript 开发者，您会知道 <code>node_modules</code> 非常大。假设您有五个子项目，每个都包含自己的 <code>node_modules</code> 目录。一旦运行 <code>ctags -R .</code>，ctags 将尝试扫描这5个 <code>node_modules</code>。但您可能不需要为 <code>node_modules</code> 运行 ctag。</p>\n<p>如果要排除 <code>node_modules</code> 后执行 ctags，可以运行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">ctags -R --exclude</span>=node_modules .<br></code></pre></td></tr></table></figure>\n\n<p>这次应该只需要不到一秒钟的时间。另外，您还可以多次使用 <code>exclude</code> 选项：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">ctags -R <span class=\"hljs-attribute\">--exclude</span>=.git <span class=\"hljs-attribute\">--exclude</span>=vendor <span class=\"hljs-attribute\">--exclude</span>=node_modules <span class=\"hljs-attribute\">--exclude</span>=db <span class=\"hljs-attribute\">--exclude</span>=log .<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"标签导航\"><a href=\"#标签导航\" class=\"headerlink\" title=\"标签导航\"></a>标签导航</h2><p>仅使用 <code>Ctrl-]</code> 也挺好，但我们还可以多学几个技巧。其实，标签跳转键 <code>Ctrl-]</code> 还有命令行模式：<code>:tag my-tag</code>。如果您运行：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:<span class=\"hljs-keyword\">tag</span> <span class=\"hljs-title\">donut</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 就会跳转至 <code>donut</code> 方法，就像在 “donut” 字符串上按 <code>Ctrl-]</code> 一样。您还可以使用 <code>&lt;Tab&gt;</code> 来自动补全参数：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">:<span class=\"hljs-keyword\">tag</span> <span class=\"hljs-title\">d</span><span class=\"hljs-tag\">&lt;Tab&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 会列出所有以 “d” 开头的标签。对于上面的命令，结果则是 “donut”。</p>\n<p>在实际项目中，您可能会遇到多个同名的方法。我们来更新下这两个文件。先是 <code>one.rb</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\">## one.rb<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">One</span><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">initialize</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">Initialized</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">donut</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">one</span> <span class=\"hljs-symbol\">donut</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><br>  <span class=\"hljs-symbol\">def</span> <span class=\"hljs-symbol\">pancake</span><br>    <span class=\"hljs-symbol\">puts</span> &quot;<span class=\"hljs-symbol\">one</span> <span class=\"hljs-symbol\">pancake</span>&quot;<br>  <span class=\"hljs-symbol\">end</span><br><span class=\"hljs-symbol\">end</span><br></code></pre></td></tr></table></figure>\n\n<p>然后 <code>two.rb</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-comment\">## two.rb</span><br><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;./one.rb&#x27;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pancake</span></span><br>  <span class=\"hljs-string\">&quot;Two pancakes&quot;</span><br><span class=\"hljs-keyword\">end</span><br><br>one = <span class=\"hljs-title class_\">One</span>.new<br>one.donut<br>puts pancake<br></code></pre></td></tr></table></figure>\n\n<p>由于新添加了一些过程，因此编写完代码后，不要忘记运行 <code>ctags -R .</code>。现在，您有了两个 <code>pancake</code> 过程。如果您在 <code>two.rb</code> 内按下 <code>Ctrl-]</code>，会发生什么呢？</p>\n<p>Vim 会跳转到 <code>two.rb</code> 内的 <code>def pancake</code>，而不是 <code>one.rb</code> 的 <code>def pancake</code>。这是因为 Vim 认为 <code>two.rb</code> 内部的 <code>pancake</code> 过程比其他的<code>pancake</code> 过程具有更高优先级。</p>\n<h2 id=\"标签优先级\"><a href=\"#标签优先级\" class=\"headerlink\" title=\"标签优先级\"></a>标签优先级</h2><p>并非所有的标签都有着相同的地位。一些标签有着更高的优先级。如果有重复的标签项，Vim 会检查关键词的优先级。顺序是：</p>\n<ol>\n<li>当前文件中完全匹配的静态标签。</li>\n<li>当前文件中完全匹配的全局标签。</li>\n<li>其他文件中完全匹配的全局标签。</li>\n<li>其他文件中完全匹配的静态标签。</li>\n<li>当前文件中不区分大小写匹配的静态标签。</li>\n<li>当前文件中不区分大小写匹配的全局标签。</li>\n<li>其他文件中区分大小写匹配的全局标签。</li>\n<li>当前文件中不区分大小写匹配的静态标签。</li>\n</ol>\n<p>根据优先级列表，Vim 会对在同一个文件上找到的精确匹配项进行优先级排序。这就是为什么 Vim 会选择 <code>two.rb</code> 里的 <code>pancake</code> 过程而不是 <code>one.rb</code> 里的。但是，上述优先级列表有些例外，取决于您的<code>&#39;tagcase&#39;</code>、<code>&#39;ignorecase&#39;</code>、<code>&#39;smartcase&#39;</code> 设置。我不打算介绍它们，您可以自行查阅 <code>:h tag-priority</code>。</p>\n<h2 id=\"选择性跳转标签\"><a href=\"#选择性跳转标签\" class=\"headerlink\" title=\"选择性跳转标签\"></a>选择性跳转标签</h2><p>如果可以选择要跳转到哪个标签，而不是始终转到优先级最高的，那就太好了。因为您可能想跳转到 <code>one.rb</code> 里的 <code>pancake</code> 方法，而不是 <code>two.rb</code> 里的。现在您可以使用 <code>:tselect</code> 做到它！运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tselect</span> pancake<br></code></pre></td></tr></table></figure>\n\n<p>您可以在屏幕底部看到：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\">## pri kind tag               file</span><br><span class=\"hljs-number\">1</span> F C f    pancake           two.rb<br>             <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pancake</span></span><br><span class=\"hljs-number\">2</span> F   f    pancake           one.rb<br>             <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>:<span class=\"hljs-title\">One</span></span><br>             <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pancake</span></span><br></code></pre></td></tr></table></figure>\n\n<p>如果输入<code>2</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>one.rb</code> 里的<code>pancake</code> 过程。如果输入<code>1</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>two.rb</code> 里的。</p>\n<p>注意<code>pri</code> 列，第一个匹配中该列是<code>F C</code>，第二个匹配中则是<code>F</code>。这就是 Vim 用来确定标签优先级的凭据。<code>F C</code>表示在当前 (<code>C</code>) 文件中完全匹配 (<code>F</code>) 的全局标签。<code>F</code> 表示仅完全匹配 (<code>F</code>) 的全局标签。<code>F C</code> 的优先级永远比 <code>F</code> 高。<em>（译注：<code>F</code>是<code>Fully-matched</code>，<code>C</code>是<code>Current file</code>）</em></p>\n<p>如果运行<code>:tselect donut</code>，即使只有一个标签可选，Vim 也会提示您选择跳转到哪一个。有没有什么方法可以让 Vim 仅在有多个匹配项时才提示标签列表，而只找到一个标签时就立即跳转呢？</p>\n<p>当然！Vim 有一个 <code>:tjump</code> 方法。运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tjump</span> donut<br></code></pre></td></tr></table></figure>\n\n<p>Vim 将立即跳转到 <code>one.rb</code> 里的<code>donut</code> 过程，就像在运行 <code>:tag donut</code> 一样。现在试试：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:tjump</span> pancake<br></code></pre></td></tr></table></figure>\n\n<p>Vim 将提示您从标签选项中选择一个，就像在运行<code>:tselect pancake</code>。<code>tjump</code> 能两全其美。</p>\n<p><code>tjump</code> 在普通模式下有一个快捷键：<code>g Ctrl-]</code>。我个人喜欢<code>g Ctrl-]</code>胜过 <code>Ctrl-]</code>。</p>\n<h2 id=\"标签的自动补全\"><a href=\"#标签的自动补全\" class=\"headerlink\" title=\"标签的自动补全\"></a>标签的自动补全</h2><p>标签能有助于自动补全。回想下第6章“插入模式”，您可以使用 <code>Ctrl-x</code> 子模式来进行各式自动补全。其中有一个我没有提到过的自动补全子模式便是 <code>Ctrl-]</code>。如果您在插入模式中输入<code>Ctrl-x Ctrl-]</code>，Vim 将使用标签文件来自动补全。</p>\n<p>在插入模式下输入<code>Ctrl-x Ctrl-]</code>，您会看到：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">One</span><br><span class=\"hljs-attribute\">donut</span><br><span class=\"hljs-attribute\">initialize</span><br><span class=\"hljs-attribute\">pancake</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"标签堆栈\"><a href=\"#标签堆栈\" class=\"headerlink\" title=\"标签堆栈\"></a>标签堆栈</h2><p>Vim 维持着一个标签堆栈，上面记录着所有您从哪儿来、跳哪儿去的标签列表。使用 <code>:tags</code> 可以看到这个堆栈。如果您首先跳转到<code>pancake</code>，紧接着是<code>donut</code>，此时运行<code>:tags</code>，您将看到：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  <span class=\"hljs-comment\"># TO tag         FROM line  in file/text</span><br> <span class=\"hljs-number\"> 1 </span><span class=\"hljs-number\"> 1 </span>pancake           <span class=\"hljs-number\"> 10 </span> ch16_tags/two.rb<br> <span class=\"hljs-number\"> 2 </span><span class=\"hljs-number\"> 1 </span>donut              <span class=\"hljs-number\"> 9 </span> ch16_tags/two.rb<br>&gt;<br></code></pre></td></tr></table></figure>\n\n<p>注意上面的 <code>&gt;</code> 符号，它代表着您当前在堆栈中的位置。要“弹出”堆栈，从而回到上一次的状态，您可以运行<code>:pop</code>。试试它，再运行<code>:tags</code>看看：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  <span class=\"hljs-comment\"># TO tag         FROM line  in file/text</span><br> <span class=\"hljs-number\"> 1 </span><span class=\"hljs-number\"> 1 </span>pancake           <span class=\"hljs-number\"> 10 </span> puts pancake<br>&gt;<span class=\"hljs-number\"> 2 </span><span class=\"hljs-number\"> 1 </span>donut              <span class=\"hljs-number\"> 9 </span> one.donut<br><br></code></pre></td></tr></table></figure>\n\n<p>注意现在 <code>&gt;</code> 符号位于 <code>donut</code> 所在的第二行了。再 <code>pop</code> 一次，然后运行<code>:tags</code>：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  <span class=\"hljs-comment\"># TO tag         FROM line  in file/text</span><br>&gt;<span class=\"hljs-number\"> 1 </span><span class=\"hljs-number\"> 1 </span>pancake           <span class=\"hljs-number\"> 10 </span> puts pancake<br> <span class=\"hljs-number\"> 2 </span><span class=\"hljs-number\"> 1 </span>donut              <span class=\"hljs-number\"> 9 </span> one.donut<br></code></pre></td></tr></table></figure>\n\n<p>在普通模式下，您可以按下 <code>Ctrl-t</code> 来达到和 <code>:pop</code> 一样的效果。</p>\n<h2 id=\"自动生成标签\"><a href=\"#自动生成标签\" class=\"headerlink\" title=\"自动生成标签\"></a>自动生成标签</h2><p>Vim 标签最大的缺点之一是，每当进行重大改变时，您需要重新生成标签文件。如果您将<code>pancake</code> 过程重命名为 <code>waffle</code>，标签文件不知道 <code>pancake</code> 被重命名了，标签列表仍旧存储着 <code>pancake</code> 过程。运行<code>ctags -R .</code> 可以创建更新的标签文件，但这可能会很缓慢。</p>\n<p>幸运的是，有几种可以自动生成标签的方法。这一小节不打算介绍一个简单明了的过程，而是提出一些想法，以便您可以扩展它们。</p>\n<h2 id=\"在保存时生成标签\"><a href=\"#在保存时生成标签\" class=\"headerlink\" title=\"在保存时生成标签\"></a>在保存时生成标签</h2><p>Vim 有一个自动命令 (<code>autocmd</code>) 方法，可以在触发事件时执行任意命令。您可以使用这个方法，以便在每次保存时生成标签。运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">autocmd</span> BufWritePost *.rb <span class=\"hljs-keyword\">silent</span> !ctags -R .<br></code></pre></td></tr></table></figure>\n\n<p>上面命令的分解如下：</p>\n<ul>\n<li><code>autocmd</code> 是 Vim 的自动命令方法，它接受一个事件名称、文件和一个命令。</li>\n<li><code>BufWritePost</code> 是保存缓冲区时的一个事件。每次保存文件时将触发一次 <code>BufWritePost</code> 事件。</li>\n<li><code>.rb</code> 是 ruby (<code>rb</code>) 文件的一种文件模式。</li>\n<li><code>silent</code> 是您传递的命令的一部分。如果不输入它，每次触发自动命令时，Vim 都会提示  <code>press ENTER or type command to continue</code>。</li>\n<li><code>!ctags -R .</code> 是要执行的命令。回想一下，<code>!cmd</code> 从 Vim 内部执行终端命令。</li>\n</ul>\n<p>现在，每次您保存一个 ruby 文件时，Vim 都会运行<code>ctags -R .</code>。</p>\n<h2 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h2><p>有几种插件可以自动生成 ctags：</p>\n<ul>\n<li><a href=\"https://github.com/ludovicchabant/vim-gutentags\">vim-gutentags</a></li>\n<li><a href=\"https://github.com/szw/vim-tags\">vim-tags</a></li>\n<li><a href=\"https://github.com/xolox/vim-easytags\">vim-easytags</a></li>\n<li><a href=\"https://github.com/craigemery/vim-autotag\">vim-autotag</a></li>\n</ul>\n<p>我使用 vim-gutentags。它的使用方法很简单，而且装上就可以直接使用。</p>\n<h2 id=\"Ctags-以及-Git-钩子\"><a href=\"#Ctags-以及-Git-钩子\" class=\"headerlink\" title=\"Ctags 以及 Git 钩子\"></a>Ctags 以及 Git 钩子</h2><p>Tim Pope 是一个写了很多非常棒的 Vim 插件的作者，他写了一篇博客，建议使用 git 钩子。<a href=\"https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html\">可以看一看</a>。</p>\n<h2 id=\"聪明地学习标签\"><a href=\"#聪明地学习标签\" class=\"headerlink\" title=\"聪明地学习标签\"></a>聪明地学习标签</h2><p>只要配置得当，标签是非常有用的。假设在一个新的代码库中，您想要搞清楚 <code>functionFood</code> 干了什么，您可以通过跳转到它的定义来搞懂它们。在那儿可以看到，它又调用了 <code>functionBreakfast</code>。继续跟踪，发现还调用了 <code>functionPancake</code>。现在您明白了，函数调用路径图长这样：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-function\"><span class=\"hljs-title\">functionFood</span> -&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-title\">functionBreakfast</span> -&gt;</span> functionPancake<br></code></pre></td></tr></table></figure>\n\n<p>进一步可以知道，这段代码和早餐吃煎饼有关。</p>\n<p>现在您已经知道如何使用标签，通过 <code>:h tags</code> 可以学习更多有关标签的知识。接下来让我们一起来探索另一个功能：折叠。</p>\n"},{"title":"VIM-折叠","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第17章 折叠\n\n在阅读文件时，经常会有一些不相关的文本会妨碍您理解。使用 Vim 折叠可以隐藏这些不必要的信息。\n\n本章中，您将学习如何使用不同的折叠方法。\n\n## 手动折叠\n\n想象您正在折叠一张纸来覆盖一些文本，实际的文本不会消失，它仍在那儿。Vim 折叠的工作方式与此相同，它*折叠*一段文本，在显示时会隐藏起来，但实际上并不会真的删除它。\n\n折叠操作符是`z`。（折叠纸张时，它看起来也像字母 \"z\"）。\n\n假设有如下文本：\n\n```\nFold me\nHold me\n```\n\n把光标放在第一行，输入 `zfj`。Vim 将这两行折叠成一行，同时会看到类似消息：\n\n```\n+-- 2 lines: Fold me -----\n```\n\n上面的命令分解如下：\n- `zf` 是折叠操作符。\n- `j` 是用于折叠操作符的动作。\n\n您可以使用 `zo` 打开/展开已折叠文本，使用 `zc` 关闭/收缩文本。\n\n折叠是一个操作符，所以它遵循语法规则（`动词+名词`）。您可以在折叠运算符后，加上一个动作(motion)或文本对象。例如，使用 `zfip` 可以折叠内部段落；使用 `zfG` 可以折叠至文件末尾；使用 `zfa{` 可以折叠 `{` 和 `}` 之间的文本。\n\n您可以在可视模式下进行折叠。高亮您想要折叠的区域后 (`v`, `V`, 或 `Ctrl-v`)，再输入 `zf` 即可。\n\n您也可以在命令行模式下，使用 `:fold` 命令执行一次折叠。若要折叠当前行及紧随其后的第二行，可以运行：\n\n```\n:,+1fold\n```\n\n`,+1` 是要折叠的范围。如果不传递范围参数，默认当前行。`+1` 是代表下一行的范围指示器。运行 `:5,10fold` 可以折叠第5至10行。运行 `:,$fold` 可以折叠当前行至文件末尾。\n\n还有许多其他折叠和展开的命令。我发现他们实在太多，以至于在刚起步时很难记住。最有用的一些命令是：\n- `zR` 展开所有折叠。\n- `zM` 收缩所有折叠。\n- `za` 切换折叠状态。\n\n`zR` 和 `zM` 可用于任意行上，但 `za` 仅能用于已折叠/未折叠的行上。输入 `:h fold-commands` 可查阅更多有关折叠的指令。\n\n## 不同的折叠方法\n\n以上部分涵盖了 Vim 手动折叠的内容。实际上，Vim 有六种不同的折叠方法：\n1. 手动折叠\n2. 缩进折叠\n3. 表达式折叠\n4. 语法折叠\n5. 差异折叠\n6. 标志折叠\n\n运行 `:set foldmethod?` 可查看您当前正在使用哪一种折叠方式。默认情况下，Vim 使用手动方式。\n\n在本章的剩余部分，您将学习其他五种折叠方法。让我们从缩进折叠开始。\n\n## 缩进折叠\n\n要使用缩进折叠，需要将 `'foldmethod'` 选项更改为缩进：\n\n```\n:set foldmethod=indent\n```\n\n假设有如下文本：\n\n```\nOne\n  Two\n  Two again\n```\n\n运行 `:set foldmethod=indent` 后将看到：\n\n```\nOne\n+-- 2 lines: Two -----\n```\n\n使用缩进折叠后，Vim 将会查看每行的开头有多少空格，并将它与 `'shiftwidth'` 选项进行比较，以此来决定该行可折叠性。`'shiftwidth'` 返回每次缩进所需的空格数。如果运行：\n\n```\n:set shiftwidth?\n```\n\nVim 的默认 `'shiftwidth'` 值为2。对于上面的文本而言，\"Two\" 和 \"Two again\" 的开头都有两个空格。当 Vim 看到了空格数 *且* `'shiftwidth'`值都为2时，Vim 认为该行的缩进折叠级别为1。\n\n假设这次文本开头只有一个空格：\n\n```\nOne\n Two\n Two again\n```\n\n运行 `:set foldmethod=indent` 后，Vim 不再折叠已缩进的行了，因为这些行没有足够的空格。1个空格不会被视作一个缩进。然而，当您改变 `'shiftwidth' ` 的值为1后：\n\n```\n:set shiftwidth=1\n```\n\n文本现在可以折叠了！现在一个空格将被视为一个缩进。\n\n现在，我们将 `'shiftwidth' ` 以及文本开头的空格数都重新恢复为2后，另外添加一些内容：\n\n```\nOne\n  Two\n  Two again\n    Three\n    Three again\n```\n\n运行折叠命令 (`zM`) 后可以看到：\n\n```\nOne\n+-- 4 lines: Two -----\n```\n\n展开已折叠的行 (`zR`)，接着移动光标至 \"Three\"，然后切换文本的折叠状态 (`za`)：\n\n```\nOne\n  Two\n  Two again\n+-- 2 lines: Three -----\n```\n\n这是啥？叠中叠？\n\n是的，您可以嵌套折叠。文本 \"Two\" 和 \"Two again\" 的折叠级别都为1，文本 \"Three\" 和 \"Three again\" 的折叠级别都为2。如果在一段可折叠文本中，具有另一段折叠级别更高的可折叠文本，则可以具有多个折叠层。\n\n## 表达式折叠\n\n表达式折叠允许您定义要匹配折叠的表达式。定义折叠表达式后，Vim 会计算每行的 `'foldexpr'` 值。这是必须配置的变量，它要返回适当的值。如果返回 0，则不折叠行。如果它返回 1，则该行的折叠级别为 1。如果它返回 2，则该线的折叠级别为 2。除了整数外还有其他的值，但我不打算介绍它们。如果你好奇，可以查阅`:h fold-expr`。\n\n首先，更改折叠方法：\n\n```\n:set foldmethod=expr\n```\n\n假设您有一份早餐食品列表，并且想要折叠所有以 \"p\" 开头的早餐项：\n\n```\ndonut\npancake\npop-tarts\nprotein bar\nsalmon\nscrambled eggs\n```\n\n其次，更改 `foldexpr` 为捕获以 \"p\" 开头的表达式：\n\n```\n:set foldexpr=getline(v:lnum)[0]==\\\\\"p\\\\\"\n```\n\n这表达式看起来有点吓人。我们来分解下：\n- `:set foldexpr` 设置 `'foldexpr'` 为自定义表达式。\n- `getline()` 是 Vim 脚本的一个函数，它返回指定行的内容。如运行 `:echo getline(5)` 可以获取第5行的内容。\n- `v:lnum` 是 Vim `'foldexpr'` 表达式的特殊变量。Vim 在扫描每一行时，都会将行号存储至 `v:lnum` 变量。在第5行，`v:lnum` 值为5。在第10行，`v:lnum`值为10。\n- `[0]` 处于 `getline(v:lnum)[0]` 语境时，代表每一行的第一个字符。Vim 在扫描某一行时，`getline(v:lnum)` 返回该行的内容，而 `getline(v:lnum)[0]` 则返回这一行的第一个字符。例如，我们早餐食品列表的第一行是 \"donut\"，则 `getline(v:lnum)[0]` 返回 \"d\"；列表的第二行是 \"pancake\"，则 `getline(v:lnum)[0]` 返回 \"p\"。\n- `==\\\\\"p\\\\\"` 是等式表达式的后半部分，它检查刚才表达式的计算结果是否等于 \"p\"。如果是，则返回1，否则返回0。在 Vim 的世界里，1代表真，0代表假。所以，那些以 \"p\" 开头的行，表达式都会返回1。回想一下本节的开始，如果 `'foldexpr'` 的值为1，则折叠级别为1。\n\n在运行这个表达式后，您将看到：\n\n```\ndonut\n+-- 3 lines: pancake -----\nsalmon\nscrambled eggs\n```\n\n## 语法折叠\n\n语法折叠是由Vim的语法高亮决定的。如果您使用了语法高亮插件，比如[vim-polyglot](https://github.com/sheerun/vim-polyglot)，那么装上插件就可以直接使用语法折叠。仅仅需要将`foldmethod`选项改为 `syntax`。\n\n```\n:set foldmethod=syntax\n```\n\n假设您正在编辑一个JavaScript文件，而且您已经装好了 vim-polyglot 插件。如果您有以下文本：\n\n```\nconst nums = [\n  one,\n  two,\n  three,\n  four\n]\n```\n\n上述文本将会使用语法折叠折起来。当您为某个特定语言（位于 `syntax/` 目录中的语言即是典型例子）定义了语法高亮，您可以添加一个 `fold` 属性，使它支持折叠。下面是 vim-polyglot 中JavaScript语法文件中的一个片段。注意最后的 `fold` 关键字。\n\n```\nsyntax region  jsBracket                      matchgroup=jsBrackets            start=/\\[/ end=/\\]/ contains=@jsExpression,jsSpreadExpression extend fold\n```\n\n本书不会详细介绍 `syntax` 功能。如果您感兴趣，可以查阅 `:h syntax.txt`。\n\n## 差异折叠\n\nVim 可以对多个文件进行差异比较。\n\n如果您有 `file1.txt`：\n\n```\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\n```\n\n以及 `file2.txt`：\n\n```\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nemacs is ok\n```\n\n运行 `vimdiff file1.txt file2.txt`：\n\n```\n+-- 3 lines: vim is awesome -----\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\n[vim is awesome] / [emacs is ok]\n```\n\nVim 会自动折叠一些相同的行。运行 `vimdiff` 命令时，Vim 会自动使用 `foldmethod=diff`。此时如果运行 `:set foldmethod?`，它将返回 `diff`。\n\n## 标志折叠\n\n要使用标志折叠，请运行：\n\n```\n:set foldmethod=marker\n```\n\n假设有如下文本：\n\n```\nHello\n\n{{{\nworld\nvim\n}}}\n```\n\n输入 `zM` 后会看到：\n\n```\nhello\n\n+-- 4 lines: -----\n```\n\nVim 将 `{{{` 和 `}}}` 视为折叠指示器，并折叠其中的内容。使用标志折叠时，Vim 会寻找由 `'foldmarker'` 选项定义的特殊标志，并标记折叠区域。要查看 Vim 使用的标志，请运行：\n\n```\n:set foldmarker?\n```\n\n默认情况下，Vim 把 `{{{` 和 `}}}` 作为指示器。如果您想将指示器更改为其他诸如 \"coffee1\" 和 \"coffee2\" 的字符串，可以运行：\n\n```\n:set foldmarker=coffee1,coffee2\n```\n\n假设有如下文本：\n\n```\nhello\n\ncoffee1\nworld\nvim\ncoffee2\n```\n\n现在，Vim 将使用 `coffee1` 和 `coffee2` 作为新折叠标志。注意，指示器必须是文本字符串，不能是正则表达式。\n\n## 持久化折叠\n\n当关闭 Vim 会话后，您将失去所有的折叠信息。假设您有 `count.txt` 文件：\n\n```\none\ntwo\nthree\nfour\nfive\n```\n\n手动从第三行开始往下折叠 (`:3,$fold`)：\n\n```\none\ntwo\n+-- 3 lines: three ---\n```\n\n当您退出 Vim 再重新打开 `count.txt` 后，这些折叠都不见了！\n\n要在折叠后保留它们，可以运行：\n\n```\n:mkview\n```\n\n当打开 `count.txt` 后，运行：\n\n```\n:loadview\n```\n\n您的折叠信息都被保留下来了。然而，您需要手动运行 `mkview` 和 `loadview`。我知道，终有一日，我会忘记运行 `mkview` 就关闭文件了，接着便会丢失所有折叠信息。能不能自动实现这个呢？\n\n当然能！要在关闭 `.txt` 文件时自动运行 `mkview`，以及在打开 `.txt` 文件后自动运行 `loadview`，将下列内容添加至您的 vimrc：\n\n```\nautocmd BufWinLeave *.txt mkview\nautocmd BufWinEnter *.txt silent loadview\n```\n\n在上一章您已经见过 `autocmd` 了，它用于在事件触发时执行一条命令。这里的两个事件是：\n- `BufWinLeave` 从窗口中删除缓冲时。\n- `BufWinEnter` 在窗口中加载缓冲时。\n\n现在，即使您在 `.txt` 文件内折叠内容后直接退出 Vim，下次再打开该文件时，您的折叠信息都能自动恢复。\n\n默认情况下，当运行 `mkview` 时，Vim将折叠信息保存在`~/.vim/view` (Unix 系统)。您可以查阅 `:h 'viewdir'` 来了解更多信息。\n\n## 聪明地学习折叠\n\n当我刚开始使用 Vim 时， 我会跳过学习 Vim 折叠，因为我觉得它不太实用。然而，随着我码龄的增长，我越发觉得折叠功能大有用处。得当地使用折叠功能，文本结构可以更加清晰，犹如一本书籍的目录。\n\n当您学习折叠时，请从手动折叠开始，因为它可以随学随用。然后逐渐学习不同的技巧来使用缩进和标志折叠。最后，学习如何使用语法和表达式折叠。您甚至可以使用后两个来编写您自己的 Vim 插件。\n","source":"_posts/Vim/ch17_fold.md","raw":"---\ntitle: VIM-折叠\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第17章 折叠\n\n在阅读文件时，经常会有一些不相关的文本会妨碍您理解。使用 Vim 折叠可以隐藏这些不必要的信息。\n\n本章中，您将学习如何使用不同的折叠方法。\n\n## 手动折叠\n\n想象您正在折叠一张纸来覆盖一些文本，实际的文本不会消失，它仍在那儿。Vim 折叠的工作方式与此相同，它*折叠*一段文本，在显示时会隐藏起来，但实际上并不会真的删除它。\n\n折叠操作符是`z`。（折叠纸张时，它看起来也像字母 \"z\"）。\n\n假设有如下文本：\n\n```\nFold me\nHold me\n```\n\n把光标放在第一行，输入 `zfj`。Vim 将这两行折叠成一行，同时会看到类似消息：\n\n```\n+-- 2 lines: Fold me -----\n```\n\n上面的命令分解如下：\n- `zf` 是折叠操作符。\n- `j` 是用于折叠操作符的动作。\n\n您可以使用 `zo` 打开/展开已折叠文本，使用 `zc` 关闭/收缩文本。\n\n折叠是一个操作符，所以它遵循语法规则（`动词+名词`）。您可以在折叠运算符后，加上一个动作(motion)或文本对象。例如，使用 `zfip` 可以折叠内部段落；使用 `zfG` 可以折叠至文件末尾；使用 `zfa{` 可以折叠 `{` 和 `}` 之间的文本。\n\n您可以在可视模式下进行折叠。高亮您想要折叠的区域后 (`v`, `V`, 或 `Ctrl-v`)，再输入 `zf` 即可。\n\n您也可以在命令行模式下，使用 `:fold` 命令执行一次折叠。若要折叠当前行及紧随其后的第二行，可以运行：\n\n```\n:,+1fold\n```\n\n`,+1` 是要折叠的范围。如果不传递范围参数，默认当前行。`+1` 是代表下一行的范围指示器。运行 `:5,10fold` 可以折叠第5至10行。运行 `:,$fold` 可以折叠当前行至文件末尾。\n\n还有许多其他折叠和展开的命令。我发现他们实在太多，以至于在刚起步时很难记住。最有用的一些命令是：\n- `zR` 展开所有折叠。\n- `zM` 收缩所有折叠。\n- `za` 切换折叠状态。\n\n`zR` 和 `zM` 可用于任意行上，但 `za` 仅能用于已折叠/未折叠的行上。输入 `:h fold-commands` 可查阅更多有关折叠的指令。\n\n## 不同的折叠方法\n\n以上部分涵盖了 Vim 手动折叠的内容。实际上，Vim 有六种不同的折叠方法：\n1. 手动折叠\n2. 缩进折叠\n3. 表达式折叠\n4. 语法折叠\n5. 差异折叠\n6. 标志折叠\n\n运行 `:set foldmethod?` 可查看您当前正在使用哪一种折叠方式。默认情况下，Vim 使用手动方式。\n\n在本章的剩余部分，您将学习其他五种折叠方法。让我们从缩进折叠开始。\n\n## 缩进折叠\n\n要使用缩进折叠，需要将 `'foldmethod'` 选项更改为缩进：\n\n```\n:set foldmethod=indent\n```\n\n假设有如下文本：\n\n```\nOne\n  Two\n  Two again\n```\n\n运行 `:set foldmethod=indent` 后将看到：\n\n```\nOne\n+-- 2 lines: Two -----\n```\n\n使用缩进折叠后，Vim 将会查看每行的开头有多少空格，并将它与 `'shiftwidth'` 选项进行比较，以此来决定该行可折叠性。`'shiftwidth'` 返回每次缩进所需的空格数。如果运行：\n\n```\n:set shiftwidth?\n```\n\nVim 的默认 `'shiftwidth'` 值为2。对于上面的文本而言，\"Two\" 和 \"Two again\" 的开头都有两个空格。当 Vim 看到了空格数 *且* `'shiftwidth'`值都为2时，Vim 认为该行的缩进折叠级别为1。\n\n假设这次文本开头只有一个空格：\n\n```\nOne\n Two\n Two again\n```\n\n运行 `:set foldmethod=indent` 后，Vim 不再折叠已缩进的行了，因为这些行没有足够的空格。1个空格不会被视作一个缩进。然而，当您改变 `'shiftwidth' ` 的值为1后：\n\n```\n:set shiftwidth=1\n```\n\n文本现在可以折叠了！现在一个空格将被视为一个缩进。\n\n现在，我们将 `'shiftwidth' ` 以及文本开头的空格数都重新恢复为2后，另外添加一些内容：\n\n```\nOne\n  Two\n  Two again\n    Three\n    Three again\n```\n\n运行折叠命令 (`zM`) 后可以看到：\n\n```\nOne\n+-- 4 lines: Two -----\n```\n\n展开已折叠的行 (`zR`)，接着移动光标至 \"Three\"，然后切换文本的折叠状态 (`za`)：\n\n```\nOne\n  Two\n  Two again\n+-- 2 lines: Three -----\n```\n\n这是啥？叠中叠？\n\n是的，您可以嵌套折叠。文本 \"Two\" 和 \"Two again\" 的折叠级别都为1，文本 \"Three\" 和 \"Three again\" 的折叠级别都为2。如果在一段可折叠文本中，具有另一段折叠级别更高的可折叠文本，则可以具有多个折叠层。\n\n## 表达式折叠\n\n表达式折叠允许您定义要匹配折叠的表达式。定义折叠表达式后，Vim 会计算每行的 `'foldexpr'` 值。这是必须配置的变量，它要返回适当的值。如果返回 0，则不折叠行。如果它返回 1，则该行的折叠级别为 1。如果它返回 2，则该线的折叠级别为 2。除了整数外还有其他的值，但我不打算介绍它们。如果你好奇，可以查阅`:h fold-expr`。\n\n首先，更改折叠方法：\n\n```\n:set foldmethod=expr\n```\n\n假设您有一份早餐食品列表，并且想要折叠所有以 \"p\" 开头的早餐项：\n\n```\ndonut\npancake\npop-tarts\nprotein bar\nsalmon\nscrambled eggs\n```\n\n其次，更改 `foldexpr` 为捕获以 \"p\" 开头的表达式：\n\n```\n:set foldexpr=getline(v:lnum)[0]==\\\\\"p\\\\\"\n```\n\n这表达式看起来有点吓人。我们来分解下：\n- `:set foldexpr` 设置 `'foldexpr'` 为自定义表达式。\n- `getline()` 是 Vim 脚本的一个函数，它返回指定行的内容。如运行 `:echo getline(5)` 可以获取第5行的内容。\n- `v:lnum` 是 Vim `'foldexpr'` 表达式的特殊变量。Vim 在扫描每一行时，都会将行号存储至 `v:lnum` 变量。在第5行，`v:lnum` 值为5。在第10行，`v:lnum`值为10。\n- `[0]` 处于 `getline(v:lnum)[0]` 语境时，代表每一行的第一个字符。Vim 在扫描某一行时，`getline(v:lnum)` 返回该行的内容，而 `getline(v:lnum)[0]` 则返回这一行的第一个字符。例如，我们早餐食品列表的第一行是 \"donut\"，则 `getline(v:lnum)[0]` 返回 \"d\"；列表的第二行是 \"pancake\"，则 `getline(v:lnum)[0]` 返回 \"p\"。\n- `==\\\\\"p\\\\\"` 是等式表达式的后半部分，它检查刚才表达式的计算结果是否等于 \"p\"。如果是，则返回1，否则返回0。在 Vim 的世界里，1代表真，0代表假。所以，那些以 \"p\" 开头的行，表达式都会返回1。回想一下本节的开始，如果 `'foldexpr'` 的值为1，则折叠级别为1。\n\n在运行这个表达式后，您将看到：\n\n```\ndonut\n+-- 3 lines: pancake -----\nsalmon\nscrambled eggs\n```\n\n## 语法折叠\n\n语法折叠是由Vim的语法高亮决定的。如果您使用了语法高亮插件，比如[vim-polyglot](https://github.com/sheerun/vim-polyglot)，那么装上插件就可以直接使用语法折叠。仅仅需要将`foldmethod`选项改为 `syntax`。\n\n```\n:set foldmethod=syntax\n```\n\n假设您正在编辑一个JavaScript文件，而且您已经装好了 vim-polyglot 插件。如果您有以下文本：\n\n```\nconst nums = [\n  one,\n  two,\n  three,\n  four\n]\n```\n\n上述文本将会使用语法折叠折起来。当您为某个特定语言（位于 `syntax/` 目录中的语言即是典型例子）定义了语法高亮，您可以添加一个 `fold` 属性，使它支持折叠。下面是 vim-polyglot 中JavaScript语法文件中的一个片段。注意最后的 `fold` 关键字。\n\n```\nsyntax region  jsBracket                      matchgroup=jsBrackets            start=/\\[/ end=/\\]/ contains=@jsExpression,jsSpreadExpression extend fold\n```\n\n本书不会详细介绍 `syntax` 功能。如果您感兴趣，可以查阅 `:h syntax.txt`。\n\n## 差异折叠\n\nVim 可以对多个文件进行差异比较。\n\n如果您有 `file1.txt`：\n\n```\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\n```\n\n以及 `file2.txt`：\n\n```\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nemacs is ok\n```\n\n运行 `vimdiff file1.txt file2.txt`：\n\n```\n+-- 3 lines: vim is awesome -----\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\nvim is awesome\n[vim is awesome] / [emacs is ok]\n```\n\nVim 会自动折叠一些相同的行。运行 `vimdiff` 命令时，Vim 会自动使用 `foldmethod=diff`。此时如果运行 `:set foldmethod?`，它将返回 `diff`。\n\n## 标志折叠\n\n要使用标志折叠，请运行：\n\n```\n:set foldmethod=marker\n```\n\n假设有如下文本：\n\n```\nHello\n\n{{{\nworld\nvim\n}}}\n```\n\n输入 `zM` 后会看到：\n\n```\nhello\n\n+-- 4 lines: -----\n```\n\nVim 将 `{{{` 和 `}}}` 视为折叠指示器，并折叠其中的内容。使用标志折叠时，Vim 会寻找由 `'foldmarker'` 选项定义的特殊标志，并标记折叠区域。要查看 Vim 使用的标志，请运行：\n\n```\n:set foldmarker?\n```\n\n默认情况下，Vim 把 `{{{` 和 `}}}` 作为指示器。如果您想将指示器更改为其他诸如 \"coffee1\" 和 \"coffee2\" 的字符串，可以运行：\n\n```\n:set foldmarker=coffee1,coffee2\n```\n\n假设有如下文本：\n\n```\nhello\n\ncoffee1\nworld\nvim\ncoffee2\n```\n\n现在，Vim 将使用 `coffee1` 和 `coffee2` 作为新折叠标志。注意，指示器必须是文本字符串，不能是正则表达式。\n\n## 持久化折叠\n\n当关闭 Vim 会话后，您将失去所有的折叠信息。假设您有 `count.txt` 文件：\n\n```\none\ntwo\nthree\nfour\nfive\n```\n\n手动从第三行开始往下折叠 (`:3,$fold`)：\n\n```\none\ntwo\n+-- 3 lines: three ---\n```\n\n当您退出 Vim 再重新打开 `count.txt` 后，这些折叠都不见了！\n\n要在折叠后保留它们，可以运行：\n\n```\n:mkview\n```\n\n当打开 `count.txt` 后，运行：\n\n```\n:loadview\n```\n\n您的折叠信息都被保留下来了。然而，您需要手动运行 `mkview` 和 `loadview`。我知道，终有一日，我会忘记运行 `mkview` 就关闭文件了，接着便会丢失所有折叠信息。能不能自动实现这个呢？\n\n当然能！要在关闭 `.txt` 文件时自动运行 `mkview`，以及在打开 `.txt` 文件后自动运行 `loadview`，将下列内容添加至您的 vimrc：\n\n```\nautocmd BufWinLeave *.txt mkview\nautocmd BufWinEnter *.txt silent loadview\n```\n\n在上一章您已经见过 `autocmd` 了，它用于在事件触发时执行一条命令。这里的两个事件是：\n- `BufWinLeave` 从窗口中删除缓冲时。\n- `BufWinEnter` 在窗口中加载缓冲时。\n\n现在，即使您在 `.txt` 文件内折叠内容后直接退出 Vim，下次再打开该文件时，您的折叠信息都能自动恢复。\n\n默认情况下，当运行 `mkview` 时，Vim将折叠信息保存在`~/.vim/view` (Unix 系统)。您可以查阅 `:h 'viewdir'` 来了解更多信息。\n\n## 聪明地学习折叠\n\n当我刚开始使用 Vim 时， 我会跳过学习 Vim 折叠，因为我觉得它不太实用。然而，随着我码龄的增长，我越发觉得折叠功能大有用处。得当地使用折叠功能，文本结构可以更加清晰，犹如一本书籍的目录。\n\n当您学习折叠时，请从手动折叠开始，因为它可以随学随用。然后逐渐学习不同的技巧来使用缩进和标志折叠。最后，学习如何使用语法和表达式折叠。您甚至可以使用后两个来编写您自己的 Vim 插件。\n","slug":"Vim/ch17_fold","published":1,"updated":"2022-08-28T07:38:59.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i23002bscvmb9aw71tc","content":"<h1 id=\"第17章-折叠\"><a href=\"#第17章-折叠\" class=\"headerlink\" title=\"第17章 折叠\"></a>第17章 折叠</h1><p>在阅读文件时，经常会有一些不相关的文本会妨碍您理解。使用 Vim 折叠可以隐藏这些不必要的信息。</p>\n<p>本章中，您将学习如何使用不同的折叠方法。</p>\n<h2 id=\"手动折叠\"><a href=\"#手动折叠\" class=\"headerlink\" title=\"手动折叠\"></a>手动折叠</h2><p>想象您正在折叠一张纸来覆盖一些文本，实际的文本不会消失，它仍在那儿。Vim 折叠的工作方式与此相同，它<em>折叠</em>一段文本，在显示时会隐藏起来，但实际上并不会真的删除它。</p>\n<p>折叠操作符是<code>z</code>。（折叠纸张时，它看起来也像字母 “z”）。</p>\n<p>假设有如下文本：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs applescript\">Fold <span class=\"hljs-keyword\">me</span><br>Hold <span class=\"hljs-keyword\">me</span><br></code></pre></td></tr></table></figure>\n\n<p>把光标放在第一行，输入 <code>zfj</code>。Vim 将这两行折叠成一行，同时会看到类似消息：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 2 lines: Fold me -----</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的命令分解如下：</p>\n<ul>\n<li><code>zf</code> 是折叠操作符。</li>\n<li><code>j</code> 是用于折叠操作符的动作。</li>\n</ul>\n<p>您可以使用 <code>zo</code> 打开&#x2F;展开已折叠文本，使用 <code>zc</code> 关闭&#x2F;收缩文本。</p>\n<p>折叠是一个操作符，所以它遵循语法规则（<code>动词+名词</code>）。您可以在折叠运算符后，加上一个动作(motion)或文本对象。例如，使用 <code>zfip</code> 可以折叠内部段落；使用 <code>zfG</code> 可以折叠至文件末尾；使用 <code>zfa&#123;</code> 可以折叠 <code>&#123;</code> 和 <code>&#125;</code> 之间的文本。</p>\n<p>您可以在可视模式下进行折叠。高亮您想要折叠的区域后 (<code>v</code>, <code>V</code>, 或 <code>Ctrl-v</code>)，再输入 <code>zf</code> 即可。</p>\n<p>您也可以在命令行模式下，使用 <code>:fold</code> 命令执行一次折叠。若要折叠当前行及紧随其后的第二行，可以运行：</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coq\">:,+<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">fold</span><br></code></pre></td></tr></table></figure>\n\n<p><code>,+1</code> 是要折叠的范围。如果不传递范围参数，默认当前行。<code>+1</code> 是代表下一行的范围指示器。运行 <code>:5,10fold</code> 可以折叠第5至10行。运行 <code>:,$fold</code> 可以折叠当前行至文件末尾。</p>\n<p>还有许多其他折叠和展开的命令。我发现他们实在太多，以至于在刚起步时很难记住。最有用的一些命令是：</p>\n<ul>\n<li><code>zR</code> 展开所有折叠。</li>\n<li><code>zM</code> 收缩所有折叠。</li>\n<li><code>za</code> 切换折叠状态。</li>\n</ul>\n<p><code>zR</code> 和 <code>zM</code> 可用于任意行上，但 <code>za</code> 仅能用于已折叠&#x2F;未折叠的行上。输入 <code>:h fold-commands</code> 可查阅更多有关折叠的指令。</p>\n<h2 id=\"不同的折叠方法\"><a href=\"#不同的折叠方法\" class=\"headerlink\" title=\"不同的折叠方法\"></a>不同的折叠方法</h2><p>以上部分涵盖了 Vim 手动折叠的内容。实际上，Vim 有六种不同的折叠方法：</p>\n<ol>\n<li>手动折叠</li>\n<li>缩进折叠</li>\n<li>表达式折叠</li>\n<li>语法折叠</li>\n<li>差异折叠</li>\n<li>标志折叠</li>\n</ol>\n<p>运行 <code>:set foldmethod?</code> 可查看您当前正在使用哪一种折叠方式。默认情况下，Vim 使用手动方式。</p>\n<p>在本章的剩余部分，您将学习其他五种折叠方法。让我们从缩进折叠开始。</p>\n<h2 id=\"缩进折叠\"><a href=\"#缩进折叠\" class=\"headerlink\" title=\"缩进折叠\"></a>缩进折叠</h2><p>要使用缩进折叠，需要将 <code>&#39;foldmethod&#39;</code> 选项更改为缩进：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=indent<br></code></pre></td></tr></table></figure>\n\n<p>假设有如下文本：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br>  <span class=\"hljs-keyword\">Two</span><br>  <span class=\"hljs-keyword\">Two</span> again<br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>:set foldmethod=indent</code> 后将看到：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">One</span><br><span class=\"hljs-operator\">+</span><span class=\"hljs-comment\">-- 2 lines: Two -----</span><br></code></pre></td></tr></table></figure>\n\n<p>使用缩进折叠后，Vim 将会查看每行的开头有多少空格，并将它与 <code>&#39;shiftwidth&#39;</code> 选项进行比较，以此来决定该行可折叠性。<code>&#39;shiftwidth&#39;</code> 返回每次缩进所需的空格数。如果运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> shiftwidth?<br></code></pre></td></tr></table></figure>\n\n<p>Vim 的默认 <code>&#39;shiftwidth&#39;</code> 值为2。对于上面的文本而言，”Two” 和 “Two again” 的开头都有两个空格。当 Vim 看到了空格数 <em>且</em> <code>&#39;shiftwidth&#39;</code>值都为2时，Vim 认为该行的缩进折叠级别为1。</p>\n<p>假设这次文本开头只有一个空格：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br> <span class=\"hljs-keyword\">Two</span><br> <span class=\"hljs-keyword\">Two</span> again<br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>:set foldmethod=indent</code> 后，Vim 不再折叠已缩进的行了，因为这些行没有足够的空格。1个空格不会被视作一个缩进。然而，当您改变 <code>&#39;shiftwidth&#39; </code> 的值为1后：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">shiftwidth</span>=1<br></code></pre></td></tr></table></figure>\n\n<p>文本现在可以折叠了！现在一个空格将被视为一个缩进。</p>\n<p>现在，我们将 <code>&#39;shiftwidth&#39; </code> 以及文本开头的空格数都重新恢复为2后，另外添加一些内容：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br>  <span class=\"hljs-keyword\">Two</span><br>  <span class=\"hljs-keyword\">Two</span> again<br>    Three<br>    Three again<br></code></pre></td></tr></table></figure>\n\n<p>运行折叠命令 (<code>zM</code>) 后可以看到：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">One</span><br><span class=\"hljs-operator\">+</span><span class=\"hljs-comment\">-- 4 lines: Two -----</span><br></code></pre></td></tr></table></figure>\n\n<p>展开已折叠的行 (<code>zR</code>)，接着移动光标至 “Three”，然后切换文本的折叠状态 (<code>za</code>)：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br>  <span class=\"hljs-keyword\">Two</span><br>  <span class=\"hljs-keyword\">Two</span> again<br>+-- 2 lines: Three -----<br></code></pre></td></tr></table></figure>\n\n<p>这是啥？叠中叠？</p>\n<p>是的，您可以嵌套折叠。文本 “Two” 和 “Two again” 的折叠级别都为1，文本 “Three” 和 “Three again” 的折叠级别都为2。如果在一段可折叠文本中，具有另一段折叠级别更高的可折叠文本，则可以具有多个折叠层。</p>\n<h2 id=\"表达式折叠\"><a href=\"#表达式折叠\" class=\"headerlink\" title=\"表达式折叠\"></a>表达式折叠</h2><p>表达式折叠允许您定义要匹配折叠的表达式。定义折叠表达式后，Vim 会计算每行的 <code>&#39;foldexpr&#39;</code> 值。这是必须配置的变量，它要返回适当的值。如果返回 0，则不折叠行。如果它返回 1，则该行的折叠级别为 1。如果它返回 2，则该线的折叠级别为 2。除了整数外还有其他的值，但我不打算介绍它们。如果你好奇，可以查阅<code>:h fold-expr</code>。</p>\n<p>首先，更改折叠方法：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=expr<br></code></pre></td></tr></table></figure>\n\n<p>假设您有一份早餐食品列表，并且想要折叠所有以 “p” 开头的早餐项：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">donut<br>pancake<br><span class=\"hljs-keyword\">pop</span>-tarts<br>protein <span class=\"hljs-built_in\">bar</span><br>salmon<br>scrambled eggs<br></code></pre></td></tr></table></figure>\n\n<p>其次，更改 <code>foldexpr</code> 为捕获以 “p” 开头的表达式：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldexpr</span>=getline(v:lnum)[0]==\\\\<span class=\"hljs-string\">&quot;p\\\\&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>这表达式看起来有点吓人。我们来分解下：</p>\n<ul>\n<li><code>:set foldexpr</code> 设置 <code>&#39;foldexpr&#39;</code> 为自定义表达式。</li>\n<li><code>getline()</code> 是 Vim 脚本的一个函数，它返回指定行的内容。如运行 <code>:echo getline(5)</code> 可以获取第5行的内容。</li>\n<li><code>v:lnum</code> 是 Vim <code>&#39;foldexpr&#39;</code> 表达式的特殊变量。Vim 在扫描每一行时，都会将行号存储至 <code>v:lnum</code> 变量。在第5行，<code>v:lnum</code> 值为5。在第10行，<code>v:lnum</code>值为10。</li>\n<li><code>[0]</code> 处于 <code>getline(v:lnum)[0]</code> 语境时，代表每一行的第一个字符。Vim 在扫描某一行时，<code>getline(v:lnum)</code> 返回该行的内容，而 <code>getline(v:lnum)[0]</code> 则返回这一行的第一个字符。例如，我们早餐食品列表的第一行是 “donut”，则 <code>getline(v:lnum)[0]</code> 返回 “d”；列表的第二行是 “pancake”，则 <code>getline(v:lnum)[0]</code> 返回 “p”。</li>\n<li><code>==\\\\&quot;p\\\\&quot;</code> 是等式表达式的后半部分，它检查刚才表达式的计算结果是否等于 “p”。如果是，则返回1，否则返回0。在 Vim 的世界里，1代表真，0代表假。所以，那些以 “p” 开头的行，表达式都会返回1。回想一下本节的开始，如果 <code>&#39;foldexpr&#39;</code> 的值为1，则折叠级别为1。</li>\n</ul>\n<p>在运行这个表达式后，您将看到：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">donut<br>+<span class=\"hljs-comment\">-- 3 lines: pancake -----</span><br>salmon<br>scrambled eggs<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"语法折叠\"><a href=\"#语法折叠\" class=\"headerlink\" title=\"语法折叠\"></a>语法折叠</h2><p>语法折叠是由Vim的语法高亮决定的。如果您使用了语法高亮插件，比如<a href=\"https://github.com/sheerun/vim-polyglot\">vim-polyglot</a>，那么装上插件就可以直接使用语法折叠。仅仅需要将<code>foldmethod</code>选项改为 <code>syntax</code>。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=syntax<br></code></pre></td></tr></table></figure>\n\n<p>假设您正在编辑一个JavaScript文件，而且您已经装好了 vim-polyglot 插件。如果您有以下文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">const nums = [<br>  <span class=\"hljs-literal\">one</span>,<br>  <span class=\"hljs-literal\">two</span>,<br>  <span class=\"hljs-literal\">three</span>,<br>  <span class=\"hljs-literal\">four</span><br>]<br></code></pre></td></tr></table></figure>\n\n<p>上述文本将会使用语法折叠折起来。当您为某个特定语言（位于 <code>syntax/</code> 目录中的语言即是典型例子）定义了语法高亮，您可以添加一个 <code>fold</code> 属性，使它支持折叠。下面是 vim-polyglot 中JavaScript语法文件中的一个片段。注意最后的 <code>fold</code> 关键字。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">syntax region  jsBracket                      <span class=\"hljs-attribute\">matchgroup</span>=jsBrackets            <span class=\"hljs-attribute\">start</span>=/\\[/ <span class=\"hljs-attribute\">end</span>=/\\]/ <span class=\"hljs-attribute\">contains</span>=@jsExpression,jsSpreadExpression extend fold<br></code></pre></td></tr></table></figure>\n\n<p>本书不会详细介绍 <code>syntax</code> 功能。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p>\n<h2 id=\"差异折叠\"><a href=\"#差异折叠\" class=\"headerlink\" title=\"差异折叠\"></a>差异折叠</h2><p>Vim 可以对多个文件进行差异比较。</p>\n<p>如果您有 <code>file1.txt</code>：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br></code></pre></td></tr></table></figure>\n\n<p>以及 <code>file2.txt</code>：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br>emacs <span class=\"hljs-keyword\">is</span> ok<br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>vimdiff file1.txt file2.txt</code>：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">+-- <span class=\"hljs-number\">3</span> lines: <span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome -----<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br>[<span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome] / [emacs <span class=\"hljs-keyword\">is</span> ok]<br></code></pre></td></tr></table></figure>\n\n<p>Vim 会自动折叠一些相同的行。运行 <code>vimdiff</code> 命令时，Vim 会自动使用 <code>foldmethod=diff</code>。此时如果运行 <code>:set foldmethod?</code>，它将返回 <code>diff</code>。</p>\n<h2 id=\"标志折叠\"><a href=\"#标志折叠\" class=\"headerlink\" title=\"标志折叠\"></a>标志折叠</h2><p>要使用标志折叠，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=marker<br></code></pre></td></tr></table></figure>\n\n<p>假设有如下文本：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs handlebars\"><span class=\"language-xml\">Hello</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><span class=\"hljs-template-variable\">&#123;&#123;&#123;</span><br><span class=\"hljs-template-variable\"><span class=\"hljs-name\">world</span></span><br><span class=\"hljs-template-variable\">vim</span><br><span class=\"hljs-template-variable\">&#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>输入 <code>zM</code> 后会看到：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">hello<br><br>+<span class=\"hljs-comment\">-- 4 lines: -----</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 将 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 视为折叠指示器，并折叠其中的内容。使用标志折叠时，Vim 会寻找由 <code>&#39;foldmarker&#39;</code> 选项定义的特殊标志，并标记折叠区域。要查看 Vim 使用的标志，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> foldmarker?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下，Vim 把 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 作为指示器。如果您想将指示器更改为其他诸如 “coffee1” 和 “coffee2” 的字符串，可以运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmarker</span>=coffee1,coffee2<br></code></pre></td></tr></table></figure>\n\n<p>假设有如下文本：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">hello</span><br><br>coffee1<br>world<br>vim<br>coffee2<br></code></pre></td></tr></table></figure>\n\n<p>现在，Vim 将使用 <code>coffee1</code> 和 <code>coffee2</code> 作为新折叠标志。注意，指示器必须是文本字符串，不能是正则表达式。</p>\n<h2 id=\"持久化折叠\"><a href=\"#持久化折叠\" class=\"headerlink\" title=\"持久化折叠\"></a>持久化折叠</h2><p>当关闭 Vim 会话后，您将失去所有的折叠信息。假设您有 <code>count.txt</code> 文件：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br><span class=\"hljs-literal\">four</span><br><span class=\"hljs-literal\">five</span><br></code></pre></td></tr></table></figure>\n\n<p>手动从第三行开始往下折叠 (<code>:3,$fold</code>)：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br>+<span class=\"hljs-comment\">-- 3 lines: three ---</span><br></code></pre></td></tr></table></figure>\n\n<p>当您退出 Vim 再重新打开 <code>count.txt</code> 后，这些折叠都不见了！</p>\n<p>要在折叠后保留它们，可以运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span><br></code></pre></td></tr></table></figure>\n\n<p>当打开 <code>count.txt</code> 后，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>您的折叠信息都被保留下来了。然而，您需要手动运行 <code>mkview</code> 和 <code>loadview</code>。我知道，终有一日，我会忘记运行 <code>mkview</code> 就关闭文件了，接着便会丢失所有折叠信息。能不能自动实现这个呢？</p>\n<p>当然能！要在关闭 <code>.txt</code> 文件时自动运行 <code>mkview</code>，以及在打开 <code>.txt</code> 文件后自动运行 <code>loadview</code>，将下列内容添加至您的 vimrc：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">autocmd</span> BufWinLeave *.txt <span class=\"hljs-keyword\">mkview</span><br><span class=\"hljs-keyword\">autocmd</span> BufWinEnter *.txt <span class=\"hljs-keyword\">silent</span> <span class=\"hljs-keyword\">loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>在上一章您已经见过 <code>autocmd</code> 了，它用于在事件触发时执行一条命令。这里的两个事件是：</p>\n<ul>\n<li><code>BufWinLeave</code> 从窗口中删除缓冲时。</li>\n<li><code>BufWinEnter</code> 在窗口中加载缓冲时。</li>\n</ul>\n<p>现在，即使您在 <code>.txt</code> 文件内折叠内容后直接退出 Vim，下次再打开该文件时，您的折叠信息都能自动恢复。</p>\n<p>默认情况下，当运行 <code>mkview</code> 时，Vim将折叠信息保存在<code>~/.vim/view</code> (Unix 系统)。您可以查阅 <code>:h &#39;viewdir&#39;</code> 来了解更多信息。</p>\n<h2 id=\"聪明地学习折叠\"><a href=\"#聪明地学习折叠\" class=\"headerlink\" title=\"聪明地学习折叠\"></a>聪明地学习折叠</h2><p>当我刚开始使用 Vim 时， 我会跳过学习 Vim 折叠，因为我觉得它不太实用。然而，随着我码龄的增长，我越发觉得折叠功能大有用处。得当地使用折叠功能，文本结构可以更加清晰，犹如一本书籍的目录。</p>\n<p>当您学习折叠时，请从手动折叠开始，因为它可以随学随用。然后逐渐学习不同的技巧来使用缩进和标志折叠。最后，学习如何使用语法和表达式折叠。您甚至可以使用后两个来编写您自己的 Vim 插件。</p>\n","site":{"data":{}},"wordcount":5200,"excerpt":"","more":"<h1 id=\"第17章-折叠\"><a href=\"#第17章-折叠\" class=\"headerlink\" title=\"第17章 折叠\"></a>第17章 折叠</h1><p>在阅读文件时，经常会有一些不相关的文本会妨碍您理解。使用 Vim 折叠可以隐藏这些不必要的信息。</p>\n<p>本章中，您将学习如何使用不同的折叠方法。</p>\n<h2 id=\"手动折叠\"><a href=\"#手动折叠\" class=\"headerlink\" title=\"手动折叠\"></a>手动折叠</h2><p>想象您正在折叠一张纸来覆盖一些文本，实际的文本不会消失，它仍在那儿。Vim 折叠的工作方式与此相同，它<em>折叠</em>一段文本，在显示时会隐藏起来，但实际上并不会真的删除它。</p>\n<p>折叠操作符是<code>z</code>。（折叠纸张时，它看起来也像字母 “z”）。</p>\n<p>假设有如下文本：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">Fold <span class=\"hljs-keyword\">me</span><br>Hold <span class=\"hljs-keyword\">me</span><br></code></pre></td></tr></table></figure>\n\n<p>把光标放在第一行，输入 <code>zfj</code>。Vim 将这两行折叠成一行，同时会看到类似消息：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 2 lines: Fold me -----</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的命令分解如下：</p>\n<ul>\n<li><code>zf</code> 是折叠操作符。</li>\n<li><code>j</code> 是用于折叠操作符的动作。</li>\n</ul>\n<p>您可以使用 <code>zo</code> 打开&#x2F;展开已折叠文本，使用 <code>zc</code> 关闭&#x2F;收缩文本。</p>\n<p>折叠是一个操作符，所以它遵循语法规则（<code>动词+名词</code>）。您可以在折叠运算符后，加上一个动作(motion)或文本对象。例如，使用 <code>zfip</code> 可以折叠内部段落；使用 <code>zfG</code> 可以折叠至文件末尾；使用 <code>zfa&#123;</code> 可以折叠 <code>&#123;</code> 和 <code>&#125;</code> 之间的文本。</p>\n<p>您可以在可视模式下进行折叠。高亮您想要折叠的区域后 (<code>v</code>, <code>V</code>, 或 <code>Ctrl-v</code>)，再输入 <code>zf</code> 即可。</p>\n<p>您也可以在命令行模式下，使用 <code>:fold</code> 命令执行一次折叠。若要折叠当前行及紧随其后的第二行，可以运行：</p>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs coq\">:,+<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">fold</span><br></code></pre></td></tr></table></figure>\n\n<p><code>,+1</code> 是要折叠的范围。如果不传递范围参数，默认当前行。<code>+1</code> 是代表下一行的范围指示器。运行 <code>:5,10fold</code> 可以折叠第5至10行。运行 <code>:,$fold</code> 可以折叠当前行至文件末尾。</p>\n<p>还有许多其他折叠和展开的命令。我发现他们实在太多，以至于在刚起步时很难记住。最有用的一些命令是：</p>\n<ul>\n<li><code>zR</code> 展开所有折叠。</li>\n<li><code>zM</code> 收缩所有折叠。</li>\n<li><code>za</code> 切换折叠状态。</li>\n</ul>\n<p><code>zR</code> 和 <code>zM</code> 可用于任意行上，但 <code>za</code> 仅能用于已折叠&#x2F;未折叠的行上。输入 <code>:h fold-commands</code> 可查阅更多有关折叠的指令。</p>\n<h2 id=\"不同的折叠方法\"><a href=\"#不同的折叠方法\" class=\"headerlink\" title=\"不同的折叠方法\"></a>不同的折叠方法</h2><p>以上部分涵盖了 Vim 手动折叠的内容。实际上，Vim 有六种不同的折叠方法：</p>\n<ol>\n<li>手动折叠</li>\n<li>缩进折叠</li>\n<li>表达式折叠</li>\n<li>语法折叠</li>\n<li>差异折叠</li>\n<li>标志折叠</li>\n</ol>\n<p>运行 <code>:set foldmethod?</code> 可查看您当前正在使用哪一种折叠方式。默认情况下，Vim 使用手动方式。</p>\n<p>在本章的剩余部分，您将学习其他五种折叠方法。让我们从缩进折叠开始。</p>\n<h2 id=\"缩进折叠\"><a href=\"#缩进折叠\" class=\"headerlink\" title=\"缩进折叠\"></a>缩进折叠</h2><p>要使用缩进折叠，需要将 <code>&#39;foldmethod&#39;</code> 选项更改为缩进：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=indent<br></code></pre></td></tr></table></figure>\n\n<p>假设有如下文本：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br>  <span class=\"hljs-keyword\">Two</span><br>  <span class=\"hljs-keyword\">Two</span> again<br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>:set foldmethod=indent</code> 后将看到：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">One</span><br><span class=\"hljs-operator\">+</span><span class=\"hljs-comment\">-- 2 lines: Two -----</span><br></code></pre></td></tr></table></figure>\n\n<p>使用缩进折叠后，Vim 将会查看每行的开头有多少空格，并将它与 <code>&#39;shiftwidth&#39;</code> 选项进行比较，以此来决定该行可折叠性。<code>&#39;shiftwidth&#39;</code> 返回每次缩进所需的空格数。如果运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> shiftwidth?<br></code></pre></td></tr></table></figure>\n\n<p>Vim 的默认 <code>&#39;shiftwidth&#39;</code> 值为2。对于上面的文本而言，”Two” 和 “Two again” 的开头都有两个空格。当 Vim 看到了空格数 <em>且</em> <code>&#39;shiftwidth&#39;</code>值都为2时，Vim 认为该行的缩进折叠级别为1。</p>\n<p>假设这次文本开头只有一个空格：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br> <span class=\"hljs-keyword\">Two</span><br> <span class=\"hljs-keyword\">Two</span> again<br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>:set foldmethod=indent</code> 后，Vim 不再折叠已缩进的行了，因为这些行没有足够的空格。1个空格不会被视作一个缩进。然而，当您改变 <code>&#39;shiftwidth&#39; </code> 的值为1后：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">shiftwidth</span>=1<br></code></pre></td></tr></table></figure>\n\n<p>文本现在可以折叠了！现在一个空格将被视为一个缩进。</p>\n<p>现在，我们将 <code>&#39;shiftwidth&#39; </code> 以及文本开头的空格数都重新恢复为2后，另外添加一些内容：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br>  <span class=\"hljs-keyword\">Two</span><br>  <span class=\"hljs-keyword\">Two</span> again<br>    Three<br>    Three again<br></code></pre></td></tr></table></figure>\n\n<p>运行折叠命令 (<code>zM</code>) 后可以看到：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">One</span><br><span class=\"hljs-operator\">+</span><span class=\"hljs-comment\">-- 4 lines: Two -----</span><br></code></pre></td></tr></table></figure>\n\n<p>展开已折叠的行 (<code>zR</code>)，接着移动光标至 “Three”，然后切换文本的折叠状态 (<code>za</code>)：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">One</span><br>  <span class=\"hljs-keyword\">Two</span><br>  <span class=\"hljs-keyword\">Two</span> again<br>+-- 2 lines: Three -----<br></code></pre></td></tr></table></figure>\n\n<p>这是啥？叠中叠？</p>\n<p>是的，您可以嵌套折叠。文本 “Two” 和 “Two again” 的折叠级别都为1，文本 “Three” 和 “Three again” 的折叠级别都为2。如果在一段可折叠文本中，具有另一段折叠级别更高的可折叠文本，则可以具有多个折叠层。</p>\n<h2 id=\"表达式折叠\"><a href=\"#表达式折叠\" class=\"headerlink\" title=\"表达式折叠\"></a>表达式折叠</h2><p>表达式折叠允许您定义要匹配折叠的表达式。定义折叠表达式后，Vim 会计算每行的 <code>&#39;foldexpr&#39;</code> 值。这是必须配置的变量，它要返回适当的值。如果返回 0，则不折叠行。如果它返回 1，则该行的折叠级别为 1。如果它返回 2，则该线的折叠级别为 2。除了整数外还有其他的值，但我不打算介绍它们。如果你好奇，可以查阅<code>:h fold-expr</code>。</p>\n<p>首先，更改折叠方法：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=expr<br></code></pre></td></tr></table></figure>\n\n<p>假设您有一份早餐食品列表，并且想要折叠所有以 “p” 开头的早餐项：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">donut<br>pancake<br><span class=\"hljs-keyword\">pop</span>-tarts<br>protein <span class=\"hljs-built_in\">bar</span><br>salmon<br>scrambled eggs<br></code></pre></td></tr></table></figure>\n\n<p>其次，更改 <code>foldexpr</code> 为捕获以 “p” 开头的表达式：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldexpr</span>=getline(v:lnum)[0]==\\\\<span class=\"hljs-string\">&quot;p\\\\&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>这表达式看起来有点吓人。我们来分解下：</p>\n<ul>\n<li><code>:set foldexpr</code> 设置 <code>&#39;foldexpr&#39;</code> 为自定义表达式。</li>\n<li><code>getline()</code> 是 Vim 脚本的一个函数，它返回指定行的内容。如运行 <code>:echo getline(5)</code> 可以获取第5行的内容。</li>\n<li><code>v:lnum</code> 是 Vim <code>&#39;foldexpr&#39;</code> 表达式的特殊变量。Vim 在扫描每一行时，都会将行号存储至 <code>v:lnum</code> 变量。在第5行，<code>v:lnum</code> 值为5。在第10行，<code>v:lnum</code>值为10。</li>\n<li><code>[0]</code> 处于 <code>getline(v:lnum)[0]</code> 语境时，代表每一行的第一个字符。Vim 在扫描某一行时，<code>getline(v:lnum)</code> 返回该行的内容，而 <code>getline(v:lnum)[0]</code> 则返回这一行的第一个字符。例如，我们早餐食品列表的第一行是 “donut”，则 <code>getline(v:lnum)[0]</code> 返回 “d”；列表的第二行是 “pancake”，则 <code>getline(v:lnum)[0]</code> 返回 “p”。</li>\n<li><code>==\\\\&quot;p\\\\&quot;</code> 是等式表达式的后半部分，它检查刚才表达式的计算结果是否等于 “p”。如果是，则返回1，否则返回0。在 Vim 的世界里，1代表真，0代表假。所以，那些以 “p” 开头的行，表达式都会返回1。回想一下本节的开始，如果 <code>&#39;foldexpr&#39;</code> 的值为1，则折叠级别为1。</li>\n</ul>\n<p>在运行这个表达式后，您将看到：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">donut<br>+<span class=\"hljs-comment\">-- 3 lines: pancake -----</span><br>salmon<br>scrambled eggs<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"语法折叠\"><a href=\"#语法折叠\" class=\"headerlink\" title=\"语法折叠\"></a>语法折叠</h2><p>语法折叠是由Vim的语法高亮决定的。如果您使用了语法高亮插件，比如<a href=\"https://github.com/sheerun/vim-polyglot\">vim-polyglot</a>，那么装上插件就可以直接使用语法折叠。仅仅需要将<code>foldmethod</code>选项改为 <code>syntax</code>。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=syntax<br></code></pre></td></tr></table></figure>\n\n<p>假设您正在编辑一个JavaScript文件，而且您已经装好了 vim-polyglot 插件。如果您有以下文本：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">const nums = [<br>  <span class=\"hljs-literal\">one</span>,<br>  <span class=\"hljs-literal\">two</span>,<br>  <span class=\"hljs-literal\">three</span>,<br>  <span class=\"hljs-literal\">four</span><br>]<br></code></pre></td></tr></table></figure>\n\n<p>上述文本将会使用语法折叠折起来。当您为某个特定语言（位于 <code>syntax/</code> 目录中的语言即是典型例子）定义了语法高亮，您可以添加一个 <code>fold</code> 属性，使它支持折叠。下面是 vim-polyglot 中JavaScript语法文件中的一个片段。注意最后的 <code>fold</code> 关键字。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">syntax region  jsBracket                      <span class=\"hljs-attribute\">matchgroup</span>=jsBrackets            <span class=\"hljs-attribute\">start</span>=/\\[/ <span class=\"hljs-attribute\">end</span>=/\\]/ <span class=\"hljs-attribute\">contains</span>=@jsExpression,jsSpreadExpression extend fold<br></code></pre></td></tr></table></figure>\n\n<p>本书不会详细介绍 <code>syntax</code> 功能。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p>\n<h2 id=\"差异折叠\"><a href=\"#差异折叠\" class=\"headerlink\" title=\"差异折叠\"></a>差异折叠</h2><p>Vim 可以对多个文件进行差异比较。</p>\n<p>如果您有 <code>file1.txt</code>：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br></code></pre></td></tr></table></figure>\n\n<p>以及 <code>file2.txt</code>：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br>emacs <span class=\"hljs-keyword\">is</span> ok<br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>vimdiff file1.txt file2.txt</code>：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">+-- <span class=\"hljs-number\">3</span> lines: <span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome -----<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br><span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome<br>[<span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">is</span> awesome] / [emacs <span class=\"hljs-keyword\">is</span> ok]<br></code></pre></td></tr></table></figure>\n\n<p>Vim 会自动折叠一些相同的行。运行 <code>vimdiff</code> 命令时，Vim 会自动使用 <code>foldmethod=diff</code>。此时如果运行 <code>:set foldmethod?</code>，它将返回 <code>diff</code>。</p>\n<h2 id=\"标志折叠\"><a href=\"#标志折叠\" class=\"headerlink\" title=\"标志折叠\"></a>标志折叠</h2><p>要使用标志折叠，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmethod</span>=marker<br></code></pre></td></tr></table></figure>\n\n<p>假设有如下文本：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs handlebars\"><span class=\"language-xml\">Hello</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><span class=\"hljs-template-variable\">&#123;&#123;&#123;</span><br><span class=\"hljs-template-variable\"><span class=\"hljs-name\">world</span></span><br><span class=\"hljs-template-variable\">vim</span><br><span class=\"hljs-template-variable\">&#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>输入 <code>zM</code> 后会看到：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">hello<br><br>+<span class=\"hljs-comment\">-- 4 lines: -----</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 将 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 视为折叠指示器，并折叠其中的内容。使用标志折叠时，Vim 会寻找由 <code>&#39;foldmarker&#39;</code> 选项定义的特殊标志，并标记折叠区域。要查看 Vim 使用的标志，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> foldmarker?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下，Vim 把 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 作为指示器。如果您想将指示器更改为其他诸如 “coffee1” 和 “coffee2” 的字符串，可以运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">foldmarker</span>=coffee1,coffee2<br></code></pre></td></tr></table></figure>\n\n<p>假设有如下文本：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">hello</span><br><br>coffee1<br>world<br>vim<br>coffee2<br></code></pre></td></tr></table></figure>\n\n<p>现在，Vim 将使用 <code>coffee1</code> 和 <code>coffee2</code> 作为新折叠标志。注意，指示器必须是文本字符串，不能是正则表达式。</p>\n<h2 id=\"持久化折叠\"><a href=\"#持久化折叠\" class=\"headerlink\" title=\"持久化折叠\"></a>持久化折叠</h2><p>当关闭 Vim 会话后，您将失去所有的折叠信息。假设您有 <code>count.txt</code> 文件：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br><span class=\"hljs-literal\">three</span><br><span class=\"hljs-literal\">four</span><br><span class=\"hljs-literal\">five</span><br></code></pre></td></tr></table></figure>\n\n<p>手动从第三行开始往下折叠 (<code>:3,$fold</code>)：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\"><span class=\"hljs-literal\">one</span><br><span class=\"hljs-literal\">two</span><br>+<span class=\"hljs-comment\">-- 3 lines: three ---</span><br></code></pre></td></tr></table></figure>\n\n<p>当您退出 Vim 再重新打开 <code>count.txt</code> 后，这些折叠都不见了！</p>\n<p>要在折叠后保留它们，可以运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span><br></code></pre></td></tr></table></figure>\n\n<p>当打开 <code>count.txt</code> 后，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>您的折叠信息都被保留下来了。然而，您需要手动运行 <code>mkview</code> 和 <code>loadview</code>。我知道，终有一日，我会忘记运行 <code>mkview</code> 就关闭文件了，接着便会丢失所有折叠信息。能不能自动实现这个呢？</p>\n<p>当然能！要在关闭 <code>.txt</code> 文件时自动运行 <code>mkview</code>，以及在打开 <code>.txt</code> 文件后自动运行 <code>loadview</code>，将下列内容添加至您的 vimrc：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">autocmd</span> BufWinLeave *.txt <span class=\"hljs-keyword\">mkview</span><br><span class=\"hljs-keyword\">autocmd</span> BufWinEnter *.txt <span class=\"hljs-keyword\">silent</span> <span class=\"hljs-keyword\">loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>在上一章您已经见过 <code>autocmd</code> 了，它用于在事件触发时执行一条命令。这里的两个事件是：</p>\n<ul>\n<li><code>BufWinLeave</code> 从窗口中删除缓冲时。</li>\n<li><code>BufWinEnter</code> 在窗口中加载缓冲时。</li>\n</ul>\n<p>现在，即使您在 <code>.txt</code> 文件内折叠内容后直接退出 Vim，下次再打开该文件时，您的折叠信息都能自动恢复。</p>\n<p>默认情况下，当运行 <code>mkview</code> 时，Vim将折叠信息保存在<code>~/.vim/view</code> (Unix 系统)。您可以查阅 <code>:h &#39;viewdir&#39;</code> 来了解更多信息。</p>\n<h2 id=\"聪明地学习折叠\"><a href=\"#聪明地学习折叠\" class=\"headerlink\" title=\"聪明地学习折叠\"></a>聪明地学习折叠</h2><p>当我刚开始使用 Vim 时， 我会跳过学习 Vim 折叠，因为我觉得它不太实用。然而，随着我码龄的增长，我越发觉得折叠功能大有用处。得当地使用折叠功能，文本结构可以更加清晰，犹如一本书籍的目录。</p>\n<p>当您学习折叠时，请从手动折叠开始，因为它可以随学随用。然后逐渐学习不同的技巧来使用缩进和标志折叠。最后，学习如何使用语法和表达式折叠。您甚至可以使用后两个来编写您自己的 Vim 插件。</p>\n"},{"title":"VIM-Git","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第18章 Git\n\nVim 和 Git 是两种实现不同功能的伟大工具。Vim 用于文本编辑，Git 用于版本控制。\n\n在本章中，您将学习如何将 Vim 和 Git 集成在一起。\n\n## 差异比较\n\n在上一章中，您看到了如何运行 `vimdiff` 命令以显示多个文件之间的差异。\n\n假设您有两个文件，`file1.txt` 和 `file2.txt`。\n\n`file1.txt` 的内容如下：\n\n```\npancakes\nwaffles\napples\n\nmilk\napple juice\n\nyogurt\n```\n\n`file2.txt` 的内容如下：\n\n```\npancakes\nwaffles\noranges\n\nmilk\norange juice\n\nyogurt\n```\n\n若要查看两个文件之间的差异，请运行：\n\n```\nvimdiff file1.txt file2.txt\n```\n\n或者也可以运行：\n\n```\nvim -d file1.txt file2.txt\n```\n\n<p align=\"center\">\n  <img alt=\"Basic diffing with Vim\" width=\"900\" height=\"auto\" src=\"images/diffing-basic.png\">\n</p>\n\n`vimdiff` 并排显示两个缓冲区。左边是 `file1.txt`，右边是 `file2.txt`。不同的两行（apples 和 oranges）会被高亮显示。\n\n假设您要使第二个缓冲区相应位置变成 apples，而不是 oranges。若想从 `file1.txt` 传输您当前位置（当前您在 `file1.txt`）的内容到 `file2.txt`，首先使用 `]c` 跳转到下一处差异（使用 `[c` 可跳回上一处差异），现在光标应该在 apples 上了。接着运行 `:diffput`。此时，这两个文件都是 apples 了。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/diffing-apples.png\">\n</p>\n\n如果您想从另一个缓冲区（orange juice，`file2.txt`）传输文本来替代当前缓冲区（apple juice，`file1.txt`），让您的光标仍然位于 `file1.txt` 的窗口中，首先使用 `]c` 跳转至下一处差异，此时光标应该在 apple juice 上。接着运行 `:diffget` 获取另一个缓冲区的 orange juice 来替代当前缓冲区中的 apple juice。\n\n`:diffput` 将文本从当前缓冲区 *输出* 到另一个缓冲区。`:diffget` 从另一个缓冲区 *获取* 文本到当前缓冲区。\n\n如果有多个缓冲区，可以运行 `:diffput fileN.txt` 和 `:diffget fileN.txt` 来指定目标缓冲区 fileN。\n\n## 使用 Vim 作为合并工具\n\n> “我非常喜欢解决合并冲突。” ——佚名\n\n我不知道有谁喜欢解决合并冲突，但总之，合并冲突是无法避免的。在本节中，您将学习如何利用 Vim 作为解决合并冲突的工具。\n\n首先，运行下列命令来将默认合并工具更改为 `vimdiff`：\n\n```\ngit config merge.tool vimdiff\ngit config merge.conflictstyle diff3\ngit config mergetool.prompt false\n```\n\n或者您也可以直接修改 `~/.gitconfig`（默认情况下，它应该处于根目录中，但您的可能在不同的位置）。上面的命令应该会将您的 `gitconfig` 改成如下设置的样子，如果您还没有运行上面的命令，您也可以手动更改您的 gitconfig。\n\n```\n[core]\n  editor = vim\n[merge]\n  tool = vimdiff\n  conflictstyle = diff3\n[difftool]\n  prompt = false\n```\n\n让我们创建一个假的合并冲突来测试一下。首先创建一个目录 `/food`，并初始化 git 仓库：\n\n```\ngit init\n```\n\n添加 `breakfast.txt` 文件，内容为：\n\n```\npancakes\nwaffles\noranges\n```\n\n添加文件并提交它：\n\n```\ngit add .\ngit commit -m \"Initial breakfast commit\"\n```\n\n接着，创建一个新分支 apples：\n\n```\ngit checkout -b apples\n```\n\n更改 `breakfast.txt` 文件为：\n\n```\npancakes\nwaffles\napples\n```\n\n保存文件，添加并提交更改：\n\n```\ngit add .\ngit commit -m \"Apples not oranges\"\n```\n\n真棒！现在 master 分支有 oranges，而 apples 分支有 apples。接着回到 master 分支：\n\n```\ngit checkout master\n```\n\n在 `breakfast.txt` 文件中，您应该能看到原来的文本 oranges。接着将它改成 grapes，因为它是现在的应季水果：\n\n```\npancakes\nwaffles\ngrapes\n```\n\n保存、添加、提交：\n\n```\ngit add .\ngit commit -m \"Grapes not oranges\"\n```\n\n嚯！这么多步骤！现在准备要将 apples 分支合并进 master 分支了：\n\n```\ngit merge apples\n```\n\n您应该会看到如下错误：\n\n```\nAuto-merging breakfast.txt\nCONFLICT (content): Merge conflict in breakfast.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n没错，一个冲突！现在一起来用一下新配置的 `mergetool` 来解决冲突吧！运行：\n\n```\ngit mergetool\n```\n\n<p align=\"center\">\n  <img alt=\"Three-way mergetool with Vim\" width=\"900\" height=\"auto\" src=\"images/mergetool-initial.png\">\n</p>\n\nVim 显示了四个窗口。注意一下顶部三个：\n\n- `LOCAL` 包含了 `grapes`。这是“本地”中的变化，也是您要合并的内容。\n- `BASE` 包含了 `oranges`。这是 `LOCAL` 和 `REMOTE` 的共同祖先，用于比较它们之间的分歧。\n- `REMOTE` 包含了 `apples`。这是要被合并的内容。\n\n底部窗口（也即第四个窗口），您能看到：\n\n```\npancakes\nwaffles\n<<<<<<< HEAD\ngrapes\n||||||| db63958\noranges\n=======\napples\n>>>>>>> apples\n```\n\n第四个窗口包含了合并冲突文本。有了这步设置，就能更轻松看到哪个环境发生了什么变化。您可以同时查看 `LOCAL`、`BASE` 和 `REMOTE` 的内容。\n\n您的光标应该在第四个窗口的高亮区域。再运行 `:diffget LOCAL`，就可以*获取*来自 `LOCAL` 的改变（grapes）。同样，运行 `:diffget BASE` 可以获取来自 `BASE` 的改变（oranges），而运行 `:diffget REMOTE` 可以获取来自 `REMOTE` 的改变（apples）。\n\n在这个例子中，我们试着获取来自 `LOCAL` 的改变。运行 `:diffget LO`（`LOCAL` 的简写），第四个窗口变成了 grapes。完成后，就可以保存并退出所有文件（`:wqall`）了。还不错吧？\n\n稍加留意您会发现，现在多了一个 `breakfast.txt.orig` 文件。这是 Git 防止事与愿违而创建的备份文件。如果您不希望 Git 在合并期间创建备份文件，可以运行：\n\n```\ngit config --global mergetool.keepBackup false\n```\n\n## 在 Vim 中使用 Git\n\nVim 本身没有集成 Git，要在 Vim 中执行 Git 命令，一种方法是在命令行模式中使用 `!` 叹号运算符。\n\n使用 `!` 可以运行任何 Git 命令：\n\n```\n:!git status\n:!git commit\n:!git diff\n:!git push origin master\n```\n\n您还可以使用 Vim 的特殊字符 `%` (当前缓冲区) 或 `#` (其他缓冲区)：\n\n```\n:!git add %         \" git add current file\n:!git checkout #    \" git checkout the other file\n```\n\n这里有一个Vim技巧，您可以用来添加不同Vim窗口中的多个文件，运行：\n\n```\nwindo !git add %\n```\n\n然后提交：\n\n```\n:!git commit \"添加了Vim窗口中的所有文件，酷\"\n```\n\n`windo`命令是VIm的 \"do\" 命令其中之一，类似于您前面看到的 `argdo` 。`windo` 将命令执行在每一个窗口中。\n\n## 插件\n\n这里有很多提供git支持的Vim插件。以下是 Vim 中较流行的 Git 相关插件列表（您读到这篇文章时可能又有更多）：\n\n- [vim-gitgutter](https://github.com/airblade/vim-gitgutter)\n- [vim-signify](https://github.com/mhinz/vim-signify)\n- [vim-fugitive](https://github.com/tpope/vim-fugitive)\n- [gv.vim](https://github.com/junegunn/gv.vim)\n- [vimagit](https://github.com/jreybert/vimagit)\n- [vim-twiggy](https://github.com/sodapopcan/vim-twiggy)\n- [rhubarb](https://github.com/tpope/vim-rhubarb)\n\n其中最流行的是 vim-fugitive。本章的剩余部分，我将使用此插件来介绍几个 git 工作流。\n\n## Vim-Fugitive\n\nvim-fugitive 插件允许您在不离开 Vim 编辑器的情况下运行 git 命令行界面。您会发现，有些命令在 Vim 内部执行时会更好。\n\n开始前，请先使用 Vim 插件管理器（[vim-plug](https://github.com/junegunn/vim-plug)、[vundle](https://github.com/VundleVim/Vundle.vim)、[dein.vim](https://github.com/Shougo/dein.vim) 等）安装 vim-fugitive。\n\n## Git Status\n\n当您不带参数地运行 `:Git` 命令时，vim-fugitive 将显示一个 git 概要窗口，它显示了未跟踪、未暂存和已暂存的文件。在此 “`git status`” 模式下，您可以做一些操作：\n\n- `Ctrl-n` / `Ctrl-p` 转到下一个 / 上一个文件。\n- `-` 暂存或取消暂存光标处的文件。\n- `s` 暂存光标处的文件。\n- `u` 取消暂存光标处的文件。\n- `>` / `<` 内联显示或隐藏光标处文件的差异变化。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git.png\">\n</p>\n\n查阅 `:h fugitive-staging-maps` 可获得更多信息。\n\n## Git Blame\n\n在当前文件运行 `:Git blame` 命令，vim-fugitive 可以显示一个拆分的问责窗口。这有助于追踪那些 BUG 是谁写的，接着就可以冲他/她怒吼（开个玩笑）。\n\n在  `\"git blame\"` 模式下您可以做：\n\n- `q` 关闭问责窗口。\n- `A` 调整作者列大小。\n- `C` 调整提交列大小。\n- `D` 调整日期/时间列大小。\n\n查阅 `:h :Git_blame` 可获得更多信息。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-blame.png\">\n</p>\n\n## Gdiffsplit\n\n当您运行 `:Gdiffsplit` 命令后，vim-fugitive 会执行 `vimdiff`，比对索引或工作树中的版本与当前文件最新更改的区别。如果运行 `:Gdiffsplit <commit>`，vim-fugitive 则会根据 `<commit>` 中的版本来执行 `vimdiff`。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-gdiffsplit.png\">\n</p>\n\n由于您处于 `vimdiff` 模式中，因此您可以使用 `:diffput` 和 `:diffget` 来 *获取* 或 *输出* 差异。\n\n## Gwrite 和 Gread\n\n当您在更改文件后运行 `:Gwrite` 命令，vim-fugitive 将暂存更改，就像运行 `git add <current-file>` 一样。\n\n当您在更改文件后运行 `:Gread` 命令，vim-fugitive 会将文件还原至更改前的状态，就像运行 `git checkout <current-file>` 一样。使用 `:Gread` 还有一个好处是操作可撤销。如果在运行 `:Gread` 后您改变主意，想要保留原来的更改，您只需要撤消（`u`），Vim 将撤回 `:Gread` 操作。要换作是在命令行中运行 `git checkout <current-file>`，就完成不了这种操作了。\n\n## Gclog\n\n当您运行 `:Gclog` 命令时，vim-fugitive 将显示提交历史记录，就像运行 `git log` 命令一样。Vim-fugitive 使用 Vim 的 quickfix 来完成此任务，因此您可以使用 `:cnext` 和 `:cprevious` 来遍历下一个或上一个日志信息。您还可以使用 `:copen` 和 `:cclose` 打开或关闭日志列表。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-log.png\">\n</p>\n\n在 `\"git log\"` 模式中，您可以做两件事：\n- 查看树。\n- 访问父级（上一个提交）。\n\n您可以像 `git log` 命令一样，传递参数给 `:Gclog` 命令。如果您项目的提交历史记录很长，只想看最后三个提交，则可以运行 `:Gclog -3`。如果需要根据提交日期来筛选记录，可以运行类似 `:Gclog --after=\"January 1\" --before=\"March 14\"` 的命令。\n\n## Vim-Fugitive 的更多功能\n\n以上只是寥寥几个 vim-fugitive 功能的例子，您可以查阅 `:h fugitive.txt` 来了解更多有关 vim-fugitive 的信息。大多数流行的 git 命令可能都有 vim-fugitive 的优化版本，您只需在文档中查找它们。\n\n如果您处于 vim-fugitive 的“特殊模式”（如 `:Git` 或 `:Git blame` 模式）中，按下 `g?` 可以了解当前有哪些可用的快捷键，Vim-fugitive 将为您所处的模式显示相应的 `:help` 窗口。棒极了！\n\n## 聪明地学习 Vim 和 Git\n\n每个人都有不同的 git 工作流，可能 vim-fugitive 非常合适您的工作流（也可能不适合）。总之，我强烈建议您试试上面列出的所有插件。可能还有一些其他的我没有列出来，都可以去试一试。\n\n要让Vim-git的集成工作得更好，一个显而易见的办法就是去深入了解git。Git 本身是一个很庞大的主题，我只向您展示了它其中很小的一部分。好了，接下来谈谈如何使用 Vim 编译您的代码。\n","source":"_posts/Vim/ch18_git.md","raw":"---\ntitle: VIM-Git\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\n  - [Git]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第18章 Git\n\nVim 和 Git 是两种实现不同功能的伟大工具。Vim 用于文本编辑，Git 用于版本控制。\n\n在本章中，您将学习如何将 Vim 和 Git 集成在一起。\n\n## 差异比较\n\n在上一章中，您看到了如何运行 `vimdiff` 命令以显示多个文件之间的差异。\n\n假设您有两个文件，`file1.txt` 和 `file2.txt`。\n\n`file1.txt` 的内容如下：\n\n```\npancakes\nwaffles\napples\n\nmilk\napple juice\n\nyogurt\n```\n\n`file2.txt` 的内容如下：\n\n```\npancakes\nwaffles\noranges\n\nmilk\norange juice\n\nyogurt\n```\n\n若要查看两个文件之间的差异，请运行：\n\n```\nvimdiff file1.txt file2.txt\n```\n\n或者也可以运行：\n\n```\nvim -d file1.txt file2.txt\n```\n\n<p align=\"center\">\n  <img alt=\"Basic diffing with Vim\" width=\"900\" height=\"auto\" src=\"images/diffing-basic.png\">\n</p>\n\n`vimdiff` 并排显示两个缓冲区。左边是 `file1.txt`，右边是 `file2.txt`。不同的两行（apples 和 oranges）会被高亮显示。\n\n假设您要使第二个缓冲区相应位置变成 apples，而不是 oranges。若想从 `file1.txt` 传输您当前位置（当前您在 `file1.txt`）的内容到 `file2.txt`，首先使用 `]c` 跳转到下一处差异（使用 `[c` 可跳回上一处差异），现在光标应该在 apples 上了。接着运行 `:diffput`。此时，这两个文件都是 apples 了。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/diffing-apples.png\">\n</p>\n\n如果您想从另一个缓冲区（orange juice，`file2.txt`）传输文本来替代当前缓冲区（apple juice，`file1.txt`），让您的光标仍然位于 `file1.txt` 的窗口中，首先使用 `]c` 跳转至下一处差异，此时光标应该在 apple juice 上。接着运行 `:diffget` 获取另一个缓冲区的 orange juice 来替代当前缓冲区中的 apple juice。\n\n`:diffput` 将文本从当前缓冲区 *输出* 到另一个缓冲区。`:diffget` 从另一个缓冲区 *获取* 文本到当前缓冲区。\n\n如果有多个缓冲区，可以运行 `:diffput fileN.txt` 和 `:diffget fileN.txt` 来指定目标缓冲区 fileN。\n\n## 使用 Vim 作为合并工具\n\n> “我非常喜欢解决合并冲突。” ——佚名\n\n我不知道有谁喜欢解决合并冲突，但总之，合并冲突是无法避免的。在本节中，您将学习如何利用 Vim 作为解决合并冲突的工具。\n\n首先，运行下列命令来将默认合并工具更改为 `vimdiff`：\n\n```\ngit config merge.tool vimdiff\ngit config merge.conflictstyle diff3\ngit config mergetool.prompt false\n```\n\n或者您也可以直接修改 `~/.gitconfig`（默认情况下，它应该处于根目录中，但您的可能在不同的位置）。上面的命令应该会将您的 `gitconfig` 改成如下设置的样子，如果您还没有运行上面的命令，您也可以手动更改您的 gitconfig。\n\n```\n[core]\n  editor = vim\n[merge]\n  tool = vimdiff\n  conflictstyle = diff3\n[difftool]\n  prompt = false\n```\n\n让我们创建一个假的合并冲突来测试一下。首先创建一个目录 `/food`，并初始化 git 仓库：\n\n```\ngit init\n```\n\n添加 `breakfast.txt` 文件，内容为：\n\n```\npancakes\nwaffles\noranges\n```\n\n添加文件并提交它：\n\n```\ngit add .\ngit commit -m \"Initial breakfast commit\"\n```\n\n接着，创建一个新分支 apples：\n\n```\ngit checkout -b apples\n```\n\n更改 `breakfast.txt` 文件为：\n\n```\npancakes\nwaffles\napples\n```\n\n保存文件，添加并提交更改：\n\n```\ngit add .\ngit commit -m \"Apples not oranges\"\n```\n\n真棒！现在 master 分支有 oranges，而 apples 分支有 apples。接着回到 master 分支：\n\n```\ngit checkout master\n```\n\n在 `breakfast.txt` 文件中，您应该能看到原来的文本 oranges。接着将它改成 grapes，因为它是现在的应季水果：\n\n```\npancakes\nwaffles\ngrapes\n```\n\n保存、添加、提交：\n\n```\ngit add .\ngit commit -m \"Grapes not oranges\"\n```\n\n嚯！这么多步骤！现在准备要将 apples 分支合并进 master 分支了：\n\n```\ngit merge apples\n```\n\n您应该会看到如下错误：\n\n```\nAuto-merging breakfast.txt\nCONFLICT (content): Merge conflict in breakfast.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n没错，一个冲突！现在一起来用一下新配置的 `mergetool` 来解决冲突吧！运行：\n\n```\ngit mergetool\n```\n\n<p align=\"center\">\n  <img alt=\"Three-way mergetool with Vim\" width=\"900\" height=\"auto\" src=\"images/mergetool-initial.png\">\n</p>\n\nVim 显示了四个窗口。注意一下顶部三个：\n\n- `LOCAL` 包含了 `grapes`。这是“本地”中的变化，也是您要合并的内容。\n- `BASE` 包含了 `oranges`。这是 `LOCAL` 和 `REMOTE` 的共同祖先，用于比较它们之间的分歧。\n- `REMOTE` 包含了 `apples`。这是要被合并的内容。\n\n底部窗口（也即第四个窗口），您能看到：\n\n```\npancakes\nwaffles\n<<<<<<< HEAD\ngrapes\n||||||| db63958\noranges\n=======\napples\n>>>>>>> apples\n```\n\n第四个窗口包含了合并冲突文本。有了这步设置，就能更轻松看到哪个环境发生了什么变化。您可以同时查看 `LOCAL`、`BASE` 和 `REMOTE` 的内容。\n\n您的光标应该在第四个窗口的高亮区域。再运行 `:diffget LOCAL`，就可以*获取*来自 `LOCAL` 的改变（grapes）。同样，运行 `:diffget BASE` 可以获取来自 `BASE` 的改变（oranges），而运行 `:diffget REMOTE` 可以获取来自 `REMOTE` 的改变（apples）。\n\n在这个例子中，我们试着获取来自 `LOCAL` 的改变。运行 `:diffget LO`（`LOCAL` 的简写），第四个窗口变成了 grapes。完成后，就可以保存并退出所有文件（`:wqall`）了。还不错吧？\n\n稍加留意您会发现，现在多了一个 `breakfast.txt.orig` 文件。这是 Git 防止事与愿违而创建的备份文件。如果您不希望 Git 在合并期间创建备份文件，可以运行：\n\n```\ngit config --global mergetool.keepBackup false\n```\n\n## 在 Vim 中使用 Git\n\nVim 本身没有集成 Git，要在 Vim 中执行 Git 命令，一种方法是在命令行模式中使用 `!` 叹号运算符。\n\n使用 `!` 可以运行任何 Git 命令：\n\n```\n:!git status\n:!git commit\n:!git diff\n:!git push origin master\n```\n\n您还可以使用 Vim 的特殊字符 `%` (当前缓冲区) 或 `#` (其他缓冲区)：\n\n```\n:!git add %         \" git add current file\n:!git checkout #    \" git checkout the other file\n```\n\n这里有一个Vim技巧，您可以用来添加不同Vim窗口中的多个文件，运行：\n\n```\nwindo !git add %\n```\n\n然后提交：\n\n```\n:!git commit \"添加了Vim窗口中的所有文件，酷\"\n```\n\n`windo`命令是VIm的 \"do\" 命令其中之一，类似于您前面看到的 `argdo` 。`windo` 将命令执行在每一个窗口中。\n\n## 插件\n\n这里有很多提供git支持的Vim插件。以下是 Vim 中较流行的 Git 相关插件列表（您读到这篇文章时可能又有更多）：\n\n- [vim-gitgutter](https://github.com/airblade/vim-gitgutter)\n- [vim-signify](https://github.com/mhinz/vim-signify)\n- [vim-fugitive](https://github.com/tpope/vim-fugitive)\n- [gv.vim](https://github.com/junegunn/gv.vim)\n- [vimagit](https://github.com/jreybert/vimagit)\n- [vim-twiggy](https://github.com/sodapopcan/vim-twiggy)\n- [rhubarb](https://github.com/tpope/vim-rhubarb)\n\n其中最流行的是 vim-fugitive。本章的剩余部分，我将使用此插件来介绍几个 git 工作流。\n\n## Vim-Fugitive\n\nvim-fugitive 插件允许您在不离开 Vim 编辑器的情况下运行 git 命令行界面。您会发现，有些命令在 Vim 内部执行时会更好。\n\n开始前，请先使用 Vim 插件管理器（[vim-plug](https://github.com/junegunn/vim-plug)、[vundle](https://github.com/VundleVim/Vundle.vim)、[dein.vim](https://github.com/Shougo/dein.vim) 等）安装 vim-fugitive。\n\n## Git Status\n\n当您不带参数地运行 `:Git` 命令时，vim-fugitive 将显示一个 git 概要窗口，它显示了未跟踪、未暂存和已暂存的文件。在此 “`git status`” 模式下，您可以做一些操作：\n\n- `Ctrl-n` / `Ctrl-p` 转到下一个 / 上一个文件。\n- `-` 暂存或取消暂存光标处的文件。\n- `s` 暂存光标处的文件。\n- `u` 取消暂存光标处的文件。\n- `>` / `<` 内联显示或隐藏光标处文件的差异变化。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git.png\">\n</p>\n\n查阅 `:h fugitive-staging-maps` 可获得更多信息。\n\n## Git Blame\n\n在当前文件运行 `:Git blame` 命令，vim-fugitive 可以显示一个拆分的问责窗口。这有助于追踪那些 BUG 是谁写的，接着就可以冲他/她怒吼（开个玩笑）。\n\n在  `\"git blame\"` 模式下您可以做：\n\n- `q` 关闭问责窗口。\n- `A` 调整作者列大小。\n- `C` 调整提交列大小。\n- `D` 调整日期/时间列大小。\n\n查阅 `:h :Git_blame` 可获得更多信息。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-blame.png\">\n</p>\n\n## Gdiffsplit\n\n当您运行 `:Gdiffsplit` 命令后，vim-fugitive 会执行 `vimdiff`，比对索引或工作树中的版本与当前文件最新更改的区别。如果运行 `:Gdiffsplit <commit>`，vim-fugitive 则会根据 `<commit>` 中的版本来执行 `vimdiff`。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-gdiffsplit.png\">\n</p>\n\n由于您处于 `vimdiff` 模式中，因此您可以使用 `:diffput` 和 `:diffget` 来 *获取* 或 *输出* 差异。\n\n## Gwrite 和 Gread\n\n当您在更改文件后运行 `:Gwrite` 命令，vim-fugitive 将暂存更改，就像运行 `git add <current-file>` 一样。\n\n当您在更改文件后运行 `:Gread` 命令，vim-fugitive 会将文件还原至更改前的状态，就像运行 `git checkout <current-file>` 一样。使用 `:Gread` 还有一个好处是操作可撤销。如果在运行 `:Gread` 后您改变主意，想要保留原来的更改，您只需要撤消（`u`），Vim 将撤回 `:Gread` 操作。要换作是在命令行中运行 `git checkout <current-file>`，就完成不了这种操作了。\n\n## Gclog\n\n当您运行 `:Gclog` 命令时，vim-fugitive 将显示提交历史记录，就像运行 `git log` 命令一样。Vim-fugitive 使用 Vim 的 quickfix 来完成此任务，因此您可以使用 `:cnext` 和 `:cprevious` 来遍历下一个或上一个日志信息。您还可以使用 `:copen` 和 `:cclose` 打开或关闭日志列表。\n\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-log.png\">\n</p>\n\n在 `\"git log\"` 模式中，您可以做两件事：\n- 查看树。\n- 访问父级（上一个提交）。\n\n您可以像 `git log` 命令一样，传递参数给 `:Gclog` 命令。如果您项目的提交历史记录很长，只想看最后三个提交，则可以运行 `:Gclog -3`。如果需要根据提交日期来筛选记录，可以运行类似 `:Gclog --after=\"January 1\" --before=\"March 14\"` 的命令。\n\n## Vim-Fugitive 的更多功能\n\n以上只是寥寥几个 vim-fugitive 功能的例子，您可以查阅 `:h fugitive.txt` 来了解更多有关 vim-fugitive 的信息。大多数流行的 git 命令可能都有 vim-fugitive 的优化版本，您只需在文档中查找它们。\n\n如果您处于 vim-fugitive 的“特殊模式”（如 `:Git` 或 `:Git blame` 模式）中，按下 `g?` 可以了解当前有哪些可用的快捷键，Vim-fugitive 将为您所处的模式显示相应的 `:help` 窗口。棒极了！\n\n## 聪明地学习 Vim 和 Git\n\n每个人都有不同的 git 工作流，可能 vim-fugitive 非常合适您的工作流（也可能不适合）。总之，我强烈建议您试试上面列出的所有插件。可能还有一些其他的我没有列出来，都可以去试一试。\n\n要让Vim-git的集成工作得更好，一个显而易见的办法就是去深入了解git。Git 本身是一个很庞大的主题，我只向您展示了它其中很小的一部分。好了，接下来谈谈如何使用 Vim 编译您的代码。\n","slug":"Vim/ch18_git","published":1,"updated":"2022-08-28T07:38:59.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i24002escvm47o16z61","content":"<h1 id=\"第18章-Git\"><a href=\"#第18章-Git\" class=\"headerlink\" title=\"第18章 Git\"></a>第18章 Git</h1><p>Vim 和 Git 是两种实现不同功能的伟大工具。Vim 用于文本编辑，Git 用于版本控制。</p>\n<p>在本章中，您将学习如何将 Vim 和 Git 集成在一起。</p>\n<h2 id=\"差异比较\"><a href=\"#差异比较\" class=\"headerlink\" title=\"差异比较\"></a>差异比较</h2><p>在上一章中，您看到了如何运行 <code>vimdiff</code> 命令以显示多个文件之间的差异。</p>\n<p>假设您有两个文件，<code>file1.txt</code> 和 <code>file2.txt</code>。</p>\n<p><code>file1.txt</code> 的内容如下：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">apples</span><br><span class=\"hljs-attribute\"></span><br><span class=\"hljs-attribute\">milk</span><br><span class=\"hljs-attribute\">apple juice</span><br><span class=\"hljs-attribute\"></span><br><span class=\"hljs-attribute\">yogurt</span><br></code></pre></td></tr></table></figure>\n\n<p><code>file2.txt</code> 的内容如下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">pancakes<br>waffles<br><span class=\"hljs-keyword\">oranges</span><br><span class=\"hljs-keyword\"></span><br>milk<br><span class=\"hljs-keyword\">orange </span><span class=\"hljs-keyword\">juice</span><br><span class=\"hljs-keyword\"></span><br>yogurt<br></code></pre></td></tr></table></figure>\n\n<p>若要查看两个文件之间的差异，请运行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">vimdiff</span> file1.txt file2.txt<br></code></pre></td></tr></table></figure>\n\n<p>或者也可以运行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">vim</span> -d file1.txt file2.txt<br></code></pre></td></tr></table></figure>\n\n<p align=\"center\">\n  <img alt=\"Basic diffing with Vim\" width=\"900\" height=\"auto\" src=\"images/diffing-basic.png\">\n</p>\n\n<p><code>vimdiff</code> 并排显示两个缓冲区。左边是 <code>file1.txt</code>，右边是 <code>file2.txt</code>。不同的两行（apples 和 oranges）会被高亮显示。</p>\n<p>假设您要使第二个缓冲区相应位置变成 apples，而不是 oranges。若想从 <code>file1.txt</code> 传输您当前位置（当前您在 <code>file1.txt</code>）的内容到 <code>file2.txt</code>，首先使用 <code>]c</code> 跳转到下一处差异（使用 <code>[c</code> 可跳回上一处差异），现在光标应该在 apples 上了。接着运行 <code>:diffput</code>。此时，这两个文件都是 apples 了。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/diffing-apples.png\">\n</p>\n\n<p>如果您想从另一个缓冲区（orange juice，<code>file2.txt</code>）传输文本来替代当前缓冲区（apple juice，<code>file1.txt</code>），让您的光标仍然位于 <code>file1.txt</code> 的窗口中，首先使用 <code>]c</code> 跳转至下一处差异，此时光标应该在 apple juice 上。接着运行 <code>:diffget</code> 获取另一个缓冲区的 orange juice 来替代当前缓冲区中的 apple juice。</p>\n<p><code>:diffput</code> 将文本从当前缓冲区 <em>输出</em> 到另一个缓冲区。<code>:diffget</code> 从另一个缓冲区 <em>获取</em> 文本到当前缓冲区。</p>\n<p>如果有多个缓冲区，可以运行 <code>:diffput fileN.txt</code> 和 <code>:diffget fileN.txt</code> 来指定目标缓冲区 fileN。</p>\n<h2 id=\"使用-Vim-作为合并工具\"><a href=\"#使用-Vim-作为合并工具\" class=\"headerlink\" title=\"使用 Vim 作为合并工具\"></a>使用 Vim 作为合并工具</h2><blockquote>\n<p>“我非常喜欢解决合并冲突。” ——佚名</p>\n</blockquote>\n<p>我不知道有谁喜欢解决合并冲突，但总之，合并冲突是无法避免的。在本节中，您将学习如何利用 Vim 作为解决合并冲突的工具。</p>\n<p>首先，运行下列命令来将默认合并工具更改为 <code>vimdiff</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">git config merge.tool vimdiff<br>git config merge.conflictstyle diff3<br>git config mergetool.prompt <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<p>或者您也可以直接修改 <code>~/.gitconfig</code>（默认情况下，它应该处于根目录中，但您的可能在不同的位置）。上面的命令应该会将您的 <code>gitconfig</code> 改成如下设置的样子，如果您还没有运行上面的命令，您也可以手动更改您的 gitconfig。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[core]</span><br>  <span class=\"hljs-attr\">editor</span> = vim<br><span class=\"hljs-section\">[merge]</span><br>  <span class=\"hljs-attr\">tool</span> = vimdiff<br>  <span class=\"hljs-attr\">conflictstyle</span> = diff3<br><span class=\"hljs-section\">[difftool]</span><br>  <span class=\"hljs-attr\">prompt</span> = <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们创建一个假的合并冲突来测试一下。首先创建一个目录 <code>/food</code>，并初始化 git 仓库：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\">git <span class=\"hljs-keyword\">init</span><br></code></pre></td></tr></table></figure>\n\n<p>添加 <code>breakfast.txt</code> 文件，内容为：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">oranges</span><br></code></pre></td></tr></table></figure>\n\n<p>添加文件并提交它：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> .<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;Initial breakfast commit&quot;<br></code></pre></td></tr></table></figure>\n\n<p>接着，创建一个新分支 apples：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">git</span> checkout -<span class=\"hljs-keyword\">b</span> apples<br></code></pre></td></tr></table></figure>\n\n<p>更改 <code>breakfast.txt</code> 文件为：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">apples</span><br></code></pre></td></tr></table></figure>\n\n<p>保存文件，添加并提交更改：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> .<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;Apples not oranges&quot;<br></code></pre></td></tr></table></figure>\n\n<p>真棒！现在 master 分支有 oranges，而 apples 分支有 apples。接着回到 master 分支：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">git checkout <span class=\"hljs-literal\">master</span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>breakfast.txt</code> 文件中，您应该能看到原来的文本 oranges。接着将它改成 grapes，因为它是现在的应季水果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">grapes</span><br></code></pre></td></tr></table></figure>\n\n<p>保存、添加、提交：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> .<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;Grapes not oranges&quot;<br></code></pre></td></tr></table></figure>\n\n<p>嚯！这么多步骤！现在准备要将 apples 分支合并进 master 分支了：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">git <span class=\"hljs-keyword\">merge</span> apples<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到如下错误：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">Auto-merging breakfast.txt<br><span class=\"hljs-keyword\">CONFLICT</span> (content): Merge <span class=\"hljs-keyword\">conflict</span> <span class=\"hljs-keyword\">in</span> breakfast.txt<br>Automatic merge failed; fix conflicts <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">commit</span> the result.<br></code></pre></td></tr></table></figure>\n\n<p>没错，一个冲突！现在一起来用一下新配置的 <code>mergetool</code> 来解决冲突吧！运行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">git mergetool</span><br></code></pre></td></tr></table></figure>\n\n<p align=\"center\">\n  <img alt=\"Three-way mergetool with Vim\" width=\"900\" height=\"auto\" src=\"images/mergetool-initial.png\">\n</p>\n\n<p>Vim 显示了四个窗口。注意一下顶部三个：</p>\n<ul>\n<li><code>LOCAL</code> 包含了 <code>grapes</code>。这是“本地”中的变化，也是您要合并的内容。</li>\n<li><code>BASE</code> 包含了 <code>oranges</code>。这是 <code>LOCAL</code> 和 <code>REMOTE</code> 的共同祖先，用于比较它们之间的分歧。</li>\n<li><code>REMOTE</code> 包含了 <code>apples</code>。这是要被合并的内容。</li>\n</ul>\n<p>底部窗口（也即第四个窗口），您能看到：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">pancakes<br>waffles<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>grapes<br>||||||| db63958<br><span class=\"hljs-section\">oranges</span><br><span class=\"hljs-section\">=======</span><br>apples<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; apples<br></code></pre></td></tr></table></figure>\n\n<p>第四个窗口包含了合并冲突文本。有了这步设置，就能更轻松看到哪个环境发生了什么变化。您可以同时查看 <code>LOCAL</code>、<code>BASE</code> 和 <code>REMOTE</code> 的内容。</p>\n<p>您的光标应该在第四个窗口的高亮区域。再运行 <code>:diffget LOCAL</code>，就可以<em>获取</em>来自 <code>LOCAL</code> 的改变（grapes）。同样，运行 <code>:diffget BASE</code> 可以获取来自 <code>BASE</code> 的改变（oranges），而运行 <code>:diffget REMOTE</code> 可以获取来自 <code>REMOTE</code> 的改变（apples）。</p>\n<p>在这个例子中，我们试着获取来自 <code>LOCAL</code> 的改变。运行 <code>:diffget LO</code>（<code>LOCAL</code> 的简写），第四个窗口变成了 grapes。完成后，就可以保存并退出所有文件（<code>:wqall</code>）了。还不错吧？</p>\n<p>稍加留意您会发现，现在多了一个 <code>breakfast.txt.orig</code> 文件。这是 Git 防止事与愿违而创建的备份文件。如果您不希望 Git 在合并期间创建备份文件，可以运行：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">git config --global mergetool.keepBackup <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"在-Vim-中使用-Git\"><a href=\"#在-Vim-中使用-Git\" class=\"headerlink\" title=\"在 Vim 中使用 Git\"></a>在 Vim 中使用 Git</h2><p>Vim 本身没有集成 Git，要在 Vim 中执行 Git 命令，一种方法是在命令行模式中使用 <code>!</code> 叹号运算符。</p>\n<p>使用 <code>!</code> 可以运行任何 Git 命令：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">:!git status<br>:!git commit<br>:!git diff<br>:!git push origin master<br></code></pre></td></tr></table></figure>\n\n<p>您还可以使用 Vim 的特殊字符 <code>%</code> (当前缓冲区) 或 <code>#</code> (其他缓冲区)：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:!git <span class=\"hljs-built_in\">add</span> %         <span class=\"hljs-comment\">&quot; git add current file</span><br>:!git checkout #    <span class=\"hljs-comment\">&quot; git checkout the other file</span><br></code></pre></td></tr></table></figure>\n\n<p>这里有一个Vim技巧，您可以用来添加不同Vim窗口中的多个文件，运行：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">windo !git add <span class=\"hljs-comment\">%</span><br></code></pre></td></tr></table></figure>\n\n<p>然后提交：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">:!git commit <span class=\"hljs-string\">&quot;添加了Vim窗口中的所有文件，酷&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>windo</code>命令是VIm的 “do” 命令其中之一，类似于您前面看到的 <code>argdo</code> 。<code>windo</code> 将命令执行在每一个窗口中。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>这里有很多提供git支持的Vim插件。以下是 Vim 中较流行的 Git 相关插件列表（您读到这篇文章时可能又有更多）：</p>\n<ul>\n<li><a href=\"https://github.com/airblade/vim-gitgutter\">vim-gitgutter</a></li>\n<li><a href=\"https://github.com/mhinz/vim-signify\">vim-signify</a></li>\n<li><a href=\"https://github.com/tpope/vim-fugitive\">vim-fugitive</a></li>\n<li><a href=\"https://github.com/junegunn/gv.vim\">gv.vim</a></li>\n<li><a href=\"https://github.com/jreybert/vimagit\">vimagit</a></li>\n<li><a href=\"https://github.com/sodapopcan/vim-twiggy\">vim-twiggy</a></li>\n<li><a href=\"https://github.com/tpope/vim-rhubarb\">rhubarb</a></li>\n</ul>\n<p>其中最流行的是 vim-fugitive。本章的剩余部分，我将使用此插件来介绍几个 git 工作流。</p>\n<h2 id=\"Vim-Fugitive\"><a href=\"#Vim-Fugitive\" class=\"headerlink\" title=\"Vim-Fugitive\"></a>Vim-Fugitive</h2><p>vim-fugitive 插件允许您在不离开 Vim 编辑器的情况下运行 git 命令行界面。您会发现，有些命令在 Vim 内部执行时会更好。</p>\n<p>开始前，请先使用 Vim 插件管理器（<a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a>、<a href=\"https://github.com/VundleVim/Vundle.vim\">vundle</a>、<a href=\"https://github.com/Shougo/dein.vim\">dein.vim</a> 等）安装 vim-fugitive。</p>\n<h2 id=\"Git-Status\"><a href=\"#Git-Status\" class=\"headerlink\" title=\"Git Status\"></a>Git Status</h2><p>当您不带参数地运行 <code>:Git</code> 命令时，vim-fugitive 将显示一个 git 概要窗口，它显示了未跟踪、未暂存和已暂存的文件。在此 “<code>git status</code>” 模式下，您可以做一些操作：</p>\n<ul>\n<li><code>Ctrl-n</code> &#x2F; <code>Ctrl-p</code> 转到下一个 &#x2F; 上一个文件。</li>\n<li><code>-</code> 暂存或取消暂存光标处的文件。</li>\n<li><code>s</code> 暂存光标处的文件。</li>\n<li><code>u</code> 取消暂存光标处的文件。</li>\n<li><code>&gt;</code> &#x2F; <code>&lt;</code> 内联显示或隐藏光标处文件的差异变化。</li>\n</ul>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git.png\">\n</p>\n\n<p>查阅 <code>:h fugitive-staging-maps</code> 可获得更多信息。</p>\n<h2 id=\"Git-Blame\"><a href=\"#Git-Blame\" class=\"headerlink\" title=\"Git Blame\"></a>Git Blame</h2><p>在当前文件运行 <code>:Git blame</code> 命令，vim-fugitive 可以显示一个拆分的问责窗口。这有助于追踪那些 BUG 是谁写的，接着就可以冲他&#x2F;她怒吼（开个玩笑）。</p>\n<p>在  <code>&quot;git blame&quot;</code> 模式下您可以做：</p>\n<ul>\n<li><code>q</code> 关闭问责窗口。</li>\n<li><code>A</code> 调整作者列大小。</li>\n<li><code>C</code> 调整提交列大小。</li>\n<li><code>D</code> 调整日期&#x2F;时间列大小。</li>\n</ul>\n<p>查阅 <code>:h :Git_blame</code> 可获得更多信息。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-blame.png\">\n</p>\n\n<h2 id=\"Gdiffsplit\"><a href=\"#Gdiffsplit\" class=\"headerlink\" title=\"Gdiffsplit\"></a>Gdiffsplit</h2><p>当您运行 <code>:Gdiffsplit</code> 命令后，vim-fugitive 会执行 <code>vimdiff</code>，比对索引或工作树中的版本与当前文件最新更改的区别。如果运行 <code>:Gdiffsplit &lt;commit&gt;</code>，vim-fugitive 则会根据 <code>&lt;commit&gt;</code> 中的版本来执行 <code>vimdiff</code>。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-gdiffsplit.png\">\n</p>\n\n<p>由于您处于 <code>vimdiff</code> 模式中，因此您可以使用 <code>:diffput</code> 和 <code>:diffget</code> 来 <em>获取</em> 或 <em>输出</em> 差异。</p>\n<h2 id=\"Gwrite-和-Gread\"><a href=\"#Gwrite-和-Gread\" class=\"headerlink\" title=\"Gwrite 和 Gread\"></a>Gwrite 和 Gread</h2><p>当您在更改文件后运行 <code>:Gwrite</code> 命令，vim-fugitive 将暂存更改，就像运行 <code>git add &lt;current-file&gt;</code> 一样。</p>\n<p>当您在更改文件后运行 <code>:Gread</code> 命令，vim-fugitive 会将文件还原至更改前的状态，就像运行 <code>git checkout &lt;current-file&gt;</code> 一样。使用 <code>:Gread</code> 还有一个好处是操作可撤销。如果在运行 <code>:Gread</code> 后您改变主意，想要保留原来的更改，您只需要撤消（<code>u</code>），Vim 将撤回 <code>:Gread</code> 操作。要换作是在命令行中运行 <code>git checkout &lt;current-file&gt;</code>，就完成不了这种操作了。</p>\n<h2 id=\"Gclog\"><a href=\"#Gclog\" class=\"headerlink\" title=\"Gclog\"></a>Gclog</h2><p>当您运行 <code>:Gclog</code> 命令时，vim-fugitive 将显示提交历史记录，就像运行 <code>git log</code> 命令一样。Vim-fugitive 使用 Vim 的 quickfix 来完成此任务，因此您可以使用 <code>:cnext</code> 和 <code>:cprevious</code> 来遍历下一个或上一个日志信息。您还可以使用 <code>:copen</code> 和 <code>:cclose</code> 打开或关闭日志列表。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-log.png\">\n</p>\n\n<p>在 <code>&quot;git log&quot;</code> 模式中，您可以做两件事：</p>\n<ul>\n<li>查看树。</li>\n<li>访问父级（上一个提交）。</li>\n</ul>\n<p>您可以像 <code>git log</code> 命令一样，传递参数给 <code>:Gclog</code> 命令。如果您项目的提交历史记录很长，只想看最后三个提交，则可以运行 <code>:Gclog -3</code>。如果需要根据提交日期来筛选记录，可以运行类似 <code>:Gclog --after=&quot;January 1&quot; --before=&quot;March 14&quot;</code> 的命令。</p>\n<h2 id=\"Vim-Fugitive-的更多功能\"><a href=\"#Vim-Fugitive-的更多功能\" class=\"headerlink\" title=\"Vim-Fugitive 的更多功能\"></a>Vim-Fugitive 的更多功能</h2><p>以上只是寥寥几个 vim-fugitive 功能的例子，您可以查阅 <code>:h fugitive.txt</code> 来了解更多有关 vim-fugitive 的信息。大多数流行的 git 命令可能都有 vim-fugitive 的优化版本，您只需在文档中查找它们。</p>\n<p>如果您处于 vim-fugitive 的“特殊模式”（如 <code>:Git</code> 或 <code>:Git blame</code> 模式）中，按下 <code>g?</code> 可以了解当前有哪些可用的快捷键，Vim-fugitive 将为您所处的模式显示相应的 <code>:help</code> 窗口。棒极了！</p>\n<h2 id=\"聪明地学习-Vim-和-Git\"><a href=\"#聪明地学习-Vim-和-Git\" class=\"headerlink\" title=\"聪明地学习 Vim 和 Git\"></a>聪明地学习 Vim 和 Git</h2><p>每个人都有不同的 git 工作流，可能 vim-fugitive 非常合适您的工作流（也可能不适合）。总之，我强烈建议您试试上面列出的所有插件。可能还有一些其他的我没有列出来，都可以去试一试。</p>\n<p>要让Vim-git的集成工作得更好，一个显而易见的办法就是去深入了解git。Git 本身是一个很庞大的主题，我只向您展示了它其中很小的一部分。好了，接下来谈谈如何使用 Vim 编译您的代码。</p>\n","site":{"data":{}},"wordcount":5138,"excerpt":"","more":"<h1 id=\"第18章-Git\"><a href=\"#第18章-Git\" class=\"headerlink\" title=\"第18章 Git\"></a>第18章 Git</h1><p>Vim 和 Git 是两种实现不同功能的伟大工具。Vim 用于文本编辑，Git 用于版本控制。</p>\n<p>在本章中，您将学习如何将 Vim 和 Git 集成在一起。</p>\n<h2 id=\"差异比较\"><a href=\"#差异比较\" class=\"headerlink\" title=\"差异比较\"></a>差异比较</h2><p>在上一章中，您看到了如何运行 <code>vimdiff</code> 命令以显示多个文件之间的差异。</p>\n<p>假设您有两个文件，<code>file1.txt</code> 和 <code>file2.txt</code>。</p>\n<p><code>file1.txt</code> 的内容如下：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">apples</span><br><span class=\"hljs-attribute\"></span><br><span class=\"hljs-attribute\">milk</span><br><span class=\"hljs-attribute\">apple juice</span><br><span class=\"hljs-attribute\"></span><br><span class=\"hljs-attribute\">yogurt</span><br></code></pre></td></tr></table></figure>\n\n<p><code>file2.txt</code> 的内容如下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">pancakes<br>waffles<br><span class=\"hljs-keyword\">oranges</span><br><span class=\"hljs-keyword\"></span><br>milk<br><span class=\"hljs-keyword\">orange </span><span class=\"hljs-keyword\">juice</span><br><span class=\"hljs-keyword\"></span><br>yogurt<br></code></pre></td></tr></table></figure>\n\n<p>若要查看两个文件之间的差异，请运行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">vimdiff</span> file1.txt file2.txt<br></code></pre></td></tr></table></figure>\n\n<p>或者也可以运行：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">vim</span> -d file1.txt file2.txt<br></code></pre></td></tr></table></figure>\n\n<p align=\"center\">\n  <img alt=\"Basic diffing with Vim\" width=\"900\" height=\"auto\" src=\"images/diffing-basic.png\">\n</p>\n\n<p><code>vimdiff</code> 并排显示两个缓冲区。左边是 <code>file1.txt</code>，右边是 <code>file2.txt</code>。不同的两行（apples 和 oranges）会被高亮显示。</p>\n<p>假设您要使第二个缓冲区相应位置变成 apples，而不是 oranges。若想从 <code>file1.txt</code> 传输您当前位置（当前您在 <code>file1.txt</code>）的内容到 <code>file2.txt</code>，首先使用 <code>]c</code> 跳转到下一处差异（使用 <code>[c</code> 可跳回上一处差异），现在光标应该在 apples 上了。接着运行 <code>:diffput</code>。此时，这两个文件都是 apples 了。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/diffing-apples.png\">\n</p>\n\n<p>如果您想从另一个缓冲区（orange juice，<code>file2.txt</code>）传输文本来替代当前缓冲区（apple juice，<code>file1.txt</code>），让您的光标仍然位于 <code>file1.txt</code> 的窗口中，首先使用 <code>]c</code> 跳转至下一处差异，此时光标应该在 apple juice 上。接着运行 <code>:diffget</code> 获取另一个缓冲区的 orange juice 来替代当前缓冲区中的 apple juice。</p>\n<p><code>:diffput</code> 将文本从当前缓冲区 <em>输出</em> 到另一个缓冲区。<code>:diffget</code> 从另一个缓冲区 <em>获取</em> 文本到当前缓冲区。</p>\n<p>如果有多个缓冲区，可以运行 <code>:diffput fileN.txt</code> 和 <code>:diffget fileN.txt</code> 来指定目标缓冲区 fileN。</p>\n<h2 id=\"使用-Vim-作为合并工具\"><a href=\"#使用-Vim-作为合并工具\" class=\"headerlink\" title=\"使用 Vim 作为合并工具\"></a>使用 Vim 作为合并工具</h2><blockquote>\n<p>“我非常喜欢解决合并冲突。” ——佚名</p>\n</blockquote>\n<p>我不知道有谁喜欢解决合并冲突，但总之，合并冲突是无法避免的。在本节中，您将学习如何利用 Vim 作为解决合并冲突的工具。</p>\n<p>首先，运行下列命令来将默认合并工具更改为 <code>vimdiff</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">git config merge.tool vimdiff<br>git config merge.conflictstyle diff3<br>git config mergetool.prompt <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<p>或者您也可以直接修改 <code>~/.gitconfig</code>（默认情况下，它应该处于根目录中，但您的可能在不同的位置）。上面的命令应该会将您的 <code>gitconfig</code> 改成如下设置的样子，如果您还没有运行上面的命令，您也可以手动更改您的 gitconfig。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[core]</span><br>  <span class=\"hljs-attr\">editor</span> = vim<br><span class=\"hljs-section\">[merge]</span><br>  <span class=\"hljs-attr\">tool</span> = vimdiff<br>  <span class=\"hljs-attr\">conflictstyle</span> = diff3<br><span class=\"hljs-section\">[difftool]</span><br>  <span class=\"hljs-attr\">prompt</span> = <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<p>让我们创建一个假的合并冲突来测试一下。首先创建一个目录 <code>/food</code>，并初始化 git 仓库：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\">git <span class=\"hljs-keyword\">init</span><br></code></pre></td></tr></table></figure>\n\n<p>添加 <code>breakfast.txt</code> 文件，内容为：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">oranges</span><br></code></pre></td></tr></table></figure>\n\n<p>添加文件并提交它：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> .<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;Initial breakfast commit&quot;<br></code></pre></td></tr></table></figure>\n\n<p>接着，创建一个新分支 apples：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">git</span> checkout -<span class=\"hljs-keyword\">b</span> apples<br></code></pre></td></tr></table></figure>\n\n<p>更改 <code>breakfast.txt</code> 文件为：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">apples</span><br></code></pre></td></tr></table></figure>\n\n<p>保存文件，添加并提交更改：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> .<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;Apples not oranges&quot;<br></code></pre></td></tr></table></figure>\n\n<p>真棒！现在 master 分支有 oranges，而 apples 分支有 apples。接着回到 master 分支：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">git checkout <span class=\"hljs-literal\">master</span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>breakfast.txt</code> 文件中，您应该能看到原来的文本 oranges。接着将它改成 grapes，因为它是现在的应季水果：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">pancakes</span><br><span class=\"hljs-attribute\">waffles</span><br><span class=\"hljs-attribute\">grapes</span><br></code></pre></td></tr></table></figure>\n\n<p>保存、添加、提交：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> .<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;Grapes not oranges&quot;<br></code></pre></td></tr></table></figure>\n\n<p>嚯！这么多步骤！现在准备要将 apples 分支合并进 master 分支了：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cos\">git <span class=\"hljs-keyword\">merge</span> apples<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到如下错误：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">Auto-merging breakfast.txt<br><span class=\"hljs-keyword\">CONFLICT</span> (content): Merge <span class=\"hljs-keyword\">conflict</span> <span class=\"hljs-keyword\">in</span> breakfast.txt<br>Automatic merge failed; fix conflicts <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">commit</span> the result.<br></code></pre></td></tr></table></figure>\n\n<p>没错，一个冲突！现在一起来用一下新配置的 <code>mergetool</code> 来解决冲突吧！运行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">git mergetool</span><br></code></pre></td></tr></table></figure>\n\n<p align=\"center\">\n  <img alt=\"Three-way mergetool with Vim\" width=\"900\" height=\"auto\" src=\"images/mergetool-initial.png\">\n</p>\n\n<p>Vim 显示了四个窗口。注意一下顶部三个：</p>\n<ul>\n<li><code>LOCAL</code> 包含了 <code>grapes</code>。这是“本地”中的变化，也是您要合并的内容。</li>\n<li><code>BASE</code> 包含了 <code>oranges</code>。这是 <code>LOCAL</code> 和 <code>REMOTE</code> 的共同祖先，用于比较它们之间的分歧。</li>\n<li><code>REMOTE</code> 包含了 <code>apples</code>。这是要被合并的内容。</li>\n</ul>\n<p>底部窗口（也即第四个窗口），您能看到：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">pancakes<br>waffles<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>grapes<br>||||||| db63958<br><span class=\"hljs-section\">oranges</span><br><span class=\"hljs-section\">=======</span><br>apples<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; apples<br></code></pre></td></tr></table></figure>\n\n<p>第四个窗口包含了合并冲突文本。有了这步设置，就能更轻松看到哪个环境发生了什么变化。您可以同时查看 <code>LOCAL</code>、<code>BASE</code> 和 <code>REMOTE</code> 的内容。</p>\n<p>您的光标应该在第四个窗口的高亮区域。再运行 <code>:diffget LOCAL</code>，就可以<em>获取</em>来自 <code>LOCAL</code> 的改变（grapes）。同样，运行 <code>:diffget BASE</code> 可以获取来自 <code>BASE</code> 的改变（oranges），而运行 <code>:diffget REMOTE</code> 可以获取来自 <code>REMOTE</code> 的改变（apples）。</p>\n<p>在这个例子中，我们试着获取来自 <code>LOCAL</code> 的改变。运行 <code>:diffget LO</code>（<code>LOCAL</code> 的简写），第四个窗口变成了 grapes。完成后，就可以保存并退出所有文件（<code>:wqall</code>）了。还不错吧？</p>\n<p>稍加留意您会发现，现在多了一个 <code>breakfast.txt.orig</code> 文件。这是 Git 防止事与愿违而创建的备份文件。如果您不希望 Git 在合并期间创建备份文件，可以运行：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">git config --global mergetool.keepBackup <span class=\"hljs-literal\">false</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"在-Vim-中使用-Git\"><a href=\"#在-Vim-中使用-Git\" class=\"headerlink\" title=\"在 Vim 中使用 Git\"></a>在 Vim 中使用 Git</h2><p>Vim 本身没有集成 Git，要在 Vim 中执行 Git 命令，一种方法是在命令行模式中使用 <code>!</code> 叹号运算符。</p>\n<p>使用 <code>!</code> 可以运行任何 Git 命令：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">:!git status<br>:!git commit<br>:!git diff<br>:!git push origin master<br></code></pre></td></tr></table></figure>\n\n<p>您还可以使用 Vim 的特殊字符 <code>%</code> (当前缓冲区) 或 <code>#</code> (其他缓冲区)：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:!git <span class=\"hljs-built_in\">add</span> %         <span class=\"hljs-comment\">&quot; git add current file</span><br>:!git checkout #    <span class=\"hljs-comment\">&quot; git checkout the other file</span><br></code></pre></td></tr></table></figure>\n\n<p>这里有一个Vim技巧，您可以用来添加不同Vim窗口中的多个文件，运行：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">windo !git add <span class=\"hljs-comment\">%</span><br></code></pre></td></tr></table></figure>\n\n<p>然后提交：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">:!git commit <span class=\"hljs-string\">&quot;添加了Vim窗口中的所有文件，酷&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>windo</code>命令是VIm的 “do” 命令其中之一，类似于您前面看到的 <code>argdo</code> 。<code>windo</code> 将命令执行在每一个窗口中。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>这里有很多提供git支持的Vim插件。以下是 Vim 中较流行的 Git 相关插件列表（您读到这篇文章时可能又有更多）：</p>\n<ul>\n<li><a href=\"https://github.com/airblade/vim-gitgutter\">vim-gitgutter</a></li>\n<li><a href=\"https://github.com/mhinz/vim-signify\">vim-signify</a></li>\n<li><a href=\"https://github.com/tpope/vim-fugitive\">vim-fugitive</a></li>\n<li><a href=\"https://github.com/junegunn/gv.vim\">gv.vim</a></li>\n<li><a href=\"https://github.com/jreybert/vimagit\">vimagit</a></li>\n<li><a href=\"https://github.com/sodapopcan/vim-twiggy\">vim-twiggy</a></li>\n<li><a href=\"https://github.com/tpope/vim-rhubarb\">rhubarb</a></li>\n</ul>\n<p>其中最流行的是 vim-fugitive。本章的剩余部分，我将使用此插件来介绍几个 git 工作流。</p>\n<h2 id=\"Vim-Fugitive\"><a href=\"#Vim-Fugitive\" class=\"headerlink\" title=\"Vim-Fugitive\"></a>Vim-Fugitive</h2><p>vim-fugitive 插件允许您在不离开 Vim 编辑器的情况下运行 git 命令行界面。您会发现，有些命令在 Vim 内部执行时会更好。</p>\n<p>开始前，请先使用 Vim 插件管理器（<a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a>、<a href=\"https://github.com/VundleVim/Vundle.vim\">vundle</a>、<a href=\"https://github.com/Shougo/dein.vim\">dein.vim</a> 等）安装 vim-fugitive。</p>\n<h2 id=\"Git-Status\"><a href=\"#Git-Status\" class=\"headerlink\" title=\"Git Status\"></a>Git Status</h2><p>当您不带参数地运行 <code>:Git</code> 命令时，vim-fugitive 将显示一个 git 概要窗口，它显示了未跟踪、未暂存和已暂存的文件。在此 “<code>git status</code>” 模式下，您可以做一些操作：</p>\n<ul>\n<li><code>Ctrl-n</code> &#x2F; <code>Ctrl-p</code> 转到下一个 &#x2F; 上一个文件。</li>\n<li><code>-</code> 暂存或取消暂存光标处的文件。</li>\n<li><code>s</code> 暂存光标处的文件。</li>\n<li><code>u</code> 取消暂存光标处的文件。</li>\n<li><code>&gt;</code> &#x2F; <code>&lt;</code> 内联显示或隐藏光标处文件的差异变化。</li>\n</ul>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git.png\">\n</p>\n\n<p>查阅 <code>:h fugitive-staging-maps</code> 可获得更多信息。</p>\n<h2 id=\"Git-Blame\"><a href=\"#Git-Blame\" class=\"headerlink\" title=\"Git Blame\"></a>Git Blame</h2><p>在当前文件运行 <code>:Git blame</code> 命令，vim-fugitive 可以显示一个拆分的问责窗口。这有助于追踪那些 BUG 是谁写的，接着就可以冲他&#x2F;她怒吼（开个玩笑）。</p>\n<p>在  <code>&quot;git blame&quot;</code> 模式下您可以做：</p>\n<ul>\n<li><code>q</code> 关闭问责窗口。</li>\n<li><code>A</code> 调整作者列大小。</li>\n<li><code>C</code> 调整提交列大小。</li>\n<li><code>D</code> 调整日期&#x2F;时间列大小。</li>\n</ul>\n<p>查阅 <code>:h :Git_blame</code> 可获得更多信息。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-blame.png\">\n</p>\n\n<h2 id=\"Gdiffsplit\"><a href=\"#Gdiffsplit\" class=\"headerlink\" title=\"Gdiffsplit\"></a>Gdiffsplit</h2><p>当您运行 <code>:Gdiffsplit</code> 命令后，vim-fugitive 会执行 <code>vimdiff</code>，比对索引或工作树中的版本与当前文件最新更改的区别。如果运行 <code>:Gdiffsplit &lt;commit&gt;</code>，vim-fugitive 则会根据 <code>&lt;commit&gt;</code> 中的版本来执行 <code>vimdiff</code>。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-gdiffsplit.png\">\n</p>\n\n<p>由于您处于 <code>vimdiff</code> 模式中，因此您可以使用 <code>:diffput</code> 和 <code>:diffget</code> 来 <em>获取</em> 或 <em>输出</em> 差异。</p>\n<h2 id=\"Gwrite-和-Gread\"><a href=\"#Gwrite-和-Gread\" class=\"headerlink\" title=\"Gwrite 和 Gread\"></a>Gwrite 和 Gread</h2><p>当您在更改文件后运行 <code>:Gwrite</code> 命令，vim-fugitive 将暂存更改，就像运行 <code>git add &lt;current-file&gt;</code> 一样。</p>\n<p>当您在更改文件后运行 <code>:Gread</code> 命令，vim-fugitive 会将文件还原至更改前的状态，就像运行 <code>git checkout &lt;current-file&gt;</code> 一样。使用 <code>:Gread</code> 还有一个好处是操作可撤销。如果在运行 <code>:Gread</code> 后您改变主意，想要保留原来的更改，您只需要撤消（<code>u</code>），Vim 将撤回 <code>:Gread</code> 操作。要换作是在命令行中运行 <code>git checkout &lt;current-file&gt;</code>，就完成不了这种操作了。</p>\n<h2 id=\"Gclog\"><a href=\"#Gclog\" class=\"headerlink\" title=\"Gclog\"></a>Gclog</h2><p>当您运行 <code>:Gclog</code> 命令时，vim-fugitive 将显示提交历史记录，就像运行 <code>git log</code> 命令一样。Vim-fugitive 使用 Vim 的 quickfix 来完成此任务，因此您可以使用 <code>:cnext</code> 和 <code>:cprevious</code> 来遍历下一个或上一个日志信息。您还可以使用 <code>:copen</code> 和 <code>:cclose</code> 打开或关闭日志列表。</p>\n<p align=\"center\">\n  <img alt=\"Finding files in FZF\" width=\"900\" height=\"auto\" src=\"images/fugitive-git-log.png\">\n</p>\n\n<p>在 <code>&quot;git log&quot;</code> 模式中，您可以做两件事：</p>\n<ul>\n<li>查看树。</li>\n<li>访问父级（上一个提交）。</li>\n</ul>\n<p>您可以像 <code>git log</code> 命令一样，传递参数给 <code>:Gclog</code> 命令。如果您项目的提交历史记录很长，只想看最后三个提交，则可以运行 <code>:Gclog -3</code>。如果需要根据提交日期来筛选记录，可以运行类似 <code>:Gclog --after=&quot;January 1&quot; --before=&quot;March 14&quot;</code> 的命令。</p>\n<h2 id=\"Vim-Fugitive-的更多功能\"><a href=\"#Vim-Fugitive-的更多功能\" class=\"headerlink\" title=\"Vim-Fugitive 的更多功能\"></a>Vim-Fugitive 的更多功能</h2><p>以上只是寥寥几个 vim-fugitive 功能的例子，您可以查阅 <code>:h fugitive.txt</code> 来了解更多有关 vim-fugitive 的信息。大多数流行的 git 命令可能都有 vim-fugitive 的优化版本，您只需在文档中查找它们。</p>\n<p>如果您处于 vim-fugitive 的“特殊模式”（如 <code>:Git</code> 或 <code>:Git blame</code> 模式）中，按下 <code>g?</code> 可以了解当前有哪些可用的快捷键，Vim-fugitive 将为您所处的模式显示相应的 <code>:help</code> 窗口。棒极了！</p>\n<h2 id=\"聪明地学习-Vim-和-Git\"><a href=\"#聪明地学习-Vim-和-Git\" class=\"headerlink\" title=\"聪明地学习 Vim 和 Git\"></a>聪明地学习 Vim 和 Git</h2><p>每个人都有不同的 git 工作流，可能 vim-fugitive 非常合适您的工作流（也可能不适合）。总之，我强烈建议您试试上面列出的所有插件。可能还有一些其他的我没有列出来，都可以去试一试。</p>\n<p>要让Vim-git的集成工作得更好，一个显而易见的办法就是去深入了解git。Git 本身是一个很庞大的主题，我只向您展示了它其中很小的一部分。好了，接下来谈谈如何使用 Vim 编译您的代码。</p>\n"},{"title":"VIM-编译","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第19章 编译\n\n编译是许多编程语言的重要主题。在本章中，您将学习如何在 Vim 中编译。此外，您将看到如何利用好 Vim 的 `:make` 命令。\n\n## 从命令行编译\n\n您可以使用叹号运算符（`!`）进行编译。如果您需要使用 `g++` 来编译 `.cpp` 文件，可以运行：\n\n```\n:!g++ hello.cpp -o hello\n```\n\n但要每次手动指定文件名和输出文件名会非常繁琐和容易出错。而 makefile 是条可行之路。\n\n## Make命令\n\nVim 有运行 makefile 的 `:make` 命令。当您运行它时，Vim 会在当前目录查找 makefile 并执行它。\n\n在当前目录创建一个文件名为 `makefile` ，然后添加下列内容：\n\n```\nall:\n\techo \"Hello all\"\nfoo:\n\techo \"Hello foo\"\nlist_pls:\n\tls\n```\n\n在 Vim 中运行：\n\n```\n:make\n```\n\nVim 执行它的方式与从终端运行它的方式相同。`:make` 命令也接受终端中 `make` 命令的参数。运行：\n\n```\n:make foo\n\" Outputs \"Hello foo\"\n\n:make list_pls\n\" Outputs the ls command result\n```\n\n如果命令执行异常，`:make` 命令将使用 Vim 的 `quickfix` 来存储这些错误。现在试着运行一个不存在的目标：\n\n```\n:make dontexist\n```\n\n您应该会看到该命令执行错误。运行 `quickfix` 命令 `:copen` 可以打开 `quickfix` 窗口来查看该错误：\n\n```\n|| make: *** No rule to make target `dontexist'.  Stop.\n```\n\n## 使用 Make 编译\n\n让我们使用 makefile 来编译一个基本的 `.cpp` 程序。首先创建一个 `hello.cpp` 文件：\n\n```\n#include <iostream>\n\nint main() {\n    std::cout << \"Hello!\\n\";\n    return 0;\n}\n```\n\n然后，更新 `makefile` 来编译和运行 `.cpp` 文件：\n\n```\nall:\n\techo \"build, run\"\nbuild:\n\tg++ hello.cpp -o hello\nrun:\n\t./hello\n```\n\n现在运行：\n\n```\n:make build\n```\n\n`g++` 将编译 `./hello.cpp` 并且生成 `./hello`。接着运行：\n\n```\n:make run\n```\n\n您应该会看到终端上打印出了 `\"Hello!\"`。\n\n## 不同的Make程序\n\n当您运行 `:make` 时，Vim 实际上会执行 `makeprg` 选项所设置的任何命令，您可以运行 `:set makeprg?` 来查看它：\n\n```\nmakeprg=make\n```\n\n`:make` 的默认命令是外部的 `make` 命令。若想修改 `:make` 命令，使每次运行它时执行 `g++ <your-file-name>`，请运行：\n\n```\n:set makeprg=g++\\ %\n```\n\n`\\` 用于转义 `g++` 后的空格。Vim 中 `%` 符号代表当前文件。因此，`g++\\ %` 命令等于运行 `g++ hello.cpp`。\n\n转到 `./hello.cpp` 然后运行 `:make`，Vim 将编译 `hello.cpp` 并输出 `a.out`（因为您没有指定输出）。让我们重构一下，使用去掉扩展名的原始文件名来命名编译后的输出。运行下面的命令（或将它们添加到vimrc）：\n\n```\n:set makeprg=g++\\ %\\ -o\\ %<\n```\n\n上面的命令分解如下：\n- `g++\\\\ %` 如上所述，等同于运行 `g++ <your-file>`。\n- `-o` 输出选项。\n- `%<` 在 Vim 中代表了没有扩展名的当前文件名（如 `hello.cpp` 变成 `hello`）。\n\n当您在 `./hello.cpp` 中运行 `:make` 时，它将编译为 `./hello`。要在 `./hello.cpp` 中快速地执行 `./hello`，可以运行 `:!./%<`。同样，它等同于运行 `:!./<无后缀的当前文件名>`。\n\n查阅 `:h :compiler` 和 `:h write-compiler-plugin` 可以了解更多信息。\n\n## 保存时自动编译\n\n有了自动化编译，您可以让生活更加轻松。回想一下，您可以使用 Vim 的 `autocmd` 来根据某些事件自动执行操作。例如，要自动在每次保存后编译 `.cpp` 文件，您可以将下面内容添加到vimrc：\n\n```\n:autocmd BufWritePost *.cpp make\n```\n\n现在您每次保存 `.cpp` 文件后，Vim 都将自动执行 `make` 命令。\n\n## 切换编译器\n\nVim 有一个 `:compiler` 命令可以快速切换编译器。您的 Vim 可能附带了一些预构建的编译配置。要检查您拥有哪些编译器，请运行：\n\n```\n:e $VIMRUNTIME/compilers/<tab>\n```\n\n您应该会看到一个不同编程语言的编译器列表。\n\n若要使用 `:compiler` 命令，假设您有一个 ruby 文件 `hello.rb`，内容是：\n\n```\nputs \"Hello ruby\"\n```\n\n回想一下，如果运行 `:make`，Vim 将执行赋值给 `makeprg` 的任何命令（默认是 `make`）。如果您运行：\n\n```\n:compiler ruby\n```\n\nVim 执行 `$VIMRUNTIME/compiler/ruby.vim` 脚本，并将 `makeprg` 更改为使用 `ruby` 命令。现在如果您运行 `:set makeprg?`，它会显示 `makeprg=ruby`（这取决于您 `$VIMRUNTIME/compiler/ruby.vim` 里的内容，如果您有其他自定义的 ruby 编译器，您的结果可能会有不同）。`:compiler <your-lang>` 命令允许您快速切换至其他编译器。如果您的项目使用多种语言，这会非常有用。\n\n您不必使用 `:compiler` 或 `makeprg` 来编译程序。您可以运行测试脚本、分析文件、发送信号或任何您想要的内容。\n\n## 创建自定义编译器\n\n让我们来创建一个简单的 Typescript 编译器。先在您的设备上安装 Typescript（`npm install -g typescript`），安装完后您将有 `tsc` 命令。如果您之前没有尝试过 typescript，`tsc` 将 Typescript 文件编译成 Javascript 文件。假设您有一个 `hello.ts` 文件：\n\n```\nconst hello = \"hello\";\nconsole.log(hello);\n```\n\n运行 `tsc hello.ts` 后，它将被编译成 `hello.js`。然而，如果您的 `hello.ts` 文件中有如下内容：\n\n```\nconst hello = \"hello\";\nhello = \"hello again\";\nconsole.log(hello);\n```\n\n这会抛出错误，因为不能更改一个 `const` 变量。运行 `tsc hello.ts` 的错误如下：\n\n```\nhello.ts:2:1 - error TS2588: Cannot assign to 'person' because it is a constant.\n\n2 person = \"hello again\";\n  ~~~~~~\n\n\nFound 1 error.\n```\n\n要创建一个简单的 Typescript 编译器，请在您的 `~/.vim/` 目录中新添加一个 `compiler` 目录（即 `~/.vim/compiler/`），接着创建 `typescript.vim` 文件（即 `~/.vim/compiler/typescript.vim`），并添加如下内容：\n\n```\nCompilerSet makeprg=tsc\nCompilerSet errorformat=%f:\\ %m\n```\n\n第一行将 `makeprg` 设置为运行 `tsc` 命令。第二行将错误格式设置为显示文件（`%f`），后跟冒号（`:`）和转义的空格（`\\ `），最后是错误消息（`%m`）。查阅 `:h errorformat` 可了解更多关于错误格式的信息。\n\n您还可以阅读一些预制的编译器，看看它们是如何实现的。输入 `:e $VIMRUNTIME/compiler/<some-language>.vim` 查看。\n\n有些插件可能会干扰 Typescript 文件，可以使用 `--noplugin` 标志以零插件的形式打开`hello.ts` 文件：\n\n```\nvim --noplugin hello.ts\n```\n\n检查 `makeprg`：\n\n```\n:set makeprg?\n```\n\n它应该会显示默认的 `make` 程序。要使用新的 Typescript 编译器，请运行：\n\n```\n:compiler typescript\n```\n\n当您运行 `:set makeprg?` 时，它应该会显示 `tsc` 了。我们来测试一下：\n\n```\n:make %\n```\n\n回想一下，`%` 代表当前文件。看看您的 Typescript 编译器是否如预期一样工作。运行 `:copen` 可以查看错误列表。\n\n## 异步编译器\n\n有时编译可能需要很长时间。在等待编译时，您不会想眼睁睁盯着已冻结的 Vim 的。如果可以异步编译，就可以在编译期间继续使用 Vim 了，岂不美哉？\n\n幸运的是，有插件来运行异步进程。有两个比较好的是：\n\n- [vim-dispatch](https://github.com/tpope/vim-dispatch)\n- [asyncrun.vim](https://github.com/skywind3000/asyncrun.vim)\n\n在这一章中，我将介绍 vim-dispatch，但我强烈建议您尝试上述列表中所有插件。\n\n*Vim 和 NeoVim 实际上都支持异步作业，但它们超出了本章的范围。如果您好奇，可以查阅 `:h job-channel-overview.txt`。*\n\n## 插件：Vim-dispatch\n\nVim-dispatch 有几个命令，最主要的两个是 `:Make` 和 `:Dispatch`。\n\n### 异步Make\n\nVim-dispatch 的 `:Make` 命令与 Vim 的 `:make` 相似，但它以异步方式运行。如果您正处于 Javascript 项目中，并且需要运行 `npm t`，可以将 `makeprg` 设置为：\n\n```\n:set makeprg=npm\\\\ t\n```\n\n如果运行：\n\n```\n:make\n```\n\nVim 将执行 `npm t`。但同时，您只能盯着冻结了的屏幕。有了 vim-dispatch，您只需要运行：\n\n```\n:Make\n```\n\nVim 将启用后台进程异步运行 `npm t`，同时您还能在 Vim 中继续编辑您的文本。棒极了！\n\n### 异步调度（Dispatch）\n\n`:Dispatch` 命令的工作方式和 `:compiler` 及 `:!` 类似，它可以在Vim中运行任意外部命令。\n\n假设您在 ruby spec 文件中，需要执行测试，可以运行：\n\n```\n:Dispatch rspec %\n```\n\nVim 将对当前文件异步运行 `rspec` 命令。\n\n### 自动调度\n\nVim-dispatch 有一个缓冲区变量`b:dispatch`，您可以配置它来自动执行特定命令，您可以利用 `autocmd`和它一起工作。如果在您的 vimrc 中添加如下内容：\n\n```\nautocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %'\n```\n\n现在每当您进入（`BufEnter`）一个以 `_spec.rb` 结尾的文件，运行`:Dispatch` 将自动执行 `bundle exec rspec <your-current-ruby-spec-file>`。\n\n## 聪明地学习编译\n\n在本章中，您了解到可以使用 `make` 和 `compiler` 命令从Vim内部异步运行 *任何* 进程，以完善您的编程工作流程。Vim 拥有通过其他程序来扩展自身的能力，这使其变得强大。\n","source":"_posts/Vim/ch19_compile.md","raw":"---\ntitle: VIM-编译\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第19章 编译\n\n编译是许多编程语言的重要主题。在本章中，您将学习如何在 Vim 中编译。此外，您将看到如何利用好 Vim 的 `:make` 命令。\n\n## 从命令行编译\n\n您可以使用叹号运算符（`!`）进行编译。如果您需要使用 `g++` 来编译 `.cpp` 文件，可以运行：\n\n```\n:!g++ hello.cpp -o hello\n```\n\n但要每次手动指定文件名和输出文件名会非常繁琐和容易出错。而 makefile 是条可行之路。\n\n## Make命令\n\nVim 有运行 makefile 的 `:make` 命令。当您运行它时，Vim 会在当前目录查找 makefile 并执行它。\n\n在当前目录创建一个文件名为 `makefile` ，然后添加下列内容：\n\n```\nall:\n\techo \"Hello all\"\nfoo:\n\techo \"Hello foo\"\nlist_pls:\n\tls\n```\n\n在 Vim 中运行：\n\n```\n:make\n```\n\nVim 执行它的方式与从终端运行它的方式相同。`:make` 命令也接受终端中 `make` 命令的参数。运行：\n\n```\n:make foo\n\" Outputs \"Hello foo\"\n\n:make list_pls\n\" Outputs the ls command result\n```\n\n如果命令执行异常，`:make` 命令将使用 Vim 的 `quickfix` 来存储这些错误。现在试着运行一个不存在的目标：\n\n```\n:make dontexist\n```\n\n您应该会看到该命令执行错误。运行 `quickfix` 命令 `:copen` 可以打开 `quickfix` 窗口来查看该错误：\n\n```\n|| make: *** No rule to make target `dontexist'.  Stop.\n```\n\n## 使用 Make 编译\n\n让我们使用 makefile 来编译一个基本的 `.cpp` 程序。首先创建一个 `hello.cpp` 文件：\n\n```\n#include <iostream>\n\nint main() {\n    std::cout << \"Hello!\\n\";\n    return 0;\n}\n```\n\n然后，更新 `makefile` 来编译和运行 `.cpp` 文件：\n\n```\nall:\n\techo \"build, run\"\nbuild:\n\tg++ hello.cpp -o hello\nrun:\n\t./hello\n```\n\n现在运行：\n\n```\n:make build\n```\n\n`g++` 将编译 `./hello.cpp` 并且生成 `./hello`。接着运行：\n\n```\n:make run\n```\n\n您应该会看到终端上打印出了 `\"Hello!\"`。\n\n## 不同的Make程序\n\n当您运行 `:make` 时，Vim 实际上会执行 `makeprg` 选项所设置的任何命令，您可以运行 `:set makeprg?` 来查看它：\n\n```\nmakeprg=make\n```\n\n`:make` 的默认命令是外部的 `make` 命令。若想修改 `:make` 命令，使每次运行它时执行 `g++ <your-file-name>`，请运行：\n\n```\n:set makeprg=g++\\ %\n```\n\n`\\` 用于转义 `g++` 后的空格。Vim 中 `%` 符号代表当前文件。因此，`g++\\ %` 命令等于运行 `g++ hello.cpp`。\n\n转到 `./hello.cpp` 然后运行 `:make`，Vim 将编译 `hello.cpp` 并输出 `a.out`（因为您没有指定输出）。让我们重构一下，使用去掉扩展名的原始文件名来命名编译后的输出。运行下面的命令（或将它们添加到vimrc）：\n\n```\n:set makeprg=g++\\ %\\ -o\\ %<\n```\n\n上面的命令分解如下：\n- `g++\\\\ %` 如上所述，等同于运行 `g++ <your-file>`。\n- `-o` 输出选项。\n- `%<` 在 Vim 中代表了没有扩展名的当前文件名（如 `hello.cpp` 变成 `hello`）。\n\n当您在 `./hello.cpp` 中运行 `:make` 时，它将编译为 `./hello`。要在 `./hello.cpp` 中快速地执行 `./hello`，可以运行 `:!./%<`。同样，它等同于运行 `:!./<无后缀的当前文件名>`。\n\n查阅 `:h :compiler` 和 `:h write-compiler-plugin` 可以了解更多信息。\n\n## 保存时自动编译\n\n有了自动化编译，您可以让生活更加轻松。回想一下，您可以使用 Vim 的 `autocmd` 来根据某些事件自动执行操作。例如，要自动在每次保存后编译 `.cpp` 文件，您可以将下面内容添加到vimrc：\n\n```\n:autocmd BufWritePost *.cpp make\n```\n\n现在您每次保存 `.cpp` 文件后，Vim 都将自动执行 `make` 命令。\n\n## 切换编译器\n\nVim 有一个 `:compiler` 命令可以快速切换编译器。您的 Vim 可能附带了一些预构建的编译配置。要检查您拥有哪些编译器，请运行：\n\n```\n:e $VIMRUNTIME/compilers/<tab>\n```\n\n您应该会看到一个不同编程语言的编译器列表。\n\n若要使用 `:compiler` 命令，假设您有一个 ruby 文件 `hello.rb`，内容是：\n\n```\nputs \"Hello ruby\"\n```\n\n回想一下，如果运行 `:make`，Vim 将执行赋值给 `makeprg` 的任何命令（默认是 `make`）。如果您运行：\n\n```\n:compiler ruby\n```\n\nVim 执行 `$VIMRUNTIME/compiler/ruby.vim` 脚本，并将 `makeprg` 更改为使用 `ruby` 命令。现在如果您运行 `:set makeprg?`，它会显示 `makeprg=ruby`（这取决于您 `$VIMRUNTIME/compiler/ruby.vim` 里的内容，如果您有其他自定义的 ruby 编译器，您的结果可能会有不同）。`:compiler <your-lang>` 命令允许您快速切换至其他编译器。如果您的项目使用多种语言，这会非常有用。\n\n您不必使用 `:compiler` 或 `makeprg` 来编译程序。您可以运行测试脚本、分析文件、发送信号或任何您想要的内容。\n\n## 创建自定义编译器\n\n让我们来创建一个简单的 Typescript 编译器。先在您的设备上安装 Typescript（`npm install -g typescript`），安装完后您将有 `tsc` 命令。如果您之前没有尝试过 typescript，`tsc` 将 Typescript 文件编译成 Javascript 文件。假设您有一个 `hello.ts` 文件：\n\n```\nconst hello = \"hello\";\nconsole.log(hello);\n```\n\n运行 `tsc hello.ts` 后，它将被编译成 `hello.js`。然而，如果您的 `hello.ts` 文件中有如下内容：\n\n```\nconst hello = \"hello\";\nhello = \"hello again\";\nconsole.log(hello);\n```\n\n这会抛出错误，因为不能更改一个 `const` 变量。运行 `tsc hello.ts` 的错误如下：\n\n```\nhello.ts:2:1 - error TS2588: Cannot assign to 'person' because it is a constant.\n\n2 person = \"hello again\";\n  ~~~~~~\n\n\nFound 1 error.\n```\n\n要创建一个简单的 Typescript 编译器，请在您的 `~/.vim/` 目录中新添加一个 `compiler` 目录（即 `~/.vim/compiler/`），接着创建 `typescript.vim` 文件（即 `~/.vim/compiler/typescript.vim`），并添加如下内容：\n\n```\nCompilerSet makeprg=tsc\nCompilerSet errorformat=%f:\\ %m\n```\n\n第一行将 `makeprg` 设置为运行 `tsc` 命令。第二行将错误格式设置为显示文件（`%f`），后跟冒号（`:`）和转义的空格（`\\ `），最后是错误消息（`%m`）。查阅 `:h errorformat` 可了解更多关于错误格式的信息。\n\n您还可以阅读一些预制的编译器，看看它们是如何实现的。输入 `:e $VIMRUNTIME/compiler/<some-language>.vim` 查看。\n\n有些插件可能会干扰 Typescript 文件，可以使用 `--noplugin` 标志以零插件的形式打开`hello.ts` 文件：\n\n```\nvim --noplugin hello.ts\n```\n\n检查 `makeprg`：\n\n```\n:set makeprg?\n```\n\n它应该会显示默认的 `make` 程序。要使用新的 Typescript 编译器，请运行：\n\n```\n:compiler typescript\n```\n\n当您运行 `:set makeprg?` 时，它应该会显示 `tsc` 了。我们来测试一下：\n\n```\n:make %\n```\n\n回想一下，`%` 代表当前文件。看看您的 Typescript 编译器是否如预期一样工作。运行 `:copen` 可以查看错误列表。\n\n## 异步编译器\n\n有时编译可能需要很长时间。在等待编译时，您不会想眼睁睁盯着已冻结的 Vim 的。如果可以异步编译，就可以在编译期间继续使用 Vim 了，岂不美哉？\n\n幸运的是，有插件来运行异步进程。有两个比较好的是：\n\n- [vim-dispatch](https://github.com/tpope/vim-dispatch)\n- [asyncrun.vim](https://github.com/skywind3000/asyncrun.vim)\n\n在这一章中，我将介绍 vim-dispatch，但我强烈建议您尝试上述列表中所有插件。\n\n*Vim 和 NeoVim 实际上都支持异步作业，但它们超出了本章的范围。如果您好奇，可以查阅 `:h job-channel-overview.txt`。*\n\n## 插件：Vim-dispatch\n\nVim-dispatch 有几个命令，最主要的两个是 `:Make` 和 `:Dispatch`。\n\n### 异步Make\n\nVim-dispatch 的 `:Make` 命令与 Vim 的 `:make` 相似，但它以异步方式运行。如果您正处于 Javascript 项目中，并且需要运行 `npm t`，可以将 `makeprg` 设置为：\n\n```\n:set makeprg=npm\\\\ t\n```\n\n如果运行：\n\n```\n:make\n```\n\nVim 将执行 `npm t`。但同时，您只能盯着冻结了的屏幕。有了 vim-dispatch，您只需要运行：\n\n```\n:Make\n```\n\nVim 将启用后台进程异步运行 `npm t`，同时您还能在 Vim 中继续编辑您的文本。棒极了！\n\n### 异步调度（Dispatch）\n\n`:Dispatch` 命令的工作方式和 `:compiler` 及 `:!` 类似，它可以在Vim中运行任意外部命令。\n\n假设您在 ruby spec 文件中，需要执行测试，可以运行：\n\n```\n:Dispatch rspec %\n```\n\nVim 将对当前文件异步运行 `rspec` 命令。\n\n### 自动调度\n\nVim-dispatch 有一个缓冲区变量`b:dispatch`，您可以配置它来自动执行特定命令，您可以利用 `autocmd`和它一起工作。如果在您的 vimrc 中添加如下内容：\n\n```\nautocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %'\n```\n\n现在每当您进入（`BufEnter`）一个以 `_spec.rb` 结尾的文件，运行`:Dispatch` 将自动执行 `bundle exec rspec <your-current-ruby-spec-file>`。\n\n## 聪明地学习编译\n\n在本章中，您了解到可以使用 `make` 和 `compiler` 命令从Vim内部异步运行 *任何* 进程，以完善您的编程工作流程。Vim 拥有通过其他程序来扩展自身的能力，这使其变得强大。\n","slug":"Vim/ch19_compile","published":1,"updated":"2022-08-28T07:38:59.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i24002hscvme6wwdgsx","content":"<h1 id=\"第19章-编译\"><a href=\"#第19章-编译\" class=\"headerlink\" title=\"第19章 编译\"></a>第19章 编译</h1><p>编译是许多编程语言的重要主题。在本章中，您将学习如何在 Vim 中编译。此外，您将看到如何利用好 Vim 的 <code>:make</code> 命令。</p>\n<h2 id=\"从命令行编译\"><a href=\"#从命令行编译\" class=\"headerlink\" title=\"从命令行编译\"></a>从命令行编译</h2><p>您可以使用叹号运算符（<code>!</code>）进行编译。如果您需要使用 <code>g++</code> 来编译 <code>.cpp</code> 文件，可以运行：</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs brainfuck\"><span class=\"hljs-comment\">:!g</span><span class=\"hljs-literal\">++</span> <span class=\"hljs-comment\">hello</span><span class=\"hljs-string\">.</span><span class=\"hljs-comment\">cpp</span> <span class=\"hljs-literal\">-</span><span class=\"hljs-comment\">o hello</span><br></code></pre></td></tr></table></figure>\n\n<p>但要每次手动指定文件名和输出文件名会非常繁琐和容易出错。而 makefile 是条可行之路。</p>\n<h2 id=\"Make命令\"><a href=\"#Make命令\" class=\"headerlink\" title=\"Make命令\"></a>Make命令</h2><p>Vim 有运行 makefile 的 <code>:make</code> 命令。当您运行它时，Vim 会在当前目录查找 makefile 并执行它。</p>\n<p>在当前目录创建一个文件名为 <code>makefile</code> ，然后添加下列内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">all</span>:<br>\t<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello all&quot;</span><br>foo:<br>\t<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello foo&quot;</span><br>list_pls:<br>\t<span class=\"hljs-keyword\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>在 Vim 中运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:make</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 执行它的方式与从终端运行它的方式相同。<code>:make</code> 命令也接受终端中 <code>make</code> 命令的参数。运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">make</span> foo<br><span class=\"hljs-string\">&quot; Outputs &quot;</span>Hello foo<span class=\"hljs-comment\">&quot;</span><br><br>:<span class=\"hljs-keyword\">make</span> list_pls<br><span class=\"hljs-comment\">&quot; Outputs the ls command result</span><br></code></pre></td></tr></table></figure>\n\n<p>如果命令执行异常，<code>:make</code> 命令将使用 Vim 的 <code>quickfix</code> 来存储这些错误。现在试着运行一个不存在的目标：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:make</span> dontexist<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到该命令执行错误。运行 <code>quickfix</code> 命令 <code>:copen</code> 可以打开 <code>quickfix</code> 窗口来查看该错误：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">|| <span class=\"hljs-built_in\">make</span>: *** No rule to <span class=\"hljs-built_in\">make</span> target `dontexist&#x27;.  <span class=\"hljs-keyword\">Stop</span>.<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用-Make-编译\"><a href=\"#使用-Make-编译\" class=\"headerlink\" title=\"使用 Make 编译\"></a>使用 Make 编译</h2><p>让我们使用 makefile 来编译一个基本的 <code>.cpp</code> 程序。首先创建一个 <code>hello.cpp</code> 文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello!\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，更新 <code>makefile</code> 来编译和运行 <code>.cpp</code> 文件：</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">all:</span><br>\techo <span class=\"hljs-string\">&quot;build, run&quot;</span><br><span class=\"hljs-symbol\">build:</span><br>\tg++ hello.cpp -o hello<br><span class=\"hljs-symbol\">run:</span><br>\t./hello<br></code></pre></td></tr></table></figure>\n\n<p>现在运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:make</span> build<br></code></pre></td></tr></table></figure>\n\n<p><code>g++</code> 将编译 <code>./hello.cpp</code> 并且生成 <code>./hello</code>。接着运行：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">:<span class=\"hljs-built_in\">make</span> <span class=\"hljs-keyword\">run</span><br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到终端上打印出了 <code>&quot;Hello!&quot;</code>。</p>\n<h2 id=\"不同的Make程序\"><a href=\"#不同的Make程序\" class=\"headerlink\" title=\"不同的Make程序\"></a>不同的Make程序</h2><p>当您运行 <code>:make</code> 时，Vim 实际上会执行 <code>makeprg</code> 选项所设置的任何命令，您可以运行 <code>:set makeprg?</code> 来查看它：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">makeprg</span><span class=\"hljs-operator\">=</span>make<br></code></pre></td></tr></table></figure>\n\n<p><code>:make</code> 的默认命令是外部的 <code>make</code> 命令。若想修改 <code>:make</code> 命令，使每次运行它时执行 <code>g++ &lt;your-file-name&gt;</code>，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">makeprg</span>=g++\\ %<br></code></pre></td></tr></table></figure>\n\n<p><code>\\</code> 用于转义 <code>g++</code> 后的空格。Vim 中 <code>%</code> 符号代表当前文件。因此，<code>g++\\ %</code> 命令等于运行 <code>g++ hello.cpp</code>。</p>\n<p>转到 <code>./hello.cpp</code> 然后运行 <code>:make</code>，Vim 将编译 <code>hello.cpp</code> 并输出 <code>a.out</code>（因为您没有指定输出）。让我们重构一下，使用去掉扩展名的原始文件名来命名编译后的输出。运行下面的命令（或将它们添加到vimrc）：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">makeprg</span>=g++\\ %\\ -o\\ %&lt;<br></code></pre></td></tr></table></figure>\n\n<p>上面的命令分解如下：</p>\n<ul>\n<li><code>g++\\\\ %</code> 如上所述，等同于运行 <code>g++ &lt;your-file&gt;</code>。</li>\n<li><code>-o</code> 输出选项。</li>\n<li><code>%&lt;</code> 在 Vim 中代表了没有扩展名的当前文件名（如 <code>hello.cpp</code> 变成 <code>hello</code>）。</li>\n</ul>\n<p>当您在 <code>./hello.cpp</code> 中运行 <code>:make</code> 时，它将编译为 <code>./hello</code>。要在 <code>./hello.cpp</code> 中快速地执行 <code>./hello</code>，可以运行 <code>:!./%&lt;</code>。同样，它等同于运行 <code>:!./&lt;无后缀的当前文件名&gt;</code>。</p>\n<p>查阅 <code>:h :compiler</code> 和 <code>:h write-compiler-plugin</code> 可以了解更多信息。</p>\n<h2 id=\"保存时自动编译\"><a href=\"#保存时自动编译\" class=\"headerlink\" title=\"保存时自动编译\"></a>保存时自动编译</h2><p>有了自动化编译，您可以让生活更加轻松。回想一下，您可以使用 Vim 的 <code>autocmd</code> 来根据某些事件自动执行操作。例如，要自动在每次保存后编译 <code>.cpp</code> 文件，您可以将下面内容添加到vimrc：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">autocmd</span> BufWritePost *.cpp <span class=\"hljs-keyword\">make</span><br></code></pre></td></tr></table></figure>\n\n<p>现在您每次保存 <code>.cpp</code> 文件后，Vim 都将自动执行 <code>make</code> 命令。</p>\n<h2 id=\"切换编译器\"><a href=\"#切换编译器\" class=\"headerlink\" title=\"切换编译器\"></a>切换编译器</h2><p>Vim 有一个 <code>:compiler</code> 命令可以快速切换编译器。您的 Vim 可能附带了一些预构建的编译配置。要检查您拥有哪些编译器，请运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:e <span class=\"hljs-variable\">$VIMRUNTIME</span><span class=\"hljs-regexp\">/compilers/</span>&lt;tab&gt;<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到一个不同编程语言的编译器列表。</p>\n<p>若要使用 <code>:compiler</code> 命令，假设您有一个 ruby 文件 <code>hello.rb</code>，内容是：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">puts</span> <span class=\"hljs-string\">&quot;Hello ruby&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>回想一下，如果运行 <code>:make</code>，Vim 将执行赋值给 <code>makeprg</code> 的任何命令（默认是 <code>make</code>）。如果您运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">compiler</span> <span class=\"hljs-keyword\">ruby</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 执行 <code>$VIMRUNTIME/compiler/ruby.vim</code> 脚本，并将 <code>makeprg</code> 更改为使用 <code>ruby</code> 命令。现在如果您运行 <code>:set makeprg?</code>，它会显示 <code>makeprg=ruby</code>（这取决于您 <code>$VIMRUNTIME/compiler/ruby.vim</code> 里的内容，如果您有其他自定义的 ruby 编译器，您的结果可能会有不同）。<code>:compiler &lt;your-lang&gt;</code> 命令允许您快速切换至其他编译器。如果您的项目使用多种语言，这会非常有用。</p>\n<p>您不必使用 <code>:compiler</code> 或 <code>makeprg</code> 来编译程序。您可以运行测试脚本、分析文件、发送信号或任何您想要的内容。</p>\n<h2 id=\"创建自定义编译器\"><a href=\"#创建自定义编译器\" class=\"headerlink\" title=\"创建自定义编译器\"></a>创建自定义编译器</h2><p>让我们来创建一个简单的 Typescript 编译器。先在您的设备上安装 Typescript（<code>npm install -g typescript</code>），安装完后您将有 <code>tsc</code> 命令。如果您之前没有尝试过 typescript，<code>tsc</code> 将 Typescript 文件编译成 Javascript 文件。假设您有一个 <code>hello.ts</code> 文件：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello&quot;</span><span class=\"hljs-comment\">;</span><br>console.log(hello)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>tsc hello.ts</code> 后，它将被编译成 <code>hello.js</code>。然而，如果您的 <code>hello.ts</code> 文件中有如下内容：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello&quot;</span><span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">hello</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello again&quot;</span><span class=\"hljs-comment\">;</span><br>console.log(hello)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>这会抛出错误，因为不能更改一个 <code>const</code> 变量。运行 <code>tsc hello.ts</code> 的错误如下：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hello.ts:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">error</span> TS2588: Cannot assign <span class=\"hljs-keyword\">to</span> &#x27;person&#x27; because <span class=\"hljs-keyword\">it</span> <span class=\"hljs-keyword\">is</span> a <span class=\"hljs-built_in\">constant</span>.<br><br><span class=\"hljs-number\">2</span> person = <span class=\"hljs-string\">&quot;hello again&quot;</span>;<br>  ~~~~~~<br><br><br>Found <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">error</span>.<br></code></pre></td></tr></table></figure>\n\n<p>要创建一个简单的 Typescript 编译器，请在您的 <code>~/.vim/</code> 目录中新添加一个 <code>compiler</code> 目录（即 <code>~/.vim/compiler/</code>），接着创建 <code>typescript.vim</code> 文件（即 <code>~/.vim/compiler/typescript.vim</code>），并添加如下内容：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">CompilerSet <span class=\"hljs-attribute\">makeprg</span>=tsc<br>CompilerSet <span class=\"hljs-attribute\">errorformat</span>=%f:\\ %m<br></code></pre></td></tr></table></figure>\n\n<p>第一行将 <code>makeprg</code> 设置为运行 <code>tsc</code> 命令。第二行将错误格式设置为显示文件（<code>%f</code>），后跟冒号（<code>:</code>）和转义的空格（<code>\\ </code>），最后是错误消息（<code>%m</code>）。查阅 <code>:h errorformat</code> 可了解更多关于错误格式的信息。</p>\n<p>您还可以阅读一些预制的编译器，看看它们是如何实现的。输入 <code>:e $VIMRUNTIME/compiler/&lt;some-language&gt;.vim</code> 查看。</p>\n<p>有些插件可能会干扰 Typescript 文件，可以使用 <code>--noplugin</code> 标志以零插件的形式打开<code>hello.ts</code> 文件：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> --noplugin hello.<span class=\"hljs-keyword\">ts</span><br></code></pre></td></tr></table></figure>\n\n<p>检查 <code>makeprg</code>：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> makeprg?<br></code></pre></td></tr></table></figure>\n\n<p>它应该会显示默认的 <code>make</code> 程序。要使用新的 Typescript 编译器，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:compiler</span> typescript<br></code></pre></td></tr></table></figure>\n\n<p>当您运行 <code>:set makeprg?</code> 时，它应该会显示 <code>tsc</code> 了。我们来测试一下：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:make</span> %<br></code></pre></td></tr></table></figure>\n\n<p>回想一下，<code>%</code> 代表当前文件。看看您的 Typescript 编译器是否如预期一样工作。运行 <code>:copen</code> 可以查看错误列表。</p>\n<h2 id=\"异步编译器\"><a href=\"#异步编译器\" class=\"headerlink\" title=\"异步编译器\"></a>异步编译器</h2><p>有时编译可能需要很长时间。在等待编译时，您不会想眼睁睁盯着已冻结的 Vim 的。如果可以异步编译，就可以在编译期间继续使用 Vim 了，岂不美哉？</p>\n<p>幸运的是，有插件来运行异步进程。有两个比较好的是：</p>\n<ul>\n<li><a href=\"https://github.com/tpope/vim-dispatch\">vim-dispatch</a></li>\n<li><a href=\"https://github.com/skywind3000/asyncrun.vim\">asyncrun.vim</a></li>\n</ul>\n<p>在这一章中，我将介绍 vim-dispatch，但我强烈建议您尝试上述列表中所有插件。</p>\n<p><em>Vim 和 NeoVim 实际上都支持异步作业，但它们超出了本章的范围。如果您好奇，可以查阅 <code>:h job-channel-overview.txt</code>。</em></p>\n<h2 id=\"插件：Vim-dispatch\"><a href=\"#插件：Vim-dispatch\" class=\"headerlink\" title=\"插件：Vim-dispatch\"></a>插件：Vim-dispatch</h2><p>Vim-dispatch 有几个命令，最主要的两个是 <code>:Make</code> 和 <code>:Dispatch</code>。</p>\n<h3 id=\"异步Make\"><a href=\"#异步Make\" class=\"headerlink\" title=\"异步Make\"></a>异步Make</h3><p>Vim-dispatch 的 <code>:Make</code> 命令与 Vim 的 <code>:make</code> 相似，但它以异步方式运行。如果您正处于 Javascript 项目中，并且需要运行 <code>npm t</code>，可以将 <code>makeprg</code> 设置为：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">makeprg</span>=npm\\\\ t<br></code></pre></td></tr></table></figure>\n\n<p>如果运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:make</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 将执行 <code>npm t</code>。但同时，您只能盯着冻结了的屏幕。有了 vim-dispatch，您只需要运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:Make</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 将启用后台进程异步运行 <code>npm t</code>，同时您还能在 Vim 中继续编辑您的文本。棒极了！</p>\n<h3 id=\"异步调度（Dispatch）\"><a href=\"#异步调度（Dispatch）\" class=\"headerlink\" title=\"异步调度（Dispatch）\"></a>异步调度（Dispatch）</h3><p><code>:Dispatch</code> 命令的工作方式和 <code>:compiler</code> 及 <code>:!</code> 类似，它可以在Vim中运行任意外部命令。</p>\n<p>假设您在 ruby spec 文件中，需要执行测试，可以运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:Dispatch</span> rspec %<br></code></pre></td></tr></table></figure>\n\n<p>Vim 将对当前文件异步运行 <code>rspec</code> 命令。</p>\n<h3 id=\"自动调度\"><a href=\"#自动调度\" class=\"headerlink\" title=\"自动调度\"></a>自动调度</h3><p>Vim-dispatch 有一个缓冲区变量<code>b:dispatch</code>，您可以配置它来自动执行特定命令，您可以利用 <code>autocmd</code>和它一起工作。如果在您的 vimrc 中添加如下内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">autocmd</span> BufEnter *_spec.rb <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">b:dispatch</span> = <span class=\"hljs-string\">&#x27;bundle exec rspec %&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>现在每当您进入（<code>BufEnter</code>）一个以 <code>_spec.rb</code> 结尾的文件，运行<code>:Dispatch</code> 将自动执行 <code>bundle exec rspec &lt;your-current-ruby-spec-file&gt;</code>。</p>\n<h2 id=\"聪明地学习编译\"><a href=\"#聪明地学习编译\" class=\"headerlink\" title=\"聪明地学习编译\"></a>聪明地学习编译</h2><p>在本章中，您了解到可以使用 <code>make</code> 和 <code>compiler</code> 命令从Vim内部异步运行 <em>任何</em> 进程，以完善您的编程工作流程。Vim 拥有通过其他程序来扩展自身的能力，这使其变得强大。</p>\n","site":{"data":{}},"wordcount":4461,"excerpt":"","more":"<h1 id=\"第19章-编译\"><a href=\"#第19章-编译\" class=\"headerlink\" title=\"第19章 编译\"></a>第19章 编译</h1><p>编译是许多编程语言的重要主题。在本章中，您将学习如何在 Vim 中编译。此外，您将看到如何利用好 Vim 的 <code>:make</code> 命令。</p>\n<h2 id=\"从命令行编译\"><a href=\"#从命令行编译\" class=\"headerlink\" title=\"从命令行编译\"></a>从命令行编译</h2><p>您可以使用叹号运算符（<code>!</code>）进行编译。如果您需要使用 <code>g++</code> 来编译 <code>.cpp</code> 文件，可以运行：</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs brainfuck\"><span class=\"hljs-comment\">:!g</span><span class=\"hljs-literal\">++</span> <span class=\"hljs-comment\">hello</span><span class=\"hljs-string\">.</span><span class=\"hljs-comment\">cpp</span> <span class=\"hljs-literal\">-</span><span class=\"hljs-comment\">o hello</span><br></code></pre></td></tr></table></figure>\n\n<p>但要每次手动指定文件名和输出文件名会非常繁琐和容易出错。而 makefile 是条可行之路。</p>\n<h2 id=\"Make命令\"><a href=\"#Make命令\" class=\"headerlink\" title=\"Make命令\"></a>Make命令</h2><p>Vim 有运行 makefile 的 <code>:make</code> 命令。当您运行它时，Vim 会在当前目录查找 makefile 并执行它。</p>\n<p>在当前目录创建一个文件名为 <code>makefile</code> ，然后添加下列内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">all</span>:<br>\t<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello all&quot;</span><br>foo:<br>\t<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello foo&quot;</span><br>list_pls:<br>\t<span class=\"hljs-keyword\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>在 Vim 中运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:make</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 执行它的方式与从终端运行它的方式相同。<code>:make</code> 命令也接受终端中 <code>make</code> 命令的参数。运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">make</span> foo<br><span class=\"hljs-string\">&quot; Outputs &quot;</span>Hello foo<span class=\"hljs-comment\">&quot;</span><br><br>:<span class=\"hljs-keyword\">make</span> list_pls<br><span class=\"hljs-comment\">&quot; Outputs the ls command result</span><br></code></pre></td></tr></table></figure>\n\n<p>如果命令执行异常，<code>:make</code> 命令将使用 Vim 的 <code>quickfix</code> 来存储这些错误。现在试着运行一个不存在的目标：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:make</span> dontexist<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到该命令执行错误。运行 <code>quickfix</code> 命令 <code>:copen</code> 可以打开 <code>quickfix</code> 窗口来查看该错误：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">|| <span class=\"hljs-built_in\">make</span>: *** No rule to <span class=\"hljs-built_in\">make</span> target `dontexist&#x27;.  <span class=\"hljs-keyword\">Stop</span>.<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用-Make-编译\"><a href=\"#使用-Make-编译\" class=\"headerlink\" title=\"使用 Make 编译\"></a>使用 Make 编译</h2><p>让我们使用 makefile 来编译一个基本的 <code>.cpp</code> 程序。首先创建一个 <code>hello.cpp</code> 文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello!\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，更新 <code>makefile</code> 来编译和运行 <code>.cpp</code> 文件：</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">all:</span><br>\techo <span class=\"hljs-string\">&quot;build, run&quot;</span><br><span class=\"hljs-symbol\">build:</span><br>\tg++ hello.cpp -o hello<br><span class=\"hljs-symbol\">run:</span><br>\t./hello<br></code></pre></td></tr></table></figure>\n\n<p>现在运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:make</span> build<br></code></pre></td></tr></table></figure>\n\n<p><code>g++</code> 将编译 <code>./hello.cpp</code> 并且生成 <code>./hello</code>。接着运行：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gauss\">:<span class=\"hljs-built_in\">make</span> <span class=\"hljs-keyword\">run</span><br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到终端上打印出了 <code>&quot;Hello!&quot;</code>。</p>\n<h2 id=\"不同的Make程序\"><a href=\"#不同的Make程序\" class=\"headerlink\" title=\"不同的Make程序\"></a>不同的Make程序</h2><p>当您运行 <code>:make</code> 时，Vim 实际上会执行 <code>makeprg</code> 选项所设置的任何命令，您可以运行 <code>:set makeprg?</code> 来查看它：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">makeprg</span><span class=\"hljs-operator\">=</span>make<br></code></pre></td></tr></table></figure>\n\n<p><code>:make</code> 的默认命令是外部的 <code>make</code> 命令。若想修改 <code>:make</code> 命令，使每次运行它时执行 <code>g++ &lt;your-file-name&gt;</code>，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">makeprg</span>=g++\\ %<br></code></pre></td></tr></table></figure>\n\n<p><code>\\</code> 用于转义 <code>g++</code> 后的空格。Vim 中 <code>%</code> 符号代表当前文件。因此，<code>g++\\ %</code> 命令等于运行 <code>g++ hello.cpp</code>。</p>\n<p>转到 <code>./hello.cpp</code> 然后运行 <code>:make</code>，Vim 将编译 <code>hello.cpp</code> 并输出 <code>a.out</code>（因为您没有指定输出）。让我们重构一下，使用去掉扩展名的原始文件名来命名编译后的输出。运行下面的命令（或将它们添加到vimrc）：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">makeprg</span>=g++\\ %\\ -o\\ %&lt;<br></code></pre></td></tr></table></figure>\n\n<p>上面的命令分解如下：</p>\n<ul>\n<li><code>g++\\\\ %</code> 如上所述，等同于运行 <code>g++ &lt;your-file&gt;</code>。</li>\n<li><code>-o</code> 输出选项。</li>\n<li><code>%&lt;</code> 在 Vim 中代表了没有扩展名的当前文件名（如 <code>hello.cpp</code> 变成 <code>hello</code>）。</li>\n</ul>\n<p>当您在 <code>./hello.cpp</code> 中运行 <code>:make</code> 时，它将编译为 <code>./hello</code>。要在 <code>./hello.cpp</code> 中快速地执行 <code>./hello</code>，可以运行 <code>:!./%&lt;</code>。同样，它等同于运行 <code>:!./&lt;无后缀的当前文件名&gt;</code>。</p>\n<p>查阅 <code>:h :compiler</code> 和 <code>:h write-compiler-plugin</code> 可以了解更多信息。</p>\n<h2 id=\"保存时自动编译\"><a href=\"#保存时自动编译\" class=\"headerlink\" title=\"保存时自动编译\"></a>保存时自动编译</h2><p>有了自动化编译，您可以让生活更加轻松。回想一下，您可以使用 Vim 的 <code>autocmd</code> 来根据某些事件自动执行操作。例如，要自动在每次保存后编译 <code>.cpp</code> 文件，您可以将下面内容添加到vimrc：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">autocmd</span> BufWritePost *.cpp <span class=\"hljs-keyword\">make</span><br></code></pre></td></tr></table></figure>\n\n<p>现在您每次保存 <code>.cpp</code> 文件后，Vim 都将自动执行 <code>make</code> 命令。</p>\n<h2 id=\"切换编译器\"><a href=\"#切换编译器\" class=\"headerlink\" title=\"切换编译器\"></a>切换编译器</h2><p>Vim 有一个 <code>:compiler</code> 命令可以快速切换编译器。您的 Vim 可能附带了一些预构建的编译配置。要检查您拥有哪些编译器，请运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:e <span class=\"hljs-variable\">$VIMRUNTIME</span><span class=\"hljs-regexp\">/compilers/</span>&lt;tab&gt;<br></code></pre></td></tr></table></figure>\n\n<p>您应该会看到一个不同编程语言的编译器列表。</p>\n<p>若要使用 <code>:compiler</code> 命令，假设您有一个 ruby 文件 <code>hello.rb</code>，内容是：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">puts</span> <span class=\"hljs-string\">&quot;Hello ruby&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>回想一下，如果运行 <code>:make</code>，Vim 将执行赋值给 <code>makeprg</code> 的任何命令（默认是 <code>make</code>）。如果您运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">compiler</span> <span class=\"hljs-keyword\">ruby</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 执行 <code>$VIMRUNTIME/compiler/ruby.vim</code> 脚本，并将 <code>makeprg</code> 更改为使用 <code>ruby</code> 命令。现在如果您运行 <code>:set makeprg?</code>，它会显示 <code>makeprg=ruby</code>（这取决于您 <code>$VIMRUNTIME/compiler/ruby.vim</code> 里的内容，如果您有其他自定义的 ruby 编译器，您的结果可能会有不同）。<code>:compiler &lt;your-lang&gt;</code> 命令允许您快速切换至其他编译器。如果您的项目使用多种语言，这会非常有用。</p>\n<p>您不必使用 <code>:compiler</code> 或 <code>makeprg</code> 来编译程序。您可以运行测试脚本、分析文件、发送信号或任何您想要的内容。</p>\n<h2 id=\"创建自定义编译器\"><a href=\"#创建自定义编译器\" class=\"headerlink\" title=\"创建自定义编译器\"></a>创建自定义编译器</h2><p>让我们来创建一个简单的 Typescript 编译器。先在您的设备上安装 Typescript（<code>npm install -g typescript</code>），安装完后您将有 <code>tsc</code> 命令。如果您之前没有尝试过 typescript，<code>tsc</code> 将 Typescript 文件编译成 Javascript 文件。假设您有一个 <code>hello.ts</code> 文件：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello&quot;</span><span class=\"hljs-comment\">;</span><br>console.log(hello)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行 <code>tsc hello.ts</code> 后，它将被编译成 <code>hello.js</code>。然而，如果您的 <code>hello.ts</code> 文件中有如下内容：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">const hello <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello&quot;</span><span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">hello</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello again&quot;</span><span class=\"hljs-comment\">;</span><br>console.log(hello)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>这会抛出错误，因为不能更改一个 <code>const</code> 变量。运行 <code>tsc hello.ts</code> 的错误如下：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hello.ts:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">error</span> TS2588: Cannot assign <span class=\"hljs-keyword\">to</span> &#x27;person&#x27; because <span class=\"hljs-keyword\">it</span> <span class=\"hljs-keyword\">is</span> a <span class=\"hljs-built_in\">constant</span>.<br><br><span class=\"hljs-number\">2</span> person = <span class=\"hljs-string\">&quot;hello again&quot;</span>;<br>  ~~~~~~<br><br><br>Found <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">error</span>.<br></code></pre></td></tr></table></figure>\n\n<p>要创建一个简单的 Typescript 编译器，请在您的 <code>~/.vim/</code> 目录中新添加一个 <code>compiler</code> 目录（即 <code>~/.vim/compiler/</code>），接着创建 <code>typescript.vim</code> 文件（即 <code>~/.vim/compiler/typescript.vim</code>），并添加如下内容：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">CompilerSet <span class=\"hljs-attribute\">makeprg</span>=tsc<br>CompilerSet <span class=\"hljs-attribute\">errorformat</span>=%f:\\ %m<br></code></pre></td></tr></table></figure>\n\n<p>第一行将 <code>makeprg</code> 设置为运行 <code>tsc</code> 命令。第二行将错误格式设置为显示文件（<code>%f</code>），后跟冒号（<code>:</code>）和转义的空格（<code>\\ </code>），最后是错误消息（<code>%m</code>）。查阅 <code>:h errorformat</code> 可了解更多关于错误格式的信息。</p>\n<p>您还可以阅读一些预制的编译器，看看它们是如何实现的。输入 <code>:e $VIMRUNTIME/compiler/&lt;some-language&gt;.vim</code> 查看。</p>\n<p>有些插件可能会干扰 Typescript 文件，可以使用 <code>--noplugin</code> 标志以零插件的形式打开<code>hello.ts</code> 文件：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> --noplugin hello.<span class=\"hljs-keyword\">ts</span><br></code></pre></td></tr></table></figure>\n\n<p>检查 <code>makeprg</code>：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> makeprg?<br></code></pre></td></tr></table></figure>\n\n<p>它应该会显示默认的 <code>make</code> 程序。要使用新的 Typescript 编译器，请运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:compiler</span> typescript<br></code></pre></td></tr></table></figure>\n\n<p>当您运行 <code>:set makeprg?</code> 时，它应该会显示 <code>tsc</code> 了。我们来测试一下：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:make</span> %<br></code></pre></td></tr></table></figure>\n\n<p>回想一下，<code>%</code> 代表当前文件。看看您的 Typescript 编译器是否如预期一样工作。运行 <code>:copen</code> 可以查看错误列表。</p>\n<h2 id=\"异步编译器\"><a href=\"#异步编译器\" class=\"headerlink\" title=\"异步编译器\"></a>异步编译器</h2><p>有时编译可能需要很长时间。在等待编译时，您不会想眼睁睁盯着已冻结的 Vim 的。如果可以异步编译，就可以在编译期间继续使用 Vim 了，岂不美哉？</p>\n<p>幸运的是，有插件来运行异步进程。有两个比较好的是：</p>\n<ul>\n<li><a href=\"https://github.com/tpope/vim-dispatch\">vim-dispatch</a></li>\n<li><a href=\"https://github.com/skywind3000/asyncrun.vim\">asyncrun.vim</a></li>\n</ul>\n<p>在这一章中，我将介绍 vim-dispatch，但我强烈建议您尝试上述列表中所有插件。</p>\n<p><em>Vim 和 NeoVim 实际上都支持异步作业，但它们超出了本章的范围。如果您好奇，可以查阅 <code>:h job-channel-overview.txt</code>。</em></p>\n<h2 id=\"插件：Vim-dispatch\"><a href=\"#插件：Vim-dispatch\" class=\"headerlink\" title=\"插件：Vim-dispatch\"></a>插件：Vim-dispatch</h2><p>Vim-dispatch 有几个命令，最主要的两个是 <code>:Make</code> 和 <code>:Dispatch</code>。</p>\n<h3 id=\"异步Make\"><a href=\"#异步Make\" class=\"headerlink\" title=\"异步Make\"></a>异步Make</h3><p>Vim-dispatch 的 <code>:Make</code> 命令与 Vim 的 <code>:make</code> 相似，但它以异步方式运行。如果您正处于 Javascript 项目中，并且需要运行 <code>npm t</code>，可以将 <code>makeprg</code> 设置为：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">makeprg</span>=npm\\\\ t<br></code></pre></td></tr></table></figure>\n\n<p>如果运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:make</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 将执行 <code>npm t</code>。但同时，您只能盯着冻结了的屏幕。有了 vim-dispatch，您只需要运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:Make</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 将启用后台进程异步运行 <code>npm t</code>，同时您还能在 Vim 中继续编辑您的文本。棒极了！</p>\n<h3 id=\"异步调度（Dispatch）\"><a href=\"#异步调度（Dispatch）\" class=\"headerlink\" title=\"异步调度（Dispatch）\"></a>异步调度（Dispatch）</h3><p><code>:Dispatch</code> 命令的工作方式和 <code>:compiler</code> 及 <code>:!</code> 类似，它可以在Vim中运行任意外部命令。</p>\n<p>假设您在 ruby spec 文件中，需要执行测试，可以运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:Dispatch</span> rspec %<br></code></pre></td></tr></table></figure>\n\n<p>Vim 将对当前文件异步运行 <code>rspec</code> 命令。</p>\n<h3 id=\"自动调度\"><a href=\"#自动调度\" class=\"headerlink\" title=\"自动调度\"></a>自动调度</h3><p>Vim-dispatch 有一个缓冲区变量<code>b:dispatch</code>，您可以配置它来自动执行特定命令，您可以利用 <code>autocmd</code>和它一起工作。如果在您的 vimrc 中添加如下内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">autocmd</span> BufEnter *_spec.rb <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">b:dispatch</span> = <span class=\"hljs-string\">&#x27;bundle exec rspec %&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>现在每当您进入（<code>BufEnter</code>）一个以 <code>_spec.rb</code> 结尾的文件，运行<code>:Dispatch</code> 将自动执行 <code>bundle exec rspec &lt;your-current-ruby-spec-file&gt;</code>。</p>\n<h2 id=\"聪明地学习编译\"><a href=\"#聪明地学习编译\" class=\"headerlink\" title=\"聪明地学习编译\"></a>聪明地学习编译</h2><p>在本章中，您了解到可以使用 <code>make</code> 和 <code>compiler</code> 命令从Vim内部异步运行 <em>任何</em> 进程，以完善您的编程工作流程。Vim 拥有通过其他程序来扩展自身的能力，这使其变得强大。</p>\n"},{"title":"VIM-视图、会话和 Viminfo","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第20章 视图、会话和 Viminfo\n\n当您做了一段时间的项目后，您可能会发现这个项目逐渐形了成自己的设置、折叠、缓冲区、布局等，就像住了一段时间公寓后，精心装饰了它一样。问题是，关闭 Vim 后，所有的这些更改都会丢失。如果能保留这些更改，等到下次打开 Vim 时，一切恢复如初，岂不美哉？\n\n本章中，您将学习如何使用 视图、会话 和 Viminfo 来保存项目的“快照”。\n\n## 视图\n\n视图是这三个部分（视图、会话、Viminfo）中的最小子集，它是单个窗口相关设置的集合。如果您长时间在一个窗口上工作，并且想要保留其映射和折叠，您可以使用视图。\n\n我们来创建一个 `foo.txt` 文件：\n\n```\nfoo1\nfoo2\nfoo3\nfoo4\nfoo5\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n在这个文件中，做三次修改：\n\n1. 在第 1 行，创建一个手动折叠 `zf4j`（折叠接下来 4 行）。\n2. 更改 `number` 设置：`setlocal nonumber norelativenumber`。这会移除窗口左侧的数字指示器。\n3. 创建本地映射，每当按一次 `j` 时，向下两行：`:nnoremap <buffer> j jj`。\n\n您的文件看起来应该像：\n\n```\n+-- 5 lines: foo1 -----\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n### 配置视图属性\n\n运行：\n\n```\n:set viewoptions?\n```\n\n默认情况下会显示（根据您的 vimrc 可能会有所不同）：\n\n```\nviewoptions=folds,cursor,curdir\n```\n\n我们来配置 `viewoptions`。要保留的三个属性分别是折叠、映射和本地设置选项。如果您的设置和我的相似，那么您已经有了 `folds` 选项。运行下列命令使视图记住 `localoptions`：\n\n```\n:set viewoptions+=localoptions\n```\n\n查阅 `:h viewoptions` 可了解 `viewoptions` 的其他可用选项。现在运行 `:set viewoptions?`，您将看到：\n\n```\nviewoptions=folds,cursor,curdir,localoptions\n```\n\n### 保存视图\n\n在 `foo.txt` 窗口经过适当折叠并设置了 `nonumber norelativenumber` 选项后，现在我们来保存视图。运行：\n\n```\n:mkview\n```\n\nVim 创建了一个视图文件。\n\n### 视图文件\n\n您可能会想“Vim 将这个视图文件保存到哪儿了呢？”，运行下列命令就可以看到答案了：\n\n```\n:set viewdir?\n```\n\n默认情况下会显示 `~/.vim/view`（根据您的操作系统，可能会有不同的路径。查阅 `:h viewdir` 获得更多信息）。如果您运行的是基于Unix的操作系统，想修改该路径，可以在您的 vimrc 中添加下列内容：\n\n```\nset viewdir=$HOME/else/where\n```\n\n### 加载视图文件\n\n关闭并重新打开 `foo.txt`，您会看到原来的文本，没有任何改变。这是预期行为。运行下列命令可以加载视图文件：\n\n```\n:loadview\n```\n\n现在您将看到：\n\n```\n+-- 5 lines: foo1 -----\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n那些折叠、本地设置以及映射都恢复了。如果您细心还可以发现，光标位于上一次您运行 `:mkview` 时所处的行上。只要您有 `cursor` 选项，视图将记住光标位置。\n\n### 多个视图\n\nVim 允许您保存 9 个编号的视图（1-9）。\n\n假设您想用 `:9,10 fold` 来额外折叠最后两行，我们把这存为视图 1。运行：\n\n```\n:mkview 1\n```\n\n如果您又想用 `:6,7 fold` 再折叠一次，并存为不同的视图，运行：\n\n```\n:mkview 2\n```\n\n关闭并重新打开 `foo.txt` 文件，运行下列命令可以加载视图 1：\n\n```\n:loadview 1\n```\n\n要加载视图 2，运行：\n\n```\n:loadview 2\n```\n\n要加载原始视图，运行：\n\n```\n:loadview\n```\n\n### 自动创建视图\n\n有一件可能会发生的很倒霉的事情是，您花了很长时间在一个大文件中进行折叠，一不小心关闭了窗口，接着丢失了所有折叠信息。您可以在 vimrc 中添加下列内容，使得在关闭缓冲区后 Vim 能自动创建视图，防止此类灾难发生：\n\n```\nautocmd BufWinLeave *.txt mkview\n```\n\n另外也能在打开缓冲区后自动加载视图：\n\n```\nautocmd BufWinEnter *.txt silent loadview\n```\n\n现在，当您编辑 `txt` 文件时，不用再担心创建和加载视图了。但也注意，随着时间的推移，视图文件会不断积累，记得每隔几个月清理一次。\n\n## 会话\n\n如果说视图保存了某个窗口的设置，那么会话则保存了所有窗口（包括布局）的信息。\n\n### 创建新会话\n\n假设您在 `foobarbaz` 工程中编辑着 3 个文件：\n\n`foo.txt` 的内容：\n\n```\nfoo1\nfoo2\nfoo3\nfoo4\nfoo5\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n`bar.txt` 的内容：\n\n```\nbar1\nbar2\nbar3\nbar4\nbar5\nbar6\nbar7\nbar8\nbar9\nbar10\n```\n\n`baz.txt` 的内容：\n\n```\nbaz1\nbaz2\nbaz3\nbaz4\nbaz5\nbaz6\nbaz7\nbaz8\nbaz9\nbaz10\n```\n\n假设您的窗口布局如下所示（适当地使用 `split` 和 `vsplit` 来放置）：\n\n![Session Layout](images/session-layout.png)\n\n要保留这个外观，您需要保存会话。运行：\n\n```\n:mksession\n```\n\n与默认存储在 `~/.vim/view` 的 `mkview` 不同，`mksession` 在当前目录存储会话文件（`Session.vim`）。如果好奇，您可以看看文件。\n\n如果您想将会话文件另存他处，可以将参数传递给 `mksession`：\n\n```\n:mksession ~/some/where/else.vim\n```\n\n使用 `!` 来调用命令可以覆盖一个已存在的会话文件（`:mksession! ~/some/where/else.vim`）。\n\n### 加载会话\n\n运行下列命令可以加载会话：\n\n```\n:source Session.vim\n```\n\n现在 Vim 看起来就像您离开它时的样子！或者，您也可以从终端加载会话文件：\n\n```\nvim -S Session.vim\n```\n\n### 配置会话属性\n\n您可以配置会话要保存的属性。若要查看当前哪些属性正被保存，请运行：\n\n```\n:set sessionoptions?\n```\n\n我的显示：\n\n```\nblank,buffers,curdir,folds,help,tabpages,winsize,terminal\n```\n\n如果在保存会话时不想存储 `terminal`，可以运行下列命令将其从会话选项中删除：\n\n```\n:set sessionoptions-=terminal\n```\n\n如果要在保存会话时存储 `options`，请运行：\n\n```\n:set sessionoptions+=options\n```\n\n下面是一些 `sessionoptions` 可以存储的属性：\n\n- `blank` 存储空窗口\n- `buffers` 存储缓冲区\n- `folds` 存储折叠\n- `globals` 存储全局变量（必须以大写字母开头，并且至少包含一个小写字母）\n- `options` 存储选项和映射\n- `resize` 存储窗口行列\n- `winpos` 存储窗口位置\n- `winsize` 存储窗口大小\n- `tabpages` 存储选项卡\n- `unix` 以 Unix 格式存储文件\n\n查阅 `:h 'sessionoptions'` 来获取完整列表。\n\n会话是保存项目外部属性的好工具。但是，一些内部属性不存储在会话中，如本地标记、寄存器、历史记录等。要保存它们，您需要使用 Viminfo！\n\n## Viminfo\n\n如果您留意，在复制一个单词进寄存器 a，再退出并重新打开 Vim 后，您仍然可以看到存储在寄存器中的文本。这就是 Viminfo 的功劳。没有它，在您关闭 Vim 后，Vim 会忘记这些寄存器。\n\n如果您使用 Vim 8 或更高版本，Vim 会默认启用 Viminfo。因此您可能一直在使用 Viminfo，而您对它毫不知情！\n\n您可能会问：Viminfo 存储了什么？与会话有何不同？\n\n要使用 Viminfo，您必须启用了 `+viminfo` 特性（`:version`）。Viminfo 存储着：\n\n- 命令行历史记录。\n- 字符串搜索历史记录。\n- 输入行历史记录。\n- 非空寄存器的内容。\n- 多个文件的标记。\n- 文件标记，它指向文件中的位置。\n- 上次搜索 / 替换模式（用于 “n” 和 “&”）。\n- 缓冲区列表。\n- 全局变量。\n\n通常，会话存储“外部”属性，Viminfo 存储“内部”属性。\n\n每个项目可以有一个会话文件，而 Viminfo 与会话不同，通常每台计算机只使用一个 Viminfo。Viminfo 是项目无关的。\n\n对于 Unix，Viminfo 的默认位置是 `$HOME/.viminfo`（`~/.viminfo`）。如果您用其他操作系统，Viminfo 位置可能会有所不同。可以查阅 `:h viminfo-file-name`。每一次您做出的“内部”更改，如将文本复制进一个寄存器，Vim 都会自动更新 Viminfo 文件。\n\n*请确保您设置了 `nocompatible` 选项（`set nocompatible`），否则您的 Viminfo 将不起作用。*\n\n### 读写 Viminfo\n\n尽管只使用一个 Viminfo 文件，但您还是可以创建多个 Viminfo 文件。使用 `:wviminfo` 命令（缩写为 `:wv`）来创建多个 Viminfo 文件。\n\n```\n:wv ~/.viminfo_extra\n```\n\n要覆盖现有的 Viminfo 文件，向 `wv` 命令多添加一个叹号：\n\n```\n:wv! ~/.viminfo_extra\n```\n\nVim 默认情况下会读取 `~/.viminfo` 文件。运行 `:rviminfo`（缩写为 `:rv`）可以读取不同的 Vimfile 文件：\n\n```\n:rv ~/.viminfo_extra\n```\n\n要在终端使用不同的 Viminfo 文件来启动 Vim，请使用 “i” 标志：\n\n```\nvim -i viminfo_extra\n```\n\n如果您要将 Vim 用于不同的任务，比如写代码和写作，您可以创建两个 Viminfo，一个针对写作优化，另一个为写代码优化。\n\n```\nvim -i viminfo_writing\n\nvim -i viminfo_coding\n```\n\n### 不使用 Viminfo 启动 Vim\n\n要不使用 Viminfo 启动 Vim，可以在终端运行：\n\n```\nvim -i NONE\n```\n\n要永不使用 Viminfo，可以在您的 vimrc 文件添加：\n\n```\nset viminfo=\"NONE\"\n```\n\n### 配置 Viminfo 属性\n\n和 `viewoptions` 以及 `sessionoptions` 类似，您可以用 `viminfo` 选项指定要存储的属性。请运行：\n\n```\n:set viminfo?\n```\n\n您会得到：\n\n```\n!,'100,<50,s10,h\n```\n\n看起来有点晦涩难懂。命令分解如下：\n- `!` 保存以大写字母开头、却不包含小写字母的全局变量。回想一下 `g:` 代表了一个全局变量。例如，假设您写了赋值语句 `let g:FOO = \"foo\"`，Viminfo 将存储全局变量 `FOO`。然而如果您写了 `let g:Foo = \"foo\"`，Viminfo 将不存储它，因为它包含了小写字母。没有 `!`，Vim 不会存储这些全局变量。\n- `'100` 代表标记。在这个例子中，Viminfo 将保存最近 100 个文件的本地标记（a-z）。注意，如果存储的文件过多，Vim 会变得很慢，1000 左右就可以了。\n- `<50` 告诉 Viminfo 每个寄存器最多保存多少行（这个例子中是 50 行）。如果我复制 100 行文本进寄存器 a（`\"ay99j`）后关闭 Vim，下次打开 Vim 并从寄存器 a（`\"ap`）粘贴时，Vim 最多只粘贴 50 行；如果不指定最大行号， *所有* 行都将被保存；如果指定 0，什么都不保存了。\n- `s10` 为寄存器设置大小限制（kb）。在这个例子中，任何大于 10kb 的寄存器都会被排除。\n- `h` 禁用高亮显示（`hlsearch` 时）。\n\n可以查阅 `:h 'viminfo'` 来了解其他更多选项。\n\n## 聪明地使用视图、会话和 Viminfo\n\nVim 能使用视图、会话和 Viminfo 来保存不同级别的 Vim 环境快照。对于微型项目，可以使用视图；对于大型项目，可以使用会话。您应该花些时间来查阅视图、会话和 Viminfo 提供的所有选项。\n\n为您的编辑风格创建属于您自己的视图、会话和 Viminfo。如果您要换台计算机使用 Vim，只需加载您的设置，立刻就会感到就像在家里的工作环境一样！\n","source":"_posts/Vim/ch20_views_sessions_viminfo.md","raw":"---\ntitle: VIM-视图、会话和 Viminfo\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第20章 视图、会话和 Viminfo\n\n当您做了一段时间的项目后，您可能会发现这个项目逐渐形了成自己的设置、折叠、缓冲区、布局等，就像住了一段时间公寓后，精心装饰了它一样。问题是，关闭 Vim 后，所有的这些更改都会丢失。如果能保留这些更改，等到下次打开 Vim 时，一切恢复如初，岂不美哉？\n\n本章中，您将学习如何使用 视图、会话 和 Viminfo 来保存项目的“快照”。\n\n## 视图\n\n视图是这三个部分（视图、会话、Viminfo）中的最小子集，它是单个窗口相关设置的集合。如果您长时间在一个窗口上工作，并且想要保留其映射和折叠，您可以使用视图。\n\n我们来创建一个 `foo.txt` 文件：\n\n```\nfoo1\nfoo2\nfoo3\nfoo4\nfoo5\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n在这个文件中，做三次修改：\n\n1. 在第 1 行，创建一个手动折叠 `zf4j`（折叠接下来 4 行）。\n2. 更改 `number` 设置：`setlocal nonumber norelativenumber`。这会移除窗口左侧的数字指示器。\n3. 创建本地映射，每当按一次 `j` 时，向下两行：`:nnoremap <buffer> j jj`。\n\n您的文件看起来应该像：\n\n```\n+-- 5 lines: foo1 -----\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n### 配置视图属性\n\n运行：\n\n```\n:set viewoptions?\n```\n\n默认情况下会显示（根据您的 vimrc 可能会有所不同）：\n\n```\nviewoptions=folds,cursor,curdir\n```\n\n我们来配置 `viewoptions`。要保留的三个属性分别是折叠、映射和本地设置选项。如果您的设置和我的相似，那么您已经有了 `folds` 选项。运行下列命令使视图记住 `localoptions`：\n\n```\n:set viewoptions+=localoptions\n```\n\n查阅 `:h viewoptions` 可了解 `viewoptions` 的其他可用选项。现在运行 `:set viewoptions?`，您将看到：\n\n```\nviewoptions=folds,cursor,curdir,localoptions\n```\n\n### 保存视图\n\n在 `foo.txt` 窗口经过适当折叠并设置了 `nonumber norelativenumber` 选项后，现在我们来保存视图。运行：\n\n```\n:mkview\n```\n\nVim 创建了一个视图文件。\n\n### 视图文件\n\n您可能会想“Vim 将这个视图文件保存到哪儿了呢？”，运行下列命令就可以看到答案了：\n\n```\n:set viewdir?\n```\n\n默认情况下会显示 `~/.vim/view`（根据您的操作系统，可能会有不同的路径。查阅 `:h viewdir` 获得更多信息）。如果您运行的是基于Unix的操作系统，想修改该路径，可以在您的 vimrc 中添加下列内容：\n\n```\nset viewdir=$HOME/else/where\n```\n\n### 加载视图文件\n\n关闭并重新打开 `foo.txt`，您会看到原来的文本，没有任何改变。这是预期行为。运行下列命令可以加载视图文件：\n\n```\n:loadview\n```\n\n现在您将看到：\n\n```\n+-- 5 lines: foo1 -----\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n那些折叠、本地设置以及映射都恢复了。如果您细心还可以发现，光标位于上一次您运行 `:mkview` 时所处的行上。只要您有 `cursor` 选项，视图将记住光标位置。\n\n### 多个视图\n\nVim 允许您保存 9 个编号的视图（1-9）。\n\n假设您想用 `:9,10 fold` 来额外折叠最后两行，我们把这存为视图 1。运行：\n\n```\n:mkview 1\n```\n\n如果您又想用 `:6,7 fold` 再折叠一次，并存为不同的视图，运行：\n\n```\n:mkview 2\n```\n\n关闭并重新打开 `foo.txt` 文件，运行下列命令可以加载视图 1：\n\n```\n:loadview 1\n```\n\n要加载视图 2，运行：\n\n```\n:loadview 2\n```\n\n要加载原始视图，运行：\n\n```\n:loadview\n```\n\n### 自动创建视图\n\n有一件可能会发生的很倒霉的事情是，您花了很长时间在一个大文件中进行折叠，一不小心关闭了窗口，接着丢失了所有折叠信息。您可以在 vimrc 中添加下列内容，使得在关闭缓冲区后 Vim 能自动创建视图，防止此类灾难发生：\n\n```\nautocmd BufWinLeave *.txt mkview\n```\n\n另外也能在打开缓冲区后自动加载视图：\n\n```\nautocmd BufWinEnter *.txt silent loadview\n```\n\n现在，当您编辑 `txt` 文件时，不用再担心创建和加载视图了。但也注意，随着时间的推移，视图文件会不断积累，记得每隔几个月清理一次。\n\n## 会话\n\n如果说视图保存了某个窗口的设置，那么会话则保存了所有窗口（包括布局）的信息。\n\n### 创建新会话\n\n假设您在 `foobarbaz` 工程中编辑着 3 个文件：\n\n`foo.txt` 的内容：\n\n```\nfoo1\nfoo2\nfoo3\nfoo4\nfoo5\nfoo6\nfoo7\nfoo8\nfoo9\nfoo10\n```\n\n`bar.txt` 的内容：\n\n```\nbar1\nbar2\nbar3\nbar4\nbar5\nbar6\nbar7\nbar8\nbar9\nbar10\n```\n\n`baz.txt` 的内容：\n\n```\nbaz1\nbaz2\nbaz3\nbaz4\nbaz5\nbaz6\nbaz7\nbaz8\nbaz9\nbaz10\n```\n\n假设您的窗口布局如下所示（适当地使用 `split` 和 `vsplit` 来放置）：\n\n![Session Layout](images/session-layout.png)\n\n要保留这个外观，您需要保存会话。运行：\n\n```\n:mksession\n```\n\n与默认存储在 `~/.vim/view` 的 `mkview` 不同，`mksession` 在当前目录存储会话文件（`Session.vim`）。如果好奇，您可以看看文件。\n\n如果您想将会话文件另存他处，可以将参数传递给 `mksession`：\n\n```\n:mksession ~/some/where/else.vim\n```\n\n使用 `!` 来调用命令可以覆盖一个已存在的会话文件（`:mksession! ~/some/where/else.vim`）。\n\n### 加载会话\n\n运行下列命令可以加载会话：\n\n```\n:source Session.vim\n```\n\n现在 Vim 看起来就像您离开它时的样子！或者，您也可以从终端加载会话文件：\n\n```\nvim -S Session.vim\n```\n\n### 配置会话属性\n\n您可以配置会话要保存的属性。若要查看当前哪些属性正被保存，请运行：\n\n```\n:set sessionoptions?\n```\n\n我的显示：\n\n```\nblank,buffers,curdir,folds,help,tabpages,winsize,terminal\n```\n\n如果在保存会话时不想存储 `terminal`，可以运行下列命令将其从会话选项中删除：\n\n```\n:set sessionoptions-=terminal\n```\n\n如果要在保存会话时存储 `options`，请运行：\n\n```\n:set sessionoptions+=options\n```\n\n下面是一些 `sessionoptions` 可以存储的属性：\n\n- `blank` 存储空窗口\n- `buffers` 存储缓冲区\n- `folds` 存储折叠\n- `globals` 存储全局变量（必须以大写字母开头，并且至少包含一个小写字母）\n- `options` 存储选项和映射\n- `resize` 存储窗口行列\n- `winpos` 存储窗口位置\n- `winsize` 存储窗口大小\n- `tabpages` 存储选项卡\n- `unix` 以 Unix 格式存储文件\n\n查阅 `:h 'sessionoptions'` 来获取完整列表。\n\n会话是保存项目外部属性的好工具。但是，一些内部属性不存储在会话中，如本地标记、寄存器、历史记录等。要保存它们，您需要使用 Viminfo！\n\n## Viminfo\n\n如果您留意，在复制一个单词进寄存器 a，再退出并重新打开 Vim 后，您仍然可以看到存储在寄存器中的文本。这就是 Viminfo 的功劳。没有它，在您关闭 Vim 后，Vim 会忘记这些寄存器。\n\n如果您使用 Vim 8 或更高版本，Vim 会默认启用 Viminfo。因此您可能一直在使用 Viminfo，而您对它毫不知情！\n\n您可能会问：Viminfo 存储了什么？与会话有何不同？\n\n要使用 Viminfo，您必须启用了 `+viminfo` 特性（`:version`）。Viminfo 存储着：\n\n- 命令行历史记录。\n- 字符串搜索历史记录。\n- 输入行历史记录。\n- 非空寄存器的内容。\n- 多个文件的标记。\n- 文件标记，它指向文件中的位置。\n- 上次搜索 / 替换模式（用于 “n” 和 “&”）。\n- 缓冲区列表。\n- 全局变量。\n\n通常，会话存储“外部”属性，Viminfo 存储“内部”属性。\n\n每个项目可以有一个会话文件，而 Viminfo 与会话不同，通常每台计算机只使用一个 Viminfo。Viminfo 是项目无关的。\n\n对于 Unix，Viminfo 的默认位置是 `$HOME/.viminfo`（`~/.viminfo`）。如果您用其他操作系统，Viminfo 位置可能会有所不同。可以查阅 `:h viminfo-file-name`。每一次您做出的“内部”更改，如将文本复制进一个寄存器，Vim 都会自动更新 Viminfo 文件。\n\n*请确保您设置了 `nocompatible` 选项（`set nocompatible`），否则您的 Viminfo 将不起作用。*\n\n### 读写 Viminfo\n\n尽管只使用一个 Viminfo 文件，但您还是可以创建多个 Viminfo 文件。使用 `:wviminfo` 命令（缩写为 `:wv`）来创建多个 Viminfo 文件。\n\n```\n:wv ~/.viminfo_extra\n```\n\n要覆盖现有的 Viminfo 文件，向 `wv` 命令多添加一个叹号：\n\n```\n:wv! ~/.viminfo_extra\n```\n\nVim 默认情况下会读取 `~/.viminfo` 文件。运行 `:rviminfo`（缩写为 `:rv`）可以读取不同的 Vimfile 文件：\n\n```\n:rv ~/.viminfo_extra\n```\n\n要在终端使用不同的 Viminfo 文件来启动 Vim，请使用 “i” 标志：\n\n```\nvim -i viminfo_extra\n```\n\n如果您要将 Vim 用于不同的任务，比如写代码和写作，您可以创建两个 Viminfo，一个针对写作优化，另一个为写代码优化。\n\n```\nvim -i viminfo_writing\n\nvim -i viminfo_coding\n```\n\n### 不使用 Viminfo 启动 Vim\n\n要不使用 Viminfo 启动 Vim，可以在终端运行：\n\n```\nvim -i NONE\n```\n\n要永不使用 Viminfo，可以在您的 vimrc 文件添加：\n\n```\nset viminfo=\"NONE\"\n```\n\n### 配置 Viminfo 属性\n\n和 `viewoptions` 以及 `sessionoptions` 类似，您可以用 `viminfo` 选项指定要存储的属性。请运行：\n\n```\n:set viminfo?\n```\n\n您会得到：\n\n```\n!,'100,<50,s10,h\n```\n\n看起来有点晦涩难懂。命令分解如下：\n- `!` 保存以大写字母开头、却不包含小写字母的全局变量。回想一下 `g:` 代表了一个全局变量。例如，假设您写了赋值语句 `let g:FOO = \"foo\"`，Viminfo 将存储全局变量 `FOO`。然而如果您写了 `let g:Foo = \"foo\"`，Viminfo 将不存储它，因为它包含了小写字母。没有 `!`，Vim 不会存储这些全局变量。\n- `'100` 代表标记。在这个例子中，Viminfo 将保存最近 100 个文件的本地标记（a-z）。注意，如果存储的文件过多，Vim 会变得很慢，1000 左右就可以了。\n- `<50` 告诉 Viminfo 每个寄存器最多保存多少行（这个例子中是 50 行）。如果我复制 100 行文本进寄存器 a（`\"ay99j`）后关闭 Vim，下次打开 Vim 并从寄存器 a（`\"ap`）粘贴时，Vim 最多只粘贴 50 行；如果不指定最大行号， *所有* 行都将被保存；如果指定 0，什么都不保存了。\n- `s10` 为寄存器设置大小限制（kb）。在这个例子中，任何大于 10kb 的寄存器都会被排除。\n- `h` 禁用高亮显示（`hlsearch` 时）。\n\n可以查阅 `:h 'viminfo'` 来了解其他更多选项。\n\n## 聪明地使用视图、会话和 Viminfo\n\nVim 能使用视图、会话和 Viminfo 来保存不同级别的 Vim 环境快照。对于微型项目，可以使用视图；对于大型项目，可以使用会话。您应该花些时间来查阅视图、会话和 Viminfo 提供的所有选项。\n\n为您的编辑风格创建属于您自己的视图、会话和 Viminfo。如果您要换台计算机使用 Vim，只需加载您的设置，立刻就会感到就像在家里的工作环境一样！\n","slug":"Vim/ch20_views_sessions_viminfo","published":1,"updated":"2022-08-28T07:38:59.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i25002jscvmbugkb2i1","content":"<h1 id=\"第20章-视图、会话和-Viminfo\"><a href=\"#第20章-视图、会话和-Viminfo\" class=\"headerlink\" title=\"第20章 视图、会话和 Viminfo\"></a>第20章 视图、会话和 Viminfo</h1><p>当您做了一段时间的项目后，您可能会发现这个项目逐渐形了成自己的设置、折叠、缓冲区、布局等，就像住了一段时间公寓后，精心装饰了它一样。问题是，关闭 Vim 后，所有的这些更改都会丢失。如果能保留这些更改，等到下次打开 Vim 时，一切恢复如初，岂不美哉？</p>\n<p>本章中，您将学习如何使用 视图、会话 和 Viminfo 来保存项目的“快照”。</p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>视图是这三个部分（视图、会话、Viminfo）中的最小子集，它是单个窗口相关设置的集合。如果您长时间在一个窗口上工作，并且想要保留其映射和折叠，您可以使用视图。</p>\n<p>我们来创建一个 <code>foo.txt</code> 文件：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs gcode\">fo<span class=\"hljs-meta\">o1</span><br>fo<span class=\"hljs-meta\">o2</span><br>fo<span class=\"hljs-meta\">o3</span><br>fo<span class=\"hljs-meta\">o4</span><br>fo<span class=\"hljs-meta\">o5</span><br>fo<span class=\"hljs-meta\">o6</span><br>fo<span class=\"hljs-meta\">o7</span><br>fo<span class=\"hljs-meta\">o8</span><br>fo<span class=\"hljs-meta\">o9</span><br>fo<span class=\"hljs-meta\">o10</span><br></code></pre></td></tr></table></figure>\n\n<p>在这个文件中，做三次修改：</p>\n<ol>\n<li>在第 1 行，创建一个手动折叠 <code>zf4j</code>（折叠接下来 4 行）。</li>\n<li>更改 <code>number</code> 设置：<code>setlocal nonumber norelativenumber</code>。这会移除窗口左侧的数字指示器。</li>\n<li>创建本地映射，每当按一次 <code>j</code> 时，向下两行：<code>:nnoremap &lt;buffer&gt; j jj</code>。</li>\n</ol>\n<p>您的文件看起来应该像：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 5 lines: foo1 -----</span><br>foo6<br>foo7<br>foo8<br>foo9<br>foo10<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置视图属性\"><a href=\"#配置视图属性\" class=\"headerlink\" title=\"配置视图属性\"></a>配置视图属性</h3><p>运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viewoptions?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下会显示（根据您的 vimrc 可能会有所不同）：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">viewoptions</span>=folds,cursor,curdir<br></code></pre></td></tr></table></figure>\n\n<p>我们来配置 <code>viewoptions</code>。要保留的三个属性分别是折叠、映射和本地设置选项。如果您的设置和我的相似，那么您已经有了 <code>folds</code> 选项。运行下列命令使视图记住 <code>localoptions</code>：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viewoptions+=localoptions<br></code></pre></td></tr></table></figure>\n\n<p>查阅 <code>:h viewoptions</code> 可了解 <code>viewoptions</code> 的其他可用选项。现在运行 <code>:set viewoptions?</code>，您将看到：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">viewoptions</span>=folds,cursor,curdir,localoptions<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"保存视图\"><a href=\"#保存视图\" class=\"headerlink\" title=\"保存视图\"></a>保存视图</h3><p>在 <code>foo.txt</code> 窗口经过适当折叠并设置了 <code>nonumber norelativenumber</code> 选项后，现在我们来保存视图。运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 创建了一个视图文件。</p>\n<h3 id=\"视图文件\"><a href=\"#视图文件\" class=\"headerlink\" title=\"视图文件\"></a>视图文件</h3><p>您可能会想“Vim 将这个视图文件保存到哪儿了呢？”，运行下列命令就可以看到答案了：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viewdir?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下会显示 <code>~/.vim/view</code>（根据您的操作系统，可能会有不同的路径。查阅 <code>:h viewdir</code> 获得更多信息）。如果您运行的是基于Unix的操作系统，想修改该路径，可以在您的 vimrc 中添加下列内容：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">viewdir</span>=<span class=\"hljs-variable\">$HOME</span>/else/where<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"加载视图文件\"><a href=\"#加载视图文件\" class=\"headerlink\" title=\"加载视图文件\"></a>加载视图文件</h3><p>关闭并重新打开 <code>foo.txt</code>，您会看到原来的文本，没有任何改变。这是预期行为。运行下列命令可以加载视图文件：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>现在您将看到：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 5 lines: foo1 -----</span><br>foo6<br>foo7<br>foo8<br>foo9<br>foo10<br></code></pre></td></tr></table></figure>\n\n<p>那些折叠、本地设置以及映射都恢复了。如果您细心还可以发现，光标位于上一次您运行 <code>:mkview</code> 时所处的行上。只要您有 <code>cursor</code> 选项，视图将记住光标位置。</p>\n<h3 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h3><p>Vim 允许您保存 9 个编号的视图（1-9）。</p>\n<p>假设您想用 <code>:9,10 fold</code> 来额外折叠最后两行，我们把这存为视图 1。运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您又想用 <code>:6,7 fold</code> 再折叠一次，并存为不同的视图，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<p>关闭并重新打开 <code>foo.txt</code> 文件，运行下列命令可以加载视图 1：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>要加载视图 2，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<p>要加载原始视图，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自动创建视图\"><a href=\"#自动创建视图\" class=\"headerlink\" title=\"自动创建视图\"></a>自动创建视图</h3><p>有一件可能会发生的很倒霉的事情是，您花了很长时间在一个大文件中进行折叠，一不小心关闭了窗口，接着丢失了所有折叠信息。您可以在 vimrc 中添加下列内容，使得在关闭缓冲区后 Vim 能自动创建视图，防止此类灾难发生：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">autocmd</span> BufWinLeave <span class=\"hljs-regexp\">*.txt</span> mkview<br></code></pre></td></tr></table></figure>\n\n<p>另外也能在打开缓冲区后自动加载视图：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">autocmd</span> BufWinEnter *.txt <span class=\"hljs-keyword\">silent</span> <span class=\"hljs-keyword\">loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，当您编辑 <code>txt</code> 文件时，不用再担心创建和加载视图了。但也注意，随着时间的推移，视图文件会不断积累，记得每隔几个月清理一次。</p>\n<h2 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a>会话</h2><p>如果说视图保存了某个窗口的设置，那么会话则保存了所有窗口（包括布局）的信息。</p>\n<h3 id=\"创建新会话\"><a href=\"#创建新会话\" class=\"headerlink\" title=\"创建新会话\"></a>创建新会话</h3><p>假设您在 <code>foobarbaz</code> 工程中编辑着 3 个文件：</p>\n<p><code>foo.txt</code> 的内容：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">fo<span class=\"hljs-meta\">o1</span><br>fo<span class=\"hljs-meta\">o2</span><br>fo<span class=\"hljs-meta\">o3</span><br>fo<span class=\"hljs-meta\">o4</span><br>fo<span class=\"hljs-meta\">o5</span><br>fo<span class=\"hljs-meta\">o6</span><br>fo<span class=\"hljs-meta\">o7</span><br>fo<span class=\"hljs-meta\">o8</span><br>fo<span class=\"hljs-meta\">o9</span><br>fo<span class=\"hljs-meta\">o10</span><br></code></pre></td></tr></table></figure>\n\n<p><code>bar.txt</code> 的内容：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">bar1</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar2</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar3</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar4</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar5</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar6</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar7</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar8</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar9</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar10</span><br></code></pre></td></tr></table></figure>\n\n<p><code>baz.txt</code> 的内容：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">baz1</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz2</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz3</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz4</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz5</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz6</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz7</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz8</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz9</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz10</span><br></code></pre></td></tr></table></figure>\n\n<p>假设您的窗口布局如下所示（适当地使用 <code>split</code> 和 <code>vsplit</code> 来放置）：</p>\n<p><img src=\"/images/session-layout.png\" alt=\"Session Layout\"></p>\n<p>要保留这个外观，您需要保存会话。运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mksession</span><br></code></pre></td></tr></table></figure>\n\n<p>与默认存储在 <code>~/.vim/view</code> 的 <code>mkview</code> 不同，<code>mksession</code> 在当前目录存储会话文件（<code>Session.vim</code>）。如果好奇，您可以看看文件。</p>\n<p>如果您想将会话文件另存他处，可以将参数传递给 <code>mksession</code>：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:mksession ~/<span class=\"hljs-keyword\">some</span>/<span class=\"hljs-keyword\">where</span>/<span class=\"hljs-keyword\">else</span>.vim<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>!</code> 来调用命令可以覆盖一个已存在的会话文件（<code>:mksession! ~/some/where/else.vim</code>）。</p>\n<h3 id=\"加载会话\"><a href=\"#加载会话\" class=\"headerlink\" title=\"加载会话\"></a>加载会话</h3><p>运行下列命令可以加载会话：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">source</span> Session.<span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>现在 Vim 看起来就像您离开它时的样子！或者，您也可以从终端加载会话文件：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> -S Session.<span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置会话属性\"><a href=\"#配置会话属性\" class=\"headerlink\" title=\"配置会话属性\"></a>配置会话属性</h3><p>您可以配置会话要保存的属性。若要查看当前哪些属性正被保存，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> sessionoptions?<br></code></pre></td></tr></table></figure>\n\n<p>我的显示：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">blank,<span class=\"hljs-keyword\">buffers</span>,curdir,folds,<span class=\"hljs-keyword\">help</span>,tabpages,<span class=\"hljs-keyword\">winsize</span>,terminal<br></code></pre></td></tr></table></figure>\n\n<p>如果在保存会话时不想存储 <code>terminal</code>，可以运行下列命令将其从会话选项中删除：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">sessionoptions-</span>=terminal<br></code></pre></td></tr></table></figure>\n\n<p>如果要在保存会话时存储 <code>options</code>，请运行：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">:<span class=\"hljs-keyword\">set</span> sessionoptions+=<span class=\"hljs-keyword\">options</span><br></code></pre></td></tr></table></figure>\n\n<p>下面是一些 <code>sessionoptions</code> 可以存储的属性：</p>\n<ul>\n<li><code>blank</code> 存储空窗口</li>\n<li><code>buffers</code> 存储缓冲区</li>\n<li><code>folds</code> 存储折叠</li>\n<li><code>globals</code> 存储全局变量（必须以大写字母开头，并且至少包含一个小写字母）</li>\n<li><code>options</code> 存储选项和映射</li>\n<li><code>resize</code> 存储窗口行列</li>\n<li><code>winpos</code> 存储窗口位置</li>\n<li><code>winsize</code> 存储窗口大小</li>\n<li><code>tabpages</code> 存储选项卡</li>\n<li><code>unix</code> 以 Unix 格式存储文件</li>\n</ul>\n<p>查阅 <code>:h &#39;sessionoptions&#39;</code> 来获取完整列表。</p>\n<p>会话是保存项目外部属性的好工具。但是，一些内部属性不存储在会话中，如本地标记、寄存器、历史记录等。要保存它们，您需要使用 Viminfo！</p>\n<h2 id=\"Viminfo\"><a href=\"#Viminfo\" class=\"headerlink\" title=\"Viminfo\"></a>Viminfo</h2><p>如果您留意，在复制一个单词进寄存器 a，再退出并重新打开 Vim 后，您仍然可以看到存储在寄存器中的文本。这就是 Viminfo 的功劳。没有它，在您关闭 Vim 后，Vim 会忘记这些寄存器。</p>\n<p>如果您使用 Vim 8 或更高版本，Vim 会默认启用 Viminfo。因此您可能一直在使用 Viminfo，而您对它毫不知情！</p>\n<p>您可能会问：Viminfo 存储了什么？与会话有何不同？</p>\n<p>要使用 Viminfo，您必须启用了 <code>+viminfo</code> 特性（<code>:version</code>）。Viminfo 存储着：</p>\n<ul>\n<li>命令行历史记录。</li>\n<li>字符串搜索历史记录。</li>\n<li>输入行历史记录。</li>\n<li>非空寄存器的内容。</li>\n<li>多个文件的标记。</li>\n<li>文件标记，它指向文件中的位置。</li>\n<li>上次搜索 &#x2F; 替换模式（用于 “n” 和 “&amp;”）。</li>\n<li>缓冲区列表。</li>\n<li>全局变量。</li>\n</ul>\n<p>通常，会话存储“外部”属性，Viminfo 存储“内部”属性。</p>\n<p>每个项目可以有一个会话文件，而 Viminfo 与会话不同，通常每台计算机只使用一个 Viminfo。Viminfo 是项目无关的。</p>\n<p>对于 Unix，Viminfo 的默认位置是 <code>$HOME/.viminfo</code>（<code>~/.viminfo</code>）。如果您用其他操作系统，Viminfo 位置可能会有所不同。可以查阅 <code>:h viminfo-file-name</code>。每一次您做出的“内部”更改，如将文本复制进一个寄存器，Vim 都会自动更新 Viminfo 文件。</p>\n<p><em>请确保您设置了 <code>nocompatible</code> 选项（<code>set nocompatible</code>），否则您的 Viminfo 将不起作用。</em></p>\n<h3 id=\"读写-Viminfo\"><a href=\"#读写-Viminfo\" class=\"headerlink\" title=\"读写 Viminfo\"></a>读写 Viminfo</h3><p>尽管只使用一个 Viminfo 文件，但您还是可以创建多个 Viminfo 文件。使用 <code>:wviminfo</code> 命令（缩写为 <code>:wv</code>）来创建多个 Viminfo 文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:wv ~/.viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>要覆盖现有的 Viminfo 文件，向 <code>wv</code> 命令多添加一个叹号：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:wv! ~/.viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>Vim 默认情况下会读取 <code>~/.viminfo</code> 文件。运行 <code>:rviminfo</code>（缩写为 <code>:rv</code>）可以读取不同的 Vimfile 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:rv ~/.viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>要在终端使用不同的 Viminfo 文件来启动 Vim，请使用 “i” 标志：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">vim -<span class=\"hljs-selector-tag\">i</span> viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>如果您要将 Vim 用于不同的任务，比如写代码和写作，您可以创建两个 Viminfo，一个针对写作优化，另一个为写代码优化。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">vim -<span class=\"hljs-selector-tag\">i</span> viminfo_writing<br><br>vim -<span class=\"hljs-selector-tag\">i</span> viminfo_coding<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"不使用-Viminfo-启动-Vim\"><a href=\"#不使用-Viminfo-启动-Vim\" class=\"headerlink\" title=\"不使用 Viminfo 启动 Vim\"></a>不使用 Viminfo 启动 Vim</h3><p>要不使用 Viminfo 启动 Vim，可以在终端运行：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">vim -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-attribute\">NONE</span><br></code></pre></td></tr></table></figure>\n\n<p>要永不使用 Viminfo，可以在您的 vimrc 文件添加：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">viminfo</span>=<span class=\"hljs-string\">&quot;NONE&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置-Viminfo-属性\"><a href=\"#配置-Viminfo-属性\" class=\"headerlink\" title=\"配置 Viminfo 属性\"></a>配置 Viminfo 属性</h3><p>和 <code>viewoptions</code> 以及 <code>sessionoptions</code> 类似，您可以用 <code>viminfo</code> 选项指定要存储的属性。请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viminfo?<br></code></pre></td></tr></table></figure>\n\n<p>您会得到：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs diff\"><span class=\"hljs-addition\">!,&#x27;100,&lt;50,s10,h</span><br></code></pre></td></tr></table></figure>\n\n<p>看起来有点晦涩难懂。命令分解如下：</p>\n<ul>\n<li><code>!</code> 保存以大写字母开头、却不包含小写字母的全局变量。回想一下 <code>g:</code> 代表了一个全局变量。例如，假设您写了赋值语句 <code>let g:FOO = &quot;foo&quot;</code>，Viminfo 将存储全局变量 <code>FOO</code>。然而如果您写了 <code>let g:Foo = &quot;foo&quot;</code>，Viminfo 将不存储它，因为它包含了小写字母。没有 <code>!</code>，Vim 不会存储这些全局变量。</li>\n<li><code>&#39;100</code> 代表标记。在这个例子中，Viminfo 将保存最近 100 个文件的本地标记（a-z）。注意，如果存储的文件过多，Vim 会变得很慢，1000 左右就可以了。</li>\n<li><code>&lt;50</code> 告诉 Viminfo 每个寄存器最多保存多少行（这个例子中是 50 行）。如果我复制 100 行文本进寄存器 a（<code>&quot;ay99j</code>）后关闭 Vim，下次打开 Vim 并从寄存器 a（<code>&quot;ap</code>）粘贴时，Vim 最多只粘贴 50 行；如果不指定最大行号， <em>所有</em> 行都将被保存；如果指定 0，什么都不保存了。</li>\n<li><code>s10</code> 为寄存器设置大小限制（kb）。在这个例子中，任何大于 10kb 的寄存器都会被排除。</li>\n<li><code>h</code> 禁用高亮显示（<code>hlsearch</code> 时）。</li>\n</ul>\n<p>可以查阅 <code>:h &#39;viminfo&#39;</code> 来了解其他更多选项。</p>\n<h2 id=\"聪明地使用视图、会话和-Viminfo\"><a href=\"#聪明地使用视图、会话和-Viminfo\" class=\"headerlink\" title=\"聪明地使用视图、会话和 Viminfo\"></a>聪明地使用视图、会话和 Viminfo</h2><p>Vim 能使用视图、会话和 Viminfo 来保存不同级别的 Vim 环境快照。对于微型项目，可以使用视图；对于大型项目，可以使用会话。您应该花些时间来查阅视图、会话和 Viminfo 提供的所有选项。</p>\n<p>为您的编辑风格创建属于您自己的视图、会话和 Viminfo。如果您要换台计算机使用 Vim，只需加载您的设置，立刻就会感到就像在家里的工作环境一样！</p>\n","site":{"data":{}},"wordcount":4819,"excerpt":"","more":"<h1 id=\"第20章-视图、会话和-Viminfo\"><a href=\"#第20章-视图、会话和-Viminfo\" class=\"headerlink\" title=\"第20章 视图、会话和 Viminfo\"></a>第20章 视图、会话和 Viminfo</h1><p>当您做了一段时间的项目后，您可能会发现这个项目逐渐形了成自己的设置、折叠、缓冲区、布局等，就像住了一段时间公寓后，精心装饰了它一样。问题是，关闭 Vim 后，所有的这些更改都会丢失。如果能保留这些更改，等到下次打开 Vim 时，一切恢复如初，岂不美哉？</p>\n<p>本章中，您将学习如何使用 视图、会话 和 Viminfo 来保存项目的“快照”。</p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>视图是这三个部分（视图、会话、Viminfo）中的最小子集，它是单个窗口相关设置的集合。如果您长时间在一个窗口上工作，并且想要保留其映射和折叠，您可以使用视图。</p>\n<p>我们来创建一个 <code>foo.txt</code> 文件：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">fo<span class=\"hljs-meta\">o1</span><br>fo<span class=\"hljs-meta\">o2</span><br>fo<span class=\"hljs-meta\">o3</span><br>fo<span class=\"hljs-meta\">o4</span><br>fo<span class=\"hljs-meta\">o5</span><br>fo<span class=\"hljs-meta\">o6</span><br>fo<span class=\"hljs-meta\">o7</span><br>fo<span class=\"hljs-meta\">o8</span><br>fo<span class=\"hljs-meta\">o9</span><br>fo<span class=\"hljs-meta\">o10</span><br></code></pre></td></tr></table></figure>\n\n<p>在这个文件中，做三次修改：</p>\n<ol>\n<li>在第 1 行，创建一个手动折叠 <code>zf4j</code>（折叠接下来 4 行）。</li>\n<li>更改 <code>number</code> 设置：<code>setlocal nonumber norelativenumber</code>。这会移除窗口左侧的数字指示器。</li>\n<li>创建本地映射，每当按一次 <code>j</code> 时，向下两行：<code>:nnoremap &lt;buffer&gt; j jj</code>。</li>\n</ol>\n<p>您的文件看起来应该像：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 5 lines: foo1 -----</span><br>foo6<br>foo7<br>foo8<br>foo9<br>foo10<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置视图属性\"><a href=\"#配置视图属性\" class=\"headerlink\" title=\"配置视图属性\"></a>配置视图属性</h3><p>运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viewoptions?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下会显示（根据您的 vimrc 可能会有所不同）：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">viewoptions</span>=folds,cursor,curdir<br></code></pre></td></tr></table></figure>\n\n<p>我们来配置 <code>viewoptions</code>。要保留的三个属性分别是折叠、映射和本地设置选项。如果您的设置和我的相似，那么您已经有了 <code>folds</code> 选项。运行下列命令使视图记住 <code>localoptions</code>：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viewoptions+=localoptions<br></code></pre></td></tr></table></figure>\n\n<p>查阅 <code>:h viewoptions</code> 可了解 <code>viewoptions</code> 的其他可用选项。现在运行 <code>:set viewoptions?</code>，您将看到：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">viewoptions</span>=folds,cursor,curdir,localoptions<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"保存视图\"><a href=\"#保存视图\" class=\"headerlink\" title=\"保存视图\"></a>保存视图</h3><p>在 <code>foo.txt</code> 窗口经过适当折叠并设置了 <code>nonumber norelativenumber</code> 选项后，现在我们来保存视图。运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span><br></code></pre></td></tr></table></figure>\n\n<p>Vim 创建了一个视图文件。</p>\n<h3 id=\"视图文件\"><a href=\"#视图文件\" class=\"headerlink\" title=\"视图文件\"></a>视图文件</h3><p>您可能会想“Vim 将这个视图文件保存到哪儿了呢？”，运行下列命令就可以看到答案了：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viewdir?<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下会显示 <code>~/.vim/view</code>（根据您的操作系统，可能会有不同的路径。查阅 <code>:h viewdir</code> 获得更多信息）。如果您运行的是基于Unix的操作系统，想修改该路径，可以在您的 vimrc 中添加下列内容：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">viewdir</span>=<span class=\"hljs-variable\">$HOME</span>/else/where<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"加载视图文件\"><a href=\"#加载视图文件\" class=\"headerlink\" title=\"加载视图文件\"></a>加载视图文件</h3><p>关闭并重新打开 <code>foo.txt</code>，您会看到原来的文本，没有任何改变。这是预期行为。运行下列命令可以加载视图文件：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>现在您将看到：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 5 lines: foo1 -----</span><br>foo6<br>foo7<br>foo8<br>foo9<br>foo10<br></code></pre></td></tr></table></figure>\n\n<p>那些折叠、本地设置以及映射都恢复了。如果您细心还可以发现，光标位于上一次您运行 <code>:mkview</code> 时所处的行上。只要您有 <code>cursor</code> 选项，视图将记住光标位置。</p>\n<h3 id=\"多个视图\"><a href=\"#多个视图\" class=\"headerlink\" title=\"多个视图\"></a>多个视图</h3><p>Vim 允许您保存 9 个编号的视图（1-9）。</p>\n<p>假设您想用 <code>:9,10 fold</code> 来额外折叠最后两行，我们把这存为视图 1。运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您又想用 <code>:6,7 fold</code> 再折叠一次，并存为不同的视图，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mkview</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<p>关闭并重新打开 <code>foo.txt</code> 文件，运行下列命令可以加载视图 1：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>要加载视图 2，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n<p>要加载原始视图，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:loadview</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自动创建视图\"><a href=\"#自动创建视图\" class=\"headerlink\" title=\"自动创建视图\"></a>自动创建视图</h3><p>有一件可能会发生的很倒霉的事情是，您花了很长时间在一个大文件中进行折叠，一不小心关闭了窗口，接着丢失了所有折叠信息。您可以在 vimrc 中添加下列内容，使得在关闭缓冲区后 Vim 能自动创建视图，防止此类灾难发生：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">autocmd</span> BufWinLeave <span class=\"hljs-regexp\">*.txt</span> mkview<br></code></pre></td></tr></table></figure>\n\n<p>另外也能在打开缓冲区后自动加载视图：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">autocmd</span> BufWinEnter *.txt <span class=\"hljs-keyword\">silent</span> <span class=\"hljs-keyword\">loadview</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，当您编辑 <code>txt</code> 文件时，不用再担心创建和加载视图了。但也注意，随着时间的推移，视图文件会不断积累，记得每隔几个月清理一次。</p>\n<h2 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a>会话</h2><p>如果说视图保存了某个窗口的设置，那么会话则保存了所有窗口（包括布局）的信息。</p>\n<h3 id=\"创建新会话\"><a href=\"#创建新会话\" class=\"headerlink\" title=\"创建新会话\"></a>创建新会话</h3><p>假设您在 <code>foobarbaz</code> 工程中编辑着 3 个文件：</p>\n<p><code>foo.txt</code> 的内容：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">fo<span class=\"hljs-meta\">o1</span><br>fo<span class=\"hljs-meta\">o2</span><br>fo<span class=\"hljs-meta\">o3</span><br>fo<span class=\"hljs-meta\">o4</span><br>fo<span class=\"hljs-meta\">o5</span><br>fo<span class=\"hljs-meta\">o6</span><br>fo<span class=\"hljs-meta\">o7</span><br>fo<span class=\"hljs-meta\">o8</span><br>fo<span class=\"hljs-meta\">o9</span><br>fo<span class=\"hljs-meta\">o10</span><br></code></pre></td></tr></table></figure>\n\n<p><code>bar.txt</code> 的内容：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">bar1</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar2</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar3</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar4</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar5</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar6</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar7</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar8</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar9</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">bar10</span><br></code></pre></td></tr></table></figure>\n\n<p><code>baz.txt</code> 的内容：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">baz1</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz2</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz3</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz4</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz5</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz6</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz7</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz8</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz9</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">baz10</span><br></code></pre></td></tr></table></figure>\n\n<p>假设您的窗口布局如下所示（适当地使用 <code>split</code> 和 <code>vsplit</code> 来放置）：</p>\n<p><img src=\"/images/session-layout.png\" alt=\"Session Layout\"></p>\n<p>要保留这个外观，您需要保存会话。运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:mksession</span><br></code></pre></td></tr></table></figure>\n\n<p>与默认存储在 <code>~/.vim/view</code> 的 <code>mkview</code> 不同，<code>mksession</code> 在当前目录存储会话文件（<code>Session.vim</code>）。如果好奇，您可以看看文件。</p>\n<p>如果您想将会话文件另存他处，可以将参数传递给 <code>mksession</code>：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">:mksession ~/<span class=\"hljs-keyword\">some</span>/<span class=\"hljs-keyword\">where</span>/<span class=\"hljs-keyword\">else</span>.vim<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>!</code> 来调用命令可以覆盖一个已存在的会话文件（<code>:mksession! ~/some/where/else.vim</code>）。</p>\n<h3 id=\"加载会话\"><a href=\"#加载会话\" class=\"headerlink\" title=\"加载会话\"></a>加载会话</h3><p>运行下列命令可以加载会话：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">source</span> Session.<span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<p>现在 Vim 看起来就像您离开它时的样子！或者，您也可以从终端加载会话文件：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">vim</span> -S Session.<span class=\"hljs-keyword\">vim</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置会话属性\"><a href=\"#配置会话属性\" class=\"headerlink\" title=\"配置会话属性\"></a>配置会话属性</h3><p>您可以配置会话要保存的属性。若要查看当前哪些属性正被保存，请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> sessionoptions?<br></code></pre></td></tr></table></figure>\n\n<p>我的显示：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">blank,<span class=\"hljs-keyword\">buffers</span>,curdir,folds,<span class=\"hljs-keyword\">help</span>,tabpages,<span class=\"hljs-keyword\">winsize</span>,terminal<br></code></pre></td></tr></table></figure>\n\n<p>如果在保存会话时不想存储 <code>terminal</code>，可以运行下列命令将其从会话选项中删除：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">sessionoptions-</span>=terminal<br></code></pre></td></tr></table></figure>\n\n<p>如果要在保存会话时存储 <code>options</code>，请运行：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">:<span class=\"hljs-keyword\">set</span> sessionoptions+=<span class=\"hljs-keyword\">options</span><br></code></pre></td></tr></table></figure>\n\n<p>下面是一些 <code>sessionoptions</code> 可以存储的属性：</p>\n<ul>\n<li><code>blank</code> 存储空窗口</li>\n<li><code>buffers</code> 存储缓冲区</li>\n<li><code>folds</code> 存储折叠</li>\n<li><code>globals</code> 存储全局变量（必须以大写字母开头，并且至少包含一个小写字母）</li>\n<li><code>options</code> 存储选项和映射</li>\n<li><code>resize</code> 存储窗口行列</li>\n<li><code>winpos</code> 存储窗口位置</li>\n<li><code>winsize</code> 存储窗口大小</li>\n<li><code>tabpages</code> 存储选项卡</li>\n<li><code>unix</code> 以 Unix 格式存储文件</li>\n</ul>\n<p>查阅 <code>:h &#39;sessionoptions&#39;</code> 来获取完整列表。</p>\n<p>会话是保存项目外部属性的好工具。但是，一些内部属性不存储在会话中，如本地标记、寄存器、历史记录等。要保存它们，您需要使用 Viminfo！</p>\n<h2 id=\"Viminfo\"><a href=\"#Viminfo\" class=\"headerlink\" title=\"Viminfo\"></a>Viminfo</h2><p>如果您留意，在复制一个单词进寄存器 a，再退出并重新打开 Vim 后，您仍然可以看到存储在寄存器中的文本。这就是 Viminfo 的功劳。没有它，在您关闭 Vim 后，Vim 会忘记这些寄存器。</p>\n<p>如果您使用 Vim 8 或更高版本，Vim 会默认启用 Viminfo。因此您可能一直在使用 Viminfo，而您对它毫不知情！</p>\n<p>您可能会问：Viminfo 存储了什么？与会话有何不同？</p>\n<p>要使用 Viminfo，您必须启用了 <code>+viminfo</code> 特性（<code>:version</code>）。Viminfo 存储着：</p>\n<ul>\n<li>命令行历史记录。</li>\n<li>字符串搜索历史记录。</li>\n<li>输入行历史记录。</li>\n<li>非空寄存器的内容。</li>\n<li>多个文件的标记。</li>\n<li>文件标记，它指向文件中的位置。</li>\n<li>上次搜索 &#x2F; 替换模式（用于 “n” 和 “&amp;”）。</li>\n<li>缓冲区列表。</li>\n<li>全局变量。</li>\n</ul>\n<p>通常，会话存储“外部”属性，Viminfo 存储“内部”属性。</p>\n<p>每个项目可以有一个会话文件，而 Viminfo 与会话不同，通常每台计算机只使用一个 Viminfo。Viminfo 是项目无关的。</p>\n<p>对于 Unix，Viminfo 的默认位置是 <code>$HOME/.viminfo</code>（<code>~/.viminfo</code>）。如果您用其他操作系统，Viminfo 位置可能会有所不同。可以查阅 <code>:h viminfo-file-name</code>。每一次您做出的“内部”更改，如将文本复制进一个寄存器，Vim 都会自动更新 Viminfo 文件。</p>\n<p><em>请确保您设置了 <code>nocompatible</code> 选项（<code>set nocompatible</code>），否则您的 Viminfo 将不起作用。</em></p>\n<h3 id=\"读写-Viminfo\"><a href=\"#读写-Viminfo\" class=\"headerlink\" title=\"读写 Viminfo\"></a>读写 Viminfo</h3><p>尽管只使用一个 Viminfo 文件，但您还是可以创建多个 Viminfo 文件。使用 <code>:wviminfo</code> 命令（缩写为 <code>:wv</code>）来创建多个 Viminfo 文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:wv ~/.viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>要覆盖现有的 Viminfo 文件，向 <code>wv</code> 命令多添加一个叹号：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:wv! ~/.viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>Vim 默认情况下会读取 <code>~/.viminfo</code> 文件。运行 <code>:rviminfo</code>（缩写为 <code>:rv</code>）可以读取不同的 Vimfile 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:rv ~/.viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>要在终端使用不同的 Viminfo 文件来启动 Vim，请使用 “i” 标志：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">vim -<span class=\"hljs-selector-tag\">i</span> viminfo_extra<br></code></pre></td></tr></table></figure>\n\n<p>如果您要将 Vim 用于不同的任务，比如写代码和写作，您可以创建两个 Viminfo，一个针对写作优化，另一个为写代码优化。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">vim -<span class=\"hljs-selector-tag\">i</span> viminfo_writing<br><br>vim -<span class=\"hljs-selector-tag\">i</span> viminfo_coding<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"不使用-Viminfo-启动-Vim\"><a href=\"#不使用-Viminfo-启动-Vim\" class=\"headerlink\" title=\"不使用 Viminfo 启动 Vim\"></a>不使用 Viminfo 启动 Vim</h3><p>要不使用 Viminfo 启动 Vim，可以在终端运行：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">vim -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-attribute\">NONE</span><br></code></pre></td></tr></table></figure>\n\n<p>要永不使用 Viminfo，可以在您的 vimrc 文件添加：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">viminfo</span>=<span class=\"hljs-string\">&quot;NONE&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置-Viminfo-属性\"><a href=\"#配置-Viminfo-属性\" class=\"headerlink\" title=\"配置 Viminfo 属性\"></a>配置 Viminfo 属性</h3><p>和 <code>viewoptions</code> 以及 <code>sessionoptions</code> 类似，您可以用 <code>viminfo</code> 选项指定要存储的属性。请运行：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">:<span class=\"hljs-built_in\">set</span> viminfo?<br></code></pre></td></tr></table></figure>\n\n<p>您会得到：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs diff\"><span class=\"hljs-addition\">!,&#x27;100,&lt;50,s10,h</span><br></code></pre></td></tr></table></figure>\n\n<p>看起来有点晦涩难懂。命令分解如下：</p>\n<ul>\n<li><code>!</code> 保存以大写字母开头、却不包含小写字母的全局变量。回想一下 <code>g:</code> 代表了一个全局变量。例如，假设您写了赋值语句 <code>let g:FOO = &quot;foo&quot;</code>，Viminfo 将存储全局变量 <code>FOO</code>。然而如果您写了 <code>let g:Foo = &quot;foo&quot;</code>，Viminfo 将不存储它，因为它包含了小写字母。没有 <code>!</code>，Vim 不会存储这些全局变量。</li>\n<li><code>&#39;100</code> 代表标记。在这个例子中，Viminfo 将保存最近 100 个文件的本地标记（a-z）。注意，如果存储的文件过多，Vim 会变得很慢，1000 左右就可以了。</li>\n<li><code>&lt;50</code> 告诉 Viminfo 每个寄存器最多保存多少行（这个例子中是 50 行）。如果我复制 100 行文本进寄存器 a（<code>&quot;ay99j</code>）后关闭 Vim，下次打开 Vim 并从寄存器 a（<code>&quot;ap</code>）粘贴时，Vim 最多只粘贴 50 行；如果不指定最大行号， <em>所有</em> 行都将被保存；如果指定 0，什么都不保存了。</li>\n<li><code>s10</code> 为寄存器设置大小限制（kb）。在这个例子中，任何大于 10kb 的寄存器都会被排除。</li>\n<li><code>h</code> 禁用高亮显示（<code>hlsearch</code> 时）。</li>\n</ul>\n<p>可以查阅 <code>:h &#39;viminfo&#39;</code> 来了解其他更多选项。</p>\n<h2 id=\"聪明地使用视图、会话和-Viminfo\"><a href=\"#聪明地使用视图、会话和-Viminfo\" class=\"headerlink\" title=\"聪明地使用视图、会话和 Viminfo\"></a>聪明地使用视图、会话和 Viminfo</h2><p>Vim 能使用视图、会话和 Viminfo 来保存不同级别的 Vim 环境快照。对于微型项目，可以使用视图；对于大型项目，可以使用会话。您应该花些时间来查阅视图、会话和 Viminfo 提供的所有选项。</p>\n<p>为您的编辑风格创建属于您自己的视图、会话和 Viminfo。如果您要换台计算机使用 Vim，只需加载您的设置，立刻就会感到就像在家里的工作环境一样！</p>\n"},{"title":"VIM-多文件操作","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第21章 多文件操作\n\n多文件编辑更新是一个值得掌握、非常有用的编辑工具。前面您已经学会了如何使用 `cfdo` 命令在多个文本中进行更新。本章，您将学到如何在Vim中进行多文件编辑的更多不同方法。\n\n## 在多个文件中执行命令的几种方法\n\n要在多个文件中执行命令，Vim有8种方法：\n- 参数列表 (`argdo`)\n- 缓冲区列表 (`bufdo`)\n- 窗口列表 (`windo`)\n- tab 列表(`tabdo`)\n- 快速修复列表 (`cdo`)\n- 文件方式的快速修复列表 (`cfdo`)\n- 位置列表 (`ldo`)\n- 文件方式的位置列表 (`lfdo`)\n\n实际上，大部分时间您可能只会用到1种或2种（就我个人而言，我使用 `cdo` 和 `argdo`比其他的多得多），但了解所有可行方法还是很有用的，这样您就可以选择一个最符合您个人编辑风格的方法。\n\n学习所有8个命令可能听起来让人有点打退堂鼓。但实际上，这些命令工作方式很相似。学习了其中一个后，再学习剩余的将容易的多。它们的运行方式都大体相同：分别创建一个列表(列表中的元素根据命令有所不同)，然后向列表传递一个您想执行的命令。\n\n## 参数列表\n\n参数列表是最基础的列表。它创建一个文件列表。要想为 file1, file2, file3创建文件列表，您可以执行：\n\n```\n:args file1 file2 file3\n```\n\n您也可以传递一个通配符（`*`），所以如果您想为当前目录下所有的 `.js` 文件创建一个列表，运行：\n\n```\n:args *.js\n```\n\n如果您想为当前目录下所有以 \"a\" 开头的Javascript文件创建列表，运行：\n\n```\n:args a*.js\n```\n\n（`*`）通配符匹配当前目录下的1个或多个任意文件名中的字符。但如果您想在某个目录下进行递归搜索怎么办呢？您可以使用双通配符（`**`）。要得到您当前位置下所有子目录中的Javascript文件，运行：\n\n```\n:args **/*.js\n```\n\n您运行了 `args` 命令后，您的当前buffer将会切换到列表中的第一个文件。运行 `:args`可以查看您刚才创建的文件列表。当您创建好了您的列表后，您就可以遍历它们了。`:first` 将让您跳至列表中的第一个文件。`:last` 将跳到最后一个文件。运行`:next`可以在列表中一次向前移动一个文件。运行 `:prev`可以在列表中一次向后移动一个文件。运行`:wnext` 和 `:wprev`命令，在向前/向后移动文件的同时还会保存修改。查阅 `: arglist` 了解更多导航命令。\n\n参数列表在定位某个特定类型的文件或少量文件时特别有用。假如您需要将所有 `yml` 文件中的`donut` 更新为 `pancake`。运行：\n\n```\n:args **/*.yml\n:argdo %s/donut/pancake/g | update\n\n```\n注意如果您再次执行 `args` 命令，它将覆盖先前的列表。比如，如果您先前运行了：\n\n```\n:args file1 file2 file3\n```\n\n假设这些文件都是存在的，那么现在您的列表为 `file1`, `file2`,以及 `file3`。然后再运行：\n\n```\n:args file4 file5\n```\n\n您的初始列表 `file1`, `file2`, `file3`将被覆盖为 `file4`, `file5`。如果您的参数列表中已经有了 `file1`, `file2`, `file3` ，而您想将 `file4`, `file5` 添加到初始列表中，请使用 `:arga`命令。运行\n\n```\n:arga file4 file5\n```\n\n现在您的列表为`file1`, `file2`, `file3`, `file4`, `file5`。\n\n如果您运行 `:arga` 时没有给任何参数，Vim会添加当前buffer到参数列表中。例如，如果您的参数列表中已经有了 `file1`, `file2`, `file3`，而您当前buffer是 `file5`，运行 `:arga` 将添加 `file5` 到您的列表中。\n\n在前面的命令（`:argdo %s/donut/pancake/g`）中您已经看到过了，当您创建好列表后就可以向它传递任意命令行命令。其他的一些示例：\n- 删除参数列表所有文件内包含 \"dessert\" 的行, 运行 `:argdo g/dessert/d`.\n- 在参数列表每个文件中执行宏a(假设您已经在a中录好了一个宏)，运行 `:argdo norm @a`.\n- 向参数列表所有文件的第一行插入\"hello \"+文件名 ，运行 `:argdo 0put='hello ' . @%`（译者注：在英文版中，原作者给出的命令是 `:argdo 0put='hello ' .. @:`，貌似这个命令有问题）。\n\n把所有工作完成后，别忘了使用 `:update` 命令保存(`:update`只会保存当前buffer，要保存列表所有文件的修改，请用 `:argdo update`)。\n\n有时候您仅仅需要在参数列表的前n个文件执行某条命令。如果是这种情况，只需要向 `argdo` 命令传递一个地址就可以了。比如，要在列表的前3个文件执行替换命令，运行：`:1,3argdo %s/donut/pancake/g`。\n\n## 缓冲区列表\n\n因为每次您创建新文件或打开文件时，Vim将它保存在一个buffer中（除非您显式地删除它），所以当您编辑新文件时，缓冲区列表就有组织地被创建了。如果您已经打开了3个文件：`file1.rb file2.rb file3.rb`，您的缓冲区列表就已经有了3个元素。运行 `:buffers`（或者`:ls`、或`:files`）可以显示缓冲区列表。要想向前或向后遍历缓冲区列表，可以使用 `:bnext` `:bprev`。要想跳至列表中第一个或最后一个buffer，可使用 `:bfirst` 和 `:blast`。\n\n另外，这里有一个和本章内容不相关，但是很酷的缓冲区技巧：如果您的缓冲区有大量的文件，您可以使用 `:ball` 显示所有缓冲区。`:ball` 命令默认使用水平分割窗口进行显示，如果想使用垂直分割的窗口显示，运行：`:vertical ball`\n\n回到本章主题。在缓冲区列表中执行某个操作的方法与参数列表操作非常相似。当您创建好缓冲区列表后，您只需要在您想执行的命令前用 `:bufdo` 代替 `:argdo`就可以了。例如，如果您想将缓冲区列表内每个文件中所有的 \"donut\" 替换为 \"pancake\"并保存修改，可以运行：`:bufdo %s/donut/pancake/g | update`。\n\n## 窗口列表和选项卡（Tab）列表\n\n窗口列表、选项卡列表的操作和参数列表、缓冲区列表同样非常相似。唯一的区别在于它们的内容和语法。\n\n窗口操作作用在每一个打开的窗口上，使用的命令是 `:windo`。选项卡（Tab）操作作用在每一个打开的选项卡上，使用的命令是 `:tabdo`。可以查询 `:h list-repeat`, `:h :windo`和`:h :tabdo`，了解更多信息。\n\n比如，如果您打开了4个窗口（您可以使用 `Ctrl-w v`打开一个垂直分割的窗口，也可以使用 `Ctrl-w s`打开一个水平分割的窗口），然后您运行 `:windo 0put = 'hello' . @%`，Vim将在所有打开的窗口的第一行输出 \"hello\"+文件名。\n\n## 快速修复列表\n\n在前面的章节中（第3章和第19章），我曾提到过快速修复（quickfix）。快速修复有很多作用，很多流行的插件都在使用快速修复提供的功能，因此值得花时间去理解它。\n\n如果您是Vim新手，快速修复对于您可能是个新概念。回想以前您执行代码编译的时候，编译期间您可能遇到过错误，而这些错误都显示在一个特殊的窗口。这就是快速修复(quickfix)的由来。当您编译您的代码的时候，Vim会在快速修复窗口显示错误信息，您可以稍后去解决。许多现代语言已经不再需要进行显式地编译，但快速修复并没有被淘汰。现在，人们使用快速修复来做各种各样的事，比如显示虚拟终端的输入、存储搜索结果等。我们重点研究后者，存储搜索结果。\n\n除编译命令外，某些特定的Vim命令也依赖快速修复接口。其中一种就是搜索命令，其使用过程中大量的使用了快速修复窗口，`:vimgrep` 和 `:grep` 都默认使用快速修复。\n\n比如，如果您需要在所有的Javascript文件中递归地搜索 \"donut\"，您可以运行：\n\n```\n:vimgrep /donut/ **/*.js\n```\n\n“donut”的搜索结果存储在快速修复窗口中。要查看快速修复窗口的结果，运行：\n\n```\n:copen\n```\n\n要关闭快速修复窗口，运行：\n\n```\n:cclose\n```\n\n在快速修复列表中向前或向后遍历，运行：\n\n```\n:cnext\n:cprev\n```\n\n跳至第一个或最后一个匹配的元素，运行：\n\n```\n:cfirst\n:clast\n```\n\n在前面我提到过，有两种快速修复命令：`cdo` 和 `cfdo` 。它们有什么区别？`cdo` 在修复列表中的每一个元素上执行命令，而 `cfdo` 在修复列表中的每一个文件上执行命令。\n\n让我讲清楚一点，假设运行完上面的 `vimgrep` 命令后，您找到以下结果：\n- 1 result in `file1.js`\n- 10 results in `file2.js`\n\n如果您运行 `:cfdo %s/donut/pancake/g`, 这个命令将会在 `file1.js` 和 `file2.js` 上分别有效地运行一次`%s/donut/pancake/g`. 它执行的次数与 *匹配结果中文件的数量* 相同。因为搜索结果中有2个文件，因此Vim在 `file1.js` 上运行一次替换命令，在 `file2.js` 上再运行一次替换命令。 尽管在第二个文件中有10个搜索结果，但 `cfdo` 只关注快速修复列表中有多少个文件。\n\n而如果您运行 `:cdo %s/donut/pancake/g` ，这个命令将会在 `file1.js` 上有效运行一次，然后在 `file2.js` 上运行10次。它执行的次数与 *快速修复列表中元素的数量* 相同。因为在 `file1.js` 上找到1个匹配结果，在 `file2.js` 上找到10个匹配结果，因此它执行的总次数是11次。\n\n由于您要在列表中运行的命令是 `%s/donut/pancake/g` ，所以使用 `cfdo`命令是比较合理的。而使用 `cdo` 是不合理的，因为它将在 `file2.js` 中运行10次 `%s/donut/pancake/g`命令（`%s`已经是一个针对整个文件的替换操作）。一个文件运行一次 `%s` 就足够了。如果您使用 `cdo`，则传给它的命令应当改为 `s/donut/pancake/g` 才是合理的。\n\n那到底什么时候该用 `cfdo`？什么时候该用 `cdo`？\t这应当想一想您要传递的命令的作用域，要看命令作用域是整个文件（比如 `:%s` 或 `:g`）？还是某一行（比如 `:s` 或 `:!`）？\n\n## 位置列表\n\n位置列表在某种意义上和快速修复列表很像。Vim也使用一个特殊的窗口来显示位置列表的信息。区别在于：您任何时候都只能有1个快速修复列表，而位置列表则是，有多少个窗口就可以有多少个位置列表。\n\n假设您打开了两个窗口，其中一个窗口显示 `food.txt` ，而另一个显示 `drinks.txt`。在 `food.txt`里面，运行一个位置列表搜索命令 `:lvimgrep` （`:vimgrep`命令关于位置列表的一个变体）。\n\n```\n:lvim /bagel/ **/*.md\n```\n\nVim将为 `food.txt`所在 *窗口*创建一个位置列表，用于存储所有的bagel搜索结果。用 `:lopen`命令可以查看位置列表。现在转到另一个窗口 `drinks.txt`，运行：\n\n```\n:lvimgrep /milk/ **/*.md\n```\n\nVim将为 `drinks.txt`所在 *窗口*再创建一个 *单独*的位置列表，用于存储所有关于milk的搜索结果。\n\n对于每个不同的窗口中您运行的位置命令，Vim都会单独创建一个位置列表。如果您有10个不同的窗口，您就可以有最多10个不同的位置列表。对比前面介绍的快速修复列表，快速修复列表任何时候都只能有1个。就算您有10个不同的窗口，您也只能有1个快速修复列表。\n\n大多数位置列表命令都和快速修复列表命令相似，唯一不同就是位置列表命令有一个 `l-`前缀，比如： `:lvimgrep`, `:lgrep`, 还有 `:lmake`。在快速修复列表命令中与之对应的是: `:vimgrep`, `:grep`, 以及 `:make`。操作位置列表窗口的方式和快速修复窗口也很相似：`:lopen`, `:lclose`, `:lfirst`, `:llast`, `:lnext`, 还有`:lprev`，与之对应快速修复版本是：`:copen`, `:cclose`, `:cfirst`, `:clast`, `:cnext`, and `:cprev`。\n\n两个位置列表参数的多文件操作命令也和快速修复列表的多文件操作命令也很类似：`:ldo` 和 `:lfdo`。`:ldo` 对位置列表中每一个元素执行命令，而 `:lfdo` 对位置列表中每一个文件执行命令。可以查阅 `:h location-list`了解更多信息。\n\n## 在Vim中运行多文件操作命令\n\n在编辑工作中，知道如何进行多文件操作是一个非常有用的技能。当您需要在多个文件中改变一个变量名字的时候，您肯定想一个操作就全部搞定。Vim有8种不同的方法支持你完成这个事。\n\n事实上，您可能并不会用到所有8种方法。您会慢慢倾向于其中1中或2种。当您刚开始时，选择其中1个（我个人建议从参数列表开始 `:argdo`）并掌握它。当您习惯了其中1个，然后再学下一个。您将会发现，学习第二个、第三个、第四个时要容易多了。记得要创造性的使用，即将它和其他各种不同命令组合起来使用。坚持练习直到您可以不经思考地高效的使用它。让它成为您的肌肉记忆。\n\n就像前面已经说过的，您现在已经掌握了Vim的编辑功能。恭喜您！\n","source":"_posts/Vim/ch21_multiple_file_operations.md","raw":"---\ntitle: VIM-多文件操作\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第21章 多文件操作\n\n多文件编辑更新是一个值得掌握、非常有用的编辑工具。前面您已经学会了如何使用 `cfdo` 命令在多个文本中进行更新。本章，您将学到如何在Vim中进行多文件编辑的更多不同方法。\n\n## 在多个文件中执行命令的几种方法\n\n要在多个文件中执行命令，Vim有8种方法：\n- 参数列表 (`argdo`)\n- 缓冲区列表 (`bufdo`)\n- 窗口列表 (`windo`)\n- tab 列表(`tabdo`)\n- 快速修复列表 (`cdo`)\n- 文件方式的快速修复列表 (`cfdo`)\n- 位置列表 (`ldo`)\n- 文件方式的位置列表 (`lfdo`)\n\n实际上，大部分时间您可能只会用到1种或2种（就我个人而言，我使用 `cdo` 和 `argdo`比其他的多得多），但了解所有可行方法还是很有用的，这样您就可以选择一个最符合您个人编辑风格的方法。\n\n学习所有8个命令可能听起来让人有点打退堂鼓。但实际上，这些命令工作方式很相似。学习了其中一个后，再学习剩余的将容易的多。它们的运行方式都大体相同：分别创建一个列表(列表中的元素根据命令有所不同)，然后向列表传递一个您想执行的命令。\n\n## 参数列表\n\n参数列表是最基础的列表。它创建一个文件列表。要想为 file1, file2, file3创建文件列表，您可以执行：\n\n```\n:args file1 file2 file3\n```\n\n您也可以传递一个通配符（`*`），所以如果您想为当前目录下所有的 `.js` 文件创建一个列表，运行：\n\n```\n:args *.js\n```\n\n如果您想为当前目录下所有以 \"a\" 开头的Javascript文件创建列表，运行：\n\n```\n:args a*.js\n```\n\n（`*`）通配符匹配当前目录下的1个或多个任意文件名中的字符。但如果您想在某个目录下进行递归搜索怎么办呢？您可以使用双通配符（`**`）。要得到您当前位置下所有子目录中的Javascript文件，运行：\n\n```\n:args **/*.js\n```\n\n您运行了 `args` 命令后，您的当前buffer将会切换到列表中的第一个文件。运行 `:args`可以查看您刚才创建的文件列表。当您创建好了您的列表后，您就可以遍历它们了。`:first` 将让您跳至列表中的第一个文件。`:last` 将跳到最后一个文件。运行`:next`可以在列表中一次向前移动一个文件。运行 `:prev`可以在列表中一次向后移动一个文件。运行`:wnext` 和 `:wprev`命令，在向前/向后移动文件的同时还会保存修改。查阅 `: arglist` 了解更多导航命令。\n\n参数列表在定位某个特定类型的文件或少量文件时特别有用。假如您需要将所有 `yml` 文件中的`donut` 更新为 `pancake`。运行：\n\n```\n:args **/*.yml\n:argdo %s/donut/pancake/g | update\n\n```\n注意如果您再次执行 `args` 命令，它将覆盖先前的列表。比如，如果您先前运行了：\n\n```\n:args file1 file2 file3\n```\n\n假设这些文件都是存在的，那么现在您的列表为 `file1`, `file2`,以及 `file3`。然后再运行：\n\n```\n:args file4 file5\n```\n\n您的初始列表 `file1`, `file2`, `file3`将被覆盖为 `file4`, `file5`。如果您的参数列表中已经有了 `file1`, `file2`, `file3` ，而您想将 `file4`, `file5` 添加到初始列表中，请使用 `:arga`命令。运行\n\n```\n:arga file4 file5\n```\n\n现在您的列表为`file1`, `file2`, `file3`, `file4`, `file5`。\n\n如果您运行 `:arga` 时没有给任何参数，Vim会添加当前buffer到参数列表中。例如，如果您的参数列表中已经有了 `file1`, `file2`, `file3`，而您当前buffer是 `file5`，运行 `:arga` 将添加 `file5` 到您的列表中。\n\n在前面的命令（`:argdo %s/donut/pancake/g`）中您已经看到过了，当您创建好列表后就可以向它传递任意命令行命令。其他的一些示例：\n- 删除参数列表所有文件内包含 \"dessert\" 的行, 运行 `:argdo g/dessert/d`.\n- 在参数列表每个文件中执行宏a(假设您已经在a中录好了一个宏)，运行 `:argdo norm @a`.\n- 向参数列表所有文件的第一行插入\"hello \"+文件名 ，运行 `:argdo 0put='hello ' . @%`（译者注：在英文版中，原作者给出的命令是 `:argdo 0put='hello ' .. @:`，貌似这个命令有问题）。\n\n把所有工作完成后，别忘了使用 `:update` 命令保存(`:update`只会保存当前buffer，要保存列表所有文件的修改，请用 `:argdo update`)。\n\n有时候您仅仅需要在参数列表的前n个文件执行某条命令。如果是这种情况，只需要向 `argdo` 命令传递一个地址就可以了。比如，要在列表的前3个文件执行替换命令，运行：`:1,3argdo %s/donut/pancake/g`。\n\n## 缓冲区列表\n\n因为每次您创建新文件或打开文件时，Vim将它保存在一个buffer中（除非您显式地删除它），所以当您编辑新文件时，缓冲区列表就有组织地被创建了。如果您已经打开了3个文件：`file1.rb file2.rb file3.rb`，您的缓冲区列表就已经有了3个元素。运行 `:buffers`（或者`:ls`、或`:files`）可以显示缓冲区列表。要想向前或向后遍历缓冲区列表，可以使用 `:bnext` `:bprev`。要想跳至列表中第一个或最后一个buffer，可使用 `:bfirst` 和 `:blast`。\n\n另外，这里有一个和本章内容不相关，但是很酷的缓冲区技巧：如果您的缓冲区有大量的文件，您可以使用 `:ball` 显示所有缓冲区。`:ball` 命令默认使用水平分割窗口进行显示，如果想使用垂直分割的窗口显示，运行：`:vertical ball`\n\n回到本章主题。在缓冲区列表中执行某个操作的方法与参数列表操作非常相似。当您创建好缓冲区列表后，您只需要在您想执行的命令前用 `:bufdo` 代替 `:argdo`就可以了。例如，如果您想将缓冲区列表内每个文件中所有的 \"donut\" 替换为 \"pancake\"并保存修改，可以运行：`:bufdo %s/donut/pancake/g | update`。\n\n## 窗口列表和选项卡（Tab）列表\n\n窗口列表、选项卡列表的操作和参数列表、缓冲区列表同样非常相似。唯一的区别在于它们的内容和语法。\n\n窗口操作作用在每一个打开的窗口上，使用的命令是 `:windo`。选项卡（Tab）操作作用在每一个打开的选项卡上，使用的命令是 `:tabdo`。可以查询 `:h list-repeat`, `:h :windo`和`:h :tabdo`，了解更多信息。\n\n比如，如果您打开了4个窗口（您可以使用 `Ctrl-w v`打开一个垂直分割的窗口，也可以使用 `Ctrl-w s`打开一个水平分割的窗口），然后您运行 `:windo 0put = 'hello' . @%`，Vim将在所有打开的窗口的第一行输出 \"hello\"+文件名。\n\n## 快速修复列表\n\n在前面的章节中（第3章和第19章），我曾提到过快速修复（quickfix）。快速修复有很多作用，很多流行的插件都在使用快速修复提供的功能，因此值得花时间去理解它。\n\n如果您是Vim新手，快速修复对于您可能是个新概念。回想以前您执行代码编译的时候，编译期间您可能遇到过错误，而这些错误都显示在一个特殊的窗口。这就是快速修复(quickfix)的由来。当您编译您的代码的时候，Vim会在快速修复窗口显示错误信息，您可以稍后去解决。许多现代语言已经不再需要进行显式地编译，但快速修复并没有被淘汰。现在，人们使用快速修复来做各种各样的事，比如显示虚拟终端的输入、存储搜索结果等。我们重点研究后者，存储搜索结果。\n\n除编译命令外，某些特定的Vim命令也依赖快速修复接口。其中一种就是搜索命令，其使用过程中大量的使用了快速修复窗口，`:vimgrep` 和 `:grep` 都默认使用快速修复。\n\n比如，如果您需要在所有的Javascript文件中递归地搜索 \"donut\"，您可以运行：\n\n```\n:vimgrep /donut/ **/*.js\n```\n\n“donut”的搜索结果存储在快速修复窗口中。要查看快速修复窗口的结果，运行：\n\n```\n:copen\n```\n\n要关闭快速修复窗口，运行：\n\n```\n:cclose\n```\n\n在快速修复列表中向前或向后遍历，运行：\n\n```\n:cnext\n:cprev\n```\n\n跳至第一个或最后一个匹配的元素，运行：\n\n```\n:cfirst\n:clast\n```\n\n在前面我提到过，有两种快速修复命令：`cdo` 和 `cfdo` 。它们有什么区别？`cdo` 在修复列表中的每一个元素上执行命令，而 `cfdo` 在修复列表中的每一个文件上执行命令。\n\n让我讲清楚一点，假设运行完上面的 `vimgrep` 命令后，您找到以下结果：\n- 1 result in `file1.js`\n- 10 results in `file2.js`\n\n如果您运行 `:cfdo %s/donut/pancake/g`, 这个命令将会在 `file1.js` 和 `file2.js` 上分别有效地运行一次`%s/donut/pancake/g`. 它执行的次数与 *匹配结果中文件的数量* 相同。因为搜索结果中有2个文件，因此Vim在 `file1.js` 上运行一次替换命令，在 `file2.js` 上再运行一次替换命令。 尽管在第二个文件中有10个搜索结果，但 `cfdo` 只关注快速修复列表中有多少个文件。\n\n而如果您运行 `:cdo %s/donut/pancake/g` ，这个命令将会在 `file1.js` 上有效运行一次，然后在 `file2.js` 上运行10次。它执行的次数与 *快速修复列表中元素的数量* 相同。因为在 `file1.js` 上找到1个匹配结果，在 `file2.js` 上找到10个匹配结果，因此它执行的总次数是11次。\n\n由于您要在列表中运行的命令是 `%s/donut/pancake/g` ，所以使用 `cfdo`命令是比较合理的。而使用 `cdo` 是不合理的，因为它将在 `file2.js` 中运行10次 `%s/donut/pancake/g`命令（`%s`已经是一个针对整个文件的替换操作）。一个文件运行一次 `%s` 就足够了。如果您使用 `cdo`，则传给它的命令应当改为 `s/donut/pancake/g` 才是合理的。\n\n那到底什么时候该用 `cfdo`？什么时候该用 `cdo`？\t这应当想一想您要传递的命令的作用域，要看命令作用域是整个文件（比如 `:%s` 或 `:g`）？还是某一行（比如 `:s` 或 `:!`）？\n\n## 位置列表\n\n位置列表在某种意义上和快速修复列表很像。Vim也使用一个特殊的窗口来显示位置列表的信息。区别在于：您任何时候都只能有1个快速修复列表，而位置列表则是，有多少个窗口就可以有多少个位置列表。\n\n假设您打开了两个窗口，其中一个窗口显示 `food.txt` ，而另一个显示 `drinks.txt`。在 `food.txt`里面，运行一个位置列表搜索命令 `:lvimgrep` （`:vimgrep`命令关于位置列表的一个变体）。\n\n```\n:lvim /bagel/ **/*.md\n```\n\nVim将为 `food.txt`所在 *窗口*创建一个位置列表，用于存储所有的bagel搜索结果。用 `:lopen`命令可以查看位置列表。现在转到另一个窗口 `drinks.txt`，运行：\n\n```\n:lvimgrep /milk/ **/*.md\n```\n\nVim将为 `drinks.txt`所在 *窗口*再创建一个 *单独*的位置列表，用于存储所有关于milk的搜索结果。\n\n对于每个不同的窗口中您运行的位置命令，Vim都会单独创建一个位置列表。如果您有10个不同的窗口，您就可以有最多10个不同的位置列表。对比前面介绍的快速修复列表，快速修复列表任何时候都只能有1个。就算您有10个不同的窗口，您也只能有1个快速修复列表。\n\n大多数位置列表命令都和快速修复列表命令相似，唯一不同就是位置列表命令有一个 `l-`前缀，比如： `:lvimgrep`, `:lgrep`, 还有 `:lmake`。在快速修复列表命令中与之对应的是: `:vimgrep`, `:grep`, 以及 `:make`。操作位置列表窗口的方式和快速修复窗口也很相似：`:lopen`, `:lclose`, `:lfirst`, `:llast`, `:lnext`, 还有`:lprev`，与之对应快速修复版本是：`:copen`, `:cclose`, `:cfirst`, `:clast`, `:cnext`, and `:cprev`。\n\n两个位置列表参数的多文件操作命令也和快速修复列表的多文件操作命令也很类似：`:ldo` 和 `:lfdo`。`:ldo` 对位置列表中每一个元素执行命令，而 `:lfdo` 对位置列表中每一个文件执行命令。可以查阅 `:h location-list`了解更多信息。\n\n## 在Vim中运行多文件操作命令\n\n在编辑工作中，知道如何进行多文件操作是一个非常有用的技能。当您需要在多个文件中改变一个变量名字的时候，您肯定想一个操作就全部搞定。Vim有8种不同的方法支持你完成这个事。\n\n事实上，您可能并不会用到所有8种方法。您会慢慢倾向于其中1中或2种。当您刚开始时，选择其中1个（我个人建议从参数列表开始 `:argdo`）并掌握它。当您习惯了其中1个，然后再学下一个。您将会发现，学习第二个、第三个、第四个时要容易多了。记得要创造性的使用，即将它和其他各种不同命令组合起来使用。坚持练习直到您可以不经思考地高效的使用它。让它成为您的肌肉记忆。\n\n就像前面已经说过的，您现在已经掌握了Vim的编辑功能。恭喜您！\n","slug":"Vim/ch21_multiple_file_operations","published":1,"updated":"2022-08-28T07:38:59.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i26002nscvmgb6pdsda","content":"<h1 id=\"第21章-多文件操作\"><a href=\"#第21章-多文件操作\" class=\"headerlink\" title=\"第21章 多文件操作\"></a>第21章 多文件操作</h1><p>多文件编辑更新是一个值得掌握、非常有用的编辑工具。前面您已经学会了如何使用 <code>cfdo</code> 命令在多个文本中进行更新。本章，您将学到如何在Vim中进行多文件编辑的更多不同方法。</p>\n<h2 id=\"在多个文件中执行命令的几种方法\"><a href=\"#在多个文件中执行命令的几种方法\" class=\"headerlink\" title=\"在多个文件中执行命令的几种方法\"></a>在多个文件中执行命令的几种方法</h2><p>要在多个文件中执行命令，Vim有8种方法：</p>\n<ul>\n<li>参数列表 (<code>argdo</code>)</li>\n<li>缓冲区列表 (<code>bufdo</code>)</li>\n<li>窗口列表 (<code>windo</code>)</li>\n<li>tab 列表(<code>tabdo</code>)</li>\n<li>快速修复列表 (<code>cdo</code>)</li>\n<li>文件方式的快速修复列表 (<code>cfdo</code>)</li>\n<li>位置列表 (<code>ldo</code>)</li>\n<li>文件方式的位置列表 (<code>lfdo</code>)</li>\n</ul>\n<p>实际上，大部分时间您可能只会用到1种或2种（就我个人而言，我使用 <code>cdo</code> 和 <code>argdo</code>比其他的多得多），但了解所有可行方法还是很有用的，这样您就可以选择一个最符合您个人编辑风格的方法。</p>\n<p>学习所有8个命令可能听起来让人有点打退堂鼓。但实际上，这些命令工作方式很相似。学习了其中一个后，再学习剩余的将容易的多。它们的运行方式都大体相同：分别创建一个列表(列表中的元素根据命令有所不同)，然后向列表传递一个您想执行的命令。</p>\n<h2 id=\"参数列表\"><a href=\"#参数列表\" class=\"headerlink\" title=\"参数列表\"></a>参数列表</h2><p>参数列表是最基础的列表。它创建一个文件列表。要想为 file1, file2, file3创建文件列表，您可以执行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> file1 file2 file3<br></code></pre></td></tr></table></figure>\n\n<p>您也可以传递一个通配符（<code>*</code>），所以如果您想为当前目录下所有的 <code>.js</code> 文件创建一个列表，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> *.js<br></code></pre></td></tr></table></figure>\n\n<p>如果您想为当前目录下所有以 “a” 开头的Javascript文件创建列表，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> a*.js<br></code></pre></td></tr></table></figure>\n\n<p>（<code>*</code>）通配符匹配当前目录下的1个或多个任意文件名中的字符。但如果您想在某个目录下进行递归搜索怎么办呢？您可以使用双通配符（<code>**</code>）。要得到您当前位置下所有子目录中的Javascript文件，运行：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">:args <span class=\"hljs-strong\">**/*</span>.js<br></code></pre></td></tr></table></figure>\n\n<p>您运行了 <code>args</code> 命令后，您的当前buffer将会切换到列表中的第一个文件。运行 <code>:args</code>可以查看您刚才创建的文件列表。当您创建好了您的列表后，您就可以遍历它们了。<code>:first</code> 将让您跳至列表中的第一个文件。<code>:last</code> 将跳到最后一个文件。运行<code>:next</code>可以在列表中一次向前移动一个文件。运行 <code>:prev</code>可以在列表中一次向后移动一个文件。运行<code>:wnext</code> 和 <code>:wprev</code>命令，在向前&#x2F;向后移动文件的同时还会保存修改。查阅 <code>: arglist</code> 了解更多导航命令。</p>\n<p>参数列表在定位某个特定类型的文件或少量文件时特别有用。假如您需要将所有 <code>yml</code> 文件中的<code>donut</code> 更新为 <code>pancake</code>。运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">args</span> **/*.yml<br>:<span class=\"hljs-keyword\">argdo</span> %s/donut/pancake/g | <span class=\"hljs-keyword\">update</span><br><br></code></pre></td></tr></table></figure>\n<p>注意如果您再次执行 <code>args</code> 命令，它将覆盖先前的列表。比如，如果您先前运行了：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> file1 file2 file3<br></code></pre></td></tr></table></figure>\n\n<p>假设这些文件都是存在的，那么现在您的列表为 <code>file1</code>, <code>file2</code>,以及 <code>file3</code>。然后再运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> file4 file5<br></code></pre></td></tr></table></figure>\n\n<p>您的初始列表 <code>file1</code>, <code>file2</code>, <code>file3</code>将被覆盖为 <code>file4</code>, <code>file5</code>。如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code> ，而您想将 <code>file4</code>, <code>file5</code> 添加到初始列表中，请使用 <code>:arga</code>命令。运行</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:arga</span> file4 file5<br></code></pre></td></tr></table></figure>\n\n<p>现在您的列表为<code>file1</code>, <code>file2</code>, <code>file3</code>, <code>file4</code>, <code>file5</code>。</p>\n<p>如果您运行 <code>:arga</code> 时没有给任何参数，Vim会添加当前buffer到参数列表中。例如，如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code>，而您当前buffer是 <code>file5</code>，运行 <code>:arga</code> 将添加 <code>file5</code> 到您的列表中。</p>\n<p>在前面的命令（<code>:argdo %s/donut/pancake/g</code>）中您已经看到过了，当您创建好列表后就可以向它传递任意命令行命令。其他的一些示例：</p>\n<ul>\n<li>删除参数列表所有文件内包含 “dessert” 的行, 运行 <code>:argdo g/dessert/d</code>.</li>\n<li>在参数列表每个文件中执行宏a(假设您已经在a中录好了一个宏)，运行 <code>:argdo norm @a</code>.</li>\n<li>向参数列表所有文件的第一行插入”hello “+文件名 ，运行 <code>:argdo 0put=&#39;hello &#39; . @%</code>（译者注：在英文版中，原作者给出的命令是 <code>:argdo 0put=&#39;hello &#39; .. @:</code>，貌似这个命令有问题）。</li>\n</ul>\n<p>把所有工作完成后，别忘了使用 <code>:update</code> 命令保存(<code>:update</code>只会保存当前buffer，要保存列表所有文件的修改，请用 <code>:argdo update</code>)。</p>\n<p>有时候您仅仅需要在参数列表的前n个文件执行某条命令。如果是这种情况，只需要向 <code>argdo</code> 命令传递一个地址就可以了。比如，要在列表的前3个文件执行替换命令，运行：<code>:1,3argdo %s/donut/pancake/g</code>。</p>\n<h2 id=\"缓冲区列表\"><a href=\"#缓冲区列表\" class=\"headerlink\" title=\"缓冲区列表\"></a>缓冲区列表</h2><p>因为每次您创建新文件或打开文件时，Vim将它保存在一个buffer中（除非您显式地删除它），所以当您编辑新文件时，缓冲区列表就有组织地被创建了。如果您已经打开了3个文件：<code>file1.rb file2.rb file3.rb</code>，您的缓冲区列表就已经有了3个元素。运行 <code>:buffers</code>（或者<code>:ls</code>、或<code>:files</code>）可以显示缓冲区列表。要想向前或向后遍历缓冲区列表，可以使用 <code>:bnext</code> <code>:bprev</code>。要想跳至列表中第一个或最后一个buffer，可使用 <code>:bfirst</code> 和 <code>:blast</code>。</p>\n<p>另外，这里有一个和本章内容不相关，但是很酷的缓冲区技巧：如果您的缓冲区有大量的文件，您可以使用 <code>:ball</code> 显示所有缓冲区。<code>:ball</code> 命令默认使用水平分割窗口进行显示，如果想使用垂直分割的窗口显示，运行：<code>:vertical ball</code></p>\n<p>回到本章主题。在缓冲区列表中执行某个操作的方法与参数列表操作非常相似。当您创建好缓冲区列表后，您只需要在您想执行的命令前用 <code>:bufdo</code> 代替 <code>:argdo</code>就可以了。例如，如果您想将缓冲区列表内每个文件中所有的 “donut” 替换为 “pancake”并保存修改，可以运行：<code>:bufdo %s/donut/pancake/g | update</code>。</p>\n<h2 id=\"窗口列表和选项卡（Tab）列表\"><a href=\"#窗口列表和选项卡（Tab）列表\" class=\"headerlink\" title=\"窗口列表和选项卡（Tab）列表\"></a>窗口列表和选项卡（Tab）列表</h2><p>窗口列表、选项卡列表的操作和参数列表、缓冲区列表同样非常相似。唯一的区别在于它们的内容和语法。</p>\n<p>窗口操作作用在每一个打开的窗口上，使用的命令是 <code>:windo</code>。选项卡（Tab）操作作用在每一个打开的选项卡上，使用的命令是 <code>:tabdo</code>。可以查询 <code>:h list-repeat</code>, <code>:h :windo</code>和<code>:h :tabdo</code>，了解更多信息。</p>\n<p>比如，如果您打开了4个窗口（您可以使用 <code>Ctrl-w v</code>打开一个垂直分割的窗口，也可以使用 <code>Ctrl-w s</code>打开一个水平分割的窗口），然后您运行 <code>:windo 0put = &#39;hello&#39; . @%</code>，Vim将在所有打开的窗口的第一行输出 “hello”+文件名。</p>\n<h2 id=\"快速修复列表\"><a href=\"#快速修复列表\" class=\"headerlink\" title=\"快速修复列表\"></a>快速修复列表</h2><p>在前面的章节中（第3章和第19章），我曾提到过快速修复（quickfix）。快速修复有很多作用，很多流行的插件都在使用快速修复提供的功能，因此值得花时间去理解它。</p>\n<p>如果您是Vim新手，快速修复对于您可能是个新概念。回想以前您执行代码编译的时候，编译期间您可能遇到过错误，而这些错误都显示在一个特殊的窗口。这就是快速修复(quickfix)的由来。当您编译您的代码的时候，Vim会在快速修复窗口显示错误信息，您可以稍后去解决。许多现代语言已经不再需要进行显式地编译，但快速修复并没有被淘汰。现在，人们使用快速修复来做各种各样的事，比如显示虚拟终端的输入、存储搜索结果等。我们重点研究后者，存储搜索结果。</p>\n<p>除编译命令外，某些特定的Vim命令也依赖快速修复接口。其中一种就是搜索命令，其使用过程中大量的使用了快速修复窗口，<code>:vimgrep</code> 和 <code>:grep</code> 都默认使用快速修复。</p>\n<p>比如，如果您需要在所有的Javascript文件中递归地搜索 “donut”，您可以运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:vimgrep <span class=\"hljs-regexp\">/donut/</span> **/*.js<br></code></pre></td></tr></table></figure>\n\n<p>“donut”的搜索结果存储在快速修复窗口中。要查看快速修复窗口的结果，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:copen</span><br></code></pre></td></tr></table></figure>\n\n<p>要关闭快速修复窗口，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:cclose</span><br></code></pre></td></tr></table></figure>\n\n<p>在快速修复列表中向前或向后遍历，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:cnext</span><br><span class=\"hljs-symbol\">:cprev</span><br></code></pre></td></tr></table></figure>\n\n<p>跳至第一个或最后一个匹配的元素，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:cfirst</span><br><span class=\"hljs-symbol\">:clast</span><br></code></pre></td></tr></table></figure>\n\n<p>在前面我提到过，有两种快速修复命令：<code>cdo</code> 和 <code>cfdo</code> 。它们有什么区别？<code>cdo</code> 在修复列表中的每一个元素上执行命令，而 <code>cfdo</code> 在修复列表中的每一个文件上执行命令。</p>\n<p>让我讲清楚一点，假设运行完上面的 <code>vimgrep</code> 命令后，您找到以下结果：</p>\n<ul>\n<li>1 result in <code>file1.js</code></li>\n<li>10 results in <code>file2.js</code></li>\n</ul>\n<p>如果您运行 <code>:cfdo %s/donut/pancake/g</code>, 这个命令将会在 <code>file1.js</code> 和 <code>file2.js</code> 上分别有效地运行一次<code>%s/donut/pancake/g</code>. 它执行的次数与 <em>匹配结果中文件的数量</em> 相同。因为搜索结果中有2个文件，因此Vim在 <code>file1.js</code> 上运行一次替换命令，在 <code>file2.js</code> 上再运行一次替换命令。 尽管在第二个文件中有10个搜索结果，但 <code>cfdo</code> 只关注快速修复列表中有多少个文件。</p>\n<p>而如果您运行 <code>:cdo %s/donut/pancake/g</code> ，这个命令将会在 <code>file1.js</code> 上有效运行一次，然后在 <code>file2.js</code> 上运行10次。它执行的次数与 <em>快速修复列表中元素的数量</em> 相同。因为在 <code>file1.js</code> 上找到1个匹配结果，在 <code>file2.js</code> 上找到10个匹配结果，因此它执行的总次数是11次。</p>\n<p>由于您要在列表中运行的命令是 <code>%s/donut/pancake/g</code> ，所以使用 <code>cfdo</code>命令是比较合理的。而使用 <code>cdo</code> 是不合理的，因为它将在 <code>file2.js</code> 中运行10次 <code>%s/donut/pancake/g</code>命令（<code>%s</code>已经是一个针对整个文件的替换操作）。一个文件运行一次 <code>%s</code> 就足够了。如果您使用 <code>cdo</code>，则传给它的命令应当改为 <code>s/donut/pancake/g</code> 才是合理的。</p>\n<p>那到底什么时候该用 <code>cfdo</code>？什么时候该用 <code>cdo</code>？    这应当想一想您要传递的命令的作用域，要看命令作用域是整个文件（比如 <code>:%s</code> 或 <code>:g</code>）？还是某一行（比如 <code>:s</code> 或 <code>:!</code>）？</p>\n<h2 id=\"位置列表\"><a href=\"#位置列表\" class=\"headerlink\" title=\"位置列表\"></a>位置列表</h2><p>位置列表在某种意义上和快速修复列表很像。Vim也使用一个特殊的窗口来显示位置列表的信息。区别在于：您任何时候都只能有1个快速修复列表，而位置列表则是，有多少个窗口就可以有多少个位置列表。</p>\n<p>假设您打开了两个窗口，其中一个窗口显示 <code>food.txt</code> ，而另一个显示 <code>drinks.txt</code>。在 <code>food.txt</code>里面，运行一个位置列表搜索命令 <code>:lvimgrep</code> （<code>:vimgrep</code>命令关于位置列表的一个变体）。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:lvim <span class=\"hljs-regexp\">/bagel/</span> **/*.md<br></code></pre></td></tr></table></figure>\n\n<p>Vim将为 <code>food.txt</code>所在 <em>窗口</em>创建一个位置列表，用于存储所有的bagel搜索结果。用 <code>:lopen</code>命令可以查看位置列表。现在转到另一个窗口 <code>drinks.txt</code>，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:lvimgrep <span class=\"hljs-regexp\">/milk/</span> **/*.md<br></code></pre></td></tr></table></figure>\n\n<p>Vim将为 <code>drinks.txt</code>所在 <em>窗口</em>再创建一个 <em>单独</em>的位置列表，用于存储所有关于milk的搜索结果。</p>\n<p>对于每个不同的窗口中您运行的位置命令，Vim都会单独创建一个位置列表。如果您有10个不同的窗口，您就可以有最多10个不同的位置列表。对比前面介绍的快速修复列表，快速修复列表任何时候都只能有1个。就算您有10个不同的窗口，您也只能有1个快速修复列表。</p>\n<p>大多数位置列表命令都和快速修复列表命令相似，唯一不同就是位置列表命令有一个 <code>l-</code>前缀，比如： <code>:lvimgrep</code>, <code>:lgrep</code>, 还有 <code>:lmake</code>。在快速修复列表命令中与之对应的是: <code>:vimgrep</code>, <code>:grep</code>, 以及 <code>:make</code>。操作位置列表窗口的方式和快速修复窗口也很相似：<code>:lopen</code>, <code>:lclose</code>, <code>:lfirst</code>, <code>:llast</code>, <code>:lnext</code>, 还有<code>:lprev</code>，与之对应快速修复版本是：<code>:copen</code>, <code>:cclose</code>, <code>:cfirst</code>, <code>:clast</code>, <code>:cnext</code>, and <code>:cprev</code>。</p>\n<p>两个位置列表参数的多文件操作命令也和快速修复列表的多文件操作命令也很类似：<code>:ldo</code> 和 <code>:lfdo</code>。<code>:ldo</code> 对位置列表中每一个元素执行命令，而 <code>:lfdo</code> 对位置列表中每一个文件执行命令。可以查阅 <code>:h location-list</code>了解更多信息。</p>\n<h2 id=\"在Vim中运行多文件操作命令\"><a href=\"#在Vim中运行多文件操作命令\" class=\"headerlink\" title=\"在Vim中运行多文件操作命令\"></a>在Vim中运行多文件操作命令</h2><p>在编辑工作中，知道如何进行多文件操作是一个非常有用的技能。当您需要在多个文件中改变一个变量名字的时候，您肯定想一个操作就全部搞定。Vim有8种不同的方法支持你完成这个事。</p>\n<p>事实上，您可能并不会用到所有8种方法。您会慢慢倾向于其中1中或2种。当您刚开始时，选择其中1个（我个人建议从参数列表开始 <code>:argdo</code>）并掌握它。当您习惯了其中1个，然后再学下一个。您将会发现，学习第二个、第三个、第四个时要容易多了。记得要创造性的使用，即将它和其他各种不同命令组合起来使用。坚持练习直到您可以不经思考地高效的使用它。让它成为您的肌肉记忆。</p>\n<p>就像前面已经说过的，您现在已经掌握了Vim的编辑功能。恭喜您！</p>\n","site":{"data":{}},"wordcount":5243,"excerpt":"","more":"<h1 id=\"第21章-多文件操作\"><a href=\"#第21章-多文件操作\" class=\"headerlink\" title=\"第21章 多文件操作\"></a>第21章 多文件操作</h1><p>多文件编辑更新是一个值得掌握、非常有用的编辑工具。前面您已经学会了如何使用 <code>cfdo</code> 命令在多个文本中进行更新。本章，您将学到如何在Vim中进行多文件编辑的更多不同方法。</p>\n<h2 id=\"在多个文件中执行命令的几种方法\"><a href=\"#在多个文件中执行命令的几种方法\" class=\"headerlink\" title=\"在多个文件中执行命令的几种方法\"></a>在多个文件中执行命令的几种方法</h2><p>要在多个文件中执行命令，Vim有8种方法：</p>\n<ul>\n<li>参数列表 (<code>argdo</code>)</li>\n<li>缓冲区列表 (<code>bufdo</code>)</li>\n<li>窗口列表 (<code>windo</code>)</li>\n<li>tab 列表(<code>tabdo</code>)</li>\n<li>快速修复列表 (<code>cdo</code>)</li>\n<li>文件方式的快速修复列表 (<code>cfdo</code>)</li>\n<li>位置列表 (<code>ldo</code>)</li>\n<li>文件方式的位置列表 (<code>lfdo</code>)</li>\n</ul>\n<p>实际上，大部分时间您可能只会用到1种或2种（就我个人而言，我使用 <code>cdo</code> 和 <code>argdo</code>比其他的多得多），但了解所有可行方法还是很有用的，这样您就可以选择一个最符合您个人编辑风格的方法。</p>\n<p>学习所有8个命令可能听起来让人有点打退堂鼓。但实际上，这些命令工作方式很相似。学习了其中一个后，再学习剩余的将容易的多。它们的运行方式都大体相同：分别创建一个列表(列表中的元素根据命令有所不同)，然后向列表传递一个您想执行的命令。</p>\n<h2 id=\"参数列表\"><a href=\"#参数列表\" class=\"headerlink\" title=\"参数列表\"></a>参数列表</h2><p>参数列表是最基础的列表。它创建一个文件列表。要想为 file1, file2, file3创建文件列表，您可以执行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> file1 file2 file3<br></code></pre></td></tr></table></figure>\n\n<p>您也可以传递一个通配符（<code>*</code>），所以如果您想为当前目录下所有的 <code>.js</code> 文件创建一个列表，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> *.js<br></code></pre></td></tr></table></figure>\n\n<p>如果您想为当前目录下所有以 “a” 开头的Javascript文件创建列表，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> a*.js<br></code></pre></td></tr></table></figure>\n\n<p>（<code>*</code>）通配符匹配当前目录下的1个或多个任意文件名中的字符。但如果您想在某个目录下进行递归搜索怎么办呢？您可以使用双通配符（<code>**</code>）。要得到您当前位置下所有子目录中的Javascript文件，运行：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">:args <span class=\"hljs-strong\">**/*</span>.js<br></code></pre></td></tr></table></figure>\n\n<p>您运行了 <code>args</code> 命令后，您的当前buffer将会切换到列表中的第一个文件。运行 <code>:args</code>可以查看您刚才创建的文件列表。当您创建好了您的列表后，您就可以遍历它们了。<code>:first</code> 将让您跳至列表中的第一个文件。<code>:last</code> 将跳到最后一个文件。运行<code>:next</code>可以在列表中一次向前移动一个文件。运行 <code>:prev</code>可以在列表中一次向后移动一个文件。运行<code>:wnext</code> 和 <code>:wprev</code>命令，在向前&#x2F;向后移动文件的同时还会保存修改。查阅 <code>: arglist</code> 了解更多导航命令。</p>\n<p>参数列表在定位某个特定类型的文件或少量文件时特别有用。假如您需要将所有 <code>yml</code> 文件中的<code>donut</code> 更新为 <code>pancake</code>。运行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">args</span> **/*.yml<br>:<span class=\"hljs-keyword\">argdo</span> %s/donut/pancake/g | <span class=\"hljs-keyword\">update</span><br><br></code></pre></td></tr></table></figure>\n<p>注意如果您再次执行 <code>args</code> 命令，它将覆盖先前的列表。比如，如果您先前运行了：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> file1 file2 file3<br></code></pre></td></tr></table></figure>\n\n<p>假设这些文件都是存在的，那么现在您的列表为 <code>file1</code>, <code>file2</code>,以及 <code>file3</code>。然后再运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:args</span> file4 file5<br></code></pre></td></tr></table></figure>\n\n<p>您的初始列表 <code>file1</code>, <code>file2</code>, <code>file3</code>将被覆盖为 <code>file4</code>, <code>file5</code>。如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code> ，而您想将 <code>file4</code>, <code>file5</code> 添加到初始列表中，请使用 <code>:arga</code>命令。运行</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:arga</span> file4 file5<br></code></pre></td></tr></table></figure>\n\n<p>现在您的列表为<code>file1</code>, <code>file2</code>, <code>file3</code>, <code>file4</code>, <code>file5</code>。</p>\n<p>如果您运行 <code>:arga</code> 时没有给任何参数，Vim会添加当前buffer到参数列表中。例如，如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code>，而您当前buffer是 <code>file5</code>，运行 <code>:arga</code> 将添加 <code>file5</code> 到您的列表中。</p>\n<p>在前面的命令（<code>:argdo %s/donut/pancake/g</code>）中您已经看到过了，当您创建好列表后就可以向它传递任意命令行命令。其他的一些示例：</p>\n<ul>\n<li>删除参数列表所有文件内包含 “dessert” 的行, 运行 <code>:argdo g/dessert/d</code>.</li>\n<li>在参数列表每个文件中执行宏a(假设您已经在a中录好了一个宏)，运行 <code>:argdo norm @a</code>.</li>\n<li>向参数列表所有文件的第一行插入”hello “+文件名 ，运行 <code>:argdo 0put=&#39;hello &#39; . @%</code>（译者注：在英文版中，原作者给出的命令是 <code>:argdo 0put=&#39;hello &#39; .. @:</code>，貌似这个命令有问题）。</li>\n</ul>\n<p>把所有工作完成后，别忘了使用 <code>:update</code> 命令保存(<code>:update</code>只会保存当前buffer，要保存列表所有文件的修改，请用 <code>:argdo update</code>)。</p>\n<p>有时候您仅仅需要在参数列表的前n个文件执行某条命令。如果是这种情况，只需要向 <code>argdo</code> 命令传递一个地址就可以了。比如，要在列表的前3个文件执行替换命令，运行：<code>:1,3argdo %s/donut/pancake/g</code>。</p>\n<h2 id=\"缓冲区列表\"><a href=\"#缓冲区列表\" class=\"headerlink\" title=\"缓冲区列表\"></a>缓冲区列表</h2><p>因为每次您创建新文件或打开文件时，Vim将它保存在一个buffer中（除非您显式地删除它），所以当您编辑新文件时，缓冲区列表就有组织地被创建了。如果您已经打开了3个文件：<code>file1.rb file2.rb file3.rb</code>，您的缓冲区列表就已经有了3个元素。运行 <code>:buffers</code>（或者<code>:ls</code>、或<code>:files</code>）可以显示缓冲区列表。要想向前或向后遍历缓冲区列表，可以使用 <code>:bnext</code> <code>:bprev</code>。要想跳至列表中第一个或最后一个buffer，可使用 <code>:bfirst</code> 和 <code>:blast</code>。</p>\n<p>另外，这里有一个和本章内容不相关，但是很酷的缓冲区技巧：如果您的缓冲区有大量的文件，您可以使用 <code>:ball</code> 显示所有缓冲区。<code>:ball</code> 命令默认使用水平分割窗口进行显示，如果想使用垂直分割的窗口显示，运行：<code>:vertical ball</code></p>\n<p>回到本章主题。在缓冲区列表中执行某个操作的方法与参数列表操作非常相似。当您创建好缓冲区列表后，您只需要在您想执行的命令前用 <code>:bufdo</code> 代替 <code>:argdo</code>就可以了。例如，如果您想将缓冲区列表内每个文件中所有的 “donut” 替换为 “pancake”并保存修改，可以运行：<code>:bufdo %s/donut/pancake/g | update</code>。</p>\n<h2 id=\"窗口列表和选项卡（Tab）列表\"><a href=\"#窗口列表和选项卡（Tab）列表\" class=\"headerlink\" title=\"窗口列表和选项卡（Tab）列表\"></a>窗口列表和选项卡（Tab）列表</h2><p>窗口列表、选项卡列表的操作和参数列表、缓冲区列表同样非常相似。唯一的区别在于它们的内容和语法。</p>\n<p>窗口操作作用在每一个打开的窗口上，使用的命令是 <code>:windo</code>。选项卡（Tab）操作作用在每一个打开的选项卡上，使用的命令是 <code>:tabdo</code>。可以查询 <code>:h list-repeat</code>, <code>:h :windo</code>和<code>:h :tabdo</code>，了解更多信息。</p>\n<p>比如，如果您打开了4个窗口（您可以使用 <code>Ctrl-w v</code>打开一个垂直分割的窗口，也可以使用 <code>Ctrl-w s</code>打开一个水平分割的窗口），然后您运行 <code>:windo 0put = &#39;hello&#39; . @%</code>，Vim将在所有打开的窗口的第一行输出 “hello”+文件名。</p>\n<h2 id=\"快速修复列表\"><a href=\"#快速修复列表\" class=\"headerlink\" title=\"快速修复列表\"></a>快速修复列表</h2><p>在前面的章节中（第3章和第19章），我曾提到过快速修复（quickfix）。快速修复有很多作用，很多流行的插件都在使用快速修复提供的功能，因此值得花时间去理解它。</p>\n<p>如果您是Vim新手，快速修复对于您可能是个新概念。回想以前您执行代码编译的时候，编译期间您可能遇到过错误，而这些错误都显示在一个特殊的窗口。这就是快速修复(quickfix)的由来。当您编译您的代码的时候，Vim会在快速修复窗口显示错误信息，您可以稍后去解决。许多现代语言已经不再需要进行显式地编译，但快速修复并没有被淘汰。现在，人们使用快速修复来做各种各样的事，比如显示虚拟终端的输入、存储搜索结果等。我们重点研究后者，存储搜索结果。</p>\n<p>除编译命令外，某些特定的Vim命令也依赖快速修复接口。其中一种就是搜索命令，其使用过程中大量的使用了快速修复窗口，<code>:vimgrep</code> 和 <code>:grep</code> 都默认使用快速修复。</p>\n<p>比如，如果您需要在所有的Javascript文件中递归地搜索 “donut”，您可以运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:vimgrep <span class=\"hljs-regexp\">/donut/</span> **/*.js<br></code></pre></td></tr></table></figure>\n\n<p>“donut”的搜索结果存储在快速修复窗口中。要查看快速修复窗口的结果，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:copen</span><br></code></pre></td></tr></table></figure>\n\n<p>要关闭快速修复窗口，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:cclose</span><br></code></pre></td></tr></table></figure>\n\n<p>在快速修复列表中向前或向后遍历，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:cnext</span><br><span class=\"hljs-symbol\">:cprev</span><br></code></pre></td></tr></table></figure>\n\n<p>跳至第一个或最后一个匹配的元素，运行：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\"><span class=\"hljs-symbol\">:cfirst</span><br><span class=\"hljs-symbol\">:clast</span><br></code></pre></td></tr></table></figure>\n\n<p>在前面我提到过，有两种快速修复命令：<code>cdo</code> 和 <code>cfdo</code> 。它们有什么区别？<code>cdo</code> 在修复列表中的每一个元素上执行命令，而 <code>cfdo</code> 在修复列表中的每一个文件上执行命令。</p>\n<p>让我讲清楚一点，假设运行完上面的 <code>vimgrep</code> 命令后，您找到以下结果：</p>\n<ul>\n<li>1 result in <code>file1.js</code></li>\n<li>10 results in <code>file2.js</code></li>\n</ul>\n<p>如果您运行 <code>:cfdo %s/donut/pancake/g</code>, 这个命令将会在 <code>file1.js</code> 和 <code>file2.js</code> 上分别有效地运行一次<code>%s/donut/pancake/g</code>. 它执行的次数与 <em>匹配结果中文件的数量</em> 相同。因为搜索结果中有2个文件，因此Vim在 <code>file1.js</code> 上运行一次替换命令，在 <code>file2.js</code> 上再运行一次替换命令。 尽管在第二个文件中有10个搜索结果，但 <code>cfdo</code> 只关注快速修复列表中有多少个文件。</p>\n<p>而如果您运行 <code>:cdo %s/donut/pancake/g</code> ，这个命令将会在 <code>file1.js</code> 上有效运行一次，然后在 <code>file2.js</code> 上运行10次。它执行的次数与 <em>快速修复列表中元素的数量</em> 相同。因为在 <code>file1.js</code> 上找到1个匹配结果，在 <code>file2.js</code> 上找到10个匹配结果，因此它执行的总次数是11次。</p>\n<p>由于您要在列表中运行的命令是 <code>%s/donut/pancake/g</code> ，所以使用 <code>cfdo</code>命令是比较合理的。而使用 <code>cdo</code> 是不合理的，因为它将在 <code>file2.js</code> 中运行10次 <code>%s/donut/pancake/g</code>命令（<code>%s</code>已经是一个针对整个文件的替换操作）。一个文件运行一次 <code>%s</code> 就足够了。如果您使用 <code>cdo</code>，则传给它的命令应当改为 <code>s/donut/pancake/g</code> 才是合理的。</p>\n<p>那到底什么时候该用 <code>cfdo</code>？什么时候该用 <code>cdo</code>？    这应当想一想您要传递的命令的作用域，要看命令作用域是整个文件（比如 <code>:%s</code> 或 <code>:g</code>）？还是某一行（比如 <code>:s</code> 或 <code>:!</code>）？</p>\n<h2 id=\"位置列表\"><a href=\"#位置列表\" class=\"headerlink\" title=\"位置列表\"></a>位置列表</h2><p>位置列表在某种意义上和快速修复列表很像。Vim也使用一个特殊的窗口来显示位置列表的信息。区别在于：您任何时候都只能有1个快速修复列表，而位置列表则是，有多少个窗口就可以有多少个位置列表。</p>\n<p>假设您打开了两个窗口，其中一个窗口显示 <code>food.txt</code> ，而另一个显示 <code>drinks.txt</code>。在 <code>food.txt</code>里面，运行一个位置列表搜索命令 <code>:lvimgrep</code> （<code>:vimgrep</code>命令关于位置列表的一个变体）。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:lvim <span class=\"hljs-regexp\">/bagel/</span> **/*.md<br></code></pre></td></tr></table></figure>\n\n<p>Vim将为 <code>food.txt</code>所在 <em>窗口</em>创建一个位置列表，用于存储所有的bagel搜索结果。用 <code>:lopen</code>命令可以查看位置列表。现在转到另一个窗口 <code>drinks.txt</code>，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">:lvimgrep <span class=\"hljs-regexp\">/milk/</span> **/*.md<br></code></pre></td></tr></table></figure>\n\n<p>Vim将为 <code>drinks.txt</code>所在 <em>窗口</em>再创建一个 <em>单独</em>的位置列表，用于存储所有关于milk的搜索结果。</p>\n<p>对于每个不同的窗口中您运行的位置命令，Vim都会单独创建一个位置列表。如果您有10个不同的窗口，您就可以有最多10个不同的位置列表。对比前面介绍的快速修复列表，快速修复列表任何时候都只能有1个。就算您有10个不同的窗口，您也只能有1个快速修复列表。</p>\n<p>大多数位置列表命令都和快速修复列表命令相似，唯一不同就是位置列表命令有一个 <code>l-</code>前缀，比如： <code>:lvimgrep</code>, <code>:lgrep</code>, 还有 <code>:lmake</code>。在快速修复列表命令中与之对应的是: <code>:vimgrep</code>, <code>:grep</code>, 以及 <code>:make</code>。操作位置列表窗口的方式和快速修复窗口也很相似：<code>:lopen</code>, <code>:lclose</code>, <code>:lfirst</code>, <code>:llast</code>, <code>:lnext</code>, 还有<code>:lprev</code>，与之对应快速修复版本是：<code>:copen</code>, <code>:cclose</code>, <code>:cfirst</code>, <code>:clast</code>, <code>:cnext</code>, and <code>:cprev</code>。</p>\n<p>两个位置列表参数的多文件操作命令也和快速修复列表的多文件操作命令也很类似：<code>:ldo</code> 和 <code>:lfdo</code>。<code>:ldo</code> 对位置列表中每一个元素执行命令，而 <code>:lfdo</code> 对位置列表中每一个文件执行命令。可以查阅 <code>:h location-list</code>了解更多信息。</p>\n<h2 id=\"在Vim中运行多文件操作命令\"><a href=\"#在Vim中运行多文件操作命令\" class=\"headerlink\" title=\"在Vim中运行多文件操作命令\"></a>在Vim中运行多文件操作命令</h2><p>在编辑工作中，知道如何进行多文件操作是一个非常有用的技能。当您需要在多个文件中改变一个变量名字的时候，您肯定想一个操作就全部搞定。Vim有8种不同的方法支持你完成这个事。</p>\n<p>事实上，您可能并不会用到所有8种方法。您会慢慢倾向于其中1中或2种。当您刚开始时，选择其中1个（我个人建议从参数列表开始 <code>:argdo</code>）并掌握它。当您习惯了其中1个，然后再学下一个。您将会发现，学习第二个、第三个、第四个时要容易多了。记得要创造性的使用，即将它和其他各种不同命令组合起来使用。坚持练习直到您可以不经思考地高效的使用它。让它成为您的肌肉记忆。</p>\n<p>就像前面已经说过的，您现在已经掌握了Vim的编辑功能。恭喜您！</p>\n"},{"title":"VIM-Vimrc","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# Ch22. Vimrc\n\n在先前的章节中，您学习了如何使用Vim。在本章，您将学习如何组织和配置Vimrc。\n\n## Vim如何找到Vimrc\n\n对于Vimrc，常见的理解是在根目录下添加一个 `.vimrc` 点文件（根据您使用的操作系统，文件路径名可能不同）。\n\n实际上，Vim在多个地方查找vimrc文件。下面是Vim检查的路径：\n- `$VIMINIT`\n- `$HOME/.vimrc`\n- `$HOME/.vim/vimrc`\n- `$EXINIT`\n- `$HOME/.exrc`\n- `$VIMRUNTIME/default.vim`\n\n当您启动Vim时，它将在上面列出的6个位置按顺序检查vimrc文件，第一个被找到的vimrc文件将被加载，而其余的将被忽略。\n\n首先，Vim将查找环境变量 `$VIMINIT`。如果没有找到，Vim将检查 `$HOME/.vimrc`。如果还没找到，VIm就检查 `$HOME/.vim/vimrc`。如果Vim找到了vimrc文件，它就停止查找，并使用 `$HOME/.vim/vimrc`。\n\n关于第一个位置，`$VIMINIT` 是一个环境变量。默认情况下它是未定义的。如果您想将 `~/dotfiles/testvimrc` 作为 `$VIMINTI` 的值，您可以创建一个包含那个vimrc路径的环境变量。当您运行 `export VIMINIT='let $MYVIMRC=\"$HOME/dotfiles/testvimrc\" | source $MYVIMRC'`后，VIm将使用 `~/dotfiles/testvimrc` 作为您的vimrc文件。\n\n第二个位置，`$HOME/.vimrc` 是很多Vim用户习惯使用的路径。`$HOME` 大部分情况下是您的根目录（`~`）。如果您有一个 `~/.vimrc` 文件，Vim将使用它作为您的vimrc文件。\n\n第三个，`$HOME/.vim/vimrc`，位于 `~/.vim` 目录中。您可能已经有了一个 `~/.vim` 目录用于存放插件、自定义脚本、或视图文件。注意这里的vimrc文件名没有“点”（`$HOME/.vim/.vimrc` 不会被识别，但 `$HOME/.vim/vimrc`能被识别）。\n\n第四个，`$EXINIT` 工作方式与 `$VIMINIT` 类似。\n\n第五个，`$HOME/.exrc` 工作方式与 `$HOME/.vimrc` 类似。\n\n第六个，`$VIMRUNTIME/defaults.vim` 是Vim编译时自带的默认vimrc文件。在我的电脑中，我是使用Homebrew安装的Vim8.2，所以我的路径是（`/usr/local/share/vim/vim82`）。如果Vim在前5个位置都没有找到vimrc文件，它将使用这个Vim自带的vimrc文件。\n\n在本章剩余部分，我将假设vimrc使用的路径是 `~/.vimrc`。\n\n## 应该把什么放在Vimrc中？\n\n我刚开始配置Vimrc时，曾问过一个问题，“我究竟该把什么放在Vimrc文件中？”。\n\n答案是，“任何您想放的东西”。 直接复制粘贴别人的vimrc文件的确是一个诱惑，但您应当抵制这个诱惑。如果您仍然坚持使用别人的vimrc文件，确保您知道这个vimrc干了什么，为什么他/她要用这些设置？以及他/她如何使用这些设置？还有最重要的是，这个vimrc文件是否符合你的实际需要？别人使用并不代表您也要使用。\n\n## Vimrc基础内容\n\n简单地说，一个vimrc是以下内容的集合：\n- 插件\n- 设置\n- 自定义函数\n- 自定义命令\n- 键盘映射\n\n当然还有一些上面没有提到的内容，但总体说，已经涵盖了绝大部分使用场景。\n\n### 插件\n\n在前面的章节中，我曾提到很多不同的插件，比如[fzf.vim](https://github.com/junegunn/fzf.vim), [vim-mundo](https://github.com/simnalamburt/vim-mundo), 还有 [vim-fugitive](https://github.com/tpope/vim-fugitive).\n\n十年前，管理插件插件是一个噩梦。但随着很多现代插件管理器的开发，现在安装插件可以在几秒内完成。我现在正在使用[vim-plug](https://github.com/junegunn/vim-plug)作为我的插件管理器，所以我在本节中将使用它。相关概念和其他流行的插件管理器应该是类似的。我强烈建议您多试试几个插件管理器，比如：\n- [vundle.vim](https://github.com/VundleVim/Vundle.vim)\n- [vim-pathogen](https://github.com/tpope/vim-pathogen)\n- [dein.vim](https://github.com/Shougo/dein.vim)\n\n除了上面列出的，还有很多插件管理器，可以随便看看。要想安装 vim-plug，如果您使用的是Unix，运行：\n\n```\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n```\n\n要添加新的插件，将您的插件名(比如，`Plug 'github-username/repository-name'`) 放置在 `call plug#begin()` 和 `call plug#end()` 之间的行中. 所以，如果您想安装 `emmet-vim` 和 `nerdtree`，将下面的片段放到您的vimrc中：\n\n```\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\n```\n\n然后保存修改，加载当前vimrc (`:source %`), 然后运行 `:PlugInstall` 安装插件。\n\n如果以后您想删除不使用的插件，您只需将插件名从 `call` 代码块之间移除，保存并加载，然后运行 `:PlugClean` 命令将它从机器上删除。\n\nVim 8 有自己的内置包管理器。您可以查阅 `:h packages` 了解更多信息。在后面一章中，我将向您展示如何使用它。\n\n### 设置\n\n在任意一个vimrc文件中都可以看到大量的 `set` 选项。 如果您在命令行模式中运行 set 命令，它只是暂时的。当您关闭Vim，设置就会丢失。比如，为了避免您每次运行Vim时都必须在命令行模式运行 `:set relativenumber number` 命令，您可以将这个命令添加在vimrc中：\n\n```\nset relativenumber number\n```\n\n有一些设置需要您赋予一个值，比如 `set tabstop=2`。想了解一个设置可以接收什么类型的值，可以查看帮助页。\n\n您也可以使用 `let` 来代替 `set`（确保在选项前添加一个 `&`号）。使用 `let` ，您可以使用表达式进行赋值。比如，要想仅当某个路径存在时，才将该路径赋予 `'dictionary'` 选项：\n\n```\nlet s:english_dict = \"/usr/share/dict/words\"\n\nif filereadable(s:english_dict)\n  let &dictionary=s:english_dict\nendif\n```\n\n在后面的章节中您将了解关于Vimscript赋值和条件的知识。\n\n要查看Vim中所有可用的选项，查阅 `:h E355`。\n\n### 自定义函数\n\nVimrc是一个很好的用来放置自定义函数的地方。在后面的章节中您将学习如何写您自己的Vimscript函数。\n\n### 自定义命令\n\n您可以使用 `command` 创建一个自定义命令行命令。\n\n比如，创建一个用于显示今天日期的基本命令 `GimmeDate`：\n\n```\n:command! GimmeDate echo call(\"strftime\", [\"%F\"])\n```\n\n当您运行 `:GimmeDate` 时，Vim将显示一个类似 \"2021-01-1\"的日期。\n\n要创建一个可以接收输入的基本命令，您可以使用 `<args>` 。如果您想向 `GimmeDate` 传递一个时间/日期格式参数：\n\n```\n:command! GimmeDate echo call(\"strftime\", [<args>])\n\n:GimmeDate \"%F\"\n\" 2020-01-01\n\n:GimmeDate \"%H:%M\"\n\" 11:30\n```\n\n如果您想限定参数的数目，您可以使用 `-nargs` 标志。`-nargs=0` 表示没有参数，`-nargs=1` 表示传递1个参数，`-nargs=+` 表示至少1个参数，`-nargs=*` 表示传递任意数量的参数，`-nargs=?` 表示传递0个或1个参数。如果您想传递n个参数，使用 `-nargs=n`（这里 `n` 是一个任意整数）。\n\n`<args>` 有两个变体：`<f-args>` 和 `<q-args>` 。前者用来向Vimscript函数传递参数，后者用来将用户输入自动转换为字符串。\n\n使用 `args`:\n\n```\n:command! -nargs=1 Hello echo \"Hello \" . <args>\n:Hello \"Iggy\"\n\" returns 'Hello Iggy'\n\n:Hello Iggy\n\" Undefined variable error\n```\n\n使用 `q-args`:\n\n```\n:command! -nargs=1 Hello echo \"Hello \" . <q-args>\n:Hello Iggy\n\" returns 'Hello Iggy'\n```\n\n使用 `f-args`:\n\n```\n:function! PrintHello(person1, person2)\n:  echo \"Hello \" . a:person1 . \" and \" . a:person2\n:endfunction\n\n:command! -nargs=* Hello call PrintHello(<f-args>)\n\n:Hello Iggy1 Iggy2\n\" returns \"Hello Iggy1 and Iggy2\"\n```\n\n当您学了关于Vimscript函数的章节后，上面的函数将更有意义。\n\n查阅 `:h command` 和 `:args` 了解更多关于command和args的信息。\n\n### 键盘映射\n\n如果您发现您重复地执行一些相同的复杂操作，那么为这些复杂操作建立一个键盘映射将会很有用：\n\n比如，在我的vimrc文件中有2个键盘映射：\n\n```\nnnoremap <silent> <C-f> :GFiles<CR>\n\nnnoremap <Leader>tn :call ToggleNumber()<CR>\n```\n\n在第一个中，我将 `Ctrl-F` 映射到 [fzf.vim](https://github.com/junegunn/fzf.vim) 插件的 `:Gfiles` 命令(快速搜索Git文件)上。在第二个中，我将 `<leader>tn` 映射到调用一个自定义函数 `ToggleNumber` （切换 `norelativenumber` 和 `relativenumber` 选项）。`Ctrl-f` 映射覆盖了Vim的原生的页面滚动。如果发生冲突，您的映射将会覆盖Vim的设置。因为从几乎从来不用Vim原生的页面滚动功能，所以我认为可以安全地覆盖它。\n\n另外，在 `<Leader>tn` 中的 \"leader\" 键到底是什么?\n\nVim有一个leader键用来辅助键盘映射。比如，我将 `<leader>tn` 映射为运行 `ToggleNumber()` 函数。如果没有leader键，我可能会用 `tn`，但Vim中的 `t` 已经用做其他功能（\"till\"搜索导航命令）了。有了leader键，我现在先按定义好的leader键作为开头，然后按 `tn`，而不用干扰已经存在的命令。您可以设置leader键作为您映射的连续按键的第一个按键。默认Vim使用反斜杠作为leader键（所以 `<Leader>tn` 会变成 \"反斜杠-t-n\"）。\n\n我个人喜欢使用空格 `<Space>` 作为leader键，代替默认的反斜杠。要想改变您的leader键，将下面的文本添加到您的vimrc中：\n\n```\nlet mapleader = \"\\<space>\"\n```\n\n上面的 `nnoremap` 命令可以分解为三个部分：\n- `n` 表示普通模式。\n- `nore` 表示禁止递归。\n- `map` 是键盘映射命令。\n\n如果不想使用 `nnoremap`，您至少也得使用 `nmap` (`nmap <silent> <C-f> :Gfiles<CR>`)。但是，最好还是使用禁止递归的版本，这样是为了避免键盘映射时潜在的无限循环风险。\n\n如果您进行键盘映射时不使用禁止递归，下面例子演示了会发生什么。假设您想给 `B` 添加一个键盘映射，用来在一行的末尾添加一个分号，然后跳回前一个词组（回想一下，`B` 是Vim普通模式的一个导航命令，用来跳回前一个词组)。 \n\n```\nnmap B A;<esc>B\n```\n\n当您按下 `B` ...哦豁，Vim开始失控了，开始无止尽的添加`;`（用 `Ctrl-c`终止）。为什么会发生这样的情况？因为在键盘映射 `A;<esc>B`中，这个 `B`不再是Vim原生的导航命令，它已经被映射到您刚才创建的键盘映射中了。这是您实际上执行的操作序列：\n\n```\nA;<esc>A;<esc>A;<esc>A;esc>...\n```\n\n要解决这个问题，您需要指定键盘映射禁止递归：\n\n```\nnnoremap B A;<esc>B\n```\n\n现在再按一下 `B` 试试。这一次它成功地在行尾添加了一个 `;`，然后跳回到前一个词组。这个映射中的 `B` 就表示Vim原生的 `B`了。\n\nVim针对不同的模式有不同的键盘映射命令。如果您想创建一个插入模式下的键盘映射 `jk`，用来退出插入模式：\n\n```\ninoremap jk <esc>\n```\n\n其他模式的键盘映射命令有：`map`（普通、可视、选择、以及操作符等待模式）， `vmap`（可视、选择）， `smap`（选择）， `xmap`（可视）， `omap`（操作符等待模式）， `map!`（插入、命令行）， `lmap`（插入，命令行，Lang-arg模式）， `cmap`（命令行）， 还有`tmap`（终端任务）。在这里我不会详细的讲解它们，要了解更多信息，查阅 `:h map.txt`。\n\n创建最直观、最一致、最易于记忆的键盘映射。\n\n## 组织管理Vimrc\n\n一段时候键，您的vimrc文件就会变大且复杂得难以阅读。有两种方法让您的vimrc文件保持整洁：\n- 将您的vimrc文件划分为几个文件\n- 折叠您的vimrc文件\n\n### 划分您的vimrc\n\n您可以使用Vim的 `:source` 命令将您的vimrc文件划分为多个文件。这个命令可以根据给定的文件参数，读取文件中的命令行命令。\n\n让我们在 `~/.vim` 下创建一个子文件夹，取名为 `/settings`（`~/.vim/settings`）。名字可以取为任意您喜欢的名字。\n\n然后你在这个文件夹下创建4个文件：\n- 第三方插件 (`~/.vim/settings/plugins.vim`).\n- 通用设置 (`~/.vim/settings/configs.vim`).\n- 自定义函数 (`~/.vim/settings/functions.vim`).\n- 键盘映射 (`~/.vim/settings/mappings.vim`) .\n\n在 `~/.vimrc` 里面添加:\n\n```\nsource $HOME/.vim/settings/plugins.vim\nsource $HOME/.vim/settings/configs.vim\nsource $HOME/.vim/settings/functions.vim\nsource $HOME/.vim/settings/mappings.vim\n```\n\n在 `~/.vim/settings/plugins.vim` 里面:\n\n```\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\n```\n\n在 `~/.vim/settings/configs.vim` 里面:\n\n```\nset nocompatible\nset relativenumber\nset number\n```\n\n在 `~/.vim/settings/functions.vim` 里面:\n\n```\nfunction! ToggleNumber()\n  if(&relativenumber == 1)\n    set norelativenumber\n  else\n    set relativenumber\n  endif\nendfunc\n```\n\n在 `~/.vim/settings/mappings.vim` 里面:\n\n```\ninoremap jk <esc>\nnnoremap <silent> <C-f> :GFiles<CR>\nnnoremap <Leader>tn :call ToggleNumber()<CR>\n```\n\n这样您的vimrc文件依然能够正常工作，但现在它只有4行了。\n\n使用这样的设置，您可以轻易知道到哪去修改配置。如果您要添加一些键盘映射，就将它们添加在 `/mappings.vim` 文件中。以后，当您的vimrc变大时，您总是可以新建几个子文件来缩小它的大小。比如，如果您想为主题配色创建相关设置，您可以添加 `~/.vim/settings/themes.vim`。\n\n### 保持单独的一个Vimrc文件\n\n如果您倾向于保持一个单独的vimrc文件，以使它更加便于携带，您可以使用标志折叠让它保持有序。在vimrc文件的顶部添加一下内容：\n\n```\n\" setup folds {{{\naugroup filetype_vim\n  autocmd!\n  autocmd FileType vim setlocal foldmethod=marker\naugroup END\n\" }}}\n```\n\nVim能够检测当前buffer所属的文件类型 (`:set filetype?`). 如果发现属于 `vim` 类型，您可以使用标志折叠。回想一个标志折叠的用法，它使用 `{{{` 和 `}}}` 来指明折叠的开始和结束。\n\n添加 `{{{` 和 `}}}` 标志将您的vimrc文件其他部分折叠起来。(别忘了使用 `\"` 对标志进行注释):\n\n```\n\" setup folds {{{\naugroup filetype_vim\n  autocmd!\n  autocmd FileType vim setlocal foldmethod=marker\naugroup END\n\" }}}\n\n\" plugins {{{\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\n\" }}}\n\n\" configs {{{\nset nocompatible\nset relativenumber\nset number\n\" }}}\n\n\" functions {{{\nfunction! ToggleNumber()\n  if(&relativenumber == 1)\n    set norelativenumber\n  else\n    set relativenumber\n  endif\nendfunc\n\" }}}\n\n\" mappings {{{\ninoremap jk <esc>\nnnoremap <silent> <C-f> :GFiles<CR>\nnnoremap <Leader>tn :call ToggleNumber()<CR>\n\" }}}\n```\n\n您的vimrc文件将会看起来类似下面：\n\n```\n+-- 6 lines: setup folds -----\n\n+-- 6 lines: plugins ---------\n\n+-- 5 lines: configs ---------\n\n+-- 9 lines: functions -------\n\n+-- 5 lines: mappings --------\n```\n\n## 启动Vim时加载/不加载Vimrc和插件\n\n如果您要启动Vim时，既不加载Vimrc，也不加载插件，运行：\n\n```\nvim -u NONE\n```\n\n如果您要启动Vim时，不加载Vimrc，但加载插件，运行：\n\n```\nvim -u NORC\n```\n\n如果您要启动Vim时，加载Vimrc，但不加载插件，运行\n\n```\nvim --noplugin\n```\n\n如果您要Vim启动加载一个 *其他的* vimrc, 比如 `~/.vimrc-backup`, 运行:\n\n```\nvim -u ~/.vimrc-backup\n```\n\n## 聪明地配置Vimrc\n\nVimrc是定制Vim时的一个重要组件，学习构建您的Vimrc最好是首先阅读他人的vimrc文件，然后逐渐地建立自己的。最好的vimrc并不是谁谁谁使用的，而是最适合您的工作需要和编辑风格的。\n","source":"_posts/Vim/ch22_vimrc.md","raw":"---\ntitle: VIM-Vimrc\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# Ch22. Vimrc\n\n在先前的章节中，您学习了如何使用Vim。在本章，您将学习如何组织和配置Vimrc。\n\n## Vim如何找到Vimrc\n\n对于Vimrc，常见的理解是在根目录下添加一个 `.vimrc` 点文件（根据您使用的操作系统，文件路径名可能不同）。\n\n实际上，Vim在多个地方查找vimrc文件。下面是Vim检查的路径：\n- `$VIMINIT`\n- `$HOME/.vimrc`\n- `$HOME/.vim/vimrc`\n- `$EXINIT`\n- `$HOME/.exrc`\n- `$VIMRUNTIME/default.vim`\n\n当您启动Vim时，它将在上面列出的6个位置按顺序检查vimrc文件，第一个被找到的vimrc文件将被加载，而其余的将被忽略。\n\n首先，Vim将查找环境变量 `$VIMINIT`。如果没有找到，Vim将检查 `$HOME/.vimrc`。如果还没找到，VIm就检查 `$HOME/.vim/vimrc`。如果Vim找到了vimrc文件，它就停止查找，并使用 `$HOME/.vim/vimrc`。\n\n关于第一个位置，`$VIMINIT` 是一个环境变量。默认情况下它是未定义的。如果您想将 `~/dotfiles/testvimrc` 作为 `$VIMINTI` 的值，您可以创建一个包含那个vimrc路径的环境变量。当您运行 `export VIMINIT='let $MYVIMRC=\"$HOME/dotfiles/testvimrc\" | source $MYVIMRC'`后，VIm将使用 `~/dotfiles/testvimrc` 作为您的vimrc文件。\n\n第二个位置，`$HOME/.vimrc` 是很多Vim用户习惯使用的路径。`$HOME` 大部分情况下是您的根目录（`~`）。如果您有一个 `~/.vimrc` 文件，Vim将使用它作为您的vimrc文件。\n\n第三个，`$HOME/.vim/vimrc`，位于 `~/.vim` 目录中。您可能已经有了一个 `~/.vim` 目录用于存放插件、自定义脚本、或视图文件。注意这里的vimrc文件名没有“点”（`$HOME/.vim/.vimrc` 不会被识别，但 `$HOME/.vim/vimrc`能被识别）。\n\n第四个，`$EXINIT` 工作方式与 `$VIMINIT` 类似。\n\n第五个，`$HOME/.exrc` 工作方式与 `$HOME/.vimrc` 类似。\n\n第六个，`$VIMRUNTIME/defaults.vim` 是Vim编译时自带的默认vimrc文件。在我的电脑中，我是使用Homebrew安装的Vim8.2，所以我的路径是（`/usr/local/share/vim/vim82`）。如果Vim在前5个位置都没有找到vimrc文件，它将使用这个Vim自带的vimrc文件。\n\n在本章剩余部分，我将假设vimrc使用的路径是 `~/.vimrc`。\n\n## 应该把什么放在Vimrc中？\n\n我刚开始配置Vimrc时，曾问过一个问题，“我究竟该把什么放在Vimrc文件中？”。\n\n答案是，“任何您想放的东西”。 直接复制粘贴别人的vimrc文件的确是一个诱惑，但您应当抵制这个诱惑。如果您仍然坚持使用别人的vimrc文件，确保您知道这个vimrc干了什么，为什么他/她要用这些设置？以及他/她如何使用这些设置？还有最重要的是，这个vimrc文件是否符合你的实际需要？别人使用并不代表您也要使用。\n\n## Vimrc基础内容\n\n简单地说，一个vimrc是以下内容的集合：\n- 插件\n- 设置\n- 自定义函数\n- 自定义命令\n- 键盘映射\n\n当然还有一些上面没有提到的内容，但总体说，已经涵盖了绝大部分使用场景。\n\n### 插件\n\n在前面的章节中，我曾提到很多不同的插件，比如[fzf.vim](https://github.com/junegunn/fzf.vim), [vim-mundo](https://github.com/simnalamburt/vim-mundo), 还有 [vim-fugitive](https://github.com/tpope/vim-fugitive).\n\n十年前，管理插件插件是一个噩梦。但随着很多现代插件管理器的开发，现在安装插件可以在几秒内完成。我现在正在使用[vim-plug](https://github.com/junegunn/vim-plug)作为我的插件管理器，所以我在本节中将使用它。相关概念和其他流行的插件管理器应该是类似的。我强烈建议您多试试几个插件管理器，比如：\n- [vundle.vim](https://github.com/VundleVim/Vundle.vim)\n- [vim-pathogen](https://github.com/tpope/vim-pathogen)\n- [dein.vim](https://github.com/Shougo/dein.vim)\n\n除了上面列出的，还有很多插件管理器，可以随便看看。要想安装 vim-plug，如果您使用的是Unix，运行：\n\n```\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n```\n\n要添加新的插件，将您的插件名(比如，`Plug 'github-username/repository-name'`) 放置在 `call plug#begin()` 和 `call plug#end()` 之间的行中. 所以，如果您想安装 `emmet-vim` 和 `nerdtree`，将下面的片段放到您的vimrc中：\n\n```\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\n```\n\n然后保存修改，加载当前vimrc (`:source %`), 然后运行 `:PlugInstall` 安装插件。\n\n如果以后您想删除不使用的插件，您只需将插件名从 `call` 代码块之间移除，保存并加载，然后运行 `:PlugClean` 命令将它从机器上删除。\n\nVim 8 有自己的内置包管理器。您可以查阅 `:h packages` 了解更多信息。在后面一章中，我将向您展示如何使用它。\n\n### 设置\n\n在任意一个vimrc文件中都可以看到大量的 `set` 选项。 如果您在命令行模式中运行 set 命令，它只是暂时的。当您关闭Vim，设置就会丢失。比如，为了避免您每次运行Vim时都必须在命令行模式运行 `:set relativenumber number` 命令，您可以将这个命令添加在vimrc中：\n\n```\nset relativenumber number\n```\n\n有一些设置需要您赋予一个值，比如 `set tabstop=2`。想了解一个设置可以接收什么类型的值，可以查看帮助页。\n\n您也可以使用 `let` 来代替 `set`（确保在选项前添加一个 `&`号）。使用 `let` ，您可以使用表达式进行赋值。比如，要想仅当某个路径存在时，才将该路径赋予 `'dictionary'` 选项：\n\n```\nlet s:english_dict = \"/usr/share/dict/words\"\n\nif filereadable(s:english_dict)\n  let &dictionary=s:english_dict\nendif\n```\n\n在后面的章节中您将了解关于Vimscript赋值和条件的知识。\n\n要查看Vim中所有可用的选项，查阅 `:h E355`。\n\n### 自定义函数\n\nVimrc是一个很好的用来放置自定义函数的地方。在后面的章节中您将学习如何写您自己的Vimscript函数。\n\n### 自定义命令\n\n您可以使用 `command` 创建一个自定义命令行命令。\n\n比如，创建一个用于显示今天日期的基本命令 `GimmeDate`：\n\n```\n:command! GimmeDate echo call(\"strftime\", [\"%F\"])\n```\n\n当您运行 `:GimmeDate` 时，Vim将显示一个类似 \"2021-01-1\"的日期。\n\n要创建一个可以接收输入的基本命令，您可以使用 `<args>` 。如果您想向 `GimmeDate` 传递一个时间/日期格式参数：\n\n```\n:command! GimmeDate echo call(\"strftime\", [<args>])\n\n:GimmeDate \"%F\"\n\" 2020-01-01\n\n:GimmeDate \"%H:%M\"\n\" 11:30\n```\n\n如果您想限定参数的数目，您可以使用 `-nargs` 标志。`-nargs=0` 表示没有参数，`-nargs=1` 表示传递1个参数，`-nargs=+` 表示至少1个参数，`-nargs=*` 表示传递任意数量的参数，`-nargs=?` 表示传递0个或1个参数。如果您想传递n个参数，使用 `-nargs=n`（这里 `n` 是一个任意整数）。\n\n`<args>` 有两个变体：`<f-args>` 和 `<q-args>` 。前者用来向Vimscript函数传递参数，后者用来将用户输入自动转换为字符串。\n\n使用 `args`:\n\n```\n:command! -nargs=1 Hello echo \"Hello \" . <args>\n:Hello \"Iggy\"\n\" returns 'Hello Iggy'\n\n:Hello Iggy\n\" Undefined variable error\n```\n\n使用 `q-args`:\n\n```\n:command! -nargs=1 Hello echo \"Hello \" . <q-args>\n:Hello Iggy\n\" returns 'Hello Iggy'\n```\n\n使用 `f-args`:\n\n```\n:function! PrintHello(person1, person2)\n:  echo \"Hello \" . a:person1 . \" and \" . a:person2\n:endfunction\n\n:command! -nargs=* Hello call PrintHello(<f-args>)\n\n:Hello Iggy1 Iggy2\n\" returns \"Hello Iggy1 and Iggy2\"\n```\n\n当您学了关于Vimscript函数的章节后，上面的函数将更有意义。\n\n查阅 `:h command` 和 `:args` 了解更多关于command和args的信息。\n\n### 键盘映射\n\n如果您发现您重复地执行一些相同的复杂操作，那么为这些复杂操作建立一个键盘映射将会很有用：\n\n比如，在我的vimrc文件中有2个键盘映射：\n\n```\nnnoremap <silent> <C-f> :GFiles<CR>\n\nnnoremap <Leader>tn :call ToggleNumber()<CR>\n```\n\n在第一个中，我将 `Ctrl-F` 映射到 [fzf.vim](https://github.com/junegunn/fzf.vim) 插件的 `:Gfiles` 命令(快速搜索Git文件)上。在第二个中，我将 `<leader>tn` 映射到调用一个自定义函数 `ToggleNumber` （切换 `norelativenumber` 和 `relativenumber` 选项）。`Ctrl-f` 映射覆盖了Vim的原生的页面滚动。如果发生冲突，您的映射将会覆盖Vim的设置。因为从几乎从来不用Vim原生的页面滚动功能，所以我认为可以安全地覆盖它。\n\n另外，在 `<Leader>tn` 中的 \"leader\" 键到底是什么?\n\nVim有一个leader键用来辅助键盘映射。比如，我将 `<leader>tn` 映射为运行 `ToggleNumber()` 函数。如果没有leader键，我可能会用 `tn`，但Vim中的 `t` 已经用做其他功能（\"till\"搜索导航命令）了。有了leader键，我现在先按定义好的leader键作为开头，然后按 `tn`，而不用干扰已经存在的命令。您可以设置leader键作为您映射的连续按键的第一个按键。默认Vim使用反斜杠作为leader键（所以 `<Leader>tn` 会变成 \"反斜杠-t-n\"）。\n\n我个人喜欢使用空格 `<Space>` 作为leader键，代替默认的反斜杠。要想改变您的leader键，将下面的文本添加到您的vimrc中：\n\n```\nlet mapleader = \"\\<space>\"\n```\n\n上面的 `nnoremap` 命令可以分解为三个部分：\n- `n` 表示普通模式。\n- `nore` 表示禁止递归。\n- `map` 是键盘映射命令。\n\n如果不想使用 `nnoremap`，您至少也得使用 `nmap` (`nmap <silent> <C-f> :Gfiles<CR>`)。但是，最好还是使用禁止递归的版本，这样是为了避免键盘映射时潜在的无限循环风险。\n\n如果您进行键盘映射时不使用禁止递归，下面例子演示了会发生什么。假设您想给 `B` 添加一个键盘映射，用来在一行的末尾添加一个分号，然后跳回前一个词组（回想一下，`B` 是Vim普通模式的一个导航命令，用来跳回前一个词组)。 \n\n```\nnmap B A;<esc>B\n```\n\n当您按下 `B` ...哦豁，Vim开始失控了，开始无止尽的添加`;`（用 `Ctrl-c`终止）。为什么会发生这样的情况？因为在键盘映射 `A;<esc>B`中，这个 `B`不再是Vim原生的导航命令，它已经被映射到您刚才创建的键盘映射中了。这是您实际上执行的操作序列：\n\n```\nA;<esc>A;<esc>A;<esc>A;esc>...\n```\n\n要解决这个问题，您需要指定键盘映射禁止递归：\n\n```\nnnoremap B A;<esc>B\n```\n\n现在再按一下 `B` 试试。这一次它成功地在行尾添加了一个 `;`，然后跳回到前一个词组。这个映射中的 `B` 就表示Vim原生的 `B`了。\n\nVim针对不同的模式有不同的键盘映射命令。如果您想创建一个插入模式下的键盘映射 `jk`，用来退出插入模式：\n\n```\ninoremap jk <esc>\n```\n\n其他模式的键盘映射命令有：`map`（普通、可视、选择、以及操作符等待模式）， `vmap`（可视、选择）， `smap`（选择）， `xmap`（可视）， `omap`（操作符等待模式）， `map!`（插入、命令行）， `lmap`（插入，命令行，Lang-arg模式）， `cmap`（命令行）， 还有`tmap`（终端任务）。在这里我不会详细的讲解它们，要了解更多信息，查阅 `:h map.txt`。\n\n创建最直观、最一致、最易于记忆的键盘映射。\n\n## 组织管理Vimrc\n\n一段时候键，您的vimrc文件就会变大且复杂得难以阅读。有两种方法让您的vimrc文件保持整洁：\n- 将您的vimrc文件划分为几个文件\n- 折叠您的vimrc文件\n\n### 划分您的vimrc\n\n您可以使用Vim的 `:source` 命令将您的vimrc文件划分为多个文件。这个命令可以根据给定的文件参数，读取文件中的命令行命令。\n\n让我们在 `~/.vim` 下创建一个子文件夹，取名为 `/settings`（`~/.vim/settings`）。名字可以取为任意您喜欢的名字。\n\n然后你在这个文件夹下创建4个文件：\n- 第三方插件 (`~/.vim/settings/plugins.vim`).\n- 通用设置 (`~/.vim/settings/configs.vim`).\n- 自定义函数 (`~/.vim/settings/functions.vim`).\n- 键盘映射 (`~/.vim/settings/mappings.vim`) .\n\n在 `~/.vimrc` 里面添加:\n\n```\nsource $HOME/.vim/settings/plugins.vim\nsource $HOME/.vim/settings/configs.vim\nsource $HOME/.vim/settings/functions.vim\nsource $HOME/.vim/settings/mappings.vim\n```\n\n在 `~/.vim/settings/plugins.vim` 里面:\n\n```\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\n```\n\n在 `~/.vim/settings/configs.vim` 里面:\n\n```\nset nocompatible\nset relativenumber\nset number\n```\n\n在 `~/.vim/settings/functions.vim` 里面:\n\n```\nfunction! ToggleNumber()\n  if(&relativenumber == 1)\n    set norelativenumber\n  else\n    set relativenumber\n  endif\nendfunc\n```\n\n在 `~/.vim/settings/mappings.vim` 里面:\n\n```\ninoremap jk <esc>\nnnoremap <silent> <C-f> :GFiles<CR>\nnnoremap <Leader>tn :call ToggleNumber()<CR>\n```\n\n这样您的vimrc文件依然能够正常工作，但现在它只有4行了。\n\n使用这样的设置，您可以轻易知道到哪去修改配置。如果您要添加一些键盘映射，就将它们添加在 `/mappings.vim` 文件中。以后，当您的vimrc变大时，您总是可以新建几个子文件来缩小它的大小。比如，如果您想为主题配色创建相关设置，您可以添加 `~/.vim/settings/themes.vim`。\n\n### 保持单独的一个Vimrc文件\n\n如果您倾向于保持一个单独的vimrc文件，以使它更加便于携带，您可以使用标志折叠让它保持有序。在vimrc文件的顶部添加一下内容：\n\n```\n\" setup folds {{{\naugroup filetype_vim\n  autocmd!\n  autocmd FileType vim setlocal foldmethod=marker\naugroup END\n\" }}}\n```\n\nVim能够检测当前buffer所属的文件类型 (`:set filetype?`). 如果发现属于 `vim` 类型，您可以使用标志折叠。回想一个标志折叠的用法，它使用 `{{{` 和 `}}}` 来指明折叠的开始和结束。\n\n添加 `{{{` 和 `}}}` 标志将您的vimrc文件其他部分折叠起来。(别忘了使用 `\"` 对标志进行注释):\n\n```\n\" setup folds {{{\naugroup filetype_vim\n  autocmd!\n  autocmd FileType vim setlocal foldmethod=marker\naugroup END\n\" }}}\n\n\" plugins {{{\ncall plug#begin('~/.vim/plugged')\n  Plug 'mattn/emmet-vim'\n  Plug 'preservim/nerdtree'\ncall plug#end()\n\" }}}\n\n\" configs {{{\nset nocompatible\nset relativenumber\nset number\n\" }}}\n\n\" functions {{{\nfunction! ToggleNumber()\n  if(&relativenumber == 1)\n    set norelativenumber\n  else\n    set relativenumber\n  endif\nendfunc\n\" }}}\n\n\" mappings {{{\ninoremap jk <esc>\nnnoremap <silent> <C-f> :GFiles<CR>\nnnoremap <Leader>tn :call ToggleNumber()<CR>\n\" }}}\n```\n\n您的vimrc文件将会看起来类似下面：\n\n```\n+-- 6 lines: setup folds -----\n\n+-- 6 lines: plugins ---------\n\n+-- 5 lines: configs ---------\n\n+-- 9 lines: functions -------\n\n+-- 5 lines: mappings --------\n```\n\n## 启动Vim时加载/不加载Vimrc和插件\n\n如果您要启动Vim时，既不加载Vimrc，也不加载插件，运行：\n\n```\nvim -u NONE\n```\n\n如果您要启动Vim时，不加载Vimrc，但加载插件，运行：\n\n```\nvim -u NORC\n```\n\n如果您要启动Vim时，加载Vimrc，但不加载插件，运行\n\n```\nvim --noplugin\n```\n\n如果您要Vim启动加载一个 *其他的* vimrc, 比如 `~/.vimrc-backup`, 运行:\n\n```\nvim -u ~/.vimrc-backup\n```\n\n## 聪明地配置Vimrc\n\nVimrc是定制Vim时的一个重要组件，学习构建您的Vimrc最好是首先阅读他人的vimrc文件，然后逐渐地建立自己的。最好的vimrc并不是谁谁谁使用的，而是最适合您的工作需要和编辑风格的。\n","slug":"Vim/ch22_vimrc","published":1,"updated":"2022-08-28T07:38:59.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i27002qscvmg55v5tlm","content":"<h1 id=\"Ch22-Vimrc\"><a href=\"#Ch22-Vimrc\" class=\"headerlink\" title=\"Ch22. Vimrc\"></a>Ch22. Vimrc</h1><p>在先前的章节中，您学习了如何使用Vim。在本章，您将学习如何组织和配置Vimrc。</p>\n<h2 id=\"Vim如何找到Vimrc\"><a href=\"#Vim如何找到Vimrc\" class=\"headerlink\" title=\"Vim如何找到Vimrc\"></a>Vim如何找到Vimrc</h2><p>对于Vimrc，常见的理解是在根目录下添加一个 <code>.vimrc</code> 点文件（根据您使用的操作系统，文件路径名可能不同）。</p>\n<p>实际上，Vim在多个地方查找vimrc文件。下面是Vim检查的路径：</p>\n<ul>\n<li><code>$VIMINIT</code></li>\n<li><code>$HOME/.vimrc</code></li>\n<li><code>$HOME/.vim/vimrc</code></li>\n<li><code>$EXINIT</code></li>\n<li><code>$HOME/.exrc</code></li>\n<li><code>$VIMRUNTIME/default.vim</code></li>\n</ul>\n<p>当您启动Vim时，它将在上面列出的6个位置按顺序检查vimrc文件，第一个被找到的vimrc文件将被加载，而其余的将被忽略。</p>\n<p>首先，Vim将查找环境变量 <code>$VIMINIT</code>。如果没有找到，Vim将检查 <code>$HOME/.vimrc</code>。如果还没找到，VIm就检查 <code>$HOME/.vim/vimrc</code>。如果Vim找到了vimrc文件，它就停止查找，并使用 <code>$HOME/.vim/vimrc</code>。</p>\n<p>关于第一个位置，<code>$VIMINIT</code> 是一个环境变量。默认情况下它是未定义的。如果您想将 <code>~/dotfiles/testvimrc</code> 作为 <code>$VIMINTI</code> 的值，您可以创建一个包含那个vimrc路径的环境变量。当您运行 <code>export VIMINIT=&#39;let $MYVIMRC=&quot;$HOME/dotfiles/testvimrc&quot; | source $MYVIMRC&#39;</code>后，VIm将使用 <code>~/dotfiles/testvimrc</code> 作为您的vimrc文件。</p>\n<p>第二个位置，<code>$HOME/.vimrc</code> 是很多Vim用户习惯使用的路径。<code>$HOME</code> 大部分情况下是您的根目录（<code>~</code>）。如果您有一个 <code>~/.vimrc</code> 文件，Vim将使用它作为您的vimrc文件。</p>\n<p>第三个，<code>$HOME/.vim/vimrc</code>，位于 <code>~/.vim</code> 目录中。您可能已经有了一个 <code>~/.vim</code> 目录用于存放插件、自定义脚本、或视图文件。注意这里的vimrc文件名没有“点”（<code>$HOME/.vim/.vimrc</code> 不会被识别，但 <code>$HOME/.vim/vimrc</code>能被识别）。</p>\n<p>第四个，<code>$EXINIT</code> 工作方式与 <code>$VIMINIT</code> 类似。</p>\n<p>第五个，<code>$HOME/.exrc</code> 工作方式与 <code>$HOME/.vimrc</code> 类似。</p>\n<p>第六个，<code>$VIMRUNTIME/defaults.vim</code> 是Vim编译时自带的默认vimrc文件。在我的电脑中，我是使用Homebrew安装的Vim8.2，所以我的路径是（<code>/usr/local/share/vim/vim82</code>）。如果Vim在前5个位置都没有找到vimrc文件，它将使用这个Vim自带的vimrc文件。</p>\n<p>在本章剩余部分，我将假设vimrc使用的路径是 <code>~/.vimrc</code>。</p>\n<h2 id=\"应该把什么放在Vimrc中？\"><a href=\"#应该把什么放在Vimrc中？\" class=\"headerlink\" title=\"应该把什么放在Vimrc中？\"></a>应该把什么放在Vimrc中？</h2><p>我刚开始配置Vimrc时，曾问过一个问题，“我究竟该把什么放在Vimrc文件中？”。</p>\n<p>答案是，“任何您想放的东西”。 直接复制粘贴别人的vimrc文件的确是一个诱惑，但您应当抵制这个诱惑。如果您仍然坚持使用别人的vimrc文件，确保您知道这个vimrc干了什么，为什么他&#x2F;她要用这些设置？以及他&#x2F;她如何使用这些设置？还有最重要的是，这个vimrc文件是否符合你的实际需要？别人使用并不代表您也要使用。</p>\n<h2 id=\"Vimrc基础内容\"><a href=\"#Vimrc基础内容\" class=\"headerlink\" title=\"Vimrc基础内容\"></a>Vimrc基础内容</h2><p>简单地说，一个vimrc是以下内容的集合：</p>\n<ul>\n<li>插件</li>\n<li>设置</li>\n<li>自定义函数</li>\n<li>自定义命令</li>\n<li>键盘映射</li>\n</ul>\n<p>当然还有一些上面没有提到的内容，但总体说，已经涵盖了绝大部分使用场景。</p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>在前面的章节中，我曾提到很多不同的插件，比如<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>, <a href=\"https://github.com/simnalamburt/vim-mundo\">vim-mundo</a>, 还有 <a href=\"https://github.com/tpope/vim-fugitive\">vim-fugitive</a>.</p>\n<p>十年前，管理插件插件是一个噩梦。但随着很多现代插件管理器的开发，现在安装插件可以在几秒内完成。我现在正在使用<a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a>作为我的插件管理器，所以我在本节中将使用它。相关概念和其他流行的插件管理器应该是类似的。我强烈建议您多试试几个插件管理器，比如：</p>\n<ul>\n<li><a href=\"https://github.com/VundleVim/Vundle.vim\">vundle.vim</a></li>\n<li><a href=\"https://github.com/tpope/vim-pathogen\">vim-pathogen</a></li>\n<li><a href=\"https://github.com/Shougo/dein.vim\">dein.vim</a></li>\n</ul>\n<p>除了上面列出的，还有很多插件管理器，可以随便看看。要想安装 vim-plug，如果您使用的是Unix，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs awk\">curl -fLo ~<span class=\"hljs-regexp\">/.vim/</span>autoload<span class=\"hljs-regexp\">/plug.vim --create-dirs https:/</span><span class=\"hljs-regexp\">/raw.githubusercontent.com/</span>junegunn<span class=\"hljs-regexp\">/vim-plug/m</span>aster/plug.vim<br></code></pre></td></tr></table></figure>\n\n<p>要添加新的插件，将您的插件名(比如，<code>Plug &#39;github-username/repository-name&#39;</code>) 放置在 <code>call plug#begin()</code> 和 <code>call plug#end()</code> 之间的行中. 所以，如果您想安装 <code>emmet-vim</code> 和 <code>nerdtree</code>，将下面的片段放到您的vimrc中：</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs leaf\">call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(&#x27;~/.<span class=\"hljs-variable\">vim</span>/<span class=\"hljs-variable\">plugged</span>&#x27;)</span></span><br>  Plug &#x27;mattn/emmet-vim&#x27;<br>  Plug &#x27;preservim/nerdtree&#x27;<br>call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>然后保存修改，加载当前vimrc (<code>:source %</code>), 然后运行 <code>:PlugInstall</code> 安装插件。</p>\n<p>如果以后您想删除不使用的插件，您只需将插件名从 <code>call</code> 代码块之间移除，保存并加载，然后运行 <code>:PlugClean</code> 命令将它从机器上删除。</p>\n<p>Vim 8 有自己的内置包管理器。您可以查阅 <code>:h packages</code> 了解更多信息。在后面一章中，我将向您展示如何使用它。</p>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p>在任意一个vimrc文件中都可以看到大量的 <code>set</code> 选项。 如果您在命令行模式中运行 set 命令，它只是暂时的。当您关闭Vim，设置就会丢失。比如，为了避免您每次运行Vim时都必须在命令行模式运行 <code>:set relativenumber number</code> 命令，您可以将这个命令添加在vimrc中：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\"><span class=\"hljs-keyword\">set</span> relativenumber <span class=\"hljs-built_in\">number</span><br></code></pre></td></tr></table></figure>\n\n<p>有一些设置需要您赋予一个值，比如 <code>set tabstop=2</code>。想了解一个设置可以接收什么类型的值，可以查看帮助页。</p>\n<p>您也可以使用 <code>let</code> 来代替 <code>set</code>（确保在选项前添加一个 <code>&amp;</code>号）。使用 <code>let</code> ，您可以使用表达式进行赋值。比如，要想仅当某个路径存在时，才将该路径赋予 <code>&#39;dictionary&#39;</code> 选项：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s:english_dict</span> = <span class=\"hljs-string\">&quot;/usr/share/dict/words&quot;</span><br><br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">filereadable</span>(<span class=\"hljs-variable\">s:english_dict</span>)<br>  <span class=\"hljs-keyword\">let</span> &amp;dictionary=<span class=\"hljs-variable\">s:english_dict</span><br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n\n<p>在后面的章节中您将了解关于Vimscript赋值和条件的知识。</p>\n<p>要查看Vim中所有可用的选项，查阅 <code>:h E355</code>。</p>\n<h3 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h3><p>Vimrc是一个很好的用来放置自定义函数的地方。在后面的章节中您将学习如何写您自己的Vimscript函数。</p>\n<h3 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h3><p>您可以使用 <code>command</code> 创建一个自定义命令行命令。</p>\n<p>比如，创建一个用于显示今天日期的基本命令 <code>GimmeDate</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:<span class=\"hljs-built_in\">command</span>! GimmeDate <span class=\"hljs-built_in\">echo</span> call(<span class=\"hljs-string\">&quot;strftime&quot;</span>, [<span class=\"hljs-string\">&quot;%F&quot;</span>])<br></code></pre></td></tr></table></figure>\n\n<p>当您运行 <code>:GimmeDate</code> 时，Vim将显示一个类似 “2021-01-1”的日期。</p>\n<p>要创建一个可以接收输入的基本命令，您可以使用 <code>&lt;args&gt;</code> 。如果您想向 <code>GimmeDate</code> 传递一个时间&#x2F;日期格式参数：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">:command! GimmeDate echo call(&quot;strftime&quot;, [&lt;args&gt;])<br><br>:GimmeDate &quot;%F&quot;<br>&quot; 2020-01-01<br><br><span class=\"hljs-meta\">:GimmeDate &quot;%H:%M&quot;</span><br>&quot; 11:30<br></code></pre></td></tr></table></figure>\n\n<p>如果您想限定参数的数目，您可以使用 <code>-nargs</code> 标志。<code>-nargs=0</code> 表示没有参数，<code>-nargs=1</code> 表示传递1个参数，<code>-nargs=+</code> 表示至少1个参数，<code>-nargs=*</code> 表示传递任意数量的参数，<code>-nargs=?</code> 表示传递0个或1个参数。如果您想传递n个参数，使用 <code>-nargs=n</code>（这里 <code>n</code> 是一个任意整数）。</p>\n<p><code>&lt;args&gt;</code> 有两个变体：<code>&lt;f-args&gt;</code> 和 <code>&lt;q-args&gt;</code> 。前者用来向Vimscript函数传递参数，后者用来将用户输入自动转换为字符串。</p>\n<p>使用 <code>args</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:command! -nargs=<span class=\"hljs-number\">1</span> Hello <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello &quot;</span> . <span class=\"hljs-symbol\">&lt;args&gt;</span><br>:Hello <span class=\"hljs-string\">&quot;Iggy&quot;</span><br><span class=\"hljs-comment\">&quot; returns &#x27;Hello Iggy&#x27;</span><br><br>:Hello Iggy<br><span class=\"hljs-comment\">&quot; Undefined variable error</span><br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>q-args</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:command! -nargs=<span class=\"hljs-number\">1</span> Hello <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello &quot;</span> . <span class=\"hljs-symbol\">&lt;q-args&gt;</span><br>:Hello Iggy<br><span class=\"hljs-comment\">&quot; returns &#x27;Hello Iggy&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>f-args</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">function!</span> <span class=\"hljs-title\">PrintHello</span><span class=\"hljs-params\">(person1, person2)</span><br>:  <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello &quot;</span> . <span class=\"hljs-variable\">a:person1</span> . <span class=\"hljs-string\">&quot; and &quot;</span> . <span class=\"hljs-variable\">a:person2</span><br>:<span class=\"hljs-keyword\">endfunction</span><br><br>:command! -nargs=* Hello <span class=\"hljs-keyword\">call</span> PrintHello(<span class=\"hljs-symbol\">&lt;f-args&gt;</span>)<br><br>:Hello Iggy1 Iggy2<br><span class=\"hljs-string\">&quot; returns &quot;</span>Hello Iggy1 <span class=\"hljs-built_in\">and</span> Iggy2<span class=\"hljs-comment\">&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>当您学了关于Vimscript函数的章节后，上面的函数将更有意义。</p>\n<p>查阅 <code>:h command</code> 和 <code>:args</code> 了解更多关于command和args的信息。</p>\n<h3 id=\"键盘映射\"><a href=\"#键盘映射\" class=\"headerlink\" title=\"键盘映射\"></a>键盘映射</h3><p>如果您发现您重复地执行一些相同的复杂操作，那么为这些复杂操作建立一个键盘映射将会很有用：</p>\n<p>比如，在我的vimrc文件中有2个键盘映射：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;silent&gt;</span> <span class=\"hljs-symbol\">&lt;C-f&gt;</span> :GFiles<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;Leader&gt;</span><span class=\"hljs-keyword\">tn</span> :<span class=\"hljs-keyword\">call</span> ToggleNumber()<span class=\"hljs-symbol\">&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>在第一个中，我将 <code>Ctrl-F</code> 映射到 <a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a> 插件的 <code>:Gfiles</code> 命令(快速搜索Git文件)上。在第二个中，我将 <code>&lt;leader&gt;tn</code> 映射到调用一个自定义函数 <code>ToggleNumber</code> （切换 <code>norelativenumber</code> 和 <code>relativenumber</code> 选项）。<code>Ctrl-f</code> 映射覆盖了Vim的原生的页面滚动。如果发生冲突，您的映射将会覆盖Vim的设置。因为从几乎从来不用Vim原生的页面滚动功能，所以我认为可以安全地覆盖它。</p>\n<p>另外，在 <code>&lt;Leader&gt;tn</code> 中的 “leader” 键到底是什么?</p>\n<p>Vim有一个leader键用来辅助键盘映射。比如，我将 <code>&lt;leader&gt;tn</code> 映射为运行 <code>ToggleNumber()</code> 函数。如果没有leader键，我可能会用 <code>tn</code>，但Vim中的 <code>t</code> 已经用做其他功能（”till”搜索导航命令）了。有了leader键，我现在先按定义好的leader键作为开头，然后按 <code>tn</code>，而不用干扰已经存在的命令。您可以设置leader键作为您映射的连续按键的第一个按键。默认Vim使用反斜杠作为leader键（所以 <code>&lt;Leader&gt;tn</code> 会变成 “反斜杠-t-n”）。</p>\n<p>我个人喜欢使用空格 <code>&lt;Space&gt;</code> 作为leader键，代替默认的反斜杠。要想改变您的leader键，将下面的文本添加到您的vimrc中：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">mapleader</span> = <span class=\"hljs-string\">&quot;\\&lt;space&gt;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的 <code>nnoremap</code> 命令可以分解为三个部分：</p>\n<ul>\n<li><code>n</code> 表示普通模式。</li>\n<li><code>nore</code> 表示禁止递归。</li>\n<li><code>map</code> 是键盘映射命令。</li>\n</ul>\n<p>如果不想使用 <code>nnoremap</code>，您至少也得使用 <code>nmap</code> (<code>nmap &lt;silent&gt; &lt;C-f&gt; :Gfiles&lt;CR&gt;</code>)。但是，最好还是使用禁止递归的版本，这样是为了避免键盘映射时潜在的无限循环风险。</p>\n<p>如果您进行键盘映射时不使用禁止递归，下面例子演示了会发生什么。假设您想给 <code>B</code> 添加一个键盘映射，用来在一行的末尾添加一个分号，然后跳回前一个词组（回想一下，<code>B</code> 是Vim普通模式的一个导航命令，用来跳回前一个词组)。 </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">nmap <span class=\"hljs-selector-tag\">B</span> <span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">B</span><br></code></pre></td></tr></table></figure>\n\n<p>当您按下 <code>B</code> …哦豁，Vim开始失控了，开始无止尽的添加<code>;</code>（用 <code>Ctrl-c</code>终止）。为什么会发生这样的情况？因为在键盘映射 <code>A;&lt;esc&gt;B</code>中，这个 <code>B</code>不再是Vim原生的导航命令，它已经被映射到您刚才创建的键盘映射中了。这是您实际上执行的操作序列：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">A</span>;esc&gt;...<br></code></pre></td></tr></table></figure>\n\n<p>要解决这个问题，您需要指定键盘映射禁止递归：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">nnoremap <span class=\"hljs-selector-tag\">B</span> <span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">B</span><br></code></pre></td></tr></table></figure>\n\n<p>现在再按一下 <code>B</code> 试试。这一次它成功地在行尾添加了一个 <code>;</code>，然后跳回到前一个词组。这个映射中的 <code>B</code> 就表示Vim原生的 <code>B</code>了。</p>\n<p>Vim针对不同的模式有不同的键盘映射命令。如果您想创建一个插入模式下的键盘映射 <code>jk</code>，用来退出插入模式：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其他模式的键盘映射命令有：<code>map</code>（普通、可视、选择、以及操作符等待模式）， <code>vmap</code>（可视、选择）， <code>smap</code>（选择）， <code>xmap</code>（可视）， <code>omap</code>（操作符等待模式）， <code>map!</code>（插入、命令行）， <code>lmap</code>（插入，命令行，Lang-arg模式）， <code>cmap</code>（命令行）， 还有<code>tmap</code>（终端任务）。在这里我不会详细的讲解它们，要了解更多信息，查阅 <code>:h map.txt</code>。</p>\n<p>创建最直观、最一致、最易于记忆的键盘映射。</p>\n<h2 id=\"组织管理Vimrc\"><a href=\"#组织管理Vimrc\" class=\"headerlink\" title=\"组织管理Vimrc\"></a>组织管理Vimrc</h2><p>一段时候键，您的vimrc文件就会变大且复杂得难以阅读。有两种方法让您的vimrc文件保持整洁：</p>\n<ul>\n<li>将您的vimrc文件划分为几个文件</li>\n<li>折叠您的vimrc文件</li>\n</ul>\n<h3 id=\"划分您的vimrc\"><a href=\"#划分您的vimrc\" class=\"headerlink\" title=\"划分您的vimrc\"></a>划分您的vimrc</h3><p>您可以使用Vim的 <code>:source</code> 命令将您的vimrc文件划分为多个文件。这个命令可以根据给定的文件参数，读取文件中的命令行命令。</p>\n<p>让我们在 <code>~/.vim</code> 下创建一个子文件夹，取名为 <code>/settings</code>（<code>~/.vim/settings</code>）。名字可以取为任意您喜欢的名字。</p>\n<p>然后你在这个文件夹下创建4个文件：</p>\n<ul>\n<li>第三方插件 (<code>~/.vim/settings/plugins.vim</code>).</li>\n<li>通用设置 (<code>~/.vim/settings/configs.vim</code>).</li>\n<li>自定义函数 (<code>~/.vim/settings/functions.vim</code>).</li>\n<li>键盘映射 (<code>~/.vim/settings/mappings.vim</code>) .</li>\n</ul>\n<p>在 <code>~/.vimrc</code> 里面添加:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/plugins.vim<br>source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/configs.vim<br>source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/functions.vim<br>source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/mappings.vim<br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/plugins.vim</code> 里面:</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs leaf\">call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(&#x27;~/.<span class=\"hljs-variable\">vim</span>/<span class=\"hljs-variable\">plugged</span>&#x27;)</span></span><br>  Plug &#x27;mattn/emmet-vim&#x27;<br>  Plug &#x27;preservim/nerdtree&#x27;<br>call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/configs.vim</code> 里面:</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> nocompatible<br><span class=\"hljs-built_in\">set</span> relativenumber<br><span class=\"hljs-built_in\">set</span> number<br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/functions.vim</code> 里面:</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">function</span><span class=\"hljs-variable\">!</span> <span class=\"hljs-function\"><span class=\"hljs-title\">ToggleNumber</span>()</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(&amp;<span class=\"hljs-variable\">relativenumber</span> == <span class=\"hljs-number\">1</span>)</span><br>    <span class=\"hljs-variable\">set</span> <span class=\"hljs-variable\">norelativenumber</span><br>  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">else</span></span><br>    <span class=\"hljs-variable\">set</span> <span class=\"hljs-variable\">relativenumber</span><br>  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-variable\">endfunc</span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/mappings.vim</code> 里面:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;silent&gt;</span> <span class=\"hljs-symbol\">&lt;C-f&gt;</span> :GFiles<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;Leader&gt;</span><span class=\"hljs-keyword\">tn</span> :<span class=\"hljs-keyword\">call</span> ToggleNumber()<span class=\"hljs-symbol\">&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这样您的vimrc文件依然能够正常工作，但现在它只有4行了。</p>\n<p>使用这样的设置，您可以轻易知道到哪去修改配置。如果您要添加一些键盘映射，就将它们添加在 <code>/mappings.vim</code> 文件中。以后，当您的vimrc变大时，您总是可以新建几个子文件来缩小它的大小。比如，如果您想为主题配色创建相关设置，您可以添加 <code>~/.vim/settings/themes.vim</code>。</p>\n<h3 id=\"保持单独的一个Vimrc文件\"><a href=\"#保持单独的一个Vimrc文件\" class=\"headerlink\" title=\"保持单独的一个Vimrc文件\"></a>保持单独的一个Vimrc文件</h3><p>如果您倾向于保持一个单独的vimrc文件，以使它更加便于携带，您可以使用标志折叠让它保持有序。在vimrc文件的顶部添加一下内容：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs handlebars\"><span class=\"language-xml\">&quot; setup folds </span><span class=\"hljs-template-variable\">&#123;&#123;&#123;</span><br><span class=\"hljs-template-variable\"><span class=\"hljs-name\">augroup</span> filetype_vim</span><br><span class=\"hljs-template-variable\">  autocmd!</span><br><span class=\"hljs-template-variable\">  autocmd FileType vim setlocal <span class=\"hljs-attr\">foldmethod</span>=marker</span><br><span class=\"hljs-template-variable\">augroup END</span><br><span class=\"hljs-template-variable\"><span class=\"hljs-string\">&quot; &#125;&#125;&#125;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>Vim能够检测当前buffer所属的文件类型 (<code>:set filetype?</code>). 如果发现属于 <code>vim</code> 类型，您可以使用标志折叠。回想一个标志折叠的用法，它使用 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 来指明折叠的开始和结束。</p>\n<p>添加 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 标志将您的vimrc文件其他部分折叠起来。(别忘了使用 <code>&quot;</code> 对标志进行注释):</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-comment\">&quot; setup folds &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">augroup</span> filetype_vim<br>  autocmd!<br>  <span class=\"hljs-keyword\">autocmd</span> FileType <span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">setlocal</span> foldmethod=marker<br><span class=\"hljs-keyword\">augroup</span> END<br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; plugins &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">call</span> plug#begin(<span class=\"hljs-string\">&#x27;~/.vim/plugged&#x27;</span>)<br>  Plug <span class=\"hljs-string\">&#x27;mattn/emmet-vim&#x27;</span><br>  Plug <span class=\"hljs-string\">&#x27;preservim/nerdtree&#x27;</span><br><span class=\"hljs-keyword\">call</span> plug#end()<br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; configs &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">set</span> nocompatible<br><span class=\"hljs-keyword\">set</span> relativenumber<br><span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">number</span><br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; functions &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">function!</span> <span class=\"hljs-title\">ToggleNumber</span><span class=\"hljs-params\">()</span><br>  <span class=\"hljs-keyword\">if</span>(&amp;relativenumber == <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">set</span> norelativenumber<br>  <span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">set</span> relativenumber<br>  <span class=\"hljs-keyword\">endif</span><br>endfunc<br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; mappings &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;silent&gt;</span> <span class=\"hljs-symbol\">&lt;C-f&gt;</span> :GFiles<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;Leader&gt;</span><span class=\"hljs-keyword\">tn</span> :<span class=\"hljs-keyword\">call</span> ToggleNumber()<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>您的vimrc文件将会看起来类似下面：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 6 lines: setup folds -----</span><br><br>+<span class=\"hljs-comment\">-- 6 lines: plugins ---------</span><br><br>+<span class=\"hljs-comment\">-- 5 lines: configs ---------</span><br><br>+<span class=\"hljs-comment\">-- 9 lines: functions -------</span><br><br>+<span class=\"hljs-comment\">-- 5 lines: mappings --------</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"启动Vim时加载-x2F-不加载Vimrc和插件\"><a href=\"#启动Vim时加载-x2F-不加载Vimrc和插件\" class=\"headerlink\" title=\"启动Vim时加载&#x2F;不加载Vimrc和插件\"></a>启动Vim时加载&#x2F;不加载Vimrc和插件</h2><p>如果您要启动Vim时，既不加载Vimrc，也不加载插件，运行：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">vim -u <span class=\"hljs-built_in\">NONE</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您要启动Vim时，不加载Vimrc，但加载插件，运行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">vim -u NORC</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您要启动Vim时，加载Vimrc，但不加载插件，运行</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">vim <span class=\"hljs-comment\">--noplugin</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您要Vim启动加载一个 <em>其他的</em> vimrc, 比如 <code>~/.vimrc-backup</code>, 运行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -u ~/.vimrc-backup<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地配置Vimrc\"><a href=\"#聪明地配置Vimrc\" class=\"headerlink\" title=\"聪明地配置Vimrc\"></a>聪明地配置Vimrc</h2><p>Vimrc是定制Vim时的一个重要组件，学习构建您的Vimrc最好是首先阅读他人的vimrc文件，然后逐渐地建立自己的。最好的vimrc并不是谁谁谁使用的，而是最适合您的工作需要和编辑风格的。</p>\n","site":{"data":{}},"wordcount":8605,"excerpt":"","more":"<h1 id=\"Ch22-Vimrc\"><a href=\"#Ch22-Vimrc\" class=\"headerlink\" title=\"Ch22. Vimrc\"></a>Ch22. Vimrc</h1><p>在先前的章节中，您学习了如何使用Vim。在本章，您将学习如何组织和配置Vimrc。</p>\n<h2 id=\"Vim如何找到Vimrc\"><a href=\"#Vim如何找到Vimrc\" class=\"headerlink\" title=\"Vim如何找到Vimrc\"></a>Vim如何找到Vimrc</h2><p>对于Vimrc，常见的理解是在根目录下添加一个 <code>.vimrc</code> 点文件（根据您使用的操作系统，文件路径名可能不同）。</p>\n<p>实际上，Vim在多个地方查找vimrc文件。下面是Vim检查的路径：</p>\n<ul>\n<li><code>$VIMINIT</code></li>\n<li><code>$HOME/.vimrc</code></li>\n<li><code>$HOME/.vim/vimrc</code></li>\n<li><code>$EXINIT</code></li>\n<li><code>$HOME/.exrc</code></li>\n<li><code>$VIMRUNTIME/default.vim</code></li>\n</ul>\n<p>当您启动Vim时，它将在上面列出的6个位置按顺序检查vimrc文件，第一个被找到的vimrc文件将被加载，而其余的将被忽略。</p>\n<p>首先，Vim将查找环境变量 <code>$VIMINIT</code>。如果没有找到，Vim将检查 <code>$HOME/.vimrc</code>。如果还没找到，VIm就检查 <code>$HOME/.vim/vimrc</code>。如果Vim找到了vimrc文件，它就停止查找，并使用 <code>$HOME/.vim/vimrc</code>。</p>\n<p>关于第一个位置，<code>$VIMINIT</code> 是一个环境变量。默认情况下它是未定义的。如果您想将 <code>~/dotfiles/testvimrc</code> 作为 <code>$VIMINTI</code> 的值，您可以创建一个包含那个vimrc路径的环境变量。当您运行 <code>export VIMINIT=&#39;let $MYVIMRC=&quot;$HOME/dotfiles/testvimrc&quot; | source $MYVIMRC&#39;</code>后，VIm将使用 <code>~/dotfiles/testvimrc</code> 作为您的vimrc文件。</p>\n<p>第二个位置，<code>$HOME/.vimrc</code> 是很多Vim用户习惯使用的路径。<code>$HOME</code> 大部分情况下是您的根目录（<code>~</code>）。如果您有一个 <code>~/.vimrc</code> 文件，Vim将使用它作为您的vimrc文件。</p>\n<p>第三个，<code>$HOME/.vim/vimrc</code>，位于 <code>~/.vim</code> 目录中。您可能已经有了一个 <code>~/.vim</code> 目录用于存放插件、自定义脚本、或视图文件。注意这里的vimrc文件名没有“点”（<code>$HOME/.vim/.vimrc</code> 不会被识别，但 <code>$HOME/.vim/vimrc</code>能被识别）。</p>\n<p>第四个，<code>$EXINIT</code> 工作方式与 <code>$VIMINIT</code> 类似。</p>\n<p>第五个，<code>$HOME/.exrc</code> 工作方式与 <code>$HOME/.vimrc</code> 类似。</p>\n<p>第六个，<code>$VIMRUNTIME/defaults.vim</code> 是Vim编译时自带的默认vimrc文件。在我的电脑中，我是使用Homebrew安装的Vim8.2，所以我的路径是（<code>/usr/local/share/vim/vim82</code>）。如果Vim在前5个位置都没有找到vimrc文件，它将使用这个Vim自带的vimrc文件。</p>\n<p>在本章剩余部分，我将假设vimrc使用的路径是 <code>~/.vimrc</code>。</p>\n<h2 id=\"应该把什么放在Vimrc中？\"><a href=\"#应该把什么放在Vimrc中？\" class=\"headerlink\" title=\"应该把什么放在Vimrc中？\"></a>应该把什么放在Vimrc中？</h2><p>我刚开始配置Vimrc时，曾问过一个问题，“我究竟该把什么放在Vimrc文件中？”。</p>\n<p>答案是，“任何您想放的东西”。 直接复制粘贴别人的vimrc文件的确是一个诱惑，但您应当抵制这个诱惑。如果您仍然坚持使用别人的vimrc文件，确保您知道这个vimrc干了什么，为什么他&#x2F;她要用这些设置？以及他&#x2F;她如何使用这些设置？还有最重要的是，这个vimrc文件是否符合你的实际需要？别人使用并不代表您也要使用。</p>\n<h2 id=\"Vimrc基础内容\"><a href=\"#Vimrc基础内容\" class=\"headerlink\" title=\"Vimrc基础内容\"></a>Vimrc基础内容</h2><p>简单地说，一个vimrc是以下内容的集合：</p>\n<ul>\n<li>插件</li>\n<li>设置</li>\n<li>自定义函数</li>\n<li>自定义命令</li>\n<li>键盘映射</li>\n</ul>\n<p>当然还有一些上面没有提到的内容，但总体说，已经涵盖了绝大部分使用场景。</p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>在前面的章节中，我曾提到很多不同的插件，比如<a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a>, <a href=\"https://github.com/simnalamburt/vim-mundo\">vim-mundo</a>, 还有 <a href=\"https://github.com/tpope/vim-fugitive\">vim-fugitive</a>.</p>\n<p>十年前，管理插件插件是一个噩梦。但随着很多现代插件管理器的开发，现在安装插件可以在几秒内完成。我现在正在使用<a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a>作为我的插件管理器，所以我在本节中将使用它。相关概念和其他流行的插件管理器应该是类似的。我强烈建议您多试试几个插件管理器，比如：</p>\n<ul>\n<li><a href=\"https://github.com/VundleVim/Vundle.vim\">vundle.vim</a></li>\n<li><a href=\"https://github.com/tpope/vim-pathogen\">vim-pathogen</a></li>\n<li><a href=\"https://github.com/Shougo/dein.vim\">dein.vim</a></li>\n</ul>\n<p>除了上面列出的，还有很多插件管理器，可以随便看看。要想安装 vim-plug，如果您使用的是Unix，运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">curl -fLo ~<span class=\"hljs-regexp\">/.vim/</span>autoload<span class=\"hljs-regexp\">/plug.vim --create-dirs https:/</span><span class=\"hljs-regexp\">/raw.githubusercontent.com/</span>junegunn<span class=\"hljs-regexp\">/vim-plug/m</span>aster/plug.vim<br></code></pre></td></tr></table></figure>\n\n<p>要添加新的插件，将您的插件名(比如，<code>Plug &#39;github-username/repository-name&#39;</code>) 放置在 <code>call plug#begin()</code> 和 <code>call plug#end()</code> 之间的行中. 所以，如果您想安装 <code>emmet-vim</code> 和 <code>nerdtree</code>，将下面的片段放到您的vimrc中：</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs leaf\">call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(&#x27;~/.<span class=\"hljs-variable\">vim</span>/<span class=\"hljs-variable\">plugged</span>&#x27;)</span></span><br>  Plug &#x27;mattn/emmet-vim&#x27;<br>  Plug &#x27;preservim/nerdtree&#x27;<br>call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>然后保存修改，加载当前vimrc (<code>:source %</code>), 然后运行 <code>:PlugInstall</code> 安装插件。</p>\n<p>如果以后您想删除不使用的插件，您只需将插件名从 <code>call</code> 代码块之间移除，保存并加载，然后运行 <code>:PlugClean</code> 命令将它从机器上删除。</p>\n<p>Vim 8 有自己的内置包管理器。您可以查阅 <code>:h packages</code> 了解更多信息。在后面一章中，我将向您展示如何使用它。</p>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p>在任意一个vimrc文件中都可以看到大量的 <code>set</code> 选项。 如果您在命令行模式中运行 set 命令，它只是暂时的。当您关闭Vim，设置就会丢失。比如，为了避免您每次运行Vim时都必须在命令行模式运行 <code>:set relativenumber number</code> 命令，您可以将这个命令添加在vimrc中：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\"><span class=\"hljs-keyword\">set</span> relativenumber <span class=\"hljs-built_in\">number</span><br></code></pre></td></tr></table></figure>\n\n<p>有一些设置需要您赋予一个值，比如 <code>set tabstop=2</code>。想了解一个设置可以接收什么类型的值，可以查看帮助页。</p>\n<p>您也可以使用 <code>let</code> 来代替 <code>set</code>（确保在选项前添加一个 <code>&amp;</code>号）。使用 <code>let</code> ，您可以使用表达式进行赋值。比如，要想仅当某个路径存在时，才将该路径赋予 <code>&#39;dictionary&#39;</code> 选项：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s:english_dict</span> = <span class=\"hljs-string\">&quot;/usr/share/dict/words&quot;</span><br><br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">filereadable</span>(<span class=\"hljs-variable\">s:english_dict</span>)<br>  <span class=\"hljs-keyword\">let</span> &amp;dictionary=<span class=\"hljs-variable\">s:english_dict</span><br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n\n<p>在后面的章节中您将了解关于Vimscript赋值和条件的知识。</p>\n<p>要查看Vim中所有可用的选项，查阅 <code>:h E355</code>。</p>\n<h3 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h3><p>Vimrc是一个很好的用来放置自定义函数的地方。在后面的章节中您将学习如何写您自己的Vimscript函数。</p>\n<h3 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h3><p>您可以使用 <code>command</code> 创建一个自定义命令行命令。</p>\n<p>比如，创建一个用于显示今天日期的基本命令 <code>GimmeDate</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">:<span class=\"hljs-built_in\">command</span>! GimmeDate <span class=\"hljs-built_in\">echo</span> call(<span class=\"hljs-string\">&quot;strftime&quot;</span>, [<span class=\"hljs-string\">&quot;%F&quot;</span>])<br></code></pre></td></tr></table></figure>\n\n<p>当您运行 <code>:GimmeDate</code> 时，Vim将显示一个类似 “2021-01-1”的日期。</p>\n<p>要创建一个可以接收输入的基本命令，您可以使用 <code>&lt;args&gt;</code> 。如果您想向 <code>GimmeDate</code> 传递一个时间&#x2F;日期格式参数：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">:command! GimmeDate echo call(&quot;strftime&quot;, [&lt;args&gt;])<br><br>:GimmeDate &quot;%F&quot;<br>&quot; 2020-01-01<br><br><span class=\"hljs-meta\">:GimmeDate &quot;%H:%M&quot;</span><br>&quot; 11:30<br></code></pre></td></tr></table></figure>\n\n<p>如果您想限定参数的数目，您可以使用 <code>-nargs</code> 标志。<code>-nargs=0</code> 表示没有参数，<code>-nargs=1</code> 表示传递1个参数，<code>-nargs=+</code> 表示至少1个参数，<code>-nargs=*</code> 表示传递任意数量的参数，<code>-nargs=?</code> 表示传递0个或1个参数。如果您想传递n个参数，使用 <code>-nargs=n</code>（这里 <code>n</code> 是一个任意整数）。</p>\n<p><code>&lt;args&gt;</code> 有两个变体：<code>&lt;f-args&gt;</code> 和 <code>&lt;q-args&gt;</code> 。前者用来向Vimscript函数传递参数，后者用来将用户输入自动转换为字符串。</p>\n<p>使用 <code>args</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:command! -nargs=<span class=\"hljs-number\">1</span> Hello <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello &quot;</span> . <span class=\"hljs-symbol\">&lt;args&gt;</span><br>:Hello <span class=\"hljs-string\">&quot;Iggy&quot;</span><br><span class=\"hljs-comment\">&quot; returns &#x27;Hello Iggy&#x27;</span><br><br>:Hello Iggy<br><span class=\"hljs-comment\">&quot; Undefined variable error</span><br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>q-args</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:command! -nargs=<span class=\"hljs-number\">1</span> Hello <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello &quot;</span> . <span class=\"hljs-symbol\">&lt;q-args&gt;</span><br>:Hello Iggy<br><span class=\"hljs-comment\">&quot; returns &#x27;Hello Iggy&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>f-args</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">:<span class=\"hljs-keyword\">function!</span> <span class=\"hljs-title\">PrintHello</span><span class=\"hljs-params\">(person1, person2)</span><br>:  <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;Hello &quot;</span> . <span class=\"hljs-variable\">a:person1</span> . <span class=\"hljs-string\">&quot; and &quot;</span> . <span class=\"hljs-variable\">a:person2</span><br>:<span class=\"hljs-keyword\">endfunction</span><br><br>:command! -nargs=* Hello <span class=\"hljs-keyword\">call</span> PrintHello(<span class=\"hljs-symbol\">&lt;f-args&gt;</span>)<br><br>:Hello Iggy1 Iggy2<br><span class=\"hljs-string\">&quot; returns &quot;</span>Hello Iggy1 <span class=\"hljs-built_in\">and</span> Iggy2<span class=\"hljs-comment\">&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>当您学了关于Vimscript函数的章节后，上面的函数将更有意义。</p>\n<p>查阅 <code>:h command</code> 和 <code>:args</code> 了解更多关于command和args的信息。</p>\n<h3 id=\"键盘映射\"><a href=\"#键盘映射\" class=\"headerlink\" title=\"键盘映射\"></a>键盘映射</h3><p>如果您发现您重复地执行一些相同的复杂操作，那么为这些复杂操作建立一个键盘映射将会很有用：</p>\n<p>比如，在我的vimrc文件中有2个键盘映射：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;silent&gt;</span> <span class=\"hljs-symbol\">&lt;C-f&gt;</span> :GFiles<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;Leader&gt;</span><span class=\"hljs-keyword\">tn</span> :<span class=\"hljs-keyword\">call</span> ToggleNumber()<span class=\"hljs-symbol\">&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>在第一个中，我将 <code>Ctrl-F</code> 映射到 <a href=\"https://github.com/junegunn/fzf.vim\">fzf.vim</a> 插件的 <code>:Gfiles</code> 命令(快速搜索Git文件)上。在第二个中，我将 <code>&lt;leader&gt;tn</code> 映射到调用一个自定义函数 <code>ToggleNumber</code> （切换 <code>norelativenumber</code> 和 <code>relativenumber</code> 选项）。<code>Ctrl-f</code> 映射覆盖了Vim的原生的页面滚动。如果发生冲突，您的映射将会覆盖Vim的设置。因为从几乎从来不用Vim原生的页面滚动功能，所以我认为可以安全地覆盖它。</p>\n<p>另外，在 <code>&lt;Leader&gt;tn</code> 中的 “leader” 键到底是什么?</p>\n<p>Vim有一个leader键用来辅助键盘映射。比如，我将 <code>&lt;leader&gt;tn</code> 映射为运行 <code>ToggleNumber()</code> 函数。如果没有leader键，我可能会用 <code>tn</code>，但Vim中的 <code>t</code> 已经用做其他功能（”till”搜索导航命令）了。有了leader键，我现在先按定义好的leader键作为开头，然后按 <code>tn</code>，而不用干扰已经存在的命令。您可以设置leader键作为您映射的连续按键的第一个按键。默认Vim使用反斜杠作为leader键（所以 <code>&lt;Leader&gt;tn</code> 会变成 “反斜杠-t-n”）。</p>\n<p>我个人喜欢使用空格 <code>&lt;Space&gt;</code> 作为leader键，代替默认的反斜杠。要想改变您的leader键，将下面的文本添加到您的vimrc中：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">mapleader</span> = <span class=\"hljs-string\">&quot;\\&lt;space&gt;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的 <code>nnoremap</code> 命令可以分解为三个部分：</p>\n<ul>\n<li><code>n</code> 表示普通模式。</li>\n<li><code>nore</code> 表示禁止递归。</li>\n<li><code>map</code> 是键盘映射命令。</li>\n</ul>\n<p>如果不想使用 <code>nnoremap</code>，您至少也得使用 <code>nmap</code> (<code>nmap &lt;silent&gt; &lt;C-f&gt; :Gfiles&lt;CR&gt;</code>)。但是，最好还是使用禁止递归的版本，这样是为了避免键盘映射时潜在的无限循环风险。</p>\n<p>如果您进行键盘映射时不使用禁止递归，下面例子演示了会发生什么。假设您想给 <code>B</code> 添加一个键盘映射，用来在一行的末尾添加一个分号，然后跳回前一个词组（回想一下，<code>B</code> 是Vim普通模式的一个导航命令，用来跳回前一个词组)。 </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">nmap <span class=\"hljs-selector-tag\">B</span> <span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">B</span><br></code></pre></td></tr></table></figure>\n\n<p>当您按下 <code>B</code> …哦豁，Vim开始失控了，开始无止尽的添加<code>;</code>（用 <code>Ctrl-c</code>终止）。为什么会发生这样的情况？因为在键盘映射 <code>A;&lt;esc&gt;B</code>中，这个 <code>B</code>不再是Vim原生的导航命令，它已经被映射到您刚才创建的键盘映射中了。这是您实际上执行的操作序列：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">A</span>;esc&gt;...<br></code></pre></td></tr></table></figure>\n\n<p>要解决这个问题，您需要指定键盘映射禁止递归：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">nnoremap <span class=\"hljs-selector-tag\">B</span> <span class=\"hljs-selector-tag\">A</span>;&lt;esc&gt;<span class=\"hljs-selector-tag\">B</span><br></code></pre></td></tr></table></figure>\n\n<p>现在再按一下 <code>B</code> 试试。这一次它成功地在行尾添加了一个 <code>;</code>，然后跳回到前一个词组。这个映射中的 <code>B</code> 就表示Vim原生的 <code>B</code>了。</p>\n<p>Vim针对不同的模式有不同的键盘映射命令。如果您想创建一个插入模式下的键盘映射 <code>jk</code>，用来退出插入模式：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>其他模式的键盘映射命令有：<code>map</code>（普通、可视、选择、以及操作符等待模式）， <code>vmap</code>（可视、选择）， <code>smap</code>（选择）， <code>xmap</code>（可视）， <code>omap</code>（操作符等待模式）， <code>map!</code>（插入、命令行）， <code>lmap</code>（插入，命令行，Lang-arg模式）， <code>cmap</code>（命令行）， 还有<code>tmap</code>（终端任务）。在这里我不会详细的讲解它们，要了解更多信息，查阅 <code>:h map.txt</code>。</p>\n<p>创建最直观、最一致、最易于记忆的键盘映射。</p>\n<h2 id=\"组织管理Vimrc\"><a href=\"#组织管理Vimrc\" class=\"headerlink\" title=\"组织管理Vimrc\"></a>组织管理Vimrc</h2><p>一段时候键，您的vimrc文件就会变大且复杂得难以阅读。有两种方法让您的vimrc文件保持整洁：</p>\n<ul>\n<li>将您的vimrc文件划分为几个文件</li>\n<li>折叠您的vimrc文件</li>\n</ul>\n<h3 id=\"划分您的vimrc\"><a href=\"#划分您的vimrc\" class=\"headerlink\" title=\"划分您的vimrc\"></a>划分您的vimrc</h3><p>您可以使用Vim的 <code>:source</code> 命令将您的vimrc文件划分为多个文件。这个命令可以根据给定的文件参数，读取文件中的命令行命令。</p>\n<p>让我们在 <code>~/.vim</code> 下创建一个子文件夹，取名为 <code>/settings</code>（<code>~/.vim/settings</code>）。名字可以取为任意您喜欢的名字。</p>\n<p>然后你在这个文件夹下创建4个文件：</p>\n<ul>\n<li>第三方插件 (<code>~/.vim/settings/plugins.vim</code>).</li>\n<li>通用设置 (<code>~/.vim/settings/configs.vim</code>).</li>\n<li>自定义函数 (<code>~/.vim/settings/functions.vim</code>).</li>\n<li>键盘映射 (<code>~/.vim/settings/mappings.vim</code>) .</li>\n</ul>\n<p>在 <code>~/.vimrc</code> 里面添加:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/plugins.vim<br>source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/configs.vim<br>source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/functions.vim<br>source <span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/.vim/</span>settings/mappings.vim<br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/plugins.vim</code> 里面:</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs leaf\">call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(&#x27;~/.<span class=\"hljs-variable\">vim</span>/<span class=\"hljs-variable\">plugged</span>&#x27;)</span></span><br>  Plug &#x27;mattn/emmet-vim&#x27;<br>  Plug &#x27;preservim/nerdtree&#x27;<br>call plug<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span></span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/configs.vim</code> 里面:</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">set</span> nocompatible<br><span class=\"hljs-built_in\">set</span> relativenumber<br><span class=\"hljs-built_in\">set</span> number<br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/functions.vim</code> 里面:</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">function</span><span class=\"hljs-variable\">!</span> <span class=\"hljs-function\"><span class=\"hljs-title\">ToggleNumber</span>()</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(&amp;<span class=\"hljs-variable\">relativenumber</span> == <span class=\"hljs-number\">1</span>)</span><br>    <span class=\"hljs-variable\">set</span> <span class=\"hljs-variable\">norelativenumber</span><br>  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">else</span></span><br>    <span class=\"hljs-variable\">set</span> <span class=\"hljs-variable\">relativenumber</span><br>  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-variable\">endfunc</span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/settings/mappings.vim</code> 里面:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;silent&gt;</span> <span class=\"hljs-symbol\">&lt;C-f&gt;</span> :GFiles<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;Leader&gt;</span><span class=\"hljs-keyword\">tn</span> :<span class=\"hljs-keyword\">call</span> ToggleNumber()<span class=\"hljs-symbol\">&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这样您的vimrc文件依然能够正常工作，但现在它只有4行了。</p>\n<p>使用这样的设置，您可以轻易知道到哪去修改配置。如果您要添加一些键盘映射，就将它们添加在 <code>/mappings.vim</code> 文件中。以后，当您的vimrc变大时，您总是可以新建几个子文件来缩小它的大小。比如，如果您想为主题配色创建相关设置，您可以添加 <code>~/.vim/settings/themes.vim</code>。</p>\n<h3 id=\"保持单独的一个Vimrc文件\"><a href=\"#保持单独的一个Vimrc文件\" class=\"headerlink\" title=\"保持单独的一个Vimrc文件\"></a>保持单独的一个Vimrc文件</h3><p>如果您倾向于保持一个单独的vimrc文件，以使它更加便于携带，您可以使用标志折叠让它保持有序。在vimrc文件的顶部添加一下内容：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs handlebars\"><span class=\"language-xml\">&quot; setup folds </span><span class=\"hljs-template-variable\">&#123;&#123;&#123;</span><br><span class=\"hljs-template-variable\"><span class=\"hljs-name\">augroup</span> filetype_vim</span><br><span class=\"hljs-template-variable\">  autocmd!</span><br><span class=\"hljs-template-variable\">  autocmd FileType vim setlocal <span class=\"hljs-attr\">foldmethod</span>=marker</span><br><span class=\"hljs-template-variable\">augroup END</span><br><span class=\"hljs-template-variable\"><span class=\"hljs-string\">&quot; &#125;&#125;&#125;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>Vim能够检测当前buffer所属的文件类型 (<code>:set filetype?</code>). 如果发现属于 <code>vim</code> 类型，您可以使用标志折叠。回想一个标志折叠的用法，它使用 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 来指明折叠的开始和结束。</p>\n<p>添加 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 标志将您的vimrc文件其他部分折叠起来。(别忘了使用 <code>&quot;</code> 对标志进行注释):</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-comment\">&quot; setup folds &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">augroup</span> filetype_vim<br>  autocmd!<br>  <span class=\"hljs-keyword\">autocmd</span> FileType <span class=\"hljs-keyword\">vim</span> <span class=\"hljs-keyword\">setlocal</span> foldmethod=marker<br><span class=\"hljs-keyword\">augroup</span> END<br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; plugins &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">call</span> plug#begin(<span class=\"hljs-string\">&#x27;~/.vim/plugged&#x27;</span>)<br>  Plug <span class=\"hljs-string\">&#x27;mattn/emmet-vim&#x27;</span><br>  Plug <span class=\"hljs-string\">&#x27;preservim/nerdtree&#x27;</span><br><span class=\"hljs-keyword\">call</span> plug#end()<br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; configs &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">set</span> nocompatible<br><span class=\"hljs-keyword\">set</span> relativenumber<br><span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">number</span><br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; functions &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">function!</span> <span class=\"hljs-title\">ToggleNumber</span><span class=\"hljs-params\">()</span><br>  <span class=\"hljs-keyword\">if</span>(&amp;relativenumber == <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-keyword\">set</span> norelativenumber<br>  <span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">set</span> relativenumber<br>  <span class=\"hljs-keyword\">endif</span><br>endfunc<br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br><br><span class=\"hljs-comment\">&quot; mappings &#123;&#123;&#123;</span><br><span class=\"hljs-keyword\">inoremap</span> jk <span class=\"hljs-symbol\">&lt;esc&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;silent&gt;</span> <span class=\"hljs-symbol\">&lt;C-f&gt;</span> :GFiles<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><span class=\"hljs-keyword\">nnoremap</span> <span class=\"hljs-symbol\">&lt;Leader&gt;</span><span class=\"hljs-keyword\">tn</span> :<span class=\"hljs-keyword\">call</span> ToggleNumber()<span class=\"hljs-symbol\">&lt;CR&gt;</span><br><span class=\"hljs-comment\">&quot; &#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>您的vimrc文件将会看起来类似下面：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">+<span class=\"hljs-comment\">-- 6 lines: setup folds -----</span><br><br>+<span class=\"hljs-comment\">-- 6 lines: plugins ---------</span><br><br>+<span class=\"hljs-comment\">-- 5 lines: configs ---------</span><br><br>+<span class=\"hljs-comment\">-- 9 lines: functions -------</span><br><br>+<span class=\"hljs-comment\">-- 5 lines: mappings --------</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"启动Vim时加载-x2F-不加载Vimrc和插件\"><a href=\"#启动Vim时加载-x2F-不加载Vimrc和插件\" class=\"headerlink\" title=\"启动Vim时加载&#x2F;不加载Vimrc和插件\"></a>启动Vim时加载&#x2F;不加载Vimrc和插件</h2><p>如果您要启动Vim时，既不加载Vimrc，也不加载插件，运行：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">vim -u <span class=\"hljs-built_in\">NONE</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您要启动Vim时，不加载Vimrc，但加载插件，运行：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">vim -u NORC</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您要启动Vim时，加载Vimrc，但不加载插件，运行</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">vim <span class=\"hljs-comment\">--noplugin</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您要Vim启动加载一个 <em>其他的</em> vimrc, 比如 <code>~/.vimrc-backup</code>, 运行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">vim -u ~/.vimrc-backup<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地配置Vimrc\"><a href=\"#聪明地配置Vimrc\" class=\"headerlink\" title=\"聪明地配置Vimrc\"></a>聪明地配置Vimrc</h2><p>Vimrc是定制Vim时的一个重要组件，学习构建您的Vimrc最好是首先阅读他人的vimrc文件，然后逐渐地建立自己的。最好的vimrc并不是谁谁谁使用的，而是最适合您的工作需要和编辑风格的。</p>\n"},{"title":"VIM-Vim软件包","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第22章 Vim软件包\n\n在前面的章节中，我提到使用第三方插件管理器来安装插件。从Vim 8开始，Vim自带了一个内置的插件管理器，名叫 *软件包（packages）*。在本章，您将学习如何使用Vim软件包来安装插件。\n\n要看您的Vim编译版本是否能够使用软件包，运行 `:version`。然后查看是否有 `+packages`属性。另外，您也可以运行 `:echo has('packages')`（如果返回1，表示可以使用软件包）。\n\n## 包目录\n\n在根目录下查看您是否有一个 `~/.vim` 文件夹。如果没有就新建一个。在文件夹里面，创建一个子文件夹取名 `pack`(`~/.vim/pack/`)。Vim会在这个子文件夹内自动搜索插件。\n\n## 两种加载方式\n\nVim软件包有两种加载机制：自动加载和手动加载。\n\n### 自动加载\n\n要想让Vim启动时自动加载插件，你需要将它们放置在 `start/`子目录中。路径看起来像这样：\n\n```\n~/.vim/pack/*/start/\n```\n\n现在您可能会问，为什么在`pack/` 和 `start/` 之间有一个 `*` ？这个星号可以是任意名字。让我们将它取为`packdemo/`：\n\n```\n~/.vim/pack/packdemo/start/\n```\n\n记住，如果您忽略这一点，用下面的路径代替的话：\n\n```\n~/.vim/pack/start/\n```\n\n软件包系统是不会正常工作的。 必须在`pack/` 和 `start/`之间添加一个名字才能正常运行。\n\n在这个示例中，让我们尝试安装 [NERDTree](https://github.com/preservim/nThe package system won't work. It is imperative to put a name between `pack/` and `start/`.erdtree) 插件。用任意方法进入 `start/` 目录（`cd ~/.vim/pack/packdemo/start/`），然后将NERDTree的仓库克隆下来：\n\n```\ngit clone https://github.com/preservim/nerdtree.git\n```\n\n完成了！您已经完成了安装。下一次您启动Vim，您可以立即执行 NERDTree 命令 `:NERDTreeToggle`。\n\n在 `~/.vim/pack/*/start/` 目录中，您想克隆多少插件仓库就克隆多少。Vim将会自动加载每一个插件。如果您删除了克隆的仓库（`rm -rf nerdtree`），那么插件就失效了。\n\n### 手动加载\n\n要想在Vim启动时手动加载插件，您得将相关插件放置在 `opt/` 目录中，类似于自动加载，这个路径看起来像这样：\n\n```\n~/.vim/pack/*/opt/\n```\n\n让我们继续使用前面的 `packdemo/` 这个名字：\n\n```\n~/.vim/pack/packdemo/opt/\n```\n\n这一次，让我们安装[killersheep](https://github.com/vim/killersheep) 游戏（需要Vim8.2以上版本）。进入`opt/` 目录(`cd ~/.vim/pack/packdemo/opt/`) 然后克隆仓库：\n\n```\ngit clone https://github.com/vim/killersheep.git\n```\n\n启动Vim。执行游戏的命令是 `:KillKillKill`。试着运行一下。Vim将会提示这不是一个有效的编辑命令。您需要首先 *手动* 加载插件，运行：\n\n```\n:packadd killersheep\n```\n\n现在再运行一下 `:KillKillKill` 。命令已经可以使用了。\n\n您可能好奇，“为什么我需要手动加载插件？启动时自动加载岂不是更好？”\n\n很好的问题。有时候有些插件我们并不是所有的时候都在用，比如 KillerSheep 游戏。您可能不会想要加载10个不同的游戏导致Vim启动变慢。但是偶尔当您觉得乏味的时候，您可能想要玩几个游戏，使用手动加载一些非必须的插件。\n\n您也可以使用这个方法有条件的加载插件。可能您同时使用了Neovim和Vim，有一些插件是为NeoVim优化过的。您可以添加类似下列的内容到您的vimrc中：\n\n```\nif has('nvim')\n  packadd! neovim-only-plugin\nelse\n  packadd! generic-vim-plugin\nendif\n```\n\n## 组织管理软件包\n\n回想一下，要使用Vim的软件包系统必须有以下需求：\n\n```\n~/.vim/pack/*/start/\n```\n\n或者:\n\n```\n~/.vim/pack/*/opt/\n```\n\n实际上，`*`星号可以使 *任意* 名字，这个名字就可以用来管理您的插件。假设您想将您的插件根据类型（颜色、语法、游戏）分组：\n\n```\n~/.vim/pack/colors/\n~/.vim/pack/syntax/\n~/.vim/pack/games/\n```\n\n您仍然可以使用各个目录下的 `start/` 和 `opt/` 。\n\n```\n~/.vim/pack/colors/start/\n~/.vim/pack/colors/opt/\n\n~/.vim/pack/syntax/start/\n~/.vim/pack/syntax/opt/\n\n~/.vim/pack/games/start/\n~/.vim/pack/games/opt/\n```\n\n## 聪明地添加插件\n\n您可能好奇，Vim软件包是否让一些流行的插件管理器，比如 vim-pathogen, vundle.vim, dein.vim, a还有vim-plug面临淘汰？\n\n答案永远是：“看情况而定。”\n\n我仍然使用vim-plug，因为使用它添加、删除、更新插件很容易。如果您使用了很多插件，插件管理器的好处更加明显，因为使用它可以对很多插件进行同时更新。有些插件管理器同时也提供了一些异步功能。\n\n如果您是极简主义者，可以尝试一下Vim软件包。如果您是一名插件重度使用者，您可能需要一个插件管理器。\n\n","source":"_posts/Vim/ch23_vim_packages.md","raw":"---\ntitle: VIM-Vim软件包\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第22章 Vim软件包\n\n在前面的章节中，我提到使用第三方插件管理器来安装插件。从Vim 8开始，Vim自带了一个内置的插件管理器，名叫 *软件包（packages）*。在本章，您将学习如何使用Vim软件包来安装插件。\n\n要看您的Vim编译版本是否能够使用软件包，运行 `:version`。然后查看是否有 `+packages`属性。另外，您也可以运行 `:echo has('packages')`（如果返回1，表示可以使用软件包）。\n\n## 包目录\n\n在根目录下查看您是否有一个 `~/.vim` 文件夹。如果没有就新建一个。在文件夹里面，创建一个子文件夹取名 `pack`(`~/.vim/pack/`)。Vim会在这个子文件夹内自动搜索插件。\n\n## 两种加载方式\n\nVim软件包有两种加载机制：自动加载和手动加载。\n\n### 自动加载\n\n要想让Vim启动时自动加载插件，你需要将它们放置在 `start/`子目录中。路径看起来像这样：\n\n```\n~/.vim/pack/*/start/\n```\n\n现在您可能会问，为什么在`pack/` 和 `start/` 之间有一个 `*` ？这个星号可以是任意名字。让我们将它取为`packdemo/`：\n\n```\n~/.vim/pack/packdemo/start/\n```\n\n记住，如果您忽略这一点，用下面的路径代替的话：\n\n```\n~/.vim/pack/start/\n```\n\n软件包系统是不会正常工作的。 必须在`pack/` 和 `start/`之间添加一个名字才能正常运行。\n\n在这个示例中，让我们尝试安装 [NERDTree](https://github.com/preservim/nThe package system won't work. It is imperative to put a name between `pack/` and `start/`.erdtree) 插件。用任意方法进入 `start/` 目录（`cd ~/.vim/pack/packdemo/start/`），然后将NERDTree的仓库克隆下来：\n\n```\ngit clone https://github.com/preservim/nerdtree.git\n```\n\n完成了！您已经完成了安装。下一次您启动Vim，您可以立即执行 NERDTree 命令 `:NERDTreeToggle`。\n\n在 `~/.vim/pack/*/start/` 目录中，您想克隆多少插件仓库就克隆多少。Vim将会自动加载每一个插件。如果您删除了克隆的仓库（`rm -rf nerdtree`），那么插件就失效了。\n\n### 手动加载\n\n要想在Vim启动时手动加载插件，您得将相关插件放置在 `opt/` 目录中，类似于自动加载，这个路径看起来像这样：\n\n```\n~/.vim/pack/*/opt/\n```\n\n让我们继续使用前面的 `packdemo/` 这个名字：\n\n```\n~/.vim/pack/packdemo/opt/\n```\n\n这一次，让我们安装[killersheep](https://github.com/vim/killersheep) 游戏（需要Vim8.2以上版本）。进入`opt/` 目录(`cd ~/.vim/pack/packdemo/opt/`) 然后克隆仓库：\n\n```\ngit clone https://github.com/vim/killersheep.git\n```\n\n启动Vim。执行游戏的命令是 `:KillKillKill`。试着运行一下。Vim将会提示这不是一个有效的编辑命令。您需要首先 *手动* 加载插件，运行：\n\n```\n:packadd killersheep\n```\n\n现在再运行一下 `:KillKillKill` 。命令已经可以使用了。\n\n您可能好奇，“为什么我需要手动加载插件？启动时自动加载岂不是更好？”\n\n很好的问题。有时候有些插件我们并不是所有的时候都在用，比如 KillerSheep 游戏。您可能不会想要加载10个不同的游戏导致Vim启动变慢。但是偶尔当您觉得乏味的时候，您可能想要玩几个游戏，使用手动加载一些非必须的插件。\n\n您也可以使用这个方法有条件的加载插件。可能您同时使用了Neovim和Vim，有一些插件是为NeoVim优化过的。您可以添加类似下列的内容到您的vimrc中：\n\n```\nif has('nvim')\n  packadd! neovim-only-plugin\nelse\n  packadd! generic-vim-plugin\nendif\n```\n\n## 组织管理软件包\n\n回想一下，要使用Vim的软件包系统必须有以下需求：\n\n```\n~/.vim/pack/*/start/\n```\n\n或者:\n\n```\n~/.vim/pack/*/opt/\n```\n\n实际上，`*`星号可以使 *任意* 名字，这个名字就可以用来管理您的插件。假设您想将您的插件根据类型（颜色、语法、游戏）分组：\n\n```\n~/.vim/pack/colors/\n~/.vim/pack/syntax/\n~/.vim/pack/games/\n```\n\n您仍然可以使用各个目录下的 `start/` 和 `opt/` 。\n\n```\n~/.vim/pack/colors/start/\n~/.vim/pack/colors/opt/\n\n~/.vim/pack/syntax/start/\n~/.vim/pack/syntax/opt/\n\n~/.vim/pack/games/start/\n~/.vim/pack/games/opt/\n```\n\n## 聪明地添加插件\n\n您可能好奇，Vim软件包是否让一些流行的插件管理器，比如 vim-pathogen, vundle.vim, dein.vim, a还有vim-plug面临淘汰？\n\n答案永远是：“看情况而定。”\n\n我仍然使用vim-plug，因为使用它添加、删除、更新插件很容易。如果您使用了很多插件，插件管理器的好处更加明显，因为使用它可以对很多插件进行同时更新。有些插件管理器同时也提供了一些异步功能。\n\n如果您是极简主义者，可以尝试一下Vim软件包。如果您是一名插件重度使用者，您可能需要一个插件管理器。\n\n","slug":"Vim/ch23_vim_packages","published":1,"updated":"2022-08-28T07:38:59.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i27002uscvm4kcs516i","content":"<h1 id=\"第22章-Vim软件包\"><a href=\"#第22章-Vim软件包\" class=\"headerlink\" title=\"第22章 Vim软件包\"></a>第22章 Vim软件包</h1><p>在前面的章节中，我提到使用第三方插件管理器来安装插件。从Vim 8开始，Vim自带了一个内置的插件管理器，名叫 <em>软件包（packages）</em>。在本章，您将学习如何使用Vim软件包来安装插件。</p>\n<p>要看您的Vim编译版本是否能够使用软件包，运行 <code>:version</code>。然后查看是否有 <code>+packages</code>属性。另外，您也可以运行 <code>:echo has(&#39;packages&#39;)</code>（如果返回1，表示可以使用软件包）。</p>\n<h2 id=\"包目录\"><a href=\"#包目录\" class=\"headerlink\" title=\"包目录\"></a>包目录</h2><p>在根目录下查看您是否有一个 <code>~/.vim</code> 文件夹。如果没有就新建一个。在文件夹里面，创建一个子文件夹取名 <code>pack</code>(<code>~/.vim/pack/</code>)。Vim会在这个子文件夹内自动搜索插件。</p>\n<h2 id=\"两种加载方式\"><a href=\"#两种加载方式\" class=\"headerlink\" title=\"两种加载方式\"></a>两种加载方式</h2><p>Vim软件包有两种加载机制：自动加载和手动加载。</p>\n<h3 id=\"自动加载\"><a href=\"#自动加载\" class=\"headerlink\" title=\"自动加载\"></a>自动加载</h3><p>要想让Vim启动时自动加载插件，你需要将它们放置在 <code>start/</code>子目录中。路径看起来像这样：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>start/<br></code></pre></td></tr></table></figure>\n\n<p>现在您可能会问，为什么在<code>pack/</code> 和 <code>start/</code> 之间有一个 <code>*</code> ？这个星号可以是任意名字。让我们将它取为<code>packdemo/</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/packdemo/</span>start/<br></code></pre></td></tr></table></figure>\n\n<p>记住，如果您忽略这一点，用下面的路径代替的话：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/start/</span><br></code></pre></td></tr></table></figure>\n\n<p>软件包系统是不会正常工作的。 必须在<code>pack/</code> 和 <code>start/</code>之间添加一个名字才能正常运行。</p>\n<p>在这个示例中，让我们尝试安装 [NERDTree](<a href=\"https://github.com/preservim/nThe\">https://github.com/preservim/nThe</a> package system won’t work. It is imperative to put a name between <code>pack/</code> and <code>start/</code>.erdtree) 插件。用任意方法进入 <code>start/</code> 目录（<code>cd ~/.vim/pack/packdemo/start/</code>），然后将NERDTree的仓库克隆下来：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">git clone https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/preservim/</span>nerdtree.git<br></code></pre></td></tr></table></figure>\n\n<p>完成了！您已经完成了安装。下一次您启动Vim，您可以立即执行 NERDTree 命令 <code>:NERDTreeToggle</code>。</p>\n<p>在 <code>~/.vim/pack/*/start/</code> 目录中，您想克隆多少插件仓库就克隆多少。Vim将会自动加载每一个插件。如果您删除了克隆的仓库（<code>rm -rf nerdtree</code>），那么插件就失效了。</p>\n<h3 id=\"手动加载\"><a href=\"#手动加载\" class=\"headerlink\" title=\"手动加载\"></a>手动加载</h3><p>要想在Vim启动时手动加载插件，您得将相关插件放置在 <code>opt/</code> 目录中，类似于自动加载，这个路径看起来像这样：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<p>让我们继续使用前面的 <code>packdemo/</code> 这个名字：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/packdemo/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<p>这一次，让我们安装<a href=\"https://github.com/vim/killersheep\">killersheep</a> 游戏（需要Vim8.2以上版本）。进入<code>opt/</code> 目录(<code>cd ~/.vim/pack/packdemo/opt/</code>) 然后克隆仓库：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">git clone https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/vim/</span>killersheep.git<br></code></pre></td></tr></table></figure>\n\n<p>启动Vim。执行游戏的命令是 <code>:KillKillKill</code>。试着运行一下。Vim将会提示这不是一个有效的编辑命令。您需要首先 <em>手动</em> 加载插件，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:packadd</span> killersheep<br></code></pre></td></tr></table></figure>\n\n<p>现在再运行一下 <code>:KillKillKill</code> 。命令已经可以使用了。</p>\n<p>您可能好奇，“为什么我需要手动加载插件？启动时自动加载岂不是更好？”</p>\n<p>很好的问题。有时候有些插件我们并不是所有的时候都在用，比如 KillerSheep 游戏。您可能不会想要加载10个不同的游戏导致Vim启动变慢。但是偶尔当您觉得乏味的时候，您可能想要玩几个游戏，使用手动加载一些非必须的插件。</p>\n<p>您也可以使用这个方法有条件的加载插件。可能您同时使用了Neovim和Vim，有一些插件是为NeoVim优化过的。您可以添加类似下列的内容到您的vimrc中：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">has</span>(<span class=\"hljs-string\">&#x27;nvim&#x27;</span>)<br>  packadd! neovim-<span class=\"hljs-keyword\">only</span>-plugin<br><span class=\"hljs-keyword\">else</span><br>  packadd! generic-<span class=\"hljs-keyword\">vim</span>-plugin<br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"组织管理软件包\"><a href=\"#组织管理软件包\" class=\"headerlink\" title=\"组织管理软件包\"></a>组织管理软件包</h2><p>回想一下，要使用Vim的软件包系统必须有以下需求：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>start/<br></code></pre></td></tr></table></figure>\n\n<p>或者:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<p>实际上，<code>*</code>星号可以使 <em>任意</em> 名字，这个名字就可以用来管理您的插件。假设您想将您的插件根据类型（颜色、语法、游戏）分组：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/colors/</span><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/syntax/</span><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/games/</span><br></code></pre></td></tr></table></figure>\n\n<p>您仍然可以使用各个目录下的 <code>start/</code> 和 <code>opt/</code> 。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/colors/</span>start/<br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/colors/</span>opt/<br><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/syntax/</span>start/<br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/syntax/</span>opt/<br><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/games/</span>start/<br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/games/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地添加插件\"><a href=\"#聪明地添加插件\" class=\"headerlink\" title=\"聪明地添加插件\"></a>聪明地添加插件</h2><p>您可能好奇，Vim软件包是否让一些流行的插件管理器，比如 vim-pathogen, vundle.vim, dein.vim, a还有vim-plug面临淘汰？</p>\n<p>答案永远是：“看情况而定。”</p>\n<p>我仍然使用vim-plug，因为使用它添加、删除、更新插件很容易。如果您使用了很多插件，插件管理器的好处更加明显，因为使用它可以对很多插件进行同时更新。有些插件管理器同时也提供了一些异步功能。</p>\n<p>如果您是极简主义者，可以尝试一下Vim软件包。如果您是一名插件重度使用者，您可能需要一个插件管理器。</p>\n","site":{"data":{}},"wordcount":2271,"excerpt":"","more":"<h1 id=\"第22章-Vim软件包\"><a href=\"#第22章-Vim软件包\" class=\"headerlink\" title=\"第22章 Vim软件包\"></a>第22章 Vim软件包</h1><p>在前面的章节中，我提到使用第三方插件管理器来安装插件。从Vim 8开始，Vim自带了一个内置的插件管理器，名叫 <em>软件包（packages）</em>。在本章，您将学习如何使用Vim软件包来安装插件。</p>\n<p>要看您的Vim编译版本是否能够使用软件包，运行 <code>:version</code>。然后查看是否有 <code>+packages</code>属性。另外，您也可以运行 <code>:echo has(&#39;packages&#39;)</code>（如果返回1，表示可以使用软件包）。</p>\n<h2 id=\"包目录\"><a href=\"#包目录\" class=\"headerlink\" title=\"包目录\"></a>包目录</h2><p>在根目录下查看您是否有一个 <code>~/.vim</code> 文件夹。如果没有就新建一个。在文件夹里面，创建一个子文件夹取名 <code>pack</code>(<code>~/.vim/pack/</code>)。Vim会在这个子文件夹内自动搜索插件。</p>\n<h2 id=\"两种加载方式\"><a href=\"#两种加载方式\" class=\"headerlink\" title=\"两种加载方式\"></a>两种加载方式</h2><p>Vim软件包有两种加载机制：自动加载和手动加载。</p>\n<h3 id=\"自动加载\"><a href=\"#自动加载\" class=\"headerlink\" title=\"自动加载\"></a>自动加载</h3><p>要想让Vim启动时自动加载插件，你需要将它们放置在 <code>start/</code>子目录中。路径看起来像这样：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>start/<br></code></pre></td></tr></table></figure>\n\n<p>现在您可能会问，为什么在<code>pack/</code> 和 <code>start/</code> 之间有一个 <code>*</code> ？这个星号可以是任意名字。让我们将它取为<code>packdemo/</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/packdemo/</span>start/<br></code></pre></td></tr></table></figure>\n\n<p>记住，如果您忽略这一点，用下面的路径代替的话：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/start/</span><br></code></pre></td></tr></table></figure>\n\n<p>软件包系统是不会正常工作的。 必须在<code>pack/</code> 和 <code>start/</code>之间添加一个名字才能正常运行。</p>\n<p>在这个示例中，让我们尝试安装 [NERDTree](<a href=\"https://github.com/preservim/nThe\">https://github.com/preservim/nThe</a> package system won’t work. It is imperative to put a name between <code>pack/</code> and <code>start/</code>.erdtree) 插件。用任意方法进入 <code>start/</code> 目录（<code>cd ~/.vim/pack/packdemo/start/</code>），然后将NERDTree的仓库克隆下来：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">git clone https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/preservim/</span>nerdtree.git<br></code></pre></td></tr></table></figure>\n\n<p>完成了！您已经完成了安装。下一次您启动Vim，您可以立即执行 NERDTree 命令 <code>:NERDTreeToggle</code>。</p>\n<p>在 <code>~/.vim/pack/*/start/</code> 目录中，您想克隆多少插件仓库就克隆多少。Vim将会自动加载每一个插件。如果您删除了克隆的仓库（<code>rm -rf nerdtree</code>），那么插件就失效了。</p>\n<h3 id=\"手动加载\"><a href=\"#手动加载\" class=\"headerlink\" title=\"手动加载\"></a>手动加载</h3><p>要想在Vim启动时手动加载插件，您得将相关插件放置在 <code>opt/</code> 目录中，类似于自动加载，这个路径看起来像这样：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<p>让我们继续使用前面的 <code>packdemo/</code> 这个名字：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/packdemo/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<p>这一次，让我们安装<a href=\"https://github.com/vim/killersheep\">killersheep</a> 游戏（需要Vim8.2以上版本）。进入<code>opt/</code> 目录(<code>cd ~/.vim/pack/packdemo/opt/</code>) 然后克隆仓库：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">git clone https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/vim/</span>killersheep.git<br></code></pre></td></tr></table></figure>\n\n<p>启动Vim。执行游戏的命令是 <code>:KillKillKill</code>。试着运行一下。Vim将会提示这不是一个有效的编辑命令。您需要首先 <em>手动</em> 加载插件，运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">:packadd</span> killersheep<br></code></pre></td></tr></table></figure>\n\n<p>现在再运行一下 <code>:KillKillKill</code> 。命令已经可以使用了。</p>\n<p>您可能好奇，“为什么我需要手动加载插件？启动时自动加载岂不是更好？”</p>\n<p>很好的问题。有时候有些插件我们并不是所有的时候都在用，比如 KillerSheep 游戏。您可能不会想要加载10个不同的游戏导致Vim启动变慢。但是偶尔当您觉得乏味的时候，您可能想要玩几个游戏，使用手动加载一些非必须的插件。</p>\n<p>您也可以使用这个方法有条件的加载插件。可能您同时使用了Neovim和Vim，有一些插件是为NeoVim优化过的。您可以添加类似下列的内容到您的vimrc中：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">has</span>(<span class=\"hljs-string\">&#x27;nvim&#x27;</span>)<br>  packadd! neovim-<span class=\"hljs-keyword\">only</span>-plugin<br><span class=\"hljs-keyword\">else</span><br>  packadd! generic-<span class=\"hljs-keyword\">vim</span>-plugin<br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"组织管理软件包\"><a href=\"#组织管理软件包\" class=\"headerlink\" title=\"组织管理软件包\"></a>组织管理软件包</h2><p>回想一下，要使用Vim的软件包系统必须有以下需求：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>start/<br></code></pre></td></tr></table></figure>\n\n<p>或者:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/*/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<p>实际上，<code>*</code>星号可以使 <em>任意</em> 名字，这个名字就可以用来管理您的插件。假设您想将您的插件根据类型（颜色、语法、游戏）分组：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/colors/</span><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/syntax/</span><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/games/</span><br></code></pre></td></tr></table></figure>\n\n<p>您仍然可以使用各个目录下的 <code>start/</code> 和 <code>opt/</code> 。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/colors/</span>start/<br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/colors/</span>opt/<br><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/syntax/</span>start/<br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/syntax/</span>opt/<br><br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/games/</span>start/<br>~<span class=\"hljs-regexp\">/.vim/</span>pack<span class=\"hljs-regexp\">/games/</span>opt/<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"聪明地添加插件\"><a href=\"#聪明地添加插件\" class=\"headerlink\" title=\"聪明地添加插件\"></a>聪明地添加插件</h2><p>您可能好奇，Vim软件包是否让一些流行的插件管理器，比如 vim-pathogen, vundle.vim, dein.vim, a还有vim-plug面临淘汰？</p>\n<p>答案永远是：“看情况而定。”</p>\n<p>我仍然使用vim-plug，因为使用它添加、删除、更新插件很容易。如果您使用了很多插件，插件管理器的好处更加明显，因为使用它可以对很多插件进行同时更新。有些插件管理器同时也提供了一些异步功能。</p>\n<p>如果您是极简主义者，可以尝试一下Vim软件包。如果您是一名插件重度使用者，您可能需要一个插件管理器。</p>\n"},{"title":"VIM-Vim Rumtime","date":"2022-04-04T16:26:39.000Z","description":"VIM相关文档","_content":"\n# 第24章 Vim Rumtime\n\n在前面的章节中，我提到Vim会自动查找一些特殊的路径，比如在`~/.vim/` 中的 `pack/`(第23章) `compiler/`（第19章）。这些都是Vim runtime路径的例子。\n\n除了上面提到的两个，Vim还有更多runtime路径。在本章，您将学习关于Vim runtime路径的高层次概述。本章的目标是向您展示它们什么时候被调用。知道这些知识能够帮您更进一步理解和定制Vim。\n\n## Runtime路径\n\n在一台Unix机器中，其中一个vim runtime路径就是 `$HOME/.vim/` （如果您用的是其他操作系统，比如Windows，您的路径可能有所不同）。要查看不同的操作系统有什么样的runtime路径，查阅 `:h runtimepath`。在本章，我将使用 `~/.vim/` 作为默认的runtime路径。\n\n## Plugin脚本\n\nVim有一个runtime路径 plugin，每次Vim启动时都会执行这个路径中的所有脚本。不要把这个名字 \"plugin\" 和Vim的外部插件（external plugins，比如NERDTree, fzf.vim, 等)搞混了。\n\n进入 `~/.vim/` 目录，然后创建 `plugin/` 子目录。 创建两个文件： `donut.vim` 和 `chocolate.vim`。\n\n在 `~/.vim/plugin/donut.vim`里面:\n\n```\necho \"donut!\"\n```\n\n在 `~/.vim/plugin/chocolate.vim`里面:\n\n```\necho \"chocolate!\"\n```\n\n现在关闭Vim。下次您启动Vim，您将会看到 `\"donut!\"` 和 `:chocolate!` 的显示。此 plugin runtime路径可以用来执行一些初始化脚本。\n\n## 文件类型检测\n\n在开始之前，为保证检测能正常运行，确保在您的vimrc中至少包含了下列的行：\n\n```\nfiletype plugin indent on\n```\n\n查阅 `:h filetype-overview` 了解更多信息。本质上，这条代码开启Vim的文件类型检测。\n\n当您打开一个新的文件，Vim通常知道这个文件是什么类型。如果您有一个文件 `hello.rb`，运行 `:set filetype?` 会返回正确的相应 `filetype=ruby`。\n\nVim知道如何检测 \"常见\" 的文件类型（Ruby, Python, Javascript, 等）。但如果是一个自定义文件会怎样呢？您需要告诉Vim去检测它，并给它指派一个正确的文件类型。\n\n有两种检测方法：使用文件名和使用文件内容\n\n### 文件名检测\n\n文件名检测使用一个文件的文件名来检测文件类型。当您打开 `hello.rb`文件时，Vim依靠扩展名 `.rb` 知道它是一个Ruby文件。\n\n有两种方法实现文件名检测：一是使用 `ftdetect` runtime目录，二是使用 `filetype.vim` runtime文件。我们两个都看一看。\n\n#### `ftdetect/`\n\n让我们创建一个古怪（但优雅）的名字，`hello.chocodonut`。当您打开它后运行 `:set filetype?` ，因为它的后缀名不是常见的文件名，Vim不知道它是什么类型，会返回 `filetype=`。\n\n您需要指示Vim将所有以 `.chocodonut`结尾的文件设置为 \"chocodonut\"类型的文件。在runtime路径根目录(`~/.vim/`)创建一个子目录，名为 `ftdetect/` 。在子目录里面，再创建一个名叫 `chocodonut.vim` 的文件（`~/.vim/ftdetect/chocodonut.vim`），在文件里面，添加：\n\n```\nautocmd BufNewFile,BufRead *.chocodonut set filetype=chocodonut\n```\n\n当您创建新buffer或打开新buffer时，事件`BufNewFile` 和 `BufRead` 就会被触发。 `*.chocodonut` 意思是只有当新打开的buffer文件名后缀是 `.chocodonut` 时事件才会被触发。最后，`set filetype=chocodonut` 命令将文件类型设置为chocodonut类型。\n\n重启Vim。新建一个 `hello.chocodonut` 文件然后运行 `:set filetype?`。它将返回 `filetype=chocodonut`.\n\n好极了！只要您想，您可以将任意多的文件放置在 `ftdetect/` 中。以后，如果您想扩展您的 donut 文件类型，你可以添加 `ftdetect/strawberrydonut.vim`, `ftdetect/plaindonut.vim` 等等。\n\n在Vim中，实际上有两种方法设置文件类型。其中给一个是您刚刚使用的 `set filetype=chocodonut`。另一种方法是运行 `setfiletype chocodonut`。前一个命令 `set filetype=chocodonut` 将 *总是* 设置文件类型为chocodonut。 而后者`setfiletype chocodonut`只有当文件类型尚未设置时，才会将文件类型设置为chocodonut。\n\n#### 文件类型文件\n\n第二种文件类型检测需要你创建一个名为 `filetype.vim`的文件，并将它放置在根目录(`~/.vim/filetype.vim`)。在文件内添加一下内容：\n\n```\nautocmd BufNewFile,BufRead *.plaindonut set filetype=plaindonut\n```\n\n创建一个名为 `hello.plaindonut` 的文件。当你打开它后运行 `:set filetype?` Vim会显示正确的自定义文件类型 `filetype=plaindonut`。\n\n太好了，修改生效了。另外，如果您仔细看看 `filetype.vim` ，您会发现当您打开`hello.plaindonut`时，这个文件文件运行了多次。为防止这一点，您可以添加一个守卫，让主脚本只运行一次。更新 `filetype.vim`:\n\n```\nif exists(\"did_load_filetypes\")\n  finish\nendif\n\naugroup donutfiletypedetection\n  autocmd! BufRead,BufNewFile *.plaindonut setfiletype plaindonut\naugroup END\n```\n\n`finish` 是一个Vim命令，用来停止执行剩余的脚本。表达式`\"did_load_filetypes\"` 并 *不是* 一个Vim内置函数。它实际上是`$VIMRUNTIME/filetype.vim` 中的一个全局变量。如果您好奇，运行`:e $VIMRUNTIME/filetype.vim`。您将会发现以下内容：\n\n```\nif exists(\"did_load_filetypes\")\n  finish\nendif\n\nlet did_load_filetypes = 1\n```\n\n当Vim调用这个文件时，它会定义 `did_load_filetypes` 变量，并将它设置为 1 。在Vim中，1 表示真。你可以试着读完 `filetype.vim` 剩余的内容，看看您是否能够理解当Vim调用它时干了什么。\n\n### 文件类型脚本\n\n让我们学习如何基于文件内容检测文件类型。\n\n假设您有一个无扩展名的文件的集合。这些文件唯一相同的地方是，第一行都是以 \"donutify\" 开头。您现在想给这些文件指派一个 `donut` 的文件类型。创建新文件，起名为 `sugardonut`, `glazeddonut`, 还有 `frieddonut`（没有扩展名）。在每个文件中，添加下列内容：\n\n```\ndonutify\n```\n\n当您在`sugardonut`中运行 `:set filetype?`，Vim无法知道应该给这个文件指派什么文件类型，会返回 `filetype=`。\n\n在runtime根目录，添加一个 `scripts.vim` 文件(`~/.vim/scripts.vim`)，在文件中，添加一下内容：\n\n```\nif did_filetype()\n  finish\nendif\n\nif getline(1) =~ '^\\\\<donutify\\\\>'\n  setfiletype donut\nendif\n```\n\n函数 `getline(1)` 返回文件第一行的内容。它检查第一行是否以 \"donutify\" 开头。函数 `did_filetype()` 是Vim的内置函数，当一个与文件类型相关的事件发生至少一次时，它返回真。它用来做守卫，防止文件类型事件反复运行。\n\n打开文件 `sugardonut` 然后运行 `:set filetype?`，Vim现在返回 `filetype=donut`。如果您打开另外一个donut文件 (`glazeddonut` 和 `frieddonut`)，Vim同样会将它们的文件类型定义为 `donut` 类型。\n\n注意，`scripts.vim` 仅当Vim打开一个未知文件类型的文件时才会运行。如果Vim打开一个已知文件类型的文件，`scripts.vim` 将不会运行。\n\n## 文件类型插件\n\n如果您想让Vim仅当您打开一个 chocodonut 文件时才运行 chocodonut 相关的特殊脚本，而当您打开的是 plaindonut 文件时，Vim就不运行这些脚本。能否做到呢？\n\n您可以使用文件类型插件runtime路径(`~/.vim/ftplugin/`)来完成这个功能。Vim会在这个目录中查找一个文件，这个文件的文件名与您打开的文件类型一样。创建一个文件，起名为`chocodonut.vim` (`~/.vim/ftplugin/chocodonut.vim`):\n\n```\necho \"Calling from chocodonut ftplugin\"\n```\n\n创建另一个 ftplugin 文件，起名为`plaindonut.vim` (`~/.vim/ftplugin/plaindonut.vim`):\n\n```\necho \"Calling from plaindonut ftplugin\"\n```\n\n现在，每次您打开一个 chocodonut 类型的文件时，Vim会运行 `~/.vim/ftplugin/chocodonut.vim`中的脚本。每次您打开 plaindonut 类型的文件时，Vim会运行 `~/.vim/ftplugin/plaindonut.vim` 中的脚本。\n\n一个警告：每当一个buffer的文件类型被设置时(比如，`set filetype=chocodonut`)，上述脚本就会运行一次。如果您打开3个不同的 chocodonut 文件，该脚本将运行 *总共* 3次。\n\n## 缩进文件\n\nVim有一个 缩进runtime路径，其工作方式与ftplugin类似，Vim也会在这个目录中查找一个与打开的文件类型名字一样的文件。缩进runtime路径的目的是存储缩进相关的代码。如果您有文件 `~/.vim/indent/chocodonut.vim`，它仅当您打开一个 chocodonut 类型的文件时执行。您可以将 chocodonut 文件中缩进相关的代码存储在这里。\n\n## 颜色\n\nVim 有一个颜色runtime路径 (`~/.vim/colors/`) ，用来存储颜色主题。这个目录中的任何文件都会在命令行命令 `:color` 中显示出来。\n\n如果您有一个文件 `~/.vim/colors/beautifulprettycolors.vim`，当您运行 `:color` 然后按 Tab，您将会看到 `beautifulprettycolors` 出现在颜色选项中。  如果您想添加自己的颜色主题，就放在这个地方。\n\n如果您想看其他人做的颜色主题，有一个好地方值得推荐：[vimcolors](https://vimcolors.com/)。\n\n## 语法高亮\n\nVim有一个语法runtime路径 (`~/.vim/syntax/`)，用来定义语法高亮。\n\n假设您有一个文件 `hello.chocodonut`，在文件里面有以下内容：\n\n```\n(donut \"tasty\")\n(donut \"savory\")\n```\n\n虽然Vim现在知道了正确的文件类型，但所有的文本都是相同的颜色。让我们添加语法高亮规则，使 \"donut\" 关键词高亮显示。创建一个新的 chocodonut 语法文件 `~/.vim/syntax/chocodonut.vim`，在文件中添加：\n\n```\nsyntax keyword donutKeyword donut\n\nhighlight link donutKeyword Keyword\n```\n\n现在重新打开 `hello.chocodonut` 文件，关键词 `donut` 已经高亮显示了。\n\n本章不会详细介绍语法高亮。它是一个庞大的主题。如果您感兴趣，可以查阅 `:h syntax.txt`。\n\n[vim-polyglot](https://github.com/sheerun/vim-polyglot) 插件非常的棒，它提供了很多流行的编程语言的语法高亮。\n\n## 文档\n\n如果您写了一个插件，您还得创建一个您自己的文档。您可以使用文档runtime路径完成这个。\n\n让我们为 chocodonut 和 plaindonut 关键字创建一个基本文档。创建文件 `donut.txt` (`~/.vim/doc/donut.txt`)。在文件中，添加一下内容：\n\n```\n*chocodonut* Delicious chocolate donut\n\n*plaindonut* No choco goodness but still delicious nonetheless\n```\n\n如果您试着搜索 `chocodonut` 或 `plaindonut` (`:h chocodonut` 或 `:h plaindonut`)，您找不到任何东西。\n\n首先，你需要运行 `:helptags`来创建新的帮助入口。运行 `:helptags ~/.vim/doc/`\n\n现在，如果您运行 `:h chocodonut` 或 `:h plaindonut`，您将找到上面那些新的帮助入口。注意，现在文件是只读的，而且类型是 \"help\"。\n\n## 延时加载脚本\n\n到现在，本章您学到的所有runtime路径都是自动运行的。如果您想手动加载一个脚本，可使用 autoload runtime路径。\n\n创建一个目录名为 autoload(`~/.vim/autoload/`)。在目录中，创建一个新文件，起名为 `tasty.vim` (`~/.vim/autoload/tasty.vim`)。在文件中：\n\n```\necho \"tasty.vim global\"\n\nfunction tasty#donut()\n  echo \"tasty#donut\"\nendfunction\n```\n\n注意，函数名是 `tasty#donut` 而不是 `donut()`。要想使用autoload功能，井号(`#`)是必须的。在使用autoload功能时，函数的命名惯例是：\n\n```\nfunction fileName#functionName()\n  ...\nendfunction\n```\n\n在本例中，文件名是 `tasty.vim`，而函数名是`donut`。\n\n要调用一个函数，可以使用 `call` 命令。让我们call这个函数 `:call tasty#donut()`。\n\n您第一次调用这个函数时，您应当会 *同时* 看到两条信息 (\"tasty.vim global\" 和 \"tasty#donut\") 。后面再调用 `tasty#donut` 函数，将只会显示 \"testy#donut\"。\n\n当您在Vim中打开一个文件，不像前面说的runtime路径，autoload脚本不会被自动加载。仅当您显式地调用 `tasty#donut()`，Vim才会查找文件`tasty.vim`，然后加载文件中的内容，包括函数 `tasty#donut()`。有些函数会占用大量资源，但我们又不常用，这时候 Autoload runtime路径就是最佳的解决方案。 \n\n您可以在autoload目录任意添加嵌套的目录。如果您有一个runtime路径 `~/.vim/autoload/one/two/three/tasty.vim`，您可以使用`:call one#two#three#tasty#donut()`来调用函数。\n\n## After脚本\n\nVim有一个 after runtime路径 (`~/.vim/after/`) ，它的结构是 `~/.vim/`的镜像。在此目录中的任何脚本都会最后执行，所以开发者通常使用这个路径来重载脚本。\n\n比如，如果您想重载 `plugin/chocolate.vim` 中的脚本，您可以创建`~/.vim/after/plugin/chocolate.vim`来放置重载脚本。Vim将会先运行 `~/.vim/plugin/chocolate.vim`， *然后运行* `~/.vim/after/plugin/chocolate.vim`\n\n## $VIMRUNTIME\n\nVim有一个环境变量 `$VIMRUNTIME` 用来加载默认脚本和支持文件。您可以运行 `:e $VIMRUNTIME`查看。\n\n它的结构应该看起来很熟悉。它包含的很多runtime路径都是我们本章前面学过的。\n\n回想第22章，当您打开Vim时，它会在6个不同的位置查找vimrc文件。当时我说最后一个位置就是 `$VIMRUNTIME/default.vim`，如果Vim在前5个位置查找用户vimrc文件失败，就会使用`default.vim` 作为vimrc。\n\n不知您是否尝试过，运行Vim是不加载比如vim-polyglot之类的语法插件，但您的文件依然有语法高亮?这是因为当Vim在runtime路径查找语法文件失败时，会从`$VIMRUNTIME` 的语法目录中查找语法文件。\n\n查阅 `:h $VIMRUNTIME`了解更多信息。\n\n## Runtimepath选项\n\n运行 `:set runtimepath?`，可以查看您的runtime路径。\n\n如果您使用 Vim-Plug 或其他流行的第三方插件管理器，它应该会显示一个目录列表。比如，我的显示如下：\n\n```\nruntimepath=~/.vim,~/.vim/plugged/vim-signify,~/.vim/plugged/base16-vim,~/.vim/plugged/fzf.vim,~/.vim/plugged/fzf,~/.vim/plugged/vim-gutentags,~/.vim/plugged/tcomment_vim,~/.vim/plugged/emmet-vim,~/.vim/plugged/vim-fugitive,~/.vim/plugged/vim-sensible,~/.vim/plugged/lightline.vim, ...\n```\n\n插件管理器做了一件事，就是将每个插件添加到runtime路径中。每个runtime路径都有一个类似 `~/.vim/`的目录结构。\n\n如果您有一个目录 `~/box/of/donuts/`，然后您想将这个目录添加到您的runtime路径中，您可以在vimrc中添加以下内容：\n\n```\nset rtp+=$HOME/box/of/donuts/\n```\n\n如果在 `~/box/of/donuts/` 里面，您有一个plugin目录 (`~/box/of/donuts/plugin/hello.vim`) 以及ftplugin目录 (`~/box/of/donuts/ftplugin/chocodonut.vim`)，当您打开Vim时，Vim将会运行 `plugin/hello.vim` 中所有脚本。同样，当您打开一个 chocodonut 文件时，Vim 将会运行 `ftplugin/chocodonut.vim`。\n\n自己试着做一下：创建一个任意目录，然后将它添加到您的 runtimepath中。添加一些我们本章学到的runtime路径。确保它们按预期工作。\n\n## 聪明地学习Runtime\n\n花点时间阅读本章，还有认真研究一下这些runtime路径。看一下真实环境下runtime路径是如何使用的。浏览一下您最喜欢的Vim插件仓库，仔细研究一下它的目录结构，您应该能够理解它们中的绝大部分。试着领会重点并跟着做。现在您已经理解了Vim的目录结构，您可以准备学习Vimscript了。\n","source":"_posts/Vim/ch24_vim_runtime.md","raw":"---\ntitle: VIM-Vim Rumtime\ndate: 2022-04-05 00:26:39\ntags:\n  - [VIM]\n  - [编辑器]\ncategories:\n  - [技术]\ndescription: VIM相关文档\n---\n\n# 第24章 Vim Rumtime\n\n在前面的章节中，我提到Vim会自动查找一些特殊的路径，比如在`~/.vim/` 中的 `pack/`(第23章) `compiler/`（第19章）。这些都是Vim runtime路径的例子。\n\n除了上面提到的两个，Vim还有更多runtime路径。在本章，您将学习关于Vim runtime路径的高层次概述。本章的目标是向您展示它们什么时候被调用。知道这些知识能够帮您更进一步理解和定制Vim。\n\n## Runtime路径\n\n在一台Unix机器中，其中一个vim runtime路径就是 `$HOME/.vim/` （如果您用的是其他操作系统，比如Windows，您的路径可能有所不同）。要查看不同的操作系统有什么样的runtime路径，查阅 `:h runtimepath`。在本章，我将使用 `~/.vim/` 作为默认的runtime路径。\n\n## Plugin脚本\n\nVim有一个runtime路径 plugin，每次Vim启动时都会执行这个路径中的所有脚本。不要把这个名字 \"plugin\" 和Vim的外部插件（external plugins，比如NERDTree, fzf.vim, 等)搞混了。\n\n进入 `~/.vim/` 目录，然后创建 `plugin/` 子目录。 创建两个文件： `donut.vim` 和 `chocolate.vim`。\n\n在 `~/.vim/plugin/donut.vim`里面:\n\n```\necho \"donut!\"\n```\n\n在 `~/.vim/plugin/chocolate.vim`里面:\n\n```\necho \"chocolate!\"\n```\n\n现在关闭Vim。下次您启动Vim，您将会看到 `\"donut!\"` 和 `:chocolate!` 的显示。此 plugin runtime路径可以用来执行一些初始化脚本。\n\n## 文件类型检测\n\n在开始之前，为保证检测能正常运行，确保在您的vimrc中至少包含了下列的行：\n\n```\nfiletype plugin indent on\n```\n\n查阅 `:h filetype-overview` 了解更多信息。本质上，这条代码开启Vim的文件类型检测。\n\n当您打开一个新的文件，Vim通常知道这个文件是什么类型。如果您有一个文件 `hello.rb`，运行 `:set filetype?` 会返回正确的相应 `filetype=ruby`。\n\nVim知道如何检测 \"常见\" 的文件类型（Ruby, Python, Javascript, 等）。但如果是一个自定义文件会怎样呢？您需要告诉Vim去检测它，并给它指派一个正确的文件类型。\n\n有两种检测方法：使用文件名和使用文件内容\n\n### 文件名检测\n\n文件名检测使用一个文件的文件名来检测文件类型。当您打开 `hello.rb`文件时，Vim依靠扩展名 `.rb` 知道它是一个Ruby文件。\n\n有两种方法实现文件名检测：一是使用 `ftdetect` runtime目录，二是使用 `filetype.vim` runtime文件。我们两个都看一看。\n\n#### `ftdetect/`\n\n让我们创建一个古怪（但优雅）的名字，`hello.chocodonut`。当您打开它后运行 `:set filetype?` ，因为它的后缀名不是常见的文件名，Vim不知道它是什么类型，会返回 `filetype=`。\n\n您需要指示Vim将所有以 `.chocodonut`结尾的文件设置为 \"chocodonut\"类型的文件。在runtime路径根目录(`~/.vim/`)创建一个子目录，名为 `ftdetect/` 。在子目录里面，再创建一个名叫 `chocodonut.vim` 的文件（`~/.vim/ftdetect/chocodonut.vim`），在文件里面，添加：\n\n```\nautocmd BufNewFile,BufRead *.chocodonut set filetype=chocodonut\n```\n\n当您创建新buffer或打开新buffer时，事件`BufNewFile` 和 `BufRead` 就会被触发。 `*.chocodonut` 意思是只有当新打开的buffer文件名后缀是 `.chocodonut` 时事件才会被触发。最后，`set filetype=chocodonut` 命令将文件类型设置为chocodonut类型。\n\n重启Vim。新建一个 `hello.chocodonut` 文件然后运行 `:set filetype?`。它将返回 `filetype=chocodonut`.\n\n好极了！只要您想，您可以将任意多的文件放置在 `ftdetect/` 中。以后，如果您想扩展您的 donut 文件类型，你可以添加 `ftdetect/strawberrydonut.vim`, `ftdetect/plaindonut.vim` 等等。\n\n在Vim中，实际上有两种方法设置文件类型。其中给一个是您刚刚使用的 `set filetype=chocodonut`。另一种方法是运行 `setfiletype chocodonut`。前一个命令 `set filetype=chocodonut` 将 *总是* 设置文件类型为chocodonut。 而后者`setfiletype chocodonut`只有当文件类型尚未设置时，才会将文件类型设置为chocodonut。\n\n#### 文件类型文件\n\n第二种文件类型检测需要你创建一个名为 `filetype.vim`的文件，并将它放置在根目录(`~/.vim/filetype.vim`)。在文件内添加一下内容：\n\n```\nautocmd BufNewFile,BufRead *.plaindonut set filetype=plaindonut\n```\n\n创建一个名为 `hello.plaindonut` 的文件。当你打开它后运行 `:set filetype?` Vim会显示正确的自定义文件类型 `filetype=plaindonut`。\n\n太好了，修改生效了。另外，如果您仔细看看 `filetype.vim` ，您会发现当您打开`hello.plaindonut`时，这个文件文件运行了多次。为防止这一点，您可以添加一个守卫，让主脚本只运行一次。更新 `filetype.vim`:\n\n```\nif exists(\"did_load_filetypes\")\n  finish\nendif\n\naugroup donutfiletypedetection\n  autocmd! BufRead,BufNewFile *.plaindonut setfiletype plaindonut\naugroup END\n```\n\n`finish` 是一个Vim命令，用来停止执行剩余的脚本。表达式`\"did_load_filetypes\"` 并 *不是* 一个Vim内置函数。它实际上是`$VIMRUNTIME/filetype.vim` 中的一个全局变量。如果您好奇，运行`:e $VIMRUNTIME/filetype.vim`。您将会发现以下内容：\n\n```\nif exists(\"did_load_filetypes\")\n  finish\nendif\n\nlet did_load_filetypes = 1\n```\n\n当Vim调用这个文件时，它会定义 `did_load_filetypes` 变量，并将它设置为 1 。在Vim中，1 表示真。你可以试着读完 `filetype.vim` 剩余的内容，看看您是否能够理解当Vim调用它时干了什么。\n\n### 文件类型脚本\n\n让我们学习如何基于文件内容检测文件类型。\n\n假设您有一个无扩展名的文件的集合。这些文件唯一相同的地方是，第一行都是以 \"donutify\" 开头。您现在想给这些文件指派一个 `donut` 的文件类型。创建新文件，起名为 `sugardonut`, `glazeddonut`, 还有 `frieddonut`（没有扩展名）。在每个文件中，添加下列内容：\n\n```\ndonutify\n```\n\n当您在`sugardonut`中运行 `:set filetype?`，Vim无法知道应该给这个文件指派什么文件类型，会返回 `filetype=`。\n\n在runtime根目录，添加一个 `scripts.vim` 文件(`~/.vim/scripts.vim`)，在文件中，添加一下内容：\n\n```\nif did_filetype()\n  finish\nendif\n\nif getline(1) =~ '^\\\\<donutify\\\\>'\n  setfiletype donut\nendif\n```\n\n函数 `getline(1)` 返回文件第一行的内容。它检查第一行是否以 \"donutify\" 开头。函数 `did_filetype()` 是Vim的内置函数，当一个与文件类型相关的事件发生至少一次时，它返回真。它用来做守卫，防止文件类型事件反复运行。\n\n打开文件 `sugardonut` 然后运行 `:set filetype?`，Vim现在返回 `filetype=donut`。如果您打开另外一个donut文件 (`glazeddonut` 和 `frieddonut`)，Vim同样会将它们的文件类型定义为 `donut` 类型。\n\n注意，`scripts.vim` 仅当Vim打开一个未知文件类型的文件时才会运行。如果Vim打开一个已知文件类型的文件，`scripts.vim` 将不会运行。\n\n## 文件类型插件\n\n如果您想让Vim仅当您打开一个 chocodonut 文件时才运行 chocodonut 相关的特殊脚本，而当您打开的是 plaindonut 文件时，Vim就不运行这些脚本。能否做到呢？\n\n您可以使用文件类型插件runtime路径(`~/.vim/ftplugin/`)来完成这个功能。Vim会在这个目录中查找一个文件，这个文件的文件名与您打开的文件类型一样。创建一个文件，起名为`chocodonut.vim` (`~/.vim/ftplugin/chocodonut.vim`):\n\n```\necho \"Calling from chocodonut ftplugin\"\n```\n\n创建另一个 ftplugin 文件，起名为`plaindonut.vim` (`~/.vim/ftplugin/plaindonut.vim`):\n\n```\necho \"Calling from plaindonut ftplugin\"\n```\n\n现在，每次您打开一个 chocodonut 类型的文件时，Vim会运行 `~/.vim/ftplugin/chocodonut.vim`中的脚本。每次您打开 plaindonut 类型的文件时，Vim会运行 `~/.vim/ftplugin/plaindonut.vim` 中的脚本。\n\n一个警告：每当一个buffer的文件类型被设置时(比如，`set filetype=chocodonut`)，上述脚本就会运行一次。如果您打开3个不同的 chocodonut 文件，该脚本将运行 *总共* 3次。\n\n## 缩进文件\n\nVim有一个 缩进runtime路径，其工作方式与ftplugin类似，Vim也会在这个目录中查找一个与打开的文件类型名字一样的文件。缩进runtime路径的目的是存储缩进相关的代码。如果您有文件 `~/.vim/indent/chocodonut.vim`，它仅当您打开一个 chocodonut 类型的文件时执行。您可以将 chocodonut 文件中缩进相关的代码存储在这里。\n\n## 颜色\n\nVim 有一个颜色runtime路径 (`~/.vim/colors/`) ，用来存储颜色主题。这个目录中的任何文件都会在命令行命令 `:color` 中显示出来。\n\n如果您有一个文件 `~/.vim/colors/beautifulprettycolors.vim`，当您运行 `:color` 然后按 Tab，您将会看到 `beautifulprettycolors` 出现在颜色选项中。  如果您想添加自己的颜色主题，就放在这个地方。\n\n如果您想看其他人做的颜色主题，有一个好地方值得推荐：[vimcolors](https://vimcolors.com/)。\n\n## 语法高亮\n\nVim有一个语法runtime路径 (`~/.vim/syntax/`)，用来定义语法高亮。\n\n假设您有一个文件 `hello.chocodonut`，在文件里面有以下内容：\n\n```\n(donut \"tasty\")\n(donut \"savory\")\n```\n\n虽然Vim现在知道了正确的文件类型，但所有的文本都是相同的颜色。让我们添加语法高亮规则，使 \"donut\" 关键词高亮显示。创建一个新的 chocodonut 语法文件 `~/.vim/syntax/chocodonut.vim`，在文件中添加：\n\n```\nsyntax keyword donutKeyword donut\n\nhighlight link donutKeyword Keyword\n```\n\n现在重新打开 `hello.chocodonut` 文件，关键词 `donut` 已经高亮显示了。\n\n本章不会详细介绍语法高亮。它是一个庞大的主题。如果您感兴趣，可以查阅 `:h syntax.txt`。\n\n[vim-polyglot](https://github.com/sheerun/vim-polyglot) 插件非常的棒，它提供了很多流行的编程语言的语法高亮。\n\n## 文档\n\n如果您写了一个插件，您还得创建一个您自己的文档。您可以使用文档runtime路径完成这个。\n\n让我们为 chocodonut 和 plaindonut 关键字创建一个基本文档。创建文件 `donut.txt` (`~/.vim/doc/donut.txt`)。在文件中，添加一下内容：\n\n```\n*chocodonut* Delicious chocolate donut\n\n*plaindonut* No choco goodness but still delicious nonetheless\n```\n\n如果您试着搜索 `chocodonut` 或 `plaindonut` (`:h chocodonut` 或 `:h plaindonut`)，您找不到任何东西。\n\n首先，你需要运行 `:helptags`来创建新的帮助入口。运行 `:helptags ~/.vim/doc/`\n\n现在，如果您运行 `:h chocodonut` 或 `:h plaindonut`，您将找到上面那些新的帮助入口。注意，现在文件是只读的，而且类型是 \"help\"。\n\n## 延时加载脚本\n\n到现在，本章您学到的所有runtime路径都是自动运行的。如果您想手动加载一个脚本，可使用 autoload runtime路径。\n\n创建一个目录名为 autoload(`~/.vim/autoload/`)。在目录中，创建一个新文件，起名为 `tasty.vim` (`~/.vim/autoload/tasty.vim`)。在文件中：\n\n```\necho \"tasty.vim global\"\n\nfunction tasty#donut()\n  echo \"tasty#donut\"\nendfunction\n```\n\n注意，函数名是 `tasty#donut` 而不是 `donut()`。要想使用autoload功能，井号(`#`)是必须的。在使用autoload功能时，函数的命名惯例是：\n\n```\nfunction fileName#functionName()\n  ...\nendfunction\n```\n\n在本例中，文件名是 `tasty.vim`，而函数名是`donut`。\n\n要调用一个函数，可以使用 `call` 命令。让我们call这个函数 `:call tasty#donut()`。\n\n您第一次调用这个函数时，您应当会 *同时* 看到两条信息 (\"tasty.vim global\" 和 \"tasty#donut\") 。后面再调用 `tasty#donut` 函数，将只会显示 \"testy#donut\"。\n\n当您在Vim中打开一个文件，不像前面说的runtime路径，autoload脚本不会被自动加载。仅当您显式地调用 `tasty#donut()`，Vim才会查找文件`tasty.vim`，然后加载文件中的内容，包括函数 `tasty#donut()`。有些函数会占用大量资源，但我们又不常用，这时候 Autoload runtime路径就是最佳的解决方案。 \n\n您可以在autoload目录任意添加嵌套的目录。如果您有一个runtime路径 `~/.vim/autoload/one/two/three/tasty.vim`，您可以使用`:call one#two#three#tasty#donut()`来调用函数。\n\n## After脚本\n\nVim有一个 after runtime路径 (`~/.vim/after/`) ，它的结构是 `~/.vim/`的镜像。在此目录中的任何脚本都会最后执行，所以开发者通常使用这个路径来重载脚本。\n\n比如，如果您想重载 `plugin/chocolate.vim` 中的脚本，您可以创建`~/.vim/after/plugin/chocolate.vim`来放置重载脚本。Vim将会先运行 `~/.vim/plugin/chocolate.vim`， *然后运行* `~/.vim/after/plugin/chocolate.vim`\n\n## $VIMRUNTIME\n\nVim有一个环境变量 `$VIMRUNTIME` 用来加载默认脚本和支持文件。您可以运行 `:e $VIMRUNTIME`查看。\n\n它的结构应该看起来很熟悉。它包含的很多runtime路径都是我们本章前面学过的。\n\n回想第22章，当您打开Vim时，它会在6个不同的位置查找vimrc文件。当时我说最后一个位置就是 `$VIMRUNTIME/default.vim`，如果Vim在前5个位置查找用户vimrc文件失败，就会使用`default.vim` 作为vimrc。\n\n不知您是否尝试过，运行Vim是不加载比如vim-polyglot之类的语法插件，但您的文件依然有语法高亮?这是因为当Vim在runtime路径查找语法文件失败时，会从`$VIMRUNTIME` 的语法目录中查找语法文件。\n\n查阅 `:h $VIMRUNTIME`了解更多信息。\n\n## Runtimepath选项\n\n运行 `:set runtimepath?`，可以查看您的runtime路径。\n\n如果您使用 Vim-Plug 或其他流行的第三方插件管理器，它应该会显示一个目录列表。比如，我的显示如下：\n\n```\nruntimepath=~/.vim,~/.vim/plugged/vim-signify,~/.vim/plugged/base16-vim,~/.vim/plugged/fzf.vim,~/.vim/plugged/fzf,~/.vim/plugged/vim-gutentags,~/.vim/plugged/tcomment_vim,~/.vim/plugged/emmet-vim,~/.vim/plugged/vim-fugitive,~/.vim/plugged/vim-sensible,~/.vim/plugged/lightline.vim, ...\n```\n\n插件管理器做了一件事，就是将每个插件添加到runtime路径中。每个runtime路径都有一个类似 `~/.vim/`的目录结构。\n\n如果您有一个目录 `~/box/of/donuts/`，然后您想将这个目录添加到您的runtime路径中，您可以在vimrc中添加以下内容：\n\n```\nset rtp+=$HOME/box/of/donuts/\n```\n\n如果在 `~/box/of/donuts/` 里面，您有一个plugin目录 (`~/box/of/donuts/plugin/hello.vim`) 以及ftplugin目录 (`~/box/of/donuts/ftplugin/chocodonut.vim`)，当您打开Vim时，Vim将会运行 `plugin/hello.vim` 中所有脚本。同样，当您打开一个 chocodonut 文件时，Vim 将会运行 `ftplugin/chocodonut.vim`。\n\n自己试着做一下：创建一个任意目录，然后将它添加到您的 runtimepath中。添加一些我们本章学到的runtime路径。确保它们按预期工作。\n\n## 聪明地学习Runtime\n\n花点时间阅读本章，还有认真研究一下这些runtime路径。看一下真实环境下runtime路径是如何使用的。浏览一下您最喜欢的Vim插件仓库，仔细研究一下它的目录结构，您应该能够理解它们中的绝大部分。试着领会重点并跟着做。现在您已经理解了Vim的目录结构，您可以准备学习Vimscript了。\n","slug":"Vim/ch24_vim_runtime","published":1,"updated":"2022-08-28T07:38:59.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i28002xscvmhjkd9hlr","content":"<h1 id=\"第24章-Vim-Rumtime\"><a href=\"#第24章-Vim-Rumtime\" class=\"headerlink\" title=\"第24章 Vim Rumtime\"></a>第24章 Vim Rumtime</h1><p>在前面的章节中，我提到Vim会自动查找一些特殊的路径，比如在<code>~/.vim/</code> 中的 <code>pack/</code>(第23章) <code>compiler/</code>（第19章）。这些都是Vim runtime路径的例子。</p>\n<p>除了上面提到的两个，Vim还有更多runtime路径。在本章，您将学习关于Vim runtime路径的高层次概述。本章的目标是向您展示它们什么时候被调用。知道这些知识能够帮您更进一步理解和定制Vim。</p>\n<h2 id=\"Runtime路径\"><a href=\"#Runtime路径\" class=\"headerlink\" title=\"Runtime路径\"></a>Runtime路径</h2><p>在一台Unix机器中，其中一个vim runtime路径就是 <code>$HOME/.vim/</code> （如果您用的是其他操作系统，比如Windows，您的路径可能有所不同）。要查看不同的操作系统有什么样的runtime路径，查阅 <code>:h runtimepath</code>。在本章，我将使用 <code>~/.vim/</code> 作为默认的runtime路径。</p>\n<h2 id=\"Plugin脚本\"><a href=\"#Plugin脚本\" class=\"headerlink\" title=\"Plugin脚本\"></a>Plugin脚本</h2><p>Vim有一个runtime路径 plugin，每次Vim启动时都会执行这个路径中的所有脚本。不要把这个名字 “plugin” 和Vim的外部插件（external plugins，比如NERDTree, fzf.vim, 等)搞混了。</p>\n<p>进入 <code>~/.vim/</code> 目录，然后创建 <code>plugin/</code> 子目录。 创建两个文件： <code>donut.vim</code> 和 <code>chocolate.vim</code>。</p>\n<p>在 <code>~/.vim/plugin/donut.vim</code>里面:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;donut!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/plugin/chocolate.vim</code>里面:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;chocolate!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>现在关闭Vim。下次您启动Vim，您将会看到 <code>&quot;donut!&quot;</code> 和 <code>:chocolate!</code> 的显示。此 plugin runtime路径可以用来执行一些初始化脚本。</p>\n<h2 id=\"文件类型检测\"><a href=\"#文件类型检测\" class=\"headerlink\" title=\"文件类型检测\"></a>文件类型检测</h2><p>在开始之前，为保证检测能正常运行，确保在您的vimrc中至少包含了下列的行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">filetype</span> plugin <span class=\"hljs-built_in\">indent</span> <span class=\"hljs-keyword\">on</span><br></code></pre></td></tr></table></figure>\n\n<p>查阅 <code>:h filetype-overview</code> 了解更多信息。本质上，这条代码开启Vim的文件类型检测。</p>\n<p>当您打开一个新的文件，Vim通常知道这个文件是什么类型。如果您有一个文件 <code>hello.rb</code>，运行 <code>:set filetype?</code> 会返回正确的相应 <code>filetype=ruby</code>。</p>\n<p>Vim知道如何检测 “常见” 的文件类型（Ruby, Python, Javascript, 等）。但如果是一个自定义文件会怎样呢？您需要告诉Vim去检测它，并给它指派一个正确的文件类型。</p>\n<p>有两种检测方法：使用文件名和使用文件内容</p>\n<h3 id=\"文件名检测\"><a href=\"#文件名检测\" class=\"headerlink\" title=\"文件名检测\"></a>文件名检测</h3><p>文件名检测使用一个文件的文件名来检测文件类型。当您打开 <code>hello.rb</code>文件时，Vim依靠扩展名 <code>.rb</code> 知道它是一个Ruby文件。</p>\n<p>有两种方法实现文件名检测：一是使用 <code>ftdetect</code> runtime目录，二是使用 <code>filetype.vim</code> runtime文件。我们两个都看一看。</p>\n<h4 id=\"ftdetect\"><a href=\"#ftdetect\" class=\"headerlink\" title=\"ftdetect/\"></a><code>ftdetect/</code></h4><p>让我们创建一个古怪（但优雅）的名字，<code>hello.chocodonut</code>。当您打开它后运行 <code>:set filetype?</code> ，因为它的后缀名不是常见的文件名，Vim不知道它是什么类型，会返回 <code>filetype=</code>。</p>\n<p>您需要指示Vim将所有以 <code>.chocodonut</code>结尾的文件设置为 “chocodonut”类型的文件。在runtime路径根目录(<code>~/.vim/</code>)创建一个子目录，名为 <code>ftdetect/</code> 。在子目录里面，再创建一个名叫 <code>chocodonut.vim</code> 的文件（<code>~/.vim/ftdetect/chocodonut.vim</code>），在文件里面，添加：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">autocmd BufNewFile,BufRead *.chocodonut <span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">filetype</span>=chocodonut<br></code></pre></td></tr></table></figure>\n\n<p>当您创建新buffer或打开新buffer时，事件<code>BufNewFile</code> 和 <code>BufRead</code> 就会被触发。 <code>*.chocodonut</code> 意思是只有当新打开的buffer文件名后缀是 <code>.chocodonut</code> 时事件才会被触发。最后，<code>set filetype=chocodonut</code> 命令将文件类型设置为chocodonut类型。</p>\n<p>重启Vim。新建一个 <code>hello.chocodonut</code> 文件然后运行 <code>:set filetype?</code>。它将返回 <code>filetype=chocodonut</code>.</p>\n<p>好极了！只要您想，您可以将任意多的文件放置在 <code>ftdetect/</code> 中。以后，如果您想扩展您的 donut 文件类型，你可以添加 <code>ftdetect/strawberrydonut.vim</code>, <code>ftdetect/plaindonut.vim</code> 等等。</p>\n<p>在Vim中，实际上有两种方法设置文件类型。其中给一个是您刚刚使用的 <code>set filetype=chocodonut</code>。另一种方法是运行 <code>setfiletype chocodonut</code>。前一个命令 <code>set filetype=chocodonut</code> 将 <em>总是</em> 设置文件类型为chocodonut。 而后者<code>setfiletype chocodonut</code>只有当文件类型尚未设置时，才会将文件类型设置为chocodonut。</p>\n<h4 id=\"文件类型文件\"><a href=\"#文件类型文件\" class=\"headerlink\" title=\"文件类型文件\"></a>文件类型文件</h4><p>第二种文件类型检测需要你创建一个名为 <code>filetype.vim</code>的文件，并将它放置在根目录(<code>~/.vim/filetype.vim</code>)。在文件内添加一下内容：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">autocmd BufNewFile,BufRead *.plaindonut <span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">filetype</span>=plaindonut<br></code></pre></td></tr></table></figure>\n\n<p>创建一个名为 <code>hello.plaindonut</code> 的文件。当你打开它后运行 <code>:set filetype?</code> Vim会显示正确的自定义文件类型 <code>filetype=plaindonut</code>。</p>\n<p>太好了，修改生效了。另外，如果您仔细看看 <code>filetype.vim</code> ，您会发现当您打开<code>hello.plaindonut</code>时，这个文件文件运行了多次。为防止这一点，您可以添加一个守卫，让主脚本只运行一次。更新 <code>filetype.vim</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">exists</span>(<span class=\"hljs-string\">&quot;did_load_filetypes&quot;</span>)<br>  <span class=\"hljs-keyword\">finish</span><br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-keyword\">augroup</span> donutfiletypedetection<br>  autocmd! BufRead,BufNewFile *.plaindonut <span class=\"hljs-keyword\">setfiletype</span> plaindonut<br><span class=\"hljs-keyword\">augroup</span> END<br></code></pre></td></tr></table></figure>\n\n<p><code>finish</code> 是一个Vim命令，用来停止执行剩余的脚本。表达式<code>&quot;did_load_filetypes&quot;</code> 并 <em>不是</em> 一个Vim内置函数。它实际上是<code>$VIMRUNTIME/filetype.vim</code> 中的一个全局变量。如果您好奇，运行<code>:e $VIMRUNTIME/filetype.vim</code>。您将会发现以下内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">exists</span>(<span class=\"hljs-string\">&quot;did_load_filetypes&quot;</span>)<br>  <span class=\"hljs-keyword\">finish</span><br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-keyword\">let</span> did_load_filetypes = <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>当Vim调用这个文件时，它会定义 <code>did_load_filetypes</code> 变量，并将它设置为 1 。在Vim中，1 表示真。你可以试着读完 <code>filetype.vim</code> 剩余的内容，看看您是否能够理解当Vim调用它时干了什么。</p>\n<h3 id=\"文件类型脚本\"><a href=\"#文件类型脚本\" class=\"headerlink\" title=\"文件类型脚本\"></a>文件类型脚本</h3><p>让我们学习如何基于文件内容检测文件类型。</p>\n<p>假设您有一个无扩展名的文件的集合。这些文件唯一相同的地方是，第一行都是以 “donutify” 开头。您现在想给这些文件指派一个 <code>donut</code> 的文件类型。创建新文件，起名为 <code>sugardonut</code>, <code>glazeddonut</code>, 还有 <code>frieddonut</code>（没有扩展名）。在每个文件中，添加下列内容：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">donutify</span><br></code></pre></td></tr></table></figure>\n\n<p>当您在<code>sugardonut</code>中运行 <code>:set filetype?</code>，Vim无法知道应该给这个文件指派什么文件类型，会返回 <code>filetype=</code>。</p>\n<p>在runtime根目录，添加一个 <code>scripts.vim</code> 文件(<code>~/.vim/scripts.vim</code>)，在文件中，添加一下内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">did_filetype</span>()<br>  <span class=\"hljs-keyword\">finish</span><br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">getline</span>(<span class=\"hljs-number\">1</span>) =~ <span class=\"hljs-string\">&#x27;^\\\\&lt;donutify\\\\&gt;&#x27;</span><br>  <span class=\"hljs-keyword\">setfiletype</span> donut<br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n\n<p>函数 <code>getline(1)</code> 返回文件第一行的内容。它检查第一行是否以 “donutify” 开头。函数 <code>did_filetype()</code> 是Vim的内置函数，当一个与文件类型相关的事件发生至少一次时，它返回真。它用来做守卫，防止文件类型事件反复运行。</p>\n<p>打开文件 <code>sugardonut</code> 然后运行 <code>:set filetype?</code>，Vim现在返回 <code>filetype=donut</code>。如果您打开另外一个donut文件 (<code>glazeddonut</code> 和 <code>frieddonut</code>)，Vim同样会将它们的文件类型定义为 <code>donut</code> 类型。</p>\n<p>注意，<code>scripts.vim</code> 仅当Vim打开一个未知文件类型的文件时才会运行。如果Vim打开一个已知文件类型的文件，<code>scripts.vim</code> 将不会运行。</p>\n<h2 id=\"文件类型插件\"><a href=\"#文件类型插件\" class=\"headerlink\" title=\"文件类型插件\"></a>文件类型插件</h2><p>如果您想让Vim仅当您打开一个 chocodonut 文件时才运行 chocodonut 相关的特殊脚本，而当您打开的是 plaindonut 文件时，Vim就不运行这些脚本。能否做到呢？</p>\n<p>您可以使用文件类型插件runtime路径(<code>~/.vim/ftplugin/</code>)来完成这个功能。Vim会在这个目录中查找一个文件，这个文件的文件名与您打开的文件类型一样。创建一个文件，起名为<code>chocodonut.vim</code> (<code>~/.vim/ftplugin/chocodonut.vim</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Calling from chocodonut ftplugin&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>创建另一个 ftplugin 文件，起名为<code>plaindonut.vim</code> (<code>~/.vim/ftplugin/plaindonut.vim</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Calling from plaindonut ftplugin&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，每次您打开一个 chocodonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/chocodonut.vim</code>中的脚本。每次您打开 plaindonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/plaindonut.vim</code> 中的脚本。</p>\n<p>一个警告：每当一个buffer的文件类型被设置时(比如，<code>set filetype=chocodonut</code>)，上述脚本就会运行一次。如果您打开3个不同的 chocodonut 文件，该脚本将运行 <em>总共</em> 3次。</p>\n<h2 id=\"缩进文件\"><a href=\"#缩进文件\" class=\"headerlink\" title=\"缩进文件\"></a>缩进文件</h2><p>Vim有一个 缩进runtime路径，其工作方式与ftplugin类似，Vim也会在这个目录中查找一个与打开的文件类型名字一样的文件。缩进runtime路径的目的是存储缩进相关的代码。如果您有文件 <code>~/.vim/indent/chocodonut.vim</code>，它仅当您打开一个 chocodonut 类型的文件时执行。您可以将 chocodonut 文件中缩进相关的代码存储在这里。</p>\n<h2 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h2><p>Vim 有一个颜色runtime路径 (<code>~/.vim/colors/</code>) ，用来存储颜色主题。这个目录中的任何文件都会在命令行命令 <code>:color</code> 中显示出来。</p>\n<p>如果您有一个文件 <code>~/.vim/colors/beautifulprettycolors.vim</code>，当您运行 <code>:color</code> 然后按 Tab，您将会看到 <code>beautifulprettycolors</code> 出现在颜色选项中。  如果您想添加自己的颜色主题，就放在这个地方。</p>\n<p>如果您想看其他人做的颜色主题，有一个好地方值得推荐：<a href=\"https://vimcolors.com/\">vimcolors</a>。</p>\n<h2 id=\"语法高亮\"><a href=\"#语法高亮\" class=\"headerlink\" title=\"语法高亮\"></a>语法高亮</h2><p>Vim有一个语法runtime路径 (<code>~/.vim/syntax/</code>)，用来定义语法高亮。</p>\n<p>假设您有一个文件 <code>hello.chocodonut</code>，在文件里面有以下内容：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\">(<span class=\"hljs-name\">donut</span> <span class=\"hljs-string\">&quot;tasty&quot;</span>)<br>(<span class=\"hljs-name\">donut</span> <span class=\"hljs-string\">&quot;savory&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>虽然Vim现在知道了正确的文件类型，但所有的文本都是相同的颜色。让我们添加语法高亮规则，使 “donut” 关键词高亮显示。创建一个新的 chocodonut 语法文件 <code>~/.vim/syntax/chocodonut.vim</code>，在文件中添加：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">syntax <span class=\"hljs-built_in\">keyword</span> donutKeyword donut<br><br>highlight <span class=\"hljs-keyword\">link</span> donutKeyword <span class=\"hljs-built_in\">Keyword</span><br></code></pre></td></tr></table></figure>\n\n<p>现在重新打开 <code>hello.chocodonut</code> 文件，关键词 <code>donut</code> 已经高亮显示了。</p>\n<p>本章不会详细介绍语法高亮。它是一个庞大的主题。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p>\n<p><a href=\"https://github.com/sheerun/vim-polyglot\">vim-polyglot</a> 插件非常的棒，它提供了很多流行的编程语言的语法高亮。</p>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><p>如果您写了一个插件，您还得创建一个您自己的文档。您可以使用文档runtime路径完成这个。</p>\n<p>让我们为 chocodonut 和 plaindonut 关键字创建一个基本文档。创建文件 <code>donut.txt</code> (<code>~/.vim/doc/donut.txt</code>)。在文件中，添加一下内容：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">*chocodonut* Delicious chocolate donut</span><br><br><span class=\"hljs-comment\">*plaindonut* No choco goodness but still delicious nonetheless</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您试着搜索 <code>chocodonut</code> 或 <code>plaindonut</code> (<code>:h chocodonut</code> 或 <code>:h plaindonut</code>)，您找不到任何东西。</p>\n<p>首先，你需要运行 <code>:helptags</code>来创建新的帮助入口。运行 <code>:helptags ~/.vim/doc/</code></p>\n<p>现在，如果您运行 <code>:h chocodonut</code> 或 <code>:h plaindonut</code>，您将找到上面那些新的帮助入口。注意，现在文件是只读的，而且类型是 “help”。</p>\n<h2 id=\"延时加载脚本\"><a href=\"#延时加载脚本\" class=\"headerlink\" title=\"延时加载脚本\"></a>延时加载脚本</h2><p>到现在，本章您学到的所有runtime路径都是自动运行的。如果您想手动加载一个脚本，可使用 autoload runtime路径。</p>\n<p>创建一个目录名为 autoload(<code>~/.vim/autoload/</code>)。在目录中，创建一个新文件，起名为 <code>tasty.vim</code> (<code>~/.vim/autoload/tasty.vim</code>)。在文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;tasty.vim global&quot;</span><br><br><span class=\"hljs-keyword\">function</span> tasty<span class=\"hljs-comment\">#donut()</span><br>  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;tasty#donut&quot;</span><br>endfunction<br></code></pre></td></tr></table></figure>\n\n<p>注意，函数名是 <code>tasty#donut</code> 而不是 <code>donut()</code>。要想使用autoload功能，井号(<code>#</code>)是必须的。在使用autoload功能时，函数的命名惯例是：</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs leaf\">function fileName<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">()</span></span><br>  ...<br>endfunction<br></code></pre></td></tr></table></figure>\n\n<p>在本例中，文件名是 <code>tasty.vim</code>，而函数名是<code>donut</code>。</p>\n<p>要调用一个函数，可以使用 <code>call</code> 命令。让我们call这个函数 <code>:call tasty#donut()</code>。</p>\n<p>您第一次调用这个函数时，您应当会 <em>同时</em> 看到两条信息 (“tasty.vim global” 和 “tasty#donut”) 。后面再调用 <code>tasty#donut</code> 函数，将只会显示 “testy#donut”。</p>\n<p>当您在Vim中打开一个文件，不像前面说的runtime路径，autoload脚本不会被自动加载。仅当您显式地调用 <code>tasty#donut()</code>，Vim才会查找文件<code>tasty.vim</code>，然后加载文件中的内容，包括函数 <code>tasty#donut()</code>。有些函数会占用大量资源，但我们又不常用，这时候 Autoload runtime路径就是最佳的解决方案。 </p>\n<p>您可以在autoload目录任意添加嵌套的目录。如果您有一个runtime路径 <code>~/.vim/autoload/one/two/three/tasty.vim</code>，您可以使用<code>:call one#two#three#tasty#donut()</code>来调用函数。</p>\n<h2 id=\"After脚本\"><a href=\"#After脚本\" class=\"headerlink\" title=\"After脚本\"></a>After脚本</h2><p>Vim有一个 after runtime路径 (<code>~/.vim/after/</code>) ，它的结构是 <code>~/.vim/</code>的镜像。在此目录中的任何脚本都会最后执行，所以开发者通常使用这个路径来重载脚本。</p>\n<p>比如，如果您想重载 <code>plugin/chocolate.vim</code> 中的脚本，您可以创建<code>~/.vim/after/plugin/chocolate.vim</code>来放置重载脚本。Vim将会先运行 <code>~/.vim/plugin/chocolate.vim</code>， <em>然后运行</em> <code>~/.vim/after/plugin/chocolate.vim</code></p>\n<h2 id=\"VIMRUNTIME\"><a href=\"#VIMRUNTIME\" class=\"headerlink\" title=\"$VIMRUNTIME\"></a>$VIMRUNTIME</h2><p>Vim有一个环境变量 <code>$VIMRUNTIME</code> 用来加载默认脚本和支持文件。您可以运行 <code>:e $VIMRUNTIME</code>查看。</p>\n<p>它的结构应该看起来很熟悉。它包含的很多runtime路径都是我们本章前面学过的。</p>\n<p>回想第22章，当您打开Vim时，它会在6个不同的位置查找vimrc文件。当时我说最后一个位置就是 <code>$VIMRUNTIME/default.vim</code>，如果Vim在前5个位置查找用户vimrc文件失败，就会使用<code>default.vim</code> 作为vimrc。</p>\n<p>不知您是否尝试过，运行Vim是不加载比如vim-polyglot之类的语法插件，但您的文件依然有语法高亮?这是因为当Vim在runtime路径查找语法文件失败时，会从<code>$VIMRUNTIME</code> 的语法目录中查找语法文件。</p>\n<p>查阅 <code>:h $VIMRUNTIME</code>了解更多信息。</p>\n<h2 id=\"Runtimepath选项\"><a href=\"#Runtimepath选项\" class=\"headerlink\" title=\"Runtimepath选项\"></a>Runtimepath选项</h2><p>运行 <code>:set runtimepath?</code>，可以查看您的runtime路径。</p>\n<p>如果您使用 Vim-Plug 或其他流行的第三方插件管理器，它应该会显示一个目录列表。比如，我的显示如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">runtimepath=~<span class=\"hljs-regexp\">/.vim,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>vim-signify,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/base16-vim,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>fzf.vim,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/fzf,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>vim-gutentags,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/tcomment_vim,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>emmet-vim,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/vim-fugitive,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>vim-sensible,~<span class=\"hljs-regexp\">/.vim/</span>plugged/lightline.vim, ...<br></code></pre></td></tr></table></figure>\n\n<p>插件管理器做了一件事，就是将每个插件添加到runtime路径中。每个runtime路径都有一个类似 <code>~/.vim/</code>的目录结构。</p>\n<p>如果您有一个目录 <code>~/box/of/donuts/</code>，然后您想将这个目录添加到您的runtime路径中，您可以在vimrc中添加以下内容：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">set rtp+=<span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/box/</span>of<span class=\"hljs-regexp\">/donuts/</span><br></code></pre></td></tr></table></figure>\n\n<p>如果在 <code>~/box/of/donuts/</code> 里面，您有一个plugin目录 (<code>~/box/of/donuts/plugin/hello.vim</code>) 以及ftplugin目录 (<code>~/box/of/donuts/ftplugin/chocodonut.vim</code>)，当您打开Vim时，Vim将会运行 <code>plugin/hello.vim</code> 中所有脚本。同样，当您打开一个 chocodonut 文件时，Vim 将会运行 <code>ftplugin/chocodonut.vim</code>。</p>\n<p>自己试着做一下：创建一个任意目录，然后将它添加到您的 runtimepath中。添加一些我们本章学到的runtime路径。确保它们按预期工作。</p>\n<h2 id=\"聪明地学习Runtime\"><a href=\"#聪明地学习Runtime\" class=\"headerlink\" title=\"聪明地学习Runtime\"></a>聪明地学习Runtime</h2><p>花点时间阅读本章，还有认真研究一下这些runtime路径。看一下真实环境下runtime路径是如何使用的。浏览一下您最喜欢的Vim插件仓库，仔细研究一下它的目录结构，您应该能够理解它们中的绝大部分。试着领会重点并跟着做。现在您已经理解了Vim的目录结构，您可以准备学习Vimscript了。</p>\n","site":{"data":{}},"wordcount":7905,"excerpt":"","more":"<h1 id=\"第24章-Vim-Rumtime\"><a href=\"#第24章-Vim-Rumtime\" class=\"headerlink\" title=\"第24章 Vim Rumtime\"></a>第24章 Vim Rumtime</h1><p>在前面的章节中，我提到Vim会自动查找一些特殊的路径，比如在<code>~/.vim/</code> 中的 <code>pack/</code>(第23章) <code>compiler/</code>（第19章）。这些都是Vim runtime路径的例子。</p>\n<p>除了上面提到的两个，Vim还有更多runtime路径。在本章，您将学习关于Vim runtime路径的高层次概述。本章的目标是向您展示它们什么时候被调用。知道这些知识能够帮您更进一步理解和定制Vim。</p>\n<h2 id=\"Runtime路径\"><a href=\"#Runtime路径\" class=\"headerlink\" title=\"Runtime路径\"></a>Runtime路径</h2><p>在一台Unix机器中，其中一个vim runtime路径就是 <code>$HOME/.vim/</code> （如果您用的是其他操作系统，比如Windows，您的路径可能有所不同）。要查看不同的操作系统有什么样的runtime路径，查阅 <code>:h runtimepath</code>。在本章，我将使用 <code>~/.vim/</code> 作为默认的runtime路径。</p>\n<h2 id=\"Plugin脚本\"><a href=\"#Plugin脚本\" class=\"headerlink\" title=\"Plugin脚本\"></a>Plugin脚本</h2><p>Vim有一个runtime路径 plugin，每次Vim启动时都会执行这个路径中的所有脚本。不要把这个名字 “plugin” 和Vim的外部插件（external plugins，比如NERDTree, fzf.vim, 等)搞混了。</p>\n<p>进入 <code>~/.vim/</code> 目录，然后创建 <code>plugin/</code> 子目录。 创建两个文件： <code>donut.vim</code> 和 <code>chocolate.vim</code>。</p>\n<p>在 <code>~/.vim/plugin/donut.vim</code>里面:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;donut!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>在 <code>~/.vim/plugin/chocolate.vim</code>里面:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;chocolate!&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>现在关闭Vim。下次您启动Vim，您将会看到 <code>&quot;donut!&quot;</code> 和 <code>:chocolate!</code> 的显示。此 plugin runtime路径可以用来执行一些初始化脚本。</p>\n<h2 id=\"文件类型检测\"><a href=\"#文件类型检测\" class=\"headerlink\" title=\"文件类型检测\"></a>文件类型检测</h2><p>在开始之前，为保证检测能正常运行，确保在您的vimrc中至少包含了下列的行：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">filetype</span> plugin <span class=\"hljs-built_in\">indent</span> <span class=\"hljs-keyword\">on</span><br></code></pre></td></tr></table></figure>\n\n<p>查阅 <code>:h filetype-overview</code> 了解更多信息。本质上，这条代码开启Vim的文件类型检测。</p>\n<p>当您打开一个新的文件，Vim通常知道这个文件是什么类型。如果您有一个文件 <code>hello.rb</code>，运行 <code>:set filetype?</code> 会返回正确的相应 <code>filetype=ruby</code>。</p>\n<p>Vim知道如何检测 “常见” 的文件类型（Ruby, Python, Javascript, 等）。但如果是一个自定义文件会怎样呢？您需要告诉Vim去检测它，并给它指派一个正确的文件类型。</p>\n<p>有两种检测方法：使用文件名和使用文件内容</p>\n<h3 id=\"文件名检测\"><a href=\"#文件名检测\" class=\"headerlink\" title=\"文件名检测\"></a>文件名检测</h3><p>文件名检测使用一个文件的文件名来检测文件类型。当您打开 <code>hello.rb</code>文件时，Vim依靠扩展名 <code>.rb</code> 知道它是一个Ruby文件。</p>\n<p>有两种方法实现文件名检测：一是使用 <code>ftdetect</code> runtime目录，二是使用 <code>filetype.vim</code> runtime文件。我们两个都看一看。</p>\n<h4 id=\"ftdetect\"><a href=\"#ftdetect\" class=\"headerlink\" title=\"ftdetect/\"></a><code>ftdetect/</code></h4><p>让我们创建一个古怪（但优雅）的名字，<code>hello.chocodonut</code>。当您打开它后运行 <code>:set filetype?</code> ，因为它的后缀名不是常见的文件名，Vim不知道它是什么类型，会返回 <code>filetype=</code>。</p>\n<p>您需要指示Vim将所有以 <code>.chocodonut</code>结尾的文件设置为 “chocodonut”类型的文件。在runtime路径根目录(<code>~/.vim/</code>)创建一个子目录，名为 <code>ftdetect/</code> 。在子目录里面，再创建一个名叫 <code>chocodonut.vim</code> 的文件（<code>~/.vim/ftdetect/chocodonut.vim</code>），在文件里面，添加：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">autocmd BufNewFile,BufRead *.chocodonut <span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">filetype</span>=chocodonut<br></code></pre></td></tr></table></figure>\n\n<p>当您创建新buffer或打开新buffer时，事件<code>BufNewFile</code> 和 <code>BufRead</code> 就会被触发。 <code>*.chocodonut</code> 意思是只有当新打开的buffer文件名后缀是 <code>.chocodonut</code> 时事件才会被触发。最后，<code>set filetype=chocodonut</code> 命令将文件类型设置为chocodonut类型。</p>\n<p>重启Vim。新建一个 <code>hello.chocodonut</code> 文件然后运行 <code>:set filetype?</code>。它将返回 <code>filetype=chocodonut</code>.</p>\n<p>好极了！只要您想，您可以将任意多的文件放置在 <code>ftdetect/</code> 中。以后，如果您想扩展您的 donut 文件类型，你可以添加 <code>ftdetect/strawberrydonut.vim</code>, <code>ftdetect/plaindonut.vim</code> 等等。</p>\n<p>在Vim中，实际上有两种方法设置文件类型。其中给一个是您刚刚使用的 <code>set filetype=chocodonut</code>。另一种方法是运行 <code>setfiletype chocodonut</code>。前一个命令 <code>set filetype=chocodonut</code> 将 <em>总是</em> 设置文件类型为chocodonut。 而后者<code>setfiletype chocodonut</code>只有当文件类型尚未设置时，才会将文件类型设置为chocodonut。</p>\n<h4 id=\"文件类型文件\"><a href=\"#文件类型文件\" class=\"headerlink\" title=\"文件类型文件\"></a>文件类型文件</h4><p>第二种文件类型检测需要你创建一个名为 <code>filetype.vim</code>的文件，并将它放置在根目录(<code>~/.vim/filetype.vim</code>)。在文件内添加一下内容：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">autocmd BufNewFile,BufRead *.plaindonut <span class=\"hljs-built_in\">set</span> <span class=\"hljs-attribute\">filetype</span>=plaindonut<br></code></pre></td></tr></table></figure>\n\n<p>创建一个名为 <code>hello.plaindonut</code> 的文件。当你打开它后运行 <code>:set filetype?</code> Vim会显示正确的自定义文件类型 <code>filetype=plaindonut</code>。</p>\n<p>太好了，修改生效了。另外，如果您仔细看看 <code>filetype.vim</code> ，您会发现当您打开<code>hello.plaindonut</code>时，这个文件文件运行了多次。为防止这一点，您可以添加一个守卫，让主脚本只运行一次。更新 <code>filetype.vim</code>:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">exists</span>(<span class=\"hljs-string\">&quot;did_load_filetypes&quot;</span>)<br>  <span class=\"hljs-keyword\">finish</span><br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-keyword\">augroup</span> donutfiletypedetection<br>  autocmd! BufRead,BufNewFile *.plaindonut <span class=\"hljs-keyword\">setfiletype</span> plaindonut<br><span class=\"hljs-keyword\">augroup</span> END<br></code></pre></td></tr></table></figure>\n\n<p><code>finish</code> 是一个Vim命令，用来停止执行剩余的脚本。表达式<code>&quot;did_load_filetypes&quot;</code> 并 <em>不是</em> 一个Vim内置函数。它实际上是<code>$VIMRUNTIME/filetype.vim</code> 中的一个全局变量。如果您好奇，运行<code>:e $VIMRUNTIME/filetype.vim</code>。您将会发现以下内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">exists</span>(<span class=\"hljs-string\">&quot;did_load_filetypes&quot;</span>)<br>  <span class=\"hljs-keyword\">finish</span><br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-keyword\">let</span> did_load_filetypes = <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>当Vim调用这个文件时，它会定义 <code>did_load_filetypes</code> 变量，并将它设置为 1 。在Vim中，1 表示真。你可以试着读完 <code>filetype.vim</code> 剩余的内容，看看您是否能够理解当Vim调用它时干了什么。</p>\n<h3 id=\"文件类型脚本\"><a href=\"#文件类型脚本\" class=\"headerlink\" title=\"文件类型脚本\"></a>文件类型脚本</h3><p>让我们学习如何基于文件内容检测文件类型。</p>\n<p>假设您有一个无扩展名的文件的集合。这些文件唯一相同的地方是，第一行都是以 “donutify” 开头。您现在想给这些文件指派一个 <code>donut</code> 的文件类型。创建新文件，起名为 <code>sugardonut</code>, <code>glazeddonut</code>, 还有 <code>frieddonut</code>（没有扩展名）。在每个文件中，添加下列内容：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">donutify</span><br></code></pre></td></tr></table></figure>\n\n<p>当您在<code>sugardonut</code>中运行 <code>:set filetype?</code>，Vim无法知道应该给这个文件指派什么文件类型，会返回 <code>filetype=</code>。</p>\n<p>在runtime根目录，添加一个 <code>scripts.vim</code> 文件(<code>~/.vim/scripts.vim</code>)，在文件中，添加一下内容：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">did_filetype</span>()<br>  <span class=\"hljs-keyword\">finish</span><br><span class=\"hljs-keyword\">endif</span><br><br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">getline</span>(<span class=\"hljs-number\">1</span>) =~ <span class=\"hljs-string\">&#x27;^\\\\&lt;donutify\\\\&gt;&#x27;</span><br>  <span class=\"hljs-keyword\">setfiletype</span> donut<br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n\n<p>函数 <code>getline(1)</code> 返回文件第一行的内容。它检查第一行是否以 “donutify” 开头。函数 <code>did_filetype()</code> 是Vim的内置函数，当一个与文件类型相关的事件发生至少一次时，它返回真。它用来做守卫，防止文件类型事件反复运行。</p>\n<p>打开文件 <code>sugardonut</code> 然后运行 <code>:set filetype?</code>，Vim现在返回 <code>filetype=donut</code>。如果您打开另外一个donut文件 (<code>glazeddonut</code> 和 <code>frieddonut</code>)，Vim同样会将它们的文件类型定义为 <code>donut</code> 类型。</p>\n<p>注意，<code>scripts.vim</code> 仅当Vim打开一个未知文件类型的文件时才会运行。如果Vim打开一个已知文件类型的文件，<code>scripts.vim</code> 将不会运行。</p>\n<h2 id=\"文件类型插件\"><a href=\"#文件类型插件\" class=\"headerlink\" title=\"文件类型插件\"></a>文件类型插件</h2><p>如果您想让Vim仅当您打开一个 chocodonut 文件时才运行 chocodonut 相关的特殊脚本，而当您打开的是 plaindonut 文件时，Vim就不运行这些脚本。能否做到呢？</p>\n<p>您可以使用文件类型插件runtime路径(<code>~/.vim/ftplugin/</code>)来完成这个功能。Vim会在这个目录中查找一个文件，这个文件的文件名与您打开的文件类型一样。创建一个文件，起名为<code>chocodonut.vim</code> (<code>~/.vim/ftplugin/chocodonut.vim</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Calling from chocodonut ftplugin&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>创建另一个 ftplugin 文件，起名为<code>plaindonut.vim</code> (<code>~/.vim/ftplugin/plaindonut.vim</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Calling from plaindonut ftplugin&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>现在，每次您打开一个 chocodonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/chocodonut.vim</code>中的脚本。每次您打开 plaindonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/plaindonut.vim</code> 中的脚本。</p>\n<p>一个警告：每当一个buffer的文件类型被设置时(比如，<code>set filetype=chocodonut</code>)，上述脚本就会运行一次。如果您打开3个不同的 chocodonut 文件，该脚本将运行 <em>总共</em> 3次。</p>\n<h2 id=\"缩进文件\"><a href=\"#缩进文件\" class=\"headerlink\" title=\"缩进文件\"></a>缩进文件</h2><p>Vim有一个 缩进runtime路径，其工作方式与ftplugin类似，Vim也会在这个目录中查找一个与打开的文件类型名字一样的文件。缩进runtime路径的目的是存储缩进相关的代码。如果您有文件 <code>~/.vim/indent/chocodonut.vim</code>，它仅当您打开一个 chocodonut 类型的文件时执行。您可以将 chocodonut 文件中缩进相关的代码存储在这里。</p>\n<h2 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h2><p>Vim 有一个颜色runtime路径 (<code>~/.vim/colors/</code>) ，用来存储颜色主题。这个目录中的任何文件都会在命令行命令 <code>:color</code> 中显示出来。</p>\n<p>如果您有一个文件 <code>~/.vim/colors/beautifulprettycolors.vim</code>，当您运行 <code>:color</code> 然后按 Tab，您将会看到 <code>beautifulprettycolors</code> 出现在颜色选项中。  如果您想添加自己的颜色主题，就放在这个地方。</p>\n<p>如果您想看其他人做的颜色主题，有一个好地方值得推荐：<a href=\"https://vimcolors.com/\">vimcolors</a>。</p>\n<h2 id=\"语法高亮\"><a href=\"#语法高亮\" class=\"headerlink\" title=\"语法高亮\"></a>语法高亮</h2><p>Vim有一个语法runtime路径 (<code>~/.vim/syntax/</code>)，用来定义语法高亮。</p>\n<p>假设您有一个文件 <code>hello.chocodonut</code>，在文件里面有以下内容：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\">(<span class=\"hljs-name\">donut</span> <span class=\"hljs-string\">&quot;tasty&quot;</span>)<br>(<span class=\"hljs-name\">donut</span> <span class=\"hljs-string\">&quot;savory&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>虽然Vim现在知道了正确的文件类型，但所有的文本都是相同的颜色。让我们添加语法高亮规则，使 “donut” 关键词高亮显示。创建一个新的 chocodonut 语法文件 <code>~/.vim/syntax/chocodonut.vim</code>，在文件中添加：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">syntax <span class=\"hljs-built_in\">keyword</span> donutKeyword donut<br><br>highlight <span class=\"hljs-keyword\">link</span> donutKeyword <span class=\"hljs-built_in\">Keyword</span><br></code></pre></td></tr></table></figure>\n\n<p>现在重新打开 <code>hello.chocodonut</code> 文件，关键词 <code>donut</code> 已经高亮显示了。</p>\n<p>本章不会详细介绍语法高亮。它是一个庞大的主题。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p>\n<p><a href=\"https://github.com/sheerun/vim-polyglot\">vim-polyglot</a> 插件非常的棒，它提供了很多流行的编程语言的语法高亮。</p>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><p>如果您写了一个插件，您还得创建一个您自己的文档。您可以使用文档runtime路径完成这个。</p>\n<p>让我们为 chocodonut 和 plaindonut 关键字创建一个基本文档。创建文件 <code>donut.txt</code> (<code>~/.vim/doc/donut.txt</code>)。在文件中，添加一下内容：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">*chocodonut* Delicious chocolate donut</span><br><br><span class=\"hljs-comment\">*plaindonut* No choco goodness but still delicious nonetheless</span><br></code></pre></td></tr></table></figure>\n\n<p>如果您试着搜索 <code>chocodonut</code> 或 <code>plaindonut</code> (<code>:h chocodonut</code> 或 <code>:h plaindonut</code>)，您找不到任何东西。</p>\n<p>首先，你需要运行 <code>:helptags</code>来创建新的帮助入口。运行 <code>:helptags ~/.vim/doc/</code></p>\n<p>现在，如果您运行 <code>:h chocodonut</code> 或 <code>:h plaindonut</code>，您将找到上面那些新的帮助入口。注意，现在文件是只读的，而且类型是 “help”。</p>\n<h2 id=\"延时加载脚本\"><a href=\"#延时加载脚本\" class=\"headerlink\" title=\"延时加载脚本\"></a>延时加载脚本</h2><p>到现在，本章您学到的所有runtime路径都是自动运行的。如果您想手动加载一个脚本，可使用 autoload runtime路径。</p>\n<p>创建一个目录名为 autoload(<code>~/.vim/autoload/</code>)。在目录中，创建一个新文件，起名为 <code>tasty.vim</code> (<code>~/.vim/autoload/tasty.vim</code>)。在文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;tasty.vim global&quot;</span><br><br><span class=\"hljs-keyword\">function</span> tasty<span class=\"hljs-comment\">#donut()</span><br>  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;tasty#donut&quot;</span><br>endfunction<br></code></pre></td></tr></table></figure>\n\n<p>注意，函数名是 <code>tasty#donut</code> 而不是 <code>donut()</code>。要想使用autoload功能，井号(<code>#</code>)是必须的。在使用autoload功能时，函数的命名惯例是：</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs leaf\">function fileName<span class=\"hljs-function\"><span class=\"hljs-keyword\">#</span><span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">()</span></span><br>  ...<br>endfunction<br></code></pre></td></tr></table></figure>\n\n<p>在本例中，文件名是 <code>tasty.vim</code>，而函数名是<code>donut</code>。</p>\n<p>要调用一个函数，可以使用 <code>call</code> 命令。让我们call这个函数 <code>:call tasty#donut()</code>。</p>\n<p>您第一次调用这个函数时，您应当会 <em>同时</em> 看到两条信息 (“tasty.vim global” 和 “tasty#donut”) 。后面再调用 <code>tasty#donut</code> 函数，将只会显示 “testy#donut”。</p>\n<p>当您在Vim中打开一个文件，不像前面说的runtime路径，autoload脚本不会被自动加载。仅当您显式地调用 <code>tasty#donut()</code>，Vim才会查找文件<code>tasty.vim</code>，然后加载文件中的内容，包括函数 <code>tasty#donut()</code>。有些函数会占用大量资源，但我们又不常用，这时候 Autoload runtime路径就是最佳的解决方案。 </p>\n<p>您可以在autoload目录任意添加嵌套的目录。如果您有一个runtime路径 <code>~/.vim/autoload/one/two/three/tasty.vim</code>，您可以使用<code>:call one#two#three#tasty#donut()</code>来调用函数。</p>\n<h2 id=\"After脚本\"><a href=\"#After脚本\" class=\"headerlink\" title=\"After脚本\"></a>After脚本</h2><p>Vim有一个 after runtime路径 (<code>~/.vim/after/</code>) ，它的结构是 <code>~/.vim/</code>的镜像。在此目录中的任何脚本都会最后执行，所以开发者通常使用这个路径来重载脚本。</p>\n<p>比如，如果您想重载 <code>plugin/chocolate.vim</code> 中的脚本，您可以创建<code>~/.vim/after/plugin/chocolate.vim</code>来放置重载脚本。Vim将会先运行 <code>~/.vim/plugin/chocolate.vim</code>， <em>然后运行</em> <code>~/.vim/after/plugin/chocolate.vim</code></p>\n<h2 id=\"VIMRUNTIME\"><a href=\"#VIMRUNTIME\" class=\"headerlink\" title=\"$VIMRUNTIME\"></a>$VIMRUNTIME</h2><p>Vim有一个环境变量 <code>$VIMRUNTIME</code> 用来加载默认脚本和支持文件。您可以运行 <code>:e $VIMRUNTIME</code>查看。</p>\n<p>它的结构应该看起来很熟悉。它包含的很多runtime路径都是我们本章前面学过的。</p>\n<p>回想第22章，当您打开Vim时，它会在6个不同的位置查找vimrc文件。当时我说最后一个位置就是 <code>$VIMRUNTIME/default.vim</code>，如果Vim在前5个位置查找用户vimrc文件失败，就会使用<code>default.vim</code> 作为vimrc。</p>\n<p>不知您是否尝试过，运行Vim是不加载比如vim-polyglot之类的语法插件，但您的文件依然有语法高亮?这是因为当Vim在runtime路径查找语法文件失败时，会从<code>$VIMRUNTIME</code> 的语法目录中查找语法文件。</p>\n<p>查阅 <code>:h $VIMRUNTIME</code>了解更多信息。</p>\n<h2 id=\"Runtimepath选项\"><a href=\"#Runtimepath选项\" class=\"headerlink\" title=\"Runtimepath选项\"></a>Runtimepath选项</h2><p>运行 <code>:set runtimepath?</code>，可以查看您的runtime路径。</p>\n<p>如果您使用 Vim-Plug 或其他流行的第三方插件管理器，它应该会显示一个目录列表。比如，我的显示如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">runtimepath=~<span class=\"hljs-regexp\">/.vim,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>vim-signify,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/base16-vim,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>fzf.vim,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/fzf,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>vim-gutentags,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/tcomment_vim,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>emmet-vim,~<span class=\"hljs-regexp\">/.vim/</span>plugged<span class=\"hljs-regexp\">/vim-fugitive,~/</span>.vim<span class=\"hljs-regexp\">/plugged/</span>vim-sensible,~<span class=\"hljs-regexp\">/.vim/</span>plugged/lightline.vim, ...<br></code></pre></td></tr></table></figure>\n\n<p>插件管理器做了一件事，就是将每个插件添加到runtime路径中。每个runtime路径都有一个类似 <code>~/.vim/</code>的目录结构。</p>\n<p>如果您有一个目录 <code>~/box/of/donuts/</code>，然后您想将这个目录添加到您的runtime路径中，您可以在vimrc中添加以下内容：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">set rtp+=<span class=\"hljs-variable\">$HOME</span><span class=\"hljs-regexp\">/box/</span>of<span class=\"hljs-regexp\">/donuts/</span><br></code></pre></td></tr></table></figure>\n\n<p>如果在 <code>~/box/of/donuts/</code> 里面，您有一个plugin目录 (<code>~/box/of/donuts/plugin/hello.vim</code>) 以及ftplugin目录 (<code>~/box/of/donuts/ftplugin/chocodonut.vim</code>)，当您打开Vim时，Vim将会运行 <code>plugin/hello.vim</code> 中所有脚本。同样，当您打开一个 chocodonut 文件时，Vim 将会运行 <code>ftplugin/chocodonut.vim</code>。</p>\n<p>自己试着做一下：创建一个任意目录，然后将它添加到您的 runtimepath中。添加一些我们本章学到的runtime路径。确保它们按预期工作。</p>\n<h2 id=\"聪明地学习Runtime\"><a href=\"#聪明地学习Runtime\" class=\"headerlink\" title=\"聪明地学习Runtime\"></a>聪明地学习Runtime</h2><p>花点时间阅读本章，还有认真研究一下这些runtime路径。看一下真实环境下runtime路径是如何使用的。浏览一下您最喜欢的Vim插件仓库，仔细研究一下它的目录结构，您应该能够理解它们中的绝大部分。试着领会重点并跟着做。现在您已经理解了Vim的目录结构，您可以准备学习Vimscript了。</p>\n"},{"title":"WebpackDay01","date":"2022-04-05T09:31:27.000Z","description":"前端打包工具Webpack学习第一天","_content":"\n# 代码分离方法\n\n## 入口起点\n\n> 使用 [`entry`](https://webpack.docschina.org/configuration/entry-context) 配置手动地分离代码。\n\n`webpack.config.js`\n\n```js\n const path = require('path');\n\n module.exports = {\n  entry: './src/index.js',\n  mode: 'development',\n  entry: {\n    index: './src/index.js',\n    another: './src/another-module.js',\n  },\n   output: {\n    filename: 'main.js',\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n   },\n };\n```\n\n**这种方式存在一些隐患**：\n\n- 如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。\n-  这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。\n\n\n## 防止重复\n\n> 使用 [Entry dependencies](https://webpack.docschina.org/configuration/entry-context/#dependencies) 或者 [`SplitChunksPlugin`](https://webpack.docschina.org/plugins/split-chunks-plugin) 去重和分离 chunk\n\n### 入口依赖\n\n```js\n const path = require('path');\n\n module.exports = {\n   mode: 'development',\n   entry: {\n     index: {\n       import: './src/index.js',\n       dependOn: 'shared',\n     },\n     another: {\n       import: './src/another-module.js',\n       dependOn: 'shared',\n     },\n     shared: 'lodash',\n   },\n   output: {\n     filename: '[name].bundle.js',\n     path: path.resolve(__dirname, 'dist'),\n   },\n  optimization: {\n    runtimeChunk: 'single',\n  },\n };\n```\n\n### SplitChunksPlugin\n\n```js\n  const path = require('path');\n\n  module.exports = {\n    mode: 'development',\n    entry: {\n      index: './src/index.js',\n      another: './src/another-module.js',\n    },\n    output: {\n      filename: '[name].bundle.js',\n      path: path.resolve(__dirname, 'dist'),\n    },\n   optimization: {\n     splitChunks: {\n       chunks: 'all',\n     },\n   },\n  };\n```\n\n## 动态导入\n\n> 通过模块的内联函数调用来分离代码。\n\n**src/index.js**\n\n```js\nasync function getComponent() {\n  const element = document.createElement('div');\n  const { default: _ } = await import('lodash');\n\n  element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n  return element;\n }\n\n getComponent().then((component) => {\n   document.body.appendChild(component);\n });\n```\n\n# 代码包分析\n\n[webpack-bundle-analyzer工具](https://github.com/webpack-contrib/webpack-bundle-analyzer)\n\n![](https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif)","source":"_posts/Webpack学习/Day01.md","raw":"---\ntitle: WebpackDay01\ndate: 2022-04-05 17:31:27\ntags:\n  - [webpack]\n  - [前端]\ncategories:\n  - [技术]\ndescription: 前端打包工具Webpack学习第一天\n---\n\n# 代码分离方法\n\n## 入口起点\n\n> 使用 [`entry`](https://webpack.docschina.org/configuration/entry-context) 配置手动地分离代码。\n\n`webpack.config.js`\n\n```js\n const path = require('path');\n\n module.exports = {\n  entry: './src/index.js',\n  mode: 'development',\n  entry: {\n    index: './src/index.js',\n    another: './src/another-module.js',\n  },\n   output: {\n    filename: 'main.js',\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n   },\n };\n```\n\n**这种方式存在一些隐患**：\n\n- 如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。\n-  这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。\n\n\n## 防止重复\n\n> 使用 [Entry dependencies](https://webpack.docschina.org/configuration/entry-context/#dependencies) 或者 [`SplitChunksPlugin`](https://webpack.docschina.org/plugins/split-chunks-plugin) 去重和分离 chunk\n\n### 入口依赖\n\n```js\n const path = require('path');\n\n module.exports = {\n   mode: 'development',\n   entry: {\n     index: {\n       import: './src/index.js',\n       dependOn: 'shared',\n     },\n     another: {\n       import: './src/another-module.js',\n       dependOn: 'shared',\n     },\n     shared: 'lodash',\n   },\n   output: {\n     filename: '[name].bundle.js',\n     path: path.resolve(__dirname, 'dist'),\n   },\n  optimization: {\n    runtimeChunk: 'single',\n  },\n };\n```\n\n### SplitChunksPlugin\n\n```js\n  const path = require('path');\n\n  module.exports = {\n    mode: 'development',\n    entry: {\n      index: './src/index.js',\n      another: './src/another-module.js',\n    },\n    output: {\n      filename: '[name].bundle.js',\n      path: path.resolve(__dirname, 'dist'),\n    },\n   optimization: {\n     splitChunks: {\n       chunks: 'all',\n     },\n   },\n  };\n```\n\n## 动态导入\n\n> 通过模块的内联函数调用来分离代码。\n\n**src/index.js**\n\n```js\nasync function getComponent() {\n  const element = document.createElement('div');\n  const { default: _ } = await import('lodash');\n\n  element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n  return element;\n }\n\n getComponent().then((component) => {\n   document.body.appendChild(component);\n });\n```\n\n# 代码包分析\n\n[webpack-bundle-analyzer工具](https://github.com/webpack-contrib/webpack-bundle-analyzer)\n\n![](https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif)","slug":"Webpack学习/Day01","published":1,"updated":"2022-08-28T07:38:59.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i290031scvm6xx94pbh","content":"<h1 id=\"代码分离方法\"><a href=\"#代码分离方法\" class=\"headerlink\" title=\"代码分离方法\"></a>代码分离方法</h1><h2 id=\"入口起点\"><a href=\"#入口起点\" class=\"headerlink\" title=\"入口起点\"></a>入口起点</h2><blockquote>\n<p>使用 <a href=\"https://webpack.docschina.org/configuration/entry-context\"><code>entry</code></a> 配置手动地分离代码。</p>\n</blockquote>\n<p><code>webpack.config.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br> <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br> <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,<br> <span class=\"hljs-attr\">entry</span>: &#123;<br>   <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br>   <span class=\"hljs-attr\">another</span>: <span class=\"hljs-string\">&#x27;./src/another-module.js&#x27;</span>,<br> &#125;,<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>   <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;main.js&#x27;</span>,<br>   <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].bundle.js&#x27;</span>,<br>   <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>这种方式存在一些隐患</strong>：</p>\n<ul>\n<li>如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。</li>\n<li>这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。</li>\n</ul>\n<h2 id=\"防止重复\"><a href=\"#防止重复\" class=\"headerlink\" title=\"防止重复\"></a>防止重复</h2><blockquote>\n<p>使用 <a href=\"https://webpack.docschina.org/configuration/entry-context/#dependencies\">Entry dependencies</a> 或者 <a href=\"https://webpack.docschina.org/plugins/split-chunks-plugin\"><code>SplitChunksPlugin</code></a> 去重和分离 chunk</p>\n</blockquote>\n<h3 id=\"入口依赖\"><a href=\"#入口依赖\" class=\"headerlink\" title=\"入口依赖\"></a>入口依赖</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,<br>  <span class=\"hljs-attr\">entry</span>: &#123;<br>    <span class=\"hljs-attr\">index</span>: &#123;<br>      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br>      <span class=\"hljs-attr\">dependOn</span>: <span class=\"hljs-string\">&#x27;shared&#x27;</span>,<br>    &#125;,<br>    <span class=\"hljs-attr\">another</span>: &#123;<br>      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&#x27;./src/another-module.js&#x27;</span>,<br>      <span class=\"hljs-attr\">dependOn</span>: <span class=\"hljs-string\">&#x27;shared&#x27;</span>,<br>    &#125;,<br>    <span class=\"hljs-attr\">shared</span>: <span class=\"hljs-string\">&#x27;lodash&#x27;</span>,<br>  &#125;,<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].bundle.js&#x27;</span>,<br>    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),<br>  &#125;,<br> <span class=\"hljs-attr\">optimization</span>: &#123;<br>   <span class=\"hljs-attr\">runtimeChunk</span>: <span class=\"hljs-string\">&#x27;single&#x27;</span>,<br> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"SplitChunksPlugin\"><a href=\"#SplitChunksPlugin\" class=\"headerlink\" title=\"SplitChunksPlugin\"></a>SplitChunksPlugin</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,<br>  <span class=\"hljs-attr\">entry</span>: &#123;<br>    <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br>    <span class=\"hljs-attr\">another</span>: <span class=\"hljs-string\">&#x27;./src/another-module.js&#x27;</span>,<br>  &#125;,<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].bundle.js&#x27;</span>,<br>    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),<br>  &#125;,<br> <span class=\"hljs-attr\">optimization</span>: &#123;<br>   <span class=\"hljs-attr\">splitChunks</span>: &#123;<br>     <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>,<br>   &#125;,<br> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"动态导入\"><a href=\"#动态导入\" class=\"headerlink\" title=\"动态导入\"></a>动态导入</h2><blockquote>\n<p>通过模块的内联函数调用来分离代码。</p>\n</blockquote>\n<p><strong>src&#x2F;index.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getComponent</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">default</span>: _ &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">&#x27;lodash&#x27;</span>);<br><br>  element.<span class=\"hljs-property\">innerHTML</span> = _.<span class=\"hljs-title function_\">join</span>([<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;webpack&#x27;</span>], <span class=\"hljs-string\">&#x27; &#x27;</span>);<br><br>  <span class=\"hljs-keyword\">return</span> element;<br> &#125;<br><br> <span class=\"hljs-title function_\">getComponent</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">component</span>) =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(component);<br> &#125;);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"代码包分析\"><a href=\"#代码包分析\" class=\"headerlink\" title=\"代码包分析\"></a>代码包分析</h1><p><a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\">webpack-bundle-analyzer工具</a></p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif\"></p>\n","site":{"data":{}},"wordcount":1899,"excerpt":"","more":"<h1 id=\"代码分离方法\"><a href=\"#代码分离方法\" class=\"headerlink\" title=\"代码分离方法\"></a>代码分离方法</h1><h2 id=\"入口起点\"><a href=\"#入口起点\" class=\"headerlink\" title=\"入口起点\"></a>入口起点</h2><blockquote>\n<p>使用 <a href=\"https://webpack.docschina.org/configuration/entry-context\"><code>entry</code></a> 配置手动地分离代码。</p>\n</blockquote>\n<p><code>webpack.config.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br> <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br> <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,<br> <span class=\"hljs-attr\">entry</span>: &#123;<br>   <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br>   <span class=\"hljs-attr\">another</span>: <span class=\"hljs-string\">&#x27;./src/another-module.js&#x27;</span>,<br> &#125;,<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>   <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;main.js&#x27;</span>,<br>   <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].bundle.js&#x27;</span>,<br>   <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>这种方式存在一些隐患</strong>：</p>\n<ul>\n<li>如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。</li>\n<li>这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。</li>\n</ul>\n<h2 id=\"防止重复\"><a href=\"#防止重复\" class=\"headerlink\" title=\"防止重复\"></a>防止重复</h2><blockquote>\n<p>使用 <a href=\"https://webpack.docschina.org/configuration/entry-context/#dependencies\">Entry dependencies</a> 或者 <a href=\"https://webpack.docschina.org/plugins/split-chunks-plugin\"><code>SplitChunksPlugin</code></a> 去重和分离 chunk</p>\n</blockquote>\n<h3 id=\"入口依赖\"><a href=\"#入口依赖\" class=\"headerlink\" title=\"入口依赖\"></a>入口依赖</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,<br>  <span class=\"hljs-attr\">entry</span>: &#123;<br>    <span class=\"hljs-attr\">index</span>: &#123;<br>      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br>      <span class=\"hljs-attr\">dependOn</span>: <span class=\"hljs-string\">&#x27;shared&#x27;</span>,<br>    &#125;,<br>    <span class=\"hljs-attr\">another</span>: &#123;<br>      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&#x27;./src/another-module.js&#x27;</span>,<br>      <span class=\"hljs-attr\">dependOn</span>: <span class=\"hljs-string\">&#x27;shared&#x27;</span>,<br>    &#125;,<br>    <span class=\"hljs-attr\">shared</span>: <span class=\"hljs-string\">&#x27;lodash&#x27;</span>,<br>  &#125;,<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].bundle.js&#x27;</span>,<br>    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),<br>  &#125;,<br> <span class=\"hljs-attr\">optimization</span>: &#123;<br>   <span class=\"hljs-attr\">runtimeChunk</span>: <span class=\"hljs-string\">&#x27;single&#x27;</span>,<br> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"SplitChunksPlugin\"><a href=\"#SplitChunksPlugin\" class=\"headerlink\" title=\"SplitChunksPlugin\"></a>SplitChunksPlugin</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,<br>  <span class=\"hljs-attr\">entry</span>: &#123;<br>    <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&#x27;./src/index.js&#x27;</span>,<br>    <span class=\"hljs-attr\">another</span>: <span class=\"hljs-string\">&#x27;./src/another-module.js&#x27;</span>,<br>  &#125;,<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].bundle.js&#x27;</span>,<br>    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),<br>  &#125;,<br> <span class=\"hljs-attr\">optimization</span>: &#123;<br>   <span class=\"hljs-attr\">splitChunks</span>: &#123;<br>     <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>,<br>   &#125;,<br> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"动态导入\"><a href=\"#动态导入\" class=\"headerlink\" title=\"动态导入\"></a>动态导入</h2><blockquote>\n<p>通过模块的内联函数调用来分离代码。</p>\n</blockquote>\n<p><strong>src&#x2F;index.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getComponent</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">default</span>: _ &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">&#x27;lodash&#x27;</span>);<br><br>  element.<span class=\"hljs-property\">innerHTML</span> = _.<span class=\"hljs-title function_\">join</span>([<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;webpack&#x27;</span>], <span class=\"hljs-string\">&#x27; &#x27;</span>);<br><br>  <span class=\"hljs-keyword\">return</span> element;<br> &#125;<br><br> <span class=\"hljs-title function_\">getComponent</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">component</span>) =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(component);<br> &#125;);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"代码包分析\"><a href=\"#代码包分析\" class=\"headerlink\" title=\"代码包分析\"></a>代码包分析</h1><p><a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\">webpack-bundle-analyzer工具</a></p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif\"></p>\n"},{"title":"利用 Github Actions 自动部署 Hexo 博客","date":"2022-04-05T10:13:27.000Z","description":"Github Actions 可以很方便实现 CI/CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。","_content":"\n# 利用 Github Actions 自动部署 Hexo 博客\n\n## 介绍\n\nGithub Actions 可以很方便实现 CI/CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。\n\n本文将介绍利用 Github Actions 实现自动部署 hexo 到 Github Pages，在之前我们需要写完文章执行 `hexo generate --deploy` 来部署，当你文章比较多的时候，可能还需要等待很久，而且还可能会遇到本地安装的 Node.js 版本与 Hexo 不兼容的问题，目前我就是因为电脑的 Node.js 版本升到 v14 版本导致与 Hexo 不兼容部署不了，才来捣腾 Github Actions 功能的。利用 Github Actions 你将会没有这些烦恼。\n\n## 前提\n\n### 创建所需仓库\n\n1. 创建 `blog` 仓库用来存放 Hexo 项目\n2. 创建 `your.github.io` 仓库用来存放静态博客页面\n\n\n\n### 生成部署密钥\n\n一路按回车直到生成成功\n\n```\n$ ssh-keygen -f github-deploy-key\n```\n\n当前目录下会有 `github-deploy-key` 和 `github-deploy-key.pub` 两个文件。\n\n### 配置部署密钥\n\n复制 `github-deploy-key` 文件内容，在 `blog` 仓库 `Settings -> Secrets -> Add a new secret` 页面上添加。\n\n1. 在 `Name` 输入框填写 `HEXO_DEPLOY_PRI`。\n2. 在 `Value` 输入框填写 `github-deploy-key` 文件内容。\n\n![img](https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-secret@2x.png)\n\n复制 `github-deploy-key.pub` 文件内容，在 `your.github.io` 仓库 `Settings -> Deploy keys -> Add deploy key` 页面上添加。\n\n1. 在 `Title` 输入框填写 `HEXO_DEPLOY_PUB`。\n2. 在 `Key` 输入框填写 `github-deploy-key.pub` 文件内容。\n3. 勾选 `Allow write access` 选项。\n\n![img](https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-key@2x.png)\n\n## 编写 Github Actions\n\n### Workflow 模版\n\n在 `blog` 仓库根目录下创建 `.github/workflows/deploy.yml` 文件，目录结构如下。\n\n```\nblog (repository)\n└── .github\n    └── workflows\n        └── deploy.yml\n```\n\n在 `deploy.yml` 文件中粘贴以下内容。\n\n```\nname: CI\n\non:\n  push:\n    branches:\n      - master\n\nenv:\n  GIT_USER: Sanonz\n  GIT_EMAIL: sanonz@126.com\n  THEME_REPO: sanonz/hexo-theme-concise\n  THEME_BRANCH: master\n  DEPLOY_REPO: sanonz/sanonz.github.io\n  DEPLOY_BRANCH: master\n\njobs:\n  build:\n    name: Build on node ${{ matrix.node_version }} and ${{ matrix.os }}\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        os: [ubuntu-latest]\n        node_version: [12.x]\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Checkout theme repo\n        uses: actions/checkout@v2\n        with:\n          repository: ${{ env.THEME_REPO }}\n          ref: ${{ env.THEME_BRANCH }}\n          path: themes/concise\n\n      - name: Checkout deploy repo\n        uses: actions/checkout@v2\n        with:\n          repository: ${{ env.DEPLOY_REPO }}\n          ref: ${{ env.DEPLOY_BRANCH }}\n          path: .deploy_git\n\n      - name: Use Node.js ${{ matrix.node_version }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node_version }}\n\n      - name: Configuration environment\n        env:\n          HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}}\n        run: |\n          sudo timedatectl set-timezone \"Asia/Shanghai\"\n          mkdir -p ~/.ssh/\n          echo \"$HEXO_DEPLOY_PRI\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.name $GIT_USER\n          git config --global user.email $GIT_EMAIL\n          cp _config.theme.yml themes/concise/_config.yml\n\n      - name: Install dependencies\n        run: |\n          npm install\n\n      - name: Deploy hexo\n        run: |\n          npm run deploy\n```\n\n### 模版参数说明\n\n- *name* 为此 Action 的名字\n\n- *on* 触发条件，当满足条件时会触发此任务，这里的 `on.push.branches.$.master` 是指当 `master` 分支收到 `push` 后执行任务。\n\n- env\n\n   \n\n  为环境变量对象\n\n  - *env.GIT_USER* 为 Hexo 编译后使用此 git 用户部署到仓库。\n  - *env.GIT_EMAIL* 为 Hexo 编译后使用此 git 邮箱部署到仓库。\n  - *env.THEME_REPO* 为您的 Hexo 所使用的主题的仓库，这里为 `sanonz/hexo-theme-concise`。\n  - *env.THEME_BRANCH* 为您的 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA。\n  - *env.DEPLOY_REPO* 为 Hexo 编译后要部署的仓库，例如：`sanonz/sanonz.github.io`。\n  - *env.DEPLOY_BRANCH* 为 Hexo 编译后要部署到的分支，例如：master。\n\n- jobs\n\n   \n\n  为此 Action 下的任务列表\n\n  - *jobs.{job}.name* 任务名称\n\n  - *jobs.{job}.runs-on* 任务所需容器，可选值：`ubuntu-latest`、`windows-latest`、`macos-latest`。\n\n  - *jobs.{job}.strategy* 策略下可以写 `array` 格式，此 job 会遍历此数组执行。\n\n  - jobs.{job}.steps\n\n     \n\n    一个步骤数组，可以把所要干的事分步骤放到这里。\n\n    - *jobs.{job}.steps.$.name* 步骤名，编译时会会以 LOG 形式输出。\n    - *jobs.{job}.steps.$.uses* 所要调用的 Action，可以到 https://github.com/actions 查看更多。\n    - *jobs.{job}.steps.$.with* 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。\n\n### 第三方 Actions\n\n使用第三方 Actions 语法 `{owner}/{repo}@{ref}` 或者 `{owner}/{repo}/{path}@{ref}` 例如：\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n```\n\n一、调用 `actions/checkout@v2` 可以实现 Checkout 一个 git 仓库到容器。\n\n例如 Checkout 当前仓库到本地，`with.repo` 不填写默认为当前仓库。\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        # with:\n          # repository: ${{ github.repository }}\n```\n\n例如 Checkout 第三方仓库 `git@github.com:sanonz/hexo-theme-concise.git` 的 `master` 分支到容器 `themes/concise` 目录。\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - with:\n          repository: sanonz/hexo-theme-concise\n          ref: master\n          path: themes/concise\n```\n\n二、调用 `actions/setup-node@v1` 可以配置容器 Node.js 环境。\n\n例如安装 Node.js 版本 v12 到容器中，`with.node-version` 可以指定 Node.js 版本。\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/setup-node@v1\n      - with:\n          node-version: v12\n```\n\n可以在这里查找更多 Actions 以及使用方式 [官方 Actions 市场](https://github.com/marketplace?type=actions&query=checkout)。\n\n### 配置文件\n\n复制一份 https://github.com/sanonz/hexo-theme-concise/blob/master/_config.example.yml，放到 `blog` 根目录下，名为 `_config.theme.yml`，如果您已经配置过此文件，只需要把您的复制过来就行。\n\n最终目录结构\n\n```\nblog (repository)\n├── _config.theme.yml\n└── .github\n    └── workflows\n        └── deploy.yml\n```\n\n把 `_config.theme.yml` 与 `deploy.yml` 文件推送到 `blog` 仓库，在此仓库 `Actions` 页面可以看到一个名字为 `CI` 的 Action。\n\n### 执行任务\n\n写一篇文章，`push` 到 `blog` 仓库的 `master` 分支，在此仓库 `Actions` 页面查看当前 task。\n\n![img](https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/run@2x.png)\n\n当任务完成后查看您的博客 `https://your.github.io`，如果不出意外的话已经可以看到新添加的文章了。\n\n## 小结\n\n偷懒是人类发展的动力，人都有偷懒的想法，目的就是为了让自己能够活得更好，经过几千年的不断发展，现在人偷懒的方式无疑更加的先进。\n\n至此结束，感谢阅读。","source":"_posts/个人博客/Hexo.md","raw":"---\ntitle: 利用 Github Actions 自动部署 Hexo 博客\ndate: 2022-04-05 18:13:27\ntags:\n  - [hexo]\n  - [git]\n  - [actions]\ncategories:\n  - [技术]\ndescription: Github Actions 可以很方便实现 CI/CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。\n---\n\n# 利用 Github Actions 自动部署 Hexo 博客\n\n## 介绍\n\nGithub Actions 可以很方便实现 CI/CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。\n\n本文将介绍利用 Github Actions 实现自动部署 hexo 到 Github Pages，在之前我们需要写完文章执行 `hexo generate --deploy` 来部署，当你文章比较多的时候，可能还需要等待很久，而且还可能会遇到本地安装的 Node.js 版本与 Hexo 不兼容的问题，目前我就是因为电脑的 Node.js 版本升到 v14 版本导致与 Hexo 不兼容部署不了，才来捣腾 Github Actions 功能的。利用 Github Actions 你将会没有这些烦恼。\n\n## 前提\n\n### 创建所需仓库\n\n1. 创建 `blog` 仓库用来存放 Hexo 项目\n2. 创建 `your.github.io` 仓库用来存放静态博客页面\n\n\n\n### 生成部署密钥\n\n一路按回车直到生成成功\n\n```\n$ ssh-keygen -f github-deploy-key\n```\n\n当前目录下会有 `github-deploy-key` 和 `github-deploy-key.pub` 两个文件。\n\n### 配置部署密钥\n\n复制 `github-deploy-key` 文件内容，在 `blog` 仓库 `Settings -> Secrets -> Add a new secret` 页面上添加。\n\n1. 在 `Name` 输入框填写 `HEXO_DEPLOY_PRI`。\n2. 在 `Value` 输入框填写 `github-deploy-key` 文件内容。\n\n![img](https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-secret@2x.png)\n\n复制 `github-deploy-key.pub` 文件内容，在 `your.github.io` 仓库 `Settings -> Deploy keys -> Add deploy key` 页面上添加。\n\n1. 在 `Title` 输入框填写 `HEXO_DEPLOY_PUB`。\n2. 在 `Key` 输入框填写 `github-deploy-key.pub` 文件内容。\n3. 勾选 `Allow write access` 选项。\n\n![img](https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-key@2x.png)\n\n## 编写 Github Actions\n\n### Workflow 模版\n\n在 `blog` 仓库根目录下创建 `.github/workflows/deploy.yml` 文件，目录结构如下。\n\n```\nblog (repository)\n└── .github\n    └── workflows\n        └── deploy.yml\n```\n\n在 `deploy.yml` 文件中粘贴以下内容。\n\n```\nname: CI\n\non:\n  push:\n    branches:\n      - master\n\nenv:\n  GIT_USER: Sanonz\n  GIT_EMAIL: sanonz@126.com\n  THEME_REPO: sanonz/hexo-theme-concise\n  THEME_BRANCH: master\n  DEPLOY_REPO: sanonz/sanonz.github.io\n  DEPLOY_BRANCH: master\n\njobs:\n  build:\n    name: Build on node ${{ matrix.node_version }} and ${{ matrix.os }}\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        os: [ubuntu-latest]\n        node_version: [12.x]\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Checkout theme repo\n        uses: actions/checkout@v2\n        with:\n          repository: ${{ env.THEME_REPO }}\n          ref: ${{ env.THEME_BRANCH }}\n          path: themes/concise\n\n      - name: Checkout deploy repo\n        uses: actions/checkout@v2\n        with:\n          repository: ${{ env.DEPLOY_REPO }}\n          ref: ${{ env.DEPLOY_BRANCH }}\n          path: .deploy_git\n\n      - name: Use Node.js ${{ matrix.node_version }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node_version }}\n\n      - name: Configuration environment\n        env:\n          HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}}\n        run: |\n          sudo timedatectl set-timezone \"Asia/Shanghai\"\n          mkdir -p ~/.ssh/\n          echo \"$HEXO_DEPLOY_PRI\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.name $GIT_USER\n          git config --global user.email $GIT_EMAIL\n          cp _config.theme.yml themes/concise/_config.yml\n\n      - name: Install dependencies\n        run: |\n          npm install\n\n      - name: Deploy hexo\n        run: |\n          npm run deploy\n```\n\n### 模版参数说明\n\n- *name* 为此 Action 的名字\n\n- *on* 触发条件，当满足条件时会触发此任务，这里的 `on.push.branches.$.master` 是指当 `master` 分支收到 `push` 后执行任务。\n\n- env\n\n   \n\n  为环境变量对象\n\n  - *env.GIT_USER* 为 Hexo 编译后使用此 git 用户部署到仓库。\n  - *env.GIT_EMAIL* 为 Hexo 编译后使用此 git 邮箱部署到仓库。\n  - *env.THEME_REPO* 为您的 Hexo 所使用的主题的仓库，这里为 `sanonz/hexo-theme-concise`。\n  - *env.THEME_BRANCH* 为您的 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA。\n  - *env.DEPLOY_REPO* 为 Hexo 编译后要部署的仓库，例如：`sanonz/sanonz.github.io`。\n  - *env.DEPLOY_BRANCH* 为 Hexo 编译后要部署到的分支，例如：master。\n\n- jobs\n\n   \n\n  为此 Action 下的任务列表\n\n  - *jobs.{job}.name* 任务名称\n\n  - *jobs.{job}.runs-on* 任务所需容器，可选值：`ubuntu-latest`、`windows-latest`、`macos-latest`。\n\n  - *jobs.{job}.strategy* 策略下可以写 `array` 格式，此 job 会遍历此数组执行。\n\n  - jobs.{job}.steps\n\n     \n\n    一个步骤数组，可以把所要干的事分步骤放到这里。\n\n    - *jobs.{job}.steps.$.name* 步骤名，编译时会会以 LOG 形式输出。\n    - *jobs.{job}.steps.$.uses* 所要调用的 Action，可以到 https://github.com/actions 查看更多。\n    - *jobs.{job}.steps.$.with* 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。\n\n### 第三方 Actions\n\n使用第三方 Actions 语法 `{owner}/{repo}@{ref}` 或者 `{owner}/{repo}/{path}@{ref}` 例如：\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n```\n\n一、调用 `actions/checkout@v2` 可以实现 Checkout 一个 git 仓库到容器。\n\n例如 Checkout 当前仓库到本地，`with.repo` 不填写默认为当前仓库。\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        # with:\n          # repository: ${{ github.repository }}\n```\n\n例如 Checkout 第三方仓库 `git@github.com:sanonz/hexo-theme-concise.git` 的 `master` 分支到容器 `themes/concise` 目录。\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - with:\n          repository: sanonz/hexo-theme-concise\n          ref: master\n          path: themes/concise\n```\n\n二、调用 `actions/setup-node@v1` 可以配置容器 Node.js 环境。\n\n例如安装 Node.js 版本 v12 到容器中，`with.node-version` 可以指定 Node.js 版本。\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/setup-node@v1\n      - with:\n          node-version: v12\n```\n\n可以在这里查找更多 Actions 以及使用方式 [官方 Actions 市场](https://github.com/marketplace?type=actions&query=checkout)。\n\n### 配置文件\n\n复制一份 https://github.com/sanonz/hexo-theme-concise/blob/master/_config.example.yml，放到 `blog` 根目录下，名为 `_config.theme.yml`，如果您已经配置过此文件，只需要把您的复制过来就行。\n\n最终目录结构\n\n```\nblog (repository)\n├── _config.theme.yml\n└── .github\n    └── workflows\n        └── deploy.yml\n```\n\n把 `_config.theme.yml` 与 `deploy.yml` 文件推送到 `blog` 仓库，在此仓库 `Actions` 页面可以看到一个名字为 `CI` 的 Action。\n\n### 执行任务\n\n写一篇文章，`push` 到 `blog` 仓库的 `master` 分支，在此仓库 `Actions` 页面查看当前 task。\n\n![img](https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/run@2x.png)\n\n当任务完成后查看您的博客 `https://your.github.io`，如果不出意外的话已经可以看到新添加的文章了。\n\n## 小结\n\n偷懒是人类发展的动力，人都有偷懒的想法，目的就是为了让自己能够活得更好，经过几千年的不断发展，现在人偷懒的方式无疑更加的先进。\n\n至此结束，感谢阅读。","slug":"个人博客/Hexo","published":1,"updated":"2022-08-28T07:38:59.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i290034scvm55vcgwpm","content":"<h1 id=\"利用-Github-Actions-自动部署-Hexo-博客\"><a href=\"#利用-Github-Actions-自动部署-Hexo-博客\" class=\"headerlink\" title=\"利用 Github Actions 自动部署 Hexo 博客\"></a>利用 Github Actions 自动部署 Hexo 博客</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Github Actions 可以很方便实现 CI&#x2F;CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。</p>\n<p>本文将介绍利用 Github Actions 实现自动部署 hexo 到 Github Pages，在之前我们需要写完文章执行 <code>hexo generate --deploy</code> 来部署，当你文章比较多的时候，可能还需要等待很久，而且还可能会遇到本地安装的 Node.js 版本与 Hexo 不兼容的问题，目前我就是因为电脑的 Node.js 版本升到 v14 版本导致与 Hexo 不兼容部署不了，才来捣腾 Github Actions 功能的。利用 Github Actions 你将会没有这些烦恼。</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><h3 id=\"创建所需仓库\"><a href=\"#创建所需仓库\" class=\"headerlink\" title=\"创建所需仓库\"></a>创建所需仓库</h3><ol>\n<li>创建 <code>blog</code> 仓库用来存放 Hexo 项目</li>\n<li>创建 <code>your.github.io</code> 仓库用来存放静态博客页面</li>\n</ol>\n<h3 id=\"生成部署密钥\"><a href=\"#生成部署密钥\" class=\"headerlink\" title=\"生成部署密钥\"></a>生成部署密钥</h3><p>一路按回车直到生成成功</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-variable\">$</span> ssh<span class=\"hljs-literal\">-keygen</span> <span class=\"hljs-operator\">-f</span> github<span class=\"hljs-literal\">-deploy-key</span><br></code></pre></td></tr></table></figure>\n\n<p>当前目录下会有 <code>github-deploy-key</code> 和 <code>github-deploy-key.pub</code> 两个文件。</p>\n<h3 id=\"配置部署密钥\"><a href=\"#配置部署密钥\" class=\"headerlink\" title=\"配置部署密钥\"></a>配置部署密钥</h3><p>复制 <code>github-deploy-key</code> 文件内容，在 <code>blog</code> 仓库 <code>Settings -&gt; Secrets -&gt; Add a new secret</code> 页面上添加。</p>\n<ol>\n<li>在 <code>Name</code> 输入框填写 <code>HEXO_DEPLOY_PRI</code>。</li>\n<li>在 <code>Value</code> 输入框填写 <code>github-deploy-key</code> 文件内容。</li>\n</ol>\n<p><img src=\"https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-secret@2x.png\" alt=\"img\"></p>\n<p>复制 <code>github-deploy-key.pub</code> 文件内容，在 <code>your.github.io</code> 仓库 <code>Settings -&gt; Deploy keys -&gt; Add deploy key</code> 页面上添加。</p>\n<ol>\n<li>在 <code>Title</code> 输入框填写 <code>HEXO_DEPLOY_PUB</code>。</li>\n<li>在 <code>Key</code> 输入框填写 <code>github-deploy-key.pub</code> 文件内容。</li>\n<li>勾选 <code>Allow write access</code> 选项。</li>\n</ol>\n<p><img src=\"https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-key@2x.png\" alt=\"img\"></p>\n<h2 id=\"编写-Github-Actions\"><a href=\"#编写-Github-Actions\" class=\"headerlink\" title=\"编写 Github Actions\"></a>编写 Github Actions</h2><h3 id=\"Workflow-模版\"><a href=\"#Workflow-模版\" class=\"headerlink\" title=\"Workflow 模版\"></a>Workflow 模版</h3><p>在 <code>blog</code> 仓库根目录下创建 <code>.github/workflows/deploy.yml</code> 文件，目录结构如下。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">blog <span class=\"hljs-params\">(repository)</span><br>└── <span class=\"hljs-string\">.github</span><br>    └── workflows<br>        └── <span class=\"hljs-keyword\">deploy</span>.yml<br></code></pre></td></tr></table></figure>\n\n<p>在 <code>deploy.yml</code> 文件中粘贴以下内容。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">CI</span><br><br><span class=\"hljs-attr\">on:</span><br>  <span class=\"hljs-attr\">push:</span><br>    <span class=\"hljs-attr\">branches:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">master</span><br><br><span class=\"hljs-attr\">env:</span><br>  <span class=\"hljs-attr\">GIT_USER:</span> <span class=\"hljs-string\">Sanonz</span><br>  <span class=\"hljs-attr\">GIT_EMAIL:</span> <span class=\"hljs-string\">sanonz@126.com</span><br>  <span class=\"hljs-attr\">THEME_REPO:</span> <span class=\"hljs-string\">sanonz/hexo-theme-concise</span><br>  <span class=\"hljs-attr\">THEME_BRANCH:</span> <span class=\"hljs-string\">master</span><br>  <span class=\"hljs-attr\">DEPLOY_REPO:</span> <span class=\"hljs-string\">sanonz/sanonz.github.io</span><br>  <span class=\"hljs-attr\">DEPLOY_BRANCH:</span> <span class=\"hljs-string\">master</span><br><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">on</span> <span class=\"hljs-string\">node</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.os</span> <span class=\"hljs-string\">&#125;&#125;</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">strategy:</span><br>      <span class=\"hljs-attr\">matrix:</span><br>        <span class=\"hljs-attr\">os:</span> [<span class=\"hljs-string\">ubuntu-latest</span>]<br>        <span class=\"hljs-attr\">node_version:</span> [<span class=\"hljs-number\">12.</span><span class=\"hljs-string\">x</span>]<br><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">theme</span> <span class=\"hljs-string\">repo</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.THEME_REPO</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">ref:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.THEME_BRANCH</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">themes/concise</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">deploy</span> <span class=\"hljs-string\">repo</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.DEPLOY_REPO</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">ref:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.DEPLOY_BRANCH</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">.deploy_git</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Use</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v1</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">node-version:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Configuration</span> <span class=\"hljs-string\">environment</span><br>        <span class=\"hljs-attr\">env:</span><br>          <span class=\"hljs-attr\">HEXO_DEPLOY_PRI:</span> <span class=\"hljs-string\">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class=\"hljs-string\">          mkdir -p ~/.ssh/</span><br><span class=\"hljs-string\">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class=\"hljs-string\">          chmod 600 ~/.ssh/id_rsa</span><br><span class=\"hljs-string\">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"hljs-string\">          git config --global user.name $GIT_USER</span><br><span class=\"hljs-string\">          git config --global user.email $GIT_EMAIL</span><br><span class=\"hljs-string\">          cp _config.theme.yml themes/concise/_config.yml</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">dependencies</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">          npm install</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">hexo</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br>          <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">deploy</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"模版参数说明\"><a href=\"#模版参数说明\" class=\"headerlink\" title=\"模版参数说明\"></a>模版参数说明</h3><ul>\n<li><p><em>name</em> 为此 Action 的名字</p>\n</li>\n<li><p><em>on</em> 触发条件，当满足条件时会触发此任务，这里的 <code>on.push.branches.$.master</code> 是指当 <code>master</code> 分支收到 <code>push</code> 后执行任务。</p>\n</li>\n<li><p>env</p>\n<p>为环境变量对象</p>\n<ul>\n<li><em>env.GIT_USER</em> 为 Hexo 编译后使用此 git 用户部署到仓库。</li>\n<li><em>env.GIT_EMAIL</em> 为 Hexo 编译后使用此 git 邮箱部署到仓库。</li>\n<li><em>env.THEME_REPO</em> 为您的 Hexo 所使用的主题的仓库，这里为 <code>sanonz/hexo-theme-concise</code>。</li>\n<li><em>env.THEME_BRANCH</em> 为您的 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA。</li>\n<li><em>env.DEPLOY_REPO</em> 为 Hexo 编译后要部署的仓库，例如：<code>sanonz/sanonz.github.io</code>。</li>\n<li><em>env.DEPLOY_BRANCH</em> 为 Hexo 编译后要部署到的分支，例如：master。</li>\n</ul>\n</li>\n<li><p>jobs</p>\n<p>为此 Action 下的任务列表</p>\n<ul>\n<li><p><em>jobs.{job}.name</em> 任务名称</p>\n</li>\n<li><p><em>jobs.{job}.runs-on</em> 任务所需容器，可选值：<code>ubuntu-latest</code>、<code>windows-latest</code>、<code>macos-latest</code>。</p>\n</li>\n<li><p><em>jobs.{job}.strategy</em> 策略下可以写 <code>array</code> 格式，此 job 会遍历此数组执行。</p>\n</li>\n<li><p>jobs.{job}.steps</p>\n<p>一个步骤数组，可以把所要干的事分步骤放到这里。</p>\n<ul>\n<li><em>jobs.{job}.steps.$.name</em> 步骤名，编译时会会以 LOG 形式输出。</li>\n<li><em>jobs.{job}.steps.$.uses</em> 所要调用的 Action，可以到 <a href=\"https://github.com/actions\">https://github.com/actions</a> 查看更多。</li>\n<li><em>jobs.{job}.steps.$.with</em> 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第三方-Actions\"><a href=\"#第三方-Actions\" class=\"headerlink\" title=\"第三方 Actions\"></a>第三方 Actions</h3><p>使用第三方 Actions 语法 <code>&#123;owner&#125;/&#123;repo&#125;@&#123;ref&#125;</code> 或者 <code>&#123;owner&#125;/&#123;repo&#125;/&#123;path&#125;@&#123;ref&#125;</code> 例如：</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/checkout@v2</span><br></code></pre></td></tr></table></figure>\n\n<p>一、调用 <code>actions/checkout@v2</code> 可以实现 Checkout 一个 git 仓库到容器。</p>\n<p>例如 Checkout 当前仓库到本地，<code>with.repo</code> 不填写默认为当前仓库。</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/checkout@v2</span><br>        <span class=\"hljs-comment\"># with:</span><br>          <span class=\"hljs-comment\"># repository: $&#123;&#123; github.repository &#125;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>例如 Checkout 第三方仓库 <code>git@github.com:sanonz/hexo-theme-concise.git</code> 的 <code>master</code> 分支到容器 <code>themes/concise</code> 目录。</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/checkout@v2</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">with:</span><br>          <span class=\"hljs-attribute\">repository</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">sanonz/hexo-theme-concise</span><br>          <span class=\"hljs-attribute\">ref</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">master</span><br>          <span class=\"hljs-attribute\">path</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">themes/concise</span><br></code></pre></td></tr></table></figure>\n\n<p>二、调用 <code>actions/setup-node@v1</code> 可以配置容器 Node.js 环境。</p>\n<p>例如安装 Node.js 版本 v12 到容器中，<code>with.node-version</code> 可以指定 Node.js 版本。</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/setup-node@v1</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">with:</span><br>          <span class=\"hljs-attribute\">node-version</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">v12</span><br></code></pre></td></tr></table></figure>\n\n<p>可以在这里查找更多 Actions 以及使用方式 <a href=\"https://github.com/marketplace?type=actions&query=checkout\">官方 Actions 市场</a>。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>复制一份 <a href=\"https://github.com/sanonz/hexo-theme-concise/blob/master/_config.example.yml%EF%BC%8C%E6%94%BE%E5%88%B0\">https://github.com/sanonz/hexo-theme-concise/blob/master/_config.example.yml，放到</a> <code>blog</code> 根目录下，名为 <code>_config.theme.yml</code>，如果您已经配置过此文件，只需要把您的复制过来就行。</p>\n<p>最终目录结构</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">blog (repository)<br>├── _config<span class=\"hljs-selector-class\">.theme</span><span class=\"hljs-selector-class\">.yml</span><br>└── <span class=\"hljs-selector-class\">.github</span><br>    └── workflows<br>        └── deploy.yml<br></code></pre></td></tr></table></figure>\n\n<p>把 <code>_config.theme.yml</code> 与 <code>deploy.yml</code> 文件推送到 <code>blog</code> 仓库，在此仓库 <code>Actions</code> 页面可以看到一个名字为 <code>CI</code> 的 Action。</p>\n<h3 id=\"执行任务\"><a href=\"#执行任务\" class=\"headerlink\" title=\"执行任务\"></a>执行任务</h3><p>写一篇文章，<code>push</code> 到 <code>blog</code> 仓库的 <code>master</code> 分支，在此仓库 <code>Actions</code> 页面查看当前 task。</p>\n<p><img src=\"https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/run@2x.png\" alt=\"img\"></p>\n<p>当任务完成后查看您的博客 <code>https://your.github.io</code>，如果不出意外的话已经可以看到新添加的文章了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>偷懒是人类发展的动力，人都有偷懒的想法，目的就是为了让自己能够活得更好，经过几千年的不断发展，现在人偷懒的方式无疑更加的先进。</p>\n<p>至此结束，感谢阅读。</p>\n","site":{"data":{}},"wordcount":4649,"excerpt":"","more":"<h1 id=\"利用-Github-Actions-自动部署-Hexo-博客\"><a href=\"#利用-Github-Actions-自动部署-Hexo-博客\" class=\"headerlink\" title=\"利用 Github Actions 自动部署 Hexo 博客\"></a>利用 Github Actions 自动部署 Hexo 博客</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Github Actions 可以很方便实现 CI&#x2F;CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。</p>\n<p>本文将介绍利用 Github Actions 实现自动部署 hexo 到 Github Pages，在之前我们需要写完文章执行 <code>hexo generate --deploy</code> 来部署，当你文章比较多的时候，可能还需要等待很久，而且还可能会遇到本地安装的 Node.js 版本与 Hexo 不兼容的问题，目前我就是因为电脑的 Node.js 版本升到 v14 版本导致与 Hexo 不兼容部署不了，才来捣腾 Github Actions 功能的。利用 Github Actions 你将会没有这些烦恼。</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2><h3 id=\"创建所需仓库\"><a href=\"#创建所需仓库\" class=\"headerlink\" title=\"创建所需仓库\"></a>创建所需仓库</h3><ol>\n<li>创建 <code>blog</code> 仓库用来存放 Hexo 项目</li>\n<li>创建 <code>your.github.io</code> 仓库用来存放静态博客页面</li>\n</ol>\n<h3 id=\"生成部署密钥\"><a href=\"#生成部署密钥\" class=\"headerlink\" title=\"生成部署密钥\"></a>生成部署密钥</h3><p>一路按回车直到生成成功</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-variable\">$</span> ssh<span class=\"hljs-literal\">-keygen</span> <span class=\"hljs-operator\">-f</span> github<span class=\"hljs-literal\">-deploy-key</span><br></code></pre></td></tr></table></figure>\n\n<p>当前目录下会有 <code>github-deploy-key</code> 和 <code>github-deploy-key.pub</code> 两个文件。</p>\n<h3 id=\"配置部署密钥\"><a href=\"#配置部署密钥\" class=\"headerlink\" title=\"配置部署密钥\"></a>配置部署密钥</h3><p>复制 <code>github-deploy-key</code> 文件内容，在 <code>blog</code> 仓库 <code>Settings -&gt; Secrets -&gt; Add a new secret</code> 页面上添加。</p>\n<ol>\n<li>在 <code>Name</code> 输入框填写 <code>HEXO_DEPLOY_PRI</code>。</li>\n<li>在 <code>Value</code> 输入框填写 <code>github-deploy-key</code> 文件内容。</li>\n</ol>\n<p><img src=\"https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-secret@2x.png\" alt=\"img\"></p>\n<p>复制 <code>github-deploy-key.pub</code> 文件内容，在 <code>your.github.io</code> 仓库 <code>Settings -&gt; Deploy keys -&gt; Add deploy key</code> 页面上添加。</p>\n<ol>\n<li>在 <code>Title</code> 输入框填写 <code>HEXO_DEPLOY_PUB</code>。</li>\n<li>在 <code>Key</code> 输入框填写 <code>github-deploy-key.pub</code> 文件内容。</li>\n<li>勾选 <code>Allow write access</code> 选项。</li>\n</ol>\n<p><img src=\"https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/add-key@2x.png\" alt=\"img\"></p>\n<h2 id=\"编写-Github-Actions\"><a href=\"#编写-Github-Actions\" class=\"headerlink\" title=\"编写 Github Actions\"></a>编写 Github Actions</h2><h3 id=\"Workflow-模版\"><a href=\"#Workflow-模版\" class=\"headerlink\" title=\"Workflow 模版\"></a>Workflow 模版</h3><p>在 <code>blog</code> 仓库根目录下创建 <code>.github/workflows/deploy.yml</code> 文件，目录结构如下。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">blog <span class=\"hljs-params\">(repository)</span><br>└── <span class=\"hljs-string\">.github</span><br>    └── workflows<br>        └── <span class=\"hljs-keyword\">deploy</span>.yml<br></code></pre></td></tr></table></figure>\n\n<p>在 <code>deploy.yml</code> 文件中粘贴以下内容。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">CI</span><br><br><span class=\"hljs-attr\">on:</span><br>  <span class=\"hljs-attr\">push:</span><br>    <span class=\"hljs-attr\">branches:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">master</span><br><br><span class=\"hljs-attr\">env:</span><br>  <span class=\"hljs-attr\">GIT_USER:</span> <span class=\"hljs-string\">Sanonz</span><br>  <span class=\"hljs-attr\">GIT_EMAIL:</span> <span class=\"hljs-string\">sanonz@126.com</span><br>  <span class=\"hljs-attr\">THEME_REPO:</span> <span class=\"hljs-string\">sanonz/hexo-theme-concise</span><br>  <span class=\"hljs-attr\">THEME_BRANCH:</span> <span class=\"hljs-string\">master</span><br>  <span class=\"hljs-attr\">DEPLOY_REPO:</span> <span class=\"hljs-string\">sanonz/sanonz.github.io</span><br>  <span class=\"hljs-attr\">DEPLOY_BRANCH:</span> <span class=\"hljs-string\">master</span><br><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">on</span> <span class=\"hljs-string\">node</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.os</span> <span class=\"hljs-string\">&#125;&#125;</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">strategy:</span><br>      <span class=\"hljs-attr\">matrix:</span><br>        <span class=\"hljs-attr\">os:</span> [<span class=\"hljs-string\">ubuntu-latest</span>]<br>        <span class=\"hljs-attr\">node_version:</span> [<span class=\"hljs-number\">12.</span><span class=\"hljs-string\">x</span>]<br><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">theme</span> <span class=\"hljs-string\">repo</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.THEME_REPO</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">ref:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.THEME_BRANCH</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">themes/concise</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">deploy</span> <span class=\"hljs-string\">repo</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.DEPLOY_REPO</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">ref:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">env.DEPLOY_BRANCH</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">.deploy_git</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Use</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v1</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">node-version:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Configuration</span> <span class=\"hljs-string\">environment</span><br>        <span class=\"hljs-attr\">env:</span><br>          <span class=\"hljs-attr\">HEXO_DEPLOY_PRI:</span> <span class=\"hljs-string\">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class=\"hljs-string\">          mkdir -p ~/.ssh/</span><br><span class=\"hljs-string\">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class=\"hljs-string\">          chmod 600 ~/.ssh/id_rsa</span><br><span class=\"hljs-string\">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class=\"hljs-string\">          git config --global user.name $GIT_USER</span><br><span class=\"hljs-string\">          git config --global user.email $GIT_EMAIL</span><br><span class=\"hljs-string\">          cp _config.theme.yml themes/concise/_config.yml</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">dependencies</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">          npm install</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">hexo</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br>          <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">deploy</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"模版参数说明\"><a href=\"#模版参数说明\" class=\"headerlink\" title=\"模版参数说明\"></a>模版参数说明</h3><ul>\n<li><p><em>name</em> 为此 Action 的名字</p>\n</li>\n<li><p><em>on</em> 触发条件，当满足条件时会触发此任务，这里的 <code>on.push.branches.$.master</code> 是指当 <code>master</code> 分支收到 <code>push</code> 后执行任务。</p>\n</li>\n<li><p>env</p>\n<p>为环境变量对象</p>\n<ul>\n<li><em>env.GIT_USER</em> 为 Hexo 编译后使用此 git 用户部署到仓库。</li>\n<li><em>env.GIT_EMAIL</em> 为 Hexo 编译后使用此 git 邮箱部署到仓库。</li>\n<li><em>env.THEME_REPO</em> 为您的 Hexo 所使用的主题的仓库，这里为 <code>sanonz/hexo-theme-concise</code>。</li>\n<li><em>env.THEME_BRANCH</em> 为您的 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA。</li>\n<li><em>env.DEPLOY_REPO</em> 为 Hexo 编译后要部署的仓库，例如：<code>sanonz/sanonz.github.io</code>。</li>\n<li><em>env.DEPLOY_BRANCH</em> 为 Hexo 编译后要部署到的分支，例如：master。</li>\n</ul>\n</li>\n<li><p>jobs</p>\n<p>为此 Action 下的任务列表</p>\n<ul>\n<li><p><em>jobs.{job}.name</em> 任务名称</p>\n</li>\n<li><p><em>jobs.{job}.runs-on</em> 任务所需容器，可选值：<code>ubuntu-latest</code>、<code>windows-latest</code>、<code>macos-latest</code>。</p>\n</li>\n<li><p><em>jobs.{job}.strategy</em> 策略下可以写 <code>array</code> 格式，此 job 会遍历此数组执行。</p>\n</li>\n<li><p>jobs.{job}.steps</p>\n<p>一个步骤数组，可以把所要干的事分步骤放到这里。</p>\n<ul>\n<li><em>jobs.{job}.steps.$.name</em> 步骤名，编译时会会以 LOG 形式输出。</li>\n<li><em>jobs.{job}.steps.$.uses</em> 所要调用的 Action，可以到 <a href=\"https://github.com/actions\">https://github.com/actions</a> 查看更多。</li>\n<li><em>jobs.{job}.steps.$.with</em> 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第三方-Actions\"><a href=\"#第三方-Actions\" class=\"headerlink\" title=\"第三方 Actions\"></a>第三方 Actions</h3><p>使用第三方 Actions 语法 <code>&#123;owner&#125;/&#123;repo&#125;@&#123;ref&#125;</code> 或者 <code>&#123;owner&#125;/&#123;repo&#125;/&#123;path&#125;@&#123;ref&#125;</code> 例如：</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/checkout@v2</span><br></code></pre></td></tr></table></figure>\n\n<p>一、调用 <code>actions/checkout@v2</code> 可以实现 Checkout 一个 git 仓库到容器。</p>\n<p>例如 Checkout 当前仓库到本地，<code>with.repo</code> 不填写默认为当前仓库。</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/checkout@v2</span><br>        <span class=\"hljs-comment\"># with:</span><br>          <span class=\"hljs-comment\"># repository: $&#123;&#123; github.repository &#125;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>例如 Checkout 第三方仓库 <code>git@github.com:sanonz/hexo-theme-concise.git</code> 的 <code>master</code> 分支到容器 <code>themes/concise</code> 目录。</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/checkout@v2</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">with:</span><br>          <span class=\"hljs-attribute\">repository</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">sanonz/hexo-theme-concise</span><br>          <span class=\"hljs-attribute\">ref</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">master</span><br>          <span class=\"hljs-attribute\">path</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">themes/concise</span><br></code></pre></td></tr></table></figure>\n\n<p>二、调用 <code>actions/setup-node@v1</code> 可以配置容器 Node.js 环境。</p>\n<p>例如安装 Node.js 版本 v12 到容器中，<code>with.node-version</code> 可以指定 Node.js 版本。</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">jobs</span><span class=\"hljs-punctuation\">:</span><br>  <span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-attribute\">runs-on</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attribute\">steps</span><span class=\"hljs-punctuation\">:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">uses: actions/setup-node@v1</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">with:</span><br>          <span class=\"hljs-attribute\">node-version</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">v12</span><br></code></pre></td></tr></table></figure>\n\n<p>可以在这里查找更多 Actions 以及使用方式 <a href=\"https://github.com/marketplace?type=actions&query=checkout\">官方 Actions 市场</a>。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>复制一份 <a href=\"https://github.com/sanonz/hexo-theme-concise/blob/master/_config.example.yml%EF%BC%8C%E6%94%BE%E5%88%B0\">https://github.com/sanonz/hexo-theme-concise/blob/master/_config.example.yml，放到</a> <code>blog</code> 根目录下，名为 <code>_config.theme.yml</code>，如果您已经配置过此文件，只需要把您的复制过来就行。</p>\n<p>最终目录结构</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">blog (repository)<br>├── _config<span class=\"hljs-selector-class\">.theme</span><span class=\"hljs-selector-class\">.yml</span><br>└── <span class=\"hljs-selector-class\">.github</span><br>    └── workflows<br>        └── deploy.yml<br></code></pre></td></tr></table></figure>\n\n<p>把 <code>_config.theme.yml</code> 与 <code>deploy.yml</code> 文件推送到 <code>blog</code> 仓库，在此仓库 <code>Actions</code> 页面可以看到一个名字为 <code>CI</code> 的 Action。</p>\n<h3 id=\"执行任务\"><a href=\"#执行任务\" class=\"headerlink\" title=\"执行任务\"></a>执行任务</h3><p>写一篇文章，<code>push</code> 到 <code>blog</code> 仓库的 <code>master</code> 分支，在此仓库 <code>Actions</code> 页面查看当前 task。</p>\n<p><img src=\"https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/run@2x.png\" alt=\"img\"></p>\n<p>当任务完成后查看您的博客 <code>https://your.github.io</code>，如果不出意外的话已经可以看到新添加的文章了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>偷懒是人类发展的动力，人都有偷懒的想法，目的就是为了让自己能够活得更好，经过几千年的不断发展，现在人偷懒的方式无疑更加的先进。</p>\n<p>至此结束，感谢阅读。</p>\n"},{"title":"贴吧和我们的不同","date":"2022-04-24T10:13:27.000Z","description":"贴吧和我们的不同","_content":"\n# 贴吧\n\n**非saas**\n\n本身针对用户\n\n本身存在属于自己的流量池\n\n从用户需求出发\n\n流量多了之后，大型ip开始自发的出现\n\n贴吧对大型ip的出现做了特殊处理（标识）\n\n# 校嘟嘟\n\n## 针对机构\n\n**是saas**\n\n本身不存在用户\n\n需要通过第三方机构来引流\n\n此种角度功能点需为机构考虑\n\n尤其要注意IP覆盖问题\n\n给一个基础的小程序模版\n\n外加一些额外功能点\n\n机构可以选择自己定制功能点\n\n甚至可以放置一些需要收费的功能点\n\n见效快\n\n收益快\n\n长远来看不适合打造自己IP\n\n## 针对学生\n\n**非saas**\n\n无IP覆盖问题（因为不需要机构去帮忙推）\n\n和校内机构一定程度上存在竞争关系\n\n本身不存在用户\n\n且没有具有大量用户的属于自己的根据地\n\n需要地推\n\n需要找第三方广告\n\n微信小程序平台内置存在推广功能\n\n此种角度功能点需为学生考虑\n\n功能点的好坏程度直接影响到用户使用情况\n\n见效慢\n\n收益慢\n\n长远来看适合打造自己的IP","source":"_posts/创业/创业.md","raw":"---\ntitle: 贴吧和我们的不同\ndate: 2022-04-24 18:13:27\ntags:\n  - [贴吧]\n  - [创业]\ncategories:\n  - [思考]\ndescription: 贴吧和我们的不同\n---\n\n# 贴吧\n\n**非saas**\n\n本身针对用户\n\n本身存在属于自己的流量池\n\n从用户需求出发\n\n流量多了之后，大型ip开始自发的出现\n\n贴吧对大型ip的出现做了特殊处理（标识）\n\n# 校嘟嘟\n\n## 针对机构\n\n**是saas**\n\n本身不存在用户\n\n需要通过第三方机构来引流\n\n此种角度功能点需为机构考虑\n\n尤其要注意IP覆盖问题\n\n给一个基础的小程序模版\n\n外加一些额外功能点\n\n机构可以选择自己定制功能点\n\n甚至可以放置一些需要收费的功能点\n\n见效快\n\n收益快\n\n长远来看不适合打造自己IP\n\n## 针对学生\n\n**非saas**\n\n无IP覆盖问题（因为不需要机构去帮忙推）\n\n和校内机构一定程度上存在竞争关系\n\n本身不存在用户\n\n且没有具有大量用户的属于自己的根据地\n\n需要地推\n\n需要找第三方广告\n\n微信小程序平台内置存在推广功能\n\n此种角度功能点需为学生考虑\n\n功能点的好坏程度直接影响到用户使用情况\n\n见效慢\n\n收益慢\n\n长远来看适合打造自己的IP","slug":"创业/创业","published":1,"updated":"2022-08-28T07:38:59.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2a0038scvm0d4ab8g4","content":"<h1 id=\"贴吧\"><a href=\"#贴吧\" class=\"headerlink\" title=\"贴吧\"></a>贴吧</h1><p><strong>非saas</strong></p>\n<p>本身针对用户</p>\n<p>本身存在属于自己的流量池</p>\n<p>从用户需求出发</p>\n<p>流量多了之后，大型ip开始自发的出现</p>\n<p>贴吧对大型ip的出现做了特殊处理（标识）</p>\n<h1 id=\"校嘟嘟\"><a href=\"#校嘟嘟\" class=\"headerlink\" title=\"校嘟嘟\"></a>校嘟嘟</h1><h2 id=\"针对机构\"><a href=\"#针对机构\" class=\"headerlink\" title=\"针对机构\"></a>针对机构</h2><p><strong>是saas</strong></p>\n<p>本身不存在用户</p>\n<p>需要通过第三方机构来引流</p>\n<p>此种角度功能点需为机构考虑</p>\n<p>尤其要注意IP覆盖问题</p>\n<p>给一个基础的小程序模版</p>\n<p>外加一些额外功能点</p>\n<p>机构可以选择自己定制功能点</p>\n<p>甚至可以放置一些需要收费的功能点</p>\n<p>见效快</p>\n<p>收益快</p>\n<p>长远来看不适合打造自己IP</p>\n<h2 id=\"针对学生\"><a href=\"#针对学生\" class=\"headerlink\" title=\"针对学生\"></a>针对学生</h2><p><strong>非saas</strong></p>\n<p>无IP覆盖问题（因为不需要机构去帮忙推）</p>\n<p>和校内机构一定程度上存在竞争关系</p>\n<p>本身不存在用户</p>\n<p>且没有具有大量用户的属于自己的根据地</p>\n<p>需要地推</p>\n<p>需要找第三方广告</p>\n<p>微信小程序平台内置存在推广功能</p>\n<p>此种角度功能点需为学生考虑</p>\n<p>功能点的好坏程度直接影响到用户使用情况</p>\n<p>见效慢</p>\n<p>收益慢</p>\n<p>长远来看适合打造自己的IP</p>\n","site":{"data":{}},"wordcount":341,"excerpt":"","more":"<h1 id=\"贴吧\"><a href=\"#贴吧\" class=\"headerlink\" title=\"贴吧\"></a>贴吧</h1><p><strong>非saas</strong></p>\n<p>本身针对用户</p>\n<p>本身存在属于自己的流量池</p>\n<p>从用户需求出发</p>\n<p>流量多了之后，大型ip开始自发的出现</p>\n<p>贴吧对大型ip的出现做了特殊处理（标识）</p>\n<h1 id=\"校嘟嘟\"><a href=\"#校嘟嘟\" class=\"headerlink\" title=\"校嘟嘟\"></a>校嘟嘟</h1><h2 id=\"针对机构\"><a href=\"#针对机构\" class=\"headerlink\" title=\"针对机构\"></a>针对机构</h2><p><strong>是saas</strong></p>\n<p>本身不存在用户</p>\n<p>需要通过第三方机构来引流</p>\n<p>此种角度功能点需为机构考虑</p>\n<p>尤其要注意IP覆盖问题</p>\n<p>给一个基础的小程序模版</p>\n<p>外加一些额外功能点</p>\n<p>机构可以选择自己定制功能点</p>\n<p>甚至可以放置一些需要收费的功能点</p>\n<p>见效快</p>\n<p>收益快</p>\n<p>长远来看不适合打造自己IP</p>\n<h2 id=\"针对学生\"><a href=\"#针对学生\" class=\"headerlink\" title=\"针对学生\"></a>针对学生</h2><p><strong>非saas</strong></p>\n<p>无IP覆盖问题（因为不需要机构去帮忙推）</p>\n<p>和校内机构一定程度上存在竞争关系</p>\n<p>本身不存在用户</p>\n<p>且没有具有大量用户的属于自己的根据地</p>\n<p>需要地推</p>\n<p>需要找第三方广告</p>\n<p>微信小程序平台内置存在推广功能</p>\n<p>此种角度功能点需为学生考虑</p>\n<p>功能点的好坏程度直接影响到用户使用情况</p>\n<p>见效慢</p>\n<p>收益慢</p>\n<p>长远来看适合打造自己的IP</p>\n"},{"title":"父子组件交互","date":"2022-05-01T16:50:27.000Z","description":"父子组件交互","_content":"\n# 父子组件交互\n\n## 多数情况下应该首先使用标准的 props 和 emit 接口来实现父子组件交互\n\n### props\n\n```vue\n<script setup>\ndefineProps(['title'])\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>\n```\n\n`defineProps()`其中可以包含所有要传递给组件的参数，并且会返回一个对象，便于获取组件参数\n\n```js\nconst props = defineProps(['title'])\nconsole.log(props.title)\n```\n\n所有的 prop 都遵循着**单向绑定**原则，prop 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改了父组件的状态，不然应用的数据流就会变得难以理解了。\n\n另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你**不应该**在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：\n\n```js\nconst props = defineProps(['foo'])\n\n// ❌ 警告！prop 是只读的！\nprops.foo = 'bar'\n```\n\n想要更改 prop 通常都符合以下两种场景：\n\n1. **prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。** 在这种情况下，最好是新定义一个局部数据属性，从 prop 上获取初始值即可：\n\n   ```js\n   const props = defineProps(['initialCounter'])\n   \n   // 计数器只是将 props.initialCounter 作为初始值\n   // 像下面这样做就使 prop 和后续更新无关了\n   const counter = ref(props.initialCounter)\n   ```\n\n2. **prop 以原始的形式传入，但还需作转换。** 在这种情况中，最好是基于该 prop 值定义一个计算属性：\n\n   ```js\n   const props = defineProps(['size'])\n   \n   // 该 prop 变更时计算属性也会自动更新\n   const normalizedSize = computed(() => props.size.trim().toLowerCase())\n   ```\n\nprops的类型检验\n\n```js\ndefineProps({\n  // 基础类型检查\n  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // Number 类型的默认值\n  propD: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propE: {\n    type: Object,\n    // 一个返回默认对象/数组值\n    // 的工厂函数\n    default() {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  propF: {\n    validator(value) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propG: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n### emit\n\n子组件事件\n\n```vue\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>\n```\n\n父组件`v-on`或者`@`接收事件\n\n```vue\n<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />\n```\n\n我们可以通过 `defineEmits` 宏来选择性地声明需要抛出的事件：\n\n```vue\n<script setup>\n  defineProps(['title'])\n  defineEmits(['enlarge-text'])\n</script>\n```\n\n这记录了一个组件发出的所有事件，并可选择对其进行[验证](https://staging-cn.vuejs.org/guide/components/events.html#validate-emitted-events)。这还使得 Vue 避免了将它们作为原生事件监听器隐式地应用于子组件的根元素。\n\n和 `defineProps` 类似，`defineEmits` 仅可用于 `<script setup>` 之中，并且不需要导入，返回的 `emit` 函数可以被用于在 JavaScript 代码中抛出事件：\n\n```js\nconst emit = defineEmits(['enlarge-text'])\n\nemit('enlarge-text')\n```\n\n## 在确实需要直接操作元素实例的情况下\n\n此时便需要`ref`\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板 ref 同名\nconst input = ref(null)\n\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n对应元素的`ref`值必须和`script`中声明的值完全一致\n\n使用了 `<script setup>` 的组件是**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\ndefineExpose({\n  a,\n  b\n})\n</script>\n```\n\n当父组件通过模板 `ref` 获取到了该组件的实例时，得到的实例类型为 `{ a: number, b: number }` (`ref `都会自动解包，和一般的实例一样)。","source":"_posts/vue3学习/Day01.md","raw":"---\ntitle: 父子组件交互\ndate: 2022-05-02 00:50:27\ntags:\n  - [vue]\n  - [组件]\ncategories:\n  - [技术]\ndescription: 父子组件交互\n---\n\n# 父子组件交互\n\n## 多数情况下应该首先使用标准的 props 和 emit 接口来实现父子组件交互\n\n### props\n\n```vue\n<script setup>\ndefineProps(['title'])\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>\n```\n\n`defineProps()`其中可以包含所有要传递给组件的参数，并且会返回一个对象，便于获取组件参数\n\n```js\nconst props = defineProps(['title'])\nconsole.log(props.title)\n```\n\n所有的 prop 都遵循着**单向绑定**原则，prop 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改了父组件的状态，不然应用的数据流就会变得难以理解了。\n\n另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你**不应该**在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：\n\n```js\nconst props = defineProps(['foo'])\n\n// ❌ 警告！prop 是只读的！\nprops.foo = 'bar'\n```\n\n想要更改 prop 通常都符合以下两种场景：\n\n1. **prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。** 在这种情况下，最好是新定义一个局部数据属性，从 prop 上获取初始值即可：\n\n   ```js\n   const props = defineProps(['initialCounter'])\n   \n   // 计数器只是将 props.initialCounter 作为初始值\n   // 像下面这样做就使 prop 和后续更新无关了\n   const counter = ref(props.initialCounter)\n   ```\n\n2. **prop 以原始的形式传入，但还需作转换。** 在这种情况中，最好是基于该 prop 值定义一个计算属性：\n\n   ```js\n   const props = defineProps(['size'])\n   \n   // 该 prop 变更时计算属性也会自动更新\n   const normalizedSize = computed(() => props.size.trim().toLowerCase())\n   ```\n\nprops的类型检验\n\n```js\ndefineProps({\n  // 基础类型检查\n  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // Number 类型的默认值\n  propD: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propE: {\n    type: Object,\n    // 一个返回默认对象/数组值\n    // 的工厂函数\n    default() {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  propF: {\n    validator(value) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propG: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n### emit\n\n子组件事件\n\n```vue\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>\n```\n\n父组件`v-on`或者`@`接收事件\n\n```vue\n<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />\n```\n\n我们可以通过 `defineEmits` 宏来选择性地声明需要抛出的事件：\n\n```vue\n<script setup>\n  defineProps(['title'])\n  defineEmits(['enlarge-text'])\n</script>\n```\n\n这记录了一个组件发出的所有事件，并可选择对其进行[验证](https://staging-cn.vuejs.org/guide/components/events.html#validate-emitted-events)。这还使得 Vue 避免了将它们作为原生事件监听器隐式地应用于子组件的根元素。\n\n和 `defineProps` 类似，`defineEmits` 仅可用于 `<script setup>` 之中，并且不需要导入，返回的 `emit` 函数可以被用于在 JavaScript 代码中抛出事件：\n\n```js\nconst emit = defineEmits(['enlarge-text'])\n\nemit('enlarge-text')\n```\n\n## 在确实需要直接操作元素实例的情况下\n\n此时便需要`ref`\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板 ref 同名\nconst input = ref(null)\n\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n对应元素的`ref`值必须和`script`中声明的值完全一致\n\n使用了 `<script setup>` 的组件是**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\ndefineExpose({\n  a,\n  b\n})\n</script>\n```\n\n当父组件通过模板 `ref` 获取到了该组件的实例时，得到的实例类型为 `{ a: number, b: number }` (`ref `都会自动解包，和一般的实例一样)。","slug":"vue3学习/Day01","published":1,"updated":"2022-08-28T07:38:59.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2b003bscvm1a9r6l8v","content":"<h1 id=\"父子组件交互\"><a href=\"#父子组件交互\" class=\"headerlink\" title=\"父子组件交互\"></a>父子组件交互</h1><h2 id=\"多数情况下应该首先使用标准的-props-和-emit-接口来实现父子组件交互\"><a href=\"#多数情况下应该首先使用标准的-props-和-emit-接口来实现父子组件交互\" class=\"headerlink\" title=\"多数情况下应该首先使用标准的 props 和 emit 接口来实现父子组件交互\"></a>多数情况下应该首先使用标准的 props 和 emit 接口来实现父子组件交互</h2><h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>defineProps()</code>其中可以包含所有要传递给组件的参数，并且会返回一个对象，便于获取组件参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;title&#x27;</span>])<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(props.<span class=\"hljs-property\">title</span>)<br></code></pre></td></tr></table></figure>\n\n<p>所有的 prop 都遵循着<strong>单向绑定</strong>原则，prop 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改了父组件的状态，不然应用的数据流就会变得难以理解了。</p>\n<p>另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你<strong>不应该</strong>在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;foo&#x27;</span>])<br><br><span class=\"hljs-comment\">// ❌ 警告！prop 是只读的！</span><br>props.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>想要更改 prop 通常都符合以下两种场景：</p>\n<ol>\n<li><p><strong>prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。</strong> 在这种情况下，最好是新定义一个局部数据属性，从 prop 上获取初始值即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;initialCounter&#x27;</span>])<br><br><span class=\"hljs-comment\">// 计数器只是将 props.initialCounter 作为初始值</span><br><span class=\"hljs-comment\">// 像下面这样做就使 prop 和后续更新无关了</span><br><span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-title function_\">ref</span>(props.<span class=\"hljs-property\">initialCounter</span>)<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prop 以原始的形式传入，但还需作转换。</strong> 在这种情况中，最好是基于该 prop 值定义一个计算属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;size&#x27;</span>])<br><br><span class=\"hljs-comment\">// 该 prop 变更时计算属性也会自动更新</span><br><span class=\"hljs-keyword\">const</span> normalizedSize = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> props.<span class=\"hljs-property\">size</span>.<span class=\"hljs-title function_\">trim</span>().<span class=\"hljs-title function_\">toLowerCase</span>())<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>props的类型检验</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">defineProps</span>(&#123;<br>  <span class=\"hljs-comment\">// 基础类型检查</span><br>  <span class=\"hljs-comment\">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span><br>  <span class=\"hljs-attr\">propA</span>: <span class=\"hljs-title class_\">Number</span>,<br>  <span class=\"hljs-comment\">// 多种可能的类型</span><br>  <span class=\"hljs-attr\">propB</span>: [<span class=\"hljs-title class_\">String</span>, <span class=\"hljs-title class_\">Number</span>],<br>  <span class=\"hljs-comment\">// 必传，且为 String 类型</span><br>  <span class=\"hljs-attr\">propC</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,<br>    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>  &#125;,<br>  <span class=\"hljs-comment\">// Number 类型的默认值</span><br>  <span class=\"hljs-attr\">propD</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Number</span>,<br>    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">100</span><br>  &#125;,<br>  <span class=\"hljs-comment\">// 对象类型的默认值</span><br>  <span class=\"hljs-attr\">propE</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Object</span>,<br>    <span class=\"hljs-comment\">// 一个返回默认对象/数组值</span><br>    <span class=\"hljs-comment\">// 的工厂函数</span><br>    <span class=\"hljs-title function_\">default</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-comment\">// 自定义类型校验函数</span><br>  <span class=\"hljs-attr\">propF</span>: &#123;<br>    <span class=\"hljs-title function_\">validator</span>(<span class=\"hljs-params\">value</span>) &#123;<br>      <span class=\"hljs-comment\">// The value must match one of these strings</span><br>      <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">&#x27;success&#x27;</span>, <span class=\"hljs-string\">&#x27;warning&#x27;</span>, <span class=\"hljs-string\">&#x27;danger&#x27;</span>].<span class=\"hljs-title function_\">includes</span>(value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-comment\">// 函数类型的默认值</span><br>  <span class=\"hljs-attr\">propG</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Function</span>,<br>    <span class=\"hljs-comment\">// 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数</span><br>    <span class=\"hljs-title function_\">default</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Default function&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"emit\"><a href=\"#emit\" class=\"headerlink\" title=\"emit\"></a>emit</h3><p>子组件事件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;template&gt;<br>  &lt;div class=&quot;blog-post&quot;&gt;<br>    &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>父组件<code>v-on</code>或者<code>@</code>接收事件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;BlogPost<br>  ...<br>  @enlarge-text=&quot;postFontSize += 0.1&quot;<br> /&gt;<br></code></pre></td></tr></table></figure>\n\n<p>我们可以通过 <code>defineEmits</code> 宏来选择性地声明需要抛出的事件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>  defineProps([&#x27;title&#x27;])<br>  defineEmits([&#x27;enlarge-text&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这记录了一个组件发出的所有事件，并可选择对其进行<a href=\"https://staging-cn.vuejs.org/guide/components/events.html#validate-emitted-events\">验证</a>。这还使得 Vue 避免了将它们作为原生事件监听器隐式地应用于子组件的根元素。</p>\n<p>和 <code>defineProps</code> 类似，<code>defineEmits</code> 仅可用于 <code>&lt;script setup&gt;</code> 之中，并且不需要导入，返回的 <code>emit</code> 函数可以被用于在 JavaScript 代码中抛出事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> emit = <span class=\"hljs-title function_\">defineEmits</span>([<span class=\"hljs-string\">&#x27;enlarge-text&#x27;</span>])<br><br><span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;enlarge-text&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"在确实需要直接操作元素实例的情况下\"><a href=\"#在确实需要直接操作元素实例的情况下\" class=\"headerlink\" title=\"在确实需要直接操作元素实例的情况下\"></a>在确实需要直接操作元素实例的情况下</h2><p>此时便需要<code>ref</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;<br><br>// 声明一个 ref 来存放该元素的引用<br>// 必须和模板 ref 同名<br>const input = ref(null)<br><br>onMounted(() =&gt; &#123;<br>  input.value.focus()<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input ref=&quot;input&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>对应元素的<code>ref</code>值必须和<code>script</code>中声明的值完全一致</p>\n<p>使用了 <code>&lt;script setup&gt;</code> 的组件是<strong>默认私有</strong>的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 <code>defineExpose</code> 宏显式暴露：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const a = 1<br>const b = ref(2)<br><br>defineExpose(&#123;<br>  a,<br>  b<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>\n\n<p>当父组件通过模板 <code>ref</code> 获取到了该组件的实例时，得到的实例类型为 <code>&#123; a: number, b: number &#125;</code> (<code>ref </code>都会自动解包，和一般的实例一样)。</p>\n","site":{"data":{}},"wordcount":3093,"excerpt":"","more":"<h1 id=\"父子组件交互\"><a href=\"#父子组件交互\" class=\"headerlink\" title=\"父子组件交互\"></a>父子组件交互</h1><h2 id=\"多数情况下应该首先使用标准的-props-和-emit-接口来实现父子组件交互\"><a href=\"#多数情况下应该首先使用标准的-props-和-emit-接口来实现父子组件交互\" class=\"headerlink\" title=\"多数情况下应该首先使用标准的 props 和 emit 接口来实现父子组件交互\"></a>多数情况下应该首先使用标准的 props 和 emit 接口来实现父子组件交互</h2><h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>defineProps()</code>其中可以包含所有要传递给组件的参数，并且会返回一个对象，便于获取组件参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;title&#x27;</span>])<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(props.<span class=\"hljs-property\">title</span>)<br></code></pre></td></tr></table></figure>\n\n<p>所有的 prop 都遵循着<strong>单向绑定</strong>原则，prop 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改了父组件的状态，不然应用的数据流就会变得难以理解了。</p>\n<p>另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你<strong>不应该</strong>在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;foo&#x27;</span>])<br><br><span class=\"hljs-comment\">// ❌ 警告！prop 是只读的！</span><br>props.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>想要更改 prop 通常都符合以下两种场景：</p>\n<ol>\n<li><p><strong>prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。</strong> 在这种情况下，最好是新定义一个局部数据属性，从 prop 上获取初始值即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;initialCounter&#x27;</span>])<br><br><span class=\"hljs-comment\">// 计数器只是将 props.initialCounter 作为初始值</span><br><span class=\"hljs-comment\">// 像下面这样做就使 prop 和后续更新无关了</span><br><span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-title function_\">ref</span>(props.<span class=\"hljs-property\">initialCounter</span>)<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>prop 以原始的形式传入，但还需作转换。</strong> 在这种情况中，最好是基于该 prop 值定义一个计算属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">&#x27;size&#x27;</span>])<br><br><span class=\"hljs-comment\">// 该 prop 变更时计算属性也会自动更新</span><br><span class=\"hljs-keyword\">const</span> normalizedSize = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> props.<span class=\"hljs-property\">size</span>.<span class=\"hljs-title function_\">trim</span>().<span class=\"hljs-title function_\">toLowerCase</span>())<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>props的类型检验</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">defineProps</span>(&#123;<br>  <span class=\"hljs-comment\">// 基础类型检查</span><br>  <span class=\"hljs-comment\">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span><br>  <span class=\"hljs-attr\">propA</span>: <span class=\"hljs-title class_\">Number</span>,<br>  <span class=\"hljs-comment\">// 多种可能的类型</span><br>  <span class=\"hljs-attr\">propB</span>: [<span class=\"hljs-title class_\">String</span>, <span class=\"hljs-title class_\">Number</span>],<br>  <span class=\"hljs-comment\">// 必传，且为 String 类型</span><br>  <span class=\"hljs-attr\">propC</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,<br>    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span><br>  &#125;,<br>  <span class=\"hljs-comment\">// Number 类型的默认值</span><br>  <span class=\"hljs-attr\">propD</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Number</span>,<br>    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">100</span><br>  &#125;,<br>  <span class=\"hljs-comment\">// 对象类型的默认值</span><br>  <span class=\"hljs-attr\">propE</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Object</span>,<br>    <span class=\"hljs-comment\">// 一个返回默认对象/数组值</span><br>    <span class=\"hljs-comment\">// 的工厂函数</span><br>    <span class=\"hljs-title function_\">default</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-comment\">// 自定义类型校验函数</span><br>  <span class=\"hljs-attr\">propF</span>: &#123;<br>    <span class=\"hljs-title function_\">validator</span>(<span class=\"hljs-params\">value</span>) &#123;<br>      <span class=\"hljs-comment\">// The value must match one of these strings</span><br>      <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">&#x27;success&#x27;</span>, <span class=\"hljs-string\">&#x27;warning&#x27;</span>, <span class=\"hljs-string\">&#x27;danger&#x27;</span>].<span class=\"hljs-title function_\">includes</span>(value)<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-comment\">// 函数类型的默认值</span><br>  <span class=\"hljs-attr\">propG</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Function</span>,<br>    <span class=\"hljs-comment\">// 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数</span><br>    <span class=\"hljs-title function_\">default</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Default function&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"emit\"><a href=\"#emit\" class=\"headerlink\" title=\"emit\"></a>emit</h3><p>子组件事件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;template&gt;<br>  &lt;div class=&quot;blog-post&quot;&gt;<br>    &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>父组件<code>v-on</code>或者<code>@</code>接收事件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;BlogPost<br>  ...<br>  @enlarge-text=&quot;postFontSize += 0.1&quot;<br> /&gt;<br></code></pre></td></tr></table></figure>\n\n<p>我们可以通过 <code>defineEmits</code> 宏来选择性地声明需要抛出的事件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>  defineProps([&#x27;title&#x27;])<br>  defineEmits([&#x27;enlarge-text&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这记录了一个组件发出的所有事件，并可选择对其进行<a href=\"https://staging-cn.vuejs.org/guide/components/events.html#validate-emitted-events\">验证</a>。这还使得 Vue 避免了将它们作为原生事件监听器隐式地应用于子组件的根元素。</p>\n<p>和 <code>defineProps</code> 类似，<code>defineEmits</code> 仅可用于 <code>&lt;script setup&gt;</code> 之中，并且不需要导入，返回的 <code>emit</code> 函数可以被用于在 JavaScript 代码中抛出事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> emit = <span class=\"hljs-title function_\">defineEmits</span>([<span class=\"hljs-string\">&#x27;enlarge-text&#x27;</span>])<br><br><span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;enlarge-text&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"在确实需要直接操作元素实例的情况下\"><a href=\"#在确实需要直接操作元素实例的情况下\" class=\"headerlink\" title=\"在确实需要直接操作元素实例的情况下\"></a>在确实需要直接操作元素实例的情况下</h2><p>此时便需要<code>ref</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;<br><br>// 声明一个 ref 来存放该元素的引用<br>// 必须和模板 ref 同名<br>const input = ref(null)<br><br>onMounted(() =&gt; &#123;<br>  input.value.focus()<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input ref=&quot;input&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>对应元素的<code>ref</code>值必须和<code>script</code>中声明的值完全一致</p>\n<p>使用了 <code>&lt;script setup&gt;</code> 的组件是<strong>默认私有</strong>的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 <code>defineExpose</code> 宏显式暴露：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const a = 1<br>const b = ref(2)<br><br>defineExpose(&#123;<br>  a,<br>  b<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>\n\n<p>当父组件通过模板 <code>ref</code> 获取到了该组件的实例时，得到的实例类型为 <code>&#123; a: number, b: number &#125;</code> (<code>ref </code>都会自动解包，和一般的实例一样)。</p>\n"},{"title":"自定义组件双向绑定","date":"2022-05-01T16:50:27.000Z","description":"自定义组件双向绑定","_content":"\n# 自定义组件双向绑定\n\n## 原生`input`组件\n\n>  自带双向绑定\n\n```vue\n<input v-model=\"searchText\" />\n```\n\n## 自定义组件\n\n>  需要作如下处理\n\n### 子组件\n\n```vue\n<!-- CustomInput.vue -->\n<script setup>\ndefineProps(['modelValue'])\ndefineEmits(['update:modelValue'])\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n### 父组件\n\n```vue\n<CustomInput v-model=\"searchText\" />\n```\n\n> 默认的传参方式需要有一个`modelValue`的`props`，以及一个`update:modelValue`的事件传参\n\n**当然也可以自定义传参，方式如下，多个数据双向绑定便可利用这种方式**\n\n### 子组件\n\n```vue\n<!-- MyComponent.vue -->\n<script setup>\ndefineProps(['title'])\ndefineEmits(['update:title'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n### 父组件\n\n```vue\n<MyComponent v-model:title=\"bookTitle\" />\n```\n\n## `v-model`修饰符\n\n### 处理 `v-model` 修饰符\n\n当我们在学习输入绑定时，我们知道了 `v-model` 有一些内置的修饰符，例如 `.trim`，`.number` 和 `.lazy`。然而在某些场景下，你可能想要添加自定义的修饰符。\n\n我们一起来创建一个自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：\n\n```vue\n<MyComponent v-model.capitalize=\"myText\" />\n```\n\n要给组件的 `v-model` 添加修饰符，都可以通过 `modelModifiers` prop 在组件内访问到。在下面的例子中，我们会创建一个包含 `modelModifiers` prop 的组件，它的默认值是一个空对象：\n\n```vue\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\ndefineEmits(['update:modelValue'])\n\nconsole.log(props.modelModifiers) // { capitalize: true }\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n注意这里组件的 `modelModifiers` prop 包含了 `capitalize` 且其值为 `true`，因为它在模板中的 `v-model` 绑定上被使用了。\n\n此时和 prop 相关的已经准备完毕，我们可以开始检索 `modelModifiers` 对象的 key 并写一个处理函数来改变抛出事件附带的值。在下面的代码里我们就是在每次 `<input/>` 元素抛出 `input` 事件时执行大写首字母：\n\n```vue\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\nconst emit = defineEmits(['update:modelValue'])\n\nfunction emitValue(e) {\n  let value = e.target.value\n  if (props.modelModifiers.capitalize) {\n    value = value.charAt(0).toUpperCase() + value.slice(1)\n  }\n  emit('update:modelValue', value)\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n对于又有参数又有修饰符的 `v-model` 绑定，生成的 prop 名将是 `arg + \"Modifiers\"`。举个例子：\n\n```vue\n<MyComponent v-model:title.capitalize=\"myText\">\n```\n\n则相应的声明应该是：\n\n```vue\nconst props = defineProps(['title', 'titleModifiers'])\ndefineEmits(['update:title'])\n\nconsole.log(props.titleModifiers) // { capitalize: true }\n```","source":"_posts/vue3学习/Day02.md","raw":"---\ntitle: 自定义组件双向绑定\ndate: 2022-05-02 00:50:27\ntags:\n  - [vue]\n  - [组件]\n  - [双向绑定]\ncategories:\n  - [技术]\ndescription: 自定义组件双向绑定\n---\n\n# 自定义组件双向绑定\n\n## 原生`input`组件\n\n>  自带双向绑定\n\n```vue\n<input v-model=\"searchText\" />\n```\n\n## 自定义组件\n\n>  需要作如下处理\n\n### 子组件\n\n```vue\n<!-- CustomInput.vue -->\n<script setup>\ndefineProps(['modelValue'])\ndefineEmits(['update:modelValue'])\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n### 父组件\n\n```vue\n<CustomInput v-model=\"searchText\" />\n```\n\n> 默认的传参方式需要有一个`modelValue`的`props`，以及一个`update:modelValue`的事件传参\n\n**当然也可以自定义传参，方式如下，多个数据双向绑定便可利用这种方式**\n\n### 子组件\n\n```vue\n<!-- MyComponent.vue -->\n<script setup>\ndefineProps(['title'])\ndefineEmits(['update:title'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n### 父组件\n\n```vue\n<MyComponent v-model:title=\"bookTitle\" />\n```\n\n## `v-model`修饰符\n\n### 处理 `v-model` 修饰符\n\n当我们在学习输入绑定时，我们知道了 `v-model` 有一些内置的修饰符，例如 `.trim`，`.number` 和 `.lazy`。然而在某些场景下，你可能想要添加自定义的修饰符。\n\n我们一起来创建一个自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：\n\n```vue\n<MyComponent v-model.capitalize=\"myText\" />\n```\n\n要给组件的 `v-model` 添加修饰符，都可以通过 `modelModifiers` prop 在组件内访问到。在下面的例子中，我们会创建一个包含 `modelModifiers` prop 的组件，它的默认值是一个空对象：\n\n```vue\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\ndefineEmits(['update:modelValue'])\n\nconsole.log(props.modelModifiers) // { capitalize: true }\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n注意这里组件的 `modelModifiers` prop 包含了 `capitalize` 且其值为 `true`，因为它在模板中的 `v-model` 绑定上被使用了。\n\n此时和 prop 相关的已经准备完毕，我们可以开始检索 `modelModifiers` 对象的 key 并写一个处理函数来改变抛出事件附带的值。在下面的代码里我们就是在每次 `<input/>` 元素抛出 `input` 事件时执行大写首字母：\n\n```vue\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\nconst emit = defineEmits(['update:modelValue'])\n\nfunction emitValue(e) {\n  let value = e.target.value\n  if (props.modelModifiers.capitalize) {\n    value = value.charAt(0).toUpperCase() + value.slice(1)\n  }\n  emit('update:modelValue', value)\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n对于又有参数又有修饰符的 `v-model` 绑定，生成的 prop 名将是 `arg + \"Modifiers\"`。举个例子：\n\n```vue\n<MyComponent v-model:title.capitalize=\"myText\">\n```\n\n则相应的声明应该是：\n\n```vue\nconst props = defineProps(['title', 'titleModifiers'])\ndefineEmits(['update:title'])\n\nconsole.log(props.titleModifiers) // { capitalize: true }\n```","slug":"vue3学习/Day02","published":1,"updated":"2022-08-28T07:38:59.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2c003fscvm98zj3wmh","content":"<h1 id=\"自定义组件双向绑定\"><a href=\"#自定义组件双向绑定\" class=\"headerlink\" title=\"自定义组件双向绑定\"></a>自定义组件双向绑定</h1><h2 id=\"原生input组件\"><a href=\"#原生input组件\" class=\"headerlink\" title=\"原生input组件\"></a>原生<code>input</code>组件</h2><blockquote>\n<p> 自带双向绑定</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;input v-model=&quot;searchText&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h2><blockquote>\n<p> 需要作如下处理</p>\n</blockquote>\n<h3 id=\"子组件\"><a href=\"#子组件\" class=\"headerlink\" title=\"子组件\"></a>子组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;!-- CustomInput.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"父组件\"><a href=\"#父组件\" class=\"headerlink\" title=\"父组件\"></a>父组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;CustomInput v-model=&quot;searchText&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>默认的传参方式需要有一个<code>modelValue</code>的<code>props</code>，以及一个<code>update:modelValue</code>的事件传参</p>\n</blockquote>\n<p><strong>当然也可以自定义传参，方式如下，多个数据双向绑定便可利用这种方式</strong></p>\n<h3 id=\"子组件-1\"><a href=\"#子组件-1\" class=\"headerlink\" title=\"子组件\"></a>子组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])<br>defineEmits([&#x27;update:title&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;title&quot;<br>    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"父组件-1\"><a href=\"#父组件-1\" class=\"headerlink\" title=\"父组件\"></a>父组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"v-model修饰符\"><a href=\"#v-model修饰符\" class=\"headerlink\" title=\"v-model修饰符\"></a><code>v-model</code>修饰符</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 <code>v-model</code> 修饰符</h3><p>当我们在学习输入绑定时，我们知道了 <code>v-model</code> 有一些内置的修饰符，例如 <code>.trim</code>，<code>.number</code> 和 <code>.lazy</code>。然而在某些场景下，你可能想要添加自定义的修饰符。</p>\n<p>我们一起来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<p>要给组件的 <code>v-model</code> 添加修饰符，都可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的例子中，我们会创建一个包含 <code>modelModifiers</code> prop 的组件，它的默认值是一个空对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  modelValue: String,<br>  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;<br>&#125;)<br><br>defineEmits([&#x27;update:modelValue&#x27;])<br><br>console.log(props.modelModifiers) // &#123; capitalize: true &#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定上被使用了。</p>\n<p>此时和 prop 相关的已经准备完毕，我们可以开始检索 <code>modelModifiers</code> 对象的 key 并写一个处理函数来改变抛出事件附带的值。在下面的代码里我们就是在每次 <code>&lt;input/&gt;</code> 元素抛出 <code>input</code> 事件时执行大写首字母：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  modelValue: String,<br>  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;<br>&#125;)<br><br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br><br>function emitValue(e) &#123;<br>  let value = e.target.value<br>  if (props.modelModifiers.capitalize) &#123;<br>    value = value.charAt(0).toUpperCase() + value.slice(1)<br>  &#125;<br>  emit(&#x27;update:modelValue&#x27;, value)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>对于又有参数又有修饰符的 <code>v-model</code> 绑定，生成的 prop 名将是 <code>arg + &quot;Modifiers&quot;</code>。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;MyComponent v-model:title.capitalize=&quot;myText&quot;&gt;<br></code></pre></td></tr></table></figure>\n\n<p>则相应的声明应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">const props = defineProps([&#x27;title&#x27;, &#x27;titleModifiers&#x27;])<br>defineEmits([&#x27;update:title&#x27;])<br><br>console.log(props.titleModifiers) // &#123; capitalize: true &#125;<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":2716,"excerpt":"","more":"<h1 id=\"自定义组件双向绑定\"><a href=\"#自定义组件双向绑定\" class=\"headerlink\" title=\"自定义组件双向绑定\"></a>自定义组件双向绑定</h1><h2 id=\"原生input组件\"><a href=\"#原生input组件\" class=\"headerlink\" title=\"原生input组件\"></a>原生<code>input</code>组件</h2><blockquote>\n<p> 自带双向绑定</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;input v-model=&quot;searchText&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h2><blockquote>\n<p> 需要作如下处理</p>\n</blockquote>\n<h3 id=\"子组件\"><a href=\"#子组件\" class=\"headerlink\" title=\"子组件\"></a>子组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;!-- CustomInput.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"父组件\"><a href=\"#父组件\" class=\"headerlink\" title=\"父组件\"></a>父组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;CustomInput v-model=&quot;searchText&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>默认的传参方式需要有一个<code>modelValue</code>的<code>props</code>，以及一个<code>update:modelValue</code>的事件传参</p>\n</blockquote>\n<p><strong>当然也可以自定义传参，方式如下，多个数据双向绑定便可利用这种方式</strong></p>\n<h3 id=\"子组件-1\"><a href=\"#子组件-1\" class=\"headerlink\" title=\"子组件\"></a>子组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])<br>defineEmits([&#x27;update:title&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;title&quot;<br>    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"父组件-1\"><a href=\"#父组件-1\" class=\"headerlink\" title=\"父组件\"></a>父组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"v-model修饰符\"><a href=\"#v-model修饰符\" class=\"headerlink\" title=\"v-model修饰符\"></a><code>v-model</code>修饰符</h2><h3 id=\"处理-v-model-修饰符\"><a href=\"#处理-v-model-修饰符\" class=\"headerlink\" title=\"处理 v-model 修饰符\"></a>处理 <code>v-model</code> 修饰符</h3><p>当我们在学习输入绑定时，我们知道了 <code>v-model</code> 有一些内置的修饰符，例如 <code>.trim</code>，<code>.number</code> 和 <code>.lazy</code>。然而在某些场景下，你可能想要添加自定义的修饰符。</p>\n<p>我们一起来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;<br></code></pre></td></tr></table></figure>\n\n<p>要给组件的 <code>v-model</code> 添加修饰符，都可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的例子中，我们会创建一个包含 <code>modelModifiers</code> prop 的组件，它的默认值是一个空对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  modelValue: String,<br>  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;<br>&#125;)<br><br>defineEmits([&#x27;update:modelValue&#x27;])<br><br>console.log(props.modelModifiers) // &#123; capitalize: true &#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定上被使用了。</p>\n<p>此时和 prop 相关的已经准备完毕，我们可以开始检索 <code>modelModifiers</code> 对象的 key 并写一个处理函数来改变抛出事件附带的值。在下面的代码里我们就是在每次 <code>&lt;input/&gt;</code> 元素抛出 <code>input</code> 事件时执行大写首字母：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  modelValue: String,<br>  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;<br>&#125;)<br><br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br><br>function emitValue(e) &#123;<br>  let value = e.target.value<br>  if (props.modelModifiers.capitalize) &#123;<br>    value = value.charAt(0).toUpperCase() + value.slice(1)<br>  &#125;<br>  emit(&#x27;update:modelValue&#x27;, value)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>\n\n<p>对于又有参数又有修饰符的 <code>v-model</code> 绑定，生成的 prop 名将是 <code>arg + &quot;Modifiers&quot;</code>。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">&lt;MyComponent v-model:title.capitalize=&quot;myText&quot;&gt;<br></code></pre></td></tr></table></figure>\n\n<p>则相应的声明应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">const props = defineProps([&#x27;title&#x27;, &#x27;titleModifiers&#x27;])<br>defineEmits([&#x27;update:title&#x27;])<br><br>console.log(props.titleModifiers) // &#123; capitalize: true &#125;<br></code></pre></td></tr></table></figure>"},{"title":"Django快速搭建后端","date":"2022-04-08T15:35:27.000Z","description":"Django后端。","_content":"\n## 官方文档（含教程）\n\n[Django](https://www.djangoproject.com/)\n\n[Home - Django REST framework](https://www.django-rest-framework.org/)\n\n## 基本操作（终端中执行）\n\n新建一个Django项目\n\n```bash\ndjango-admin startproject mysite\n```\n\n新建一个接口组\n\n```bash\ndjango-admin startapp test_app\n```\n\n启动Django项目\n\n```bash\npython manage.py runserver\n```\n\n创建管理员账户\n\n```bash\npython manage.py createsuperuser\n```\n\n## rest_framework\n\n```python\nINSTALLED_APPS = [\n\t\t'rest_framework', #增加这一行\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n```\n\n## 解决时区问题\n\n在`settings.py`中修改\n\n```python\nTIME_ZONE = 'Asia/Shanghai' #时区改成上海\n# USE_TZ = True #这行注释\n```\n\n## 解决跨域\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n\nMIDDLEWARE = [\n\t\t#中间件修改成如下\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n```\n\n## Django默认样式不好看\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'simpleui', #增加这一行\n    'mall.apps.MallConfig',\n    'rest_framework',\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n```\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n```python\n# 去掉默认Logo或换成自己Logo链接\nSIMPLEUI_LOGO = '<https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png>'\n# 默认语言换成中文\nLANGUAGE_CODE = 'zh-hans'\n```\n\n## Django的时间返回中间带`T`\n\n`settings.py`中增加如下配置\n\n```python\nREST_FRAMEWORK = {\n    'DATETIME_FORMAT': \"%Y-%m-%d %H:%M:%S\",\n}\n```\n\n## 数据库配置\n\n```python\nDATABASES = {\n    'default': {\n        'OPTIONS': {'charset': 'utf8mb4'},\n        'ENGINE': 'django.db.backends.mysql',  # 数据库引擎\n        'NAME': 'mall',  # 数据库名称\n        'USER': 'root',  # 连接数据库的用户名称\n        'PASSWORD': 'root',  # 用户密码\n        'HOST': 'localhost',  # 访问的数据库的主机的ip地址\n        'PORT': '3306',  # 默认mysql访问端口\n    },\n}\n```\n\n## Mysql转Django模型类\n\n创建一个Django项目\n\n```javascript\ndjango-admin startproject ‘xxxx‘\n```\n\n修改setting文件，在setting里面设置你要连接的数据库类型和连接名称，地址之类，和创建新项目的时候一致\n\n```javascript\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'sqlexam',\n        'USER': 'root',\n        'PASSWORD': 'root12345',\n        'HOST': '127.0.0.1',\n        'PORT': 3306\n    }\n}\n```\n\n接下来就可以根据数据库数据生成对应的models模型文件\n\n1、生成模型文件\n\n```javascript\npython3 manage.py inspectdb\n```\n\n2、将模型文件导入到app当中\n\n创建app\n\n```javascript\npython3 manage.py startapp 'app名字'\n```\n\n将模型导入创建的app中\n\n```javascript\npython3 manage.py inspectdb > app/models.py\n```\n\n# 修改数据库\n\n## 方法一\n\n1. 在nivicat中直接直接改动数据结构\n\n2. 在终端中执行\n\n   ```python\n   python manage.py inspectdb\n   ```\n\n   \n\n","source":"_posts/后端/Django.md","raw":"---\ntitle: Django快速搭建后端\ndate: 2022-04-08 23:35:27\ntags:\n  - [django]\n  - [后端]\ncategories:\n  - [技术]\ndescription: Django后端。\n---\n\n## 官方文档（含教程）\n\n[Django](https://www.djangoproject.com/)\n\n[Home - Django REST framework](https://www.django-rest-framework.org/)\n\n## 基本操作（终端中执行）\n\n新建一个Django项目\n\n```bash\ndjango-admin startproject mysite\n```\n\n新建一个接口组\n\n```bash\ndjango-admin startapp test_app\n```\n\n启动Django项目\n\n```bash\npython manage.py runserver\n```\n\n创建管理员账户\n\n```bash\npython manage.py createsuperuser\n```\n\n## rest_framework\n\n```python\nINSTALLED_APPS = [\n\t\t'rest_framework', #增加这一行\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n```\n\n## 解决时区问题\n\n在`settings.py`中修改\n\n```python\nTIME_ZONE = 'Asia/Shanghai' #时区改成上海\n# USE_TZ = True #这行注释\n```\n\n## 解决跨域\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n\nMIDDLEWARE = [\n\t\t#中间件修改成如下\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n```\n\n## Django默认样式不好看\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'simpleui', #增加这一行\n    'mall.apps.MallConfig',\n    'rest_framework',\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n```\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n```python\n# 去掉默认Logo或换成自己Logo链接\nSIMPLEUI_LOGO = '<https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png>'\n# 默认语言换成中文\nLANGUAGE_CODE = 'zh-hans'\n```\n\n## Django的时间返回中间带`T`\n\n`settings.py`中增加如下配置\n\n```python\nREST_FRAMEWORK = {\n    'DATETIME_FORMAT': \"%Y-%m-%d %H:%M:%S\",\n}\n```\n\n## 数据库配置\n\n```python\nDATABASES = {\n    'default': {\n        'OPTIONS': {'charset': 'utf8mb4'},\n        'ENGINE': 'django.db.backends.mysql',  # 数据库引擎\n        'NAME': 'mall',  # 数据库名称\n        'USER': 'root',  # 连接数据库的用户名称\n        'PASSWORD': 'root',  # 用户密码\n        'HOST': 'localhost',  # 访问的数据库的主机的ip地址\n        'PORT': '3306',  # 默认mysql访问端口\n    },\n}\n```\n\n## Mysql转Django模型类\n\n创建一个Django项目\n\n```javascript\ndjango-admin startproject ‘xxxx‘\n```\n\n修改setting文件，在setting里面设置你要连接的数据库类型和连接名称，地址之类，和创建新项目的时候一致\n\n```javascript\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'sqlexam',\n        'USER': 'root',\n        'PASSWORD': 'root12345',\n        'HOST': '127.0.0.1',\n        'PORT': 3306\n    }\n}\n```\n\n接下来就可以根据数据库数据生成对应的models模型文件\n\n1、生成模型文件\n\n```javascript\npython3 manage.py inspectdb\n```\n\n2、将模型文件导入到app当中\n\n创建app\n\n```javascript\npython3 manage.py startapp 'app名字'\n```\n\n将模型导入创建的app中\n\n```javascript\npython3 manage.py inspectdb > app/models.py\n```\n\n# 修改数据库\n\n## 方法一\n\n1. 在nivicat中直接直接改动数据结构\n\n2. 在终端中执行\n\n   ```python\n   python manage.py inspectdb\n   ```\n\n   \n\n","slug":"后端/Django","published":1,"updated":"2022-08-28T07:38:59.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2c003jscvmeu2l8f2d","content":"<h2 id=\"官方文档（含教程）\"><a href=\"#官方文档（含教程）\" class=\"headerlink\" title=\"官方文档（含教程）\"></a>官方文档（含教程）</h2><p><a href=\"https://www.djangoproject.com/\">Django</a></p>\n<p><a href=\"https://www.django-rest-framework.org/\">Home - Django REST framework</a></p>\n<h2 id=\"基本操作（终端中执行）\"><a href=\"#基本操作（终端中执行）\" class=\"headerlink\" title=\"基本操作（终端中执行）\"></a>基本操作（终端中执行）</h2><p>新建一个Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startproject mysite<br></code></pre></td></tr></table></figure>\n\n<p>新建一个接口组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startapp test_app<br></code></pre></td></tr></table></figure>\n\n<p>启动Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py runserver<br></code></pre></td></tr></table></figure>\n\n<p>创建管理员账户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py createsuperuser<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"rest-framework\"><a href=\"#rest-framework\" class=\"headerlink\" title=\"rest_framework\"></a>rest_framework</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>\t\t<span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决时区问题\"><a href=\"#解决时区问题\" class=\"headerlink\" title=\"解决时区问题\"></a>解决时区问题</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">TIME_ZONE = <span class=\"hljs-string\">&#x27;Asia/Shanghai&#x27;</span> <span class=\"hljs-comment\">#时区改成上海</span><br><span class=\"hljs-comment\"># USE_TZ = True #这行注释</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决跨域\"><a href=\"#解决跨域\" class=\"headerlink\" title=\"解决跨域\"></a>解决跨域</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br><br>MIDDLEWARE = [<br>\t\t<span class=\"hljs-comment\">#中间件修改成如下</span><br>    <span class=\"hljs-string\">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django默认样式不好看\"><a href=\"#Django默认样式不好看\" class=\"headerlink\" title=\"Django默认样式不好看\"></a>Django默认样式不好看</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;simpleui&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;mall.apps.MallConfig&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br></code></pre></td></tr></table></figure>\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 去掉默认Logo或换成自己Logo链接</span><br>SIMPLEUI_LOGO = <span class=\"hljs-string\">&#x27;&lt;https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png&gt;&#x27;</span><br><span class=\"hljs-comment\"># 默认语言换成中文</span><br>LANGUAGE_CODE = <span class=\"hljs-string\">&#x27;zh-hans&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django的时间返回中间带T\"><a href=\"#Django的时间返回中间带T\" class=\"headerlink\" title=\"Django的时间返回中间带T\"></a>Django的时间返回中间带<code>T</code></h2><p><code>settings.py</code>中增加如下配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">REST_FRAMEWORK = &#123;<br>    <span class=\"hljs-string\">&#x27;DATETIME_FORMAT&#x27;</span>: <span class=\"hljs-string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据库配置\"><a href=\"#数据库配置\" class=\"headerlink\" title=\"数据库配置\"></a>数据库配置</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">DATABASES = &#123;<br>    <span class=\"hljs-string\">&#x27;default&#x27;</span>: &#123;<br>        <span class=\"hljs-string\">&#x27;OPTIONS&#x27;</span>: &#123;<span class=\"hljs-string\">&#x27;charset&#x27;</span>: <span class=\"hljs-string\">&#x27;utf8mb4&#x27;</span>&#125;,<br>        <span class=\"hljs-string\">&#x27;ENGINE&#x27;</span>: <span class=\"hljs-string\">&#x27;django.db.backends.mysql&#x27;</span>,  <span class=\"hljs-comment\"># 数据库引擎</span><br>        <span class=\"hljs-string\">&#x27;NAME&#x27;</span>: <span class=\"hljs-string\">&#x27;mall&#x27;</span>,  <span class=\"hljs-comment\"># 数据库名称</span><br>        <span class=\"hljs-string\">&#x27;USER&#x27;</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,  <span class=\"hljs-comment\"># 连接数据库的用户名称</span><br>        <span class=\"hljs-string\">&#x27;PASSWORD&#x27;</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,  <span class=\"hljs-comment\"># 用户密码</span><br>        <span class=\"hljs-string\">&#x27;HOST&#x27;</span>: <span class=\"hljs-string\">&#x27;localhost&#x27;</span>,  <span class=\"hljs-comment\"># 访问的数据库的主机的ip地址</span><br>        <span class=\"hljs-string\">&#x27;PORT&#x27;</span>: <span class=\"hljs-string\">&#x27;3306&#x27;</span>,  <span class=\"hljs-comment\"># 默认mysql访问端口</span><br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql转Django模型类\"><a href=\"#Mysql转Django模型类\" class=\"headerlink\" title=\"Mysql转Django模型类\"></a>Mysql转Django模型类</h2><p>创建一个Django项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">django-admin startproject ‘xxxx‘<br></code></pre></td></tr></table></figure>\n\n<p>修改setting文件，在setting里面设置你要连接的数据库类型和连接名称，地址之类，和创建新项目的时候一致</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable constant_\">DATABASES</span> = &#123;<br>    <span class=\"hljs-string\">&#x27;default&#x27;</span>: &#123;<br>        <span class=\"hljs-string\">&#x27;ENGINE&#x27;</span>: <span class=\"hljs-string\">&#x27;django.db.backends.mysql&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;NAME&#x27;</span>: <span class=\"hljs-string\">&#x27;sqlexam&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;USER&#x27;</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;PASSWORD&#x27;</span>: <span class=\"hljs-string\">&#x27;root12345&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;HOST&#x27;</span>: <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;PORT&#x27;</span>: <span class=\"hljs-number\">3306</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接下来就可以根据数据库数据生成对应的models模型文件</p>\n<p>1、生成模型文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">python3 manage.<span class=\"hljs-property\">py</span> inspectdb<br></code></pre></td></tr></table></figure>\n\n<p>2、将模型文件导入到app当中</p>\n<p>创建app</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">python3 manage.<span class=\"hljs-property\">py</span> startapp <span class=\"hljs-string\">&#x27;app名字&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>将模型导入创建的app中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">python3 manage.<span class=\"hljs-property\">py</span> inspectdb &gt; app/models.<span class=\"hljs-property\">py</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"修改数据库\"><a href=\"#修改数据库\" class=\"headerlink\" title=\"修改数据库\"></a>修改数据库</h1><h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><ol>\n<li><p>在nivicat中直接直接改动数据结构</p>\n</li>\n<li><p>在终端中执行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">python manage.py inspectdb<br></code></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":3204,"excerpt":"","more":"<h2 id=\"官方文档（含教程）\"><a href=\"#官方文档（含教程）\" class=\"headerlink\" title=\"官方文档（含教程）\"></a>官方文档（含教程）</h2><p><a href=\"https://www.djangoproject.com/\">Django</a></p>\n<p><a href=\"https://www.django-rest-framework.org/\">Home - Django REST framework</a></p>\n<h2 id=\"基本操作（终端中执行）\"><a href=\"#基本操作（终端中执行）\" class=\"headerlink\" title=\"基本操作（终端中执行）\"></a>基本操作（终端中执行）</h2><p>新建一个Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startproject mysite<br></code></pre></td></tr></table></figure>\n\n<p>新建一个接口组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startapp test_app<br></code></pre></td></tr></table></figure>\n\n<p>启动Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py runserver<br></code></pre></td></tr></table></figure>\n\n<p>创建管理员账户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py createsuperuser<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"rest-framework\"><a href=\"#rest-framework\" class=\"headerlink\" title=\"rest_framework\"></a>rest_framework</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>\t\t<span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决时区问题\"><a href=\"#解决时区问题\" class=\"headerlink\" title=\"解决时区问题\"></a>解决时区问题</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">TIME_ZONE = <span class=\"hljs-string\">&#x27;Asia/Shanghai&#x27;</span> <span class=\"hljs-comment\">#时区改成上海</span><br><span class=\"hljs-comment\"># USE_TZ = True #这行注释</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决跨域\"><a href=\"#解决跨域\" class=\"headerlink\" title=\"解决跨域\"></a>解决跨域</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br><br>MIDDLEWARE = [<br>\t\t<span class=\"hljs-comment\">#中间件修改成如下</span><br>    <span class=\"hljs-string\">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django默认样式不好看\"><a href=\"#Django默认样式不好看\" class=\"headerlink\" title=\"Django默认样式不好看\"></a>Django默认样式不好看</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;simpleui&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;mall.apps.MallConfig&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br></code></pre></td></tr></table></figure>\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 去掉默认Logo或换成自己Logo链接</span><br>SIMPLEUI_LOGO = <span class=\"hljs-string\">&#x27;&lt;https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png&gt;&#x27;</span><br><span class=\"hljs-comment\"># 默认语言换成中文</span><br>LANGUAGE_CODE = <span class=\"hljs-string\">&#x27;zh-hans&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django的时间返回中间带T\"><a href=\"#Django的时间返回中间带T\" class=\"headerlink\" title=\"Django的时间返回中间带T\"></a>Django的时间返回中间带<code>T</code></h2><p><code>settings.py</code>中增加如下配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">REST_FRAMEWORK = &#123;<br>    <span class=\"hljs-string\">&#x27;DATETIME_FORMAT&#x27;</span>: <span class=\"hljs-string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据库配置\"><a href=\"#数据库配置\" class=\"headerlink\" title=\"数据库配置\"></a>数据库配置</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">DATABASES = &#123;<br>    <span class=\"hljs-string\">&#x27;default&#x27;</span>: &#123;<br>        <span class=\"hljs-string\">&#x27;OPTIONS&#x27;</span>: &#123;<span class=\"hljs-string\">&#x27;charset&#x27;</span>: <span class=\"hljs-string\">&#x27;utf8mb4&#x27;</span>&#125;,<br>        <span class=\"hljs-string\">&#x27;ENGINE&#x27;</span>: <span class=\"hljs-string\">&#x27;django.db.backends.mysql&#x27;</span>,  <span class=\"hljs-comment\"># 数据库引擎</span><br>        <span class=\"hljs-string\">&#x27;NAME&#x27;</span>: <span class=\"hljs-string\">&#x27;mall&#x27;</span>,  <span class=\"hljs-comment\"># 数据库名称</span><br>        <span class=\"hljs-string\">&#x27;USER&#x27;</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,  <span class=\"hljs-comment\"># 连接数据库的用户名称</span><br>        <span class=\"hljs-string\">&#x27;PASSWORD&#x27;</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,  <span class=\"hljs-comment\"># 用户密码</span><br>        <span class=\"hljs-string\">&#x27;HOST&#x27;</span>: <span class=\"hljs-string\">&#x27;localhost&#x27;</span>,  <span class=\"hljs-comment\"># 访问的数据库的主机的ip地址</span><br>        <span class=\"hljs-string\">&#x27;PORT&#x27;</span>: <span class=\"hljs-string\">&#x27;3306&#x27;</span>,  <span class=\"hljs-comment\"># 默认mysql访问端口</span><br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql转Django模型类\"><a href=\"#Mysql转Django模型类\" class=\"headerlink\" title=\"Mysql转Django模型类\"></a>Mysql转Django模型类</h2><p>创建一个Django项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">django-admin startproject ‘xxxx‘<br></code></pre></td></tr></table></figure>\n\n<p>修改setting文件，在setting里面设置你要连接的数据库类型和连接名称，地址之类，和创建新项目的时候一致</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable constant_\">DATABASES</span> = &#123;<br>    <span class=\"hljs-string\">&#x27;default&#x27;</span>: &#123;<br>        <span class=\"hljs-string\">&#x27;ENGINE&#x27;</span>: <span class=\"hljs-string\">&#x27;django.db.backends.mysql&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;NAME&#x27;</span>: <span class=\"hljs-string\">&#x27;sqlexam&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;USER&#x27;</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;PASSWORD&#x27;</span>: <span class=\"hljs-string\">&#x27;root12345&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;HOST&#x27;</span>: <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>,<br>        <span class=\"hljs-string\">&#x27;PORT&#x27;</span>: <span class=\"hljs-number\">3306</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接下来就可以根据数据库数据生成对应的models模型文件</p>\n<p>1、生成模型文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">python3 manage.<span class=\"hljs-property\">py</span> inspectdb<br></code></pre></td></tr></table></figure>\n\n<p>2、将模型文件导入到app当中</p>\n<p>创建app</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">python3 manage.<span class=\"hljs-property\">py</span> startapp <span class=\"hljs-string\">&#x27;app名字&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>将模型导入创建的app中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">python3 manage.<span class=\"hljs-property\">py</span> inspectdb &gt; app/models.<span class=\"hljs-property\">py</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"修改数据库\"><a href=\"#修改数据库\" class=\"headerlink\" title=\"修改数据库\"></a>修改数据库</h1><h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><ol>\n<li><p>在nivicat中直接直接改动数据结构</p>\n</li>\n<li><p>在终端中执行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">python manage.py inspectdb<br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"CSS和SVG中的剪切——clip-path属性和<clipPath>元素","date":"2022-05-28T16:45:23.000Z","description":"CSS和SVG有很多共同之处。CSS有很多特性都是从SVG中引入过来的。其中就有“剪切”的特性。CSS和SVG都允许我们对一个元素进行非矩形的剪切。在这篇文章中，将介绍CSS和SVG中的剪切技术。","_content":"\n\n\n# CSS和SVG中的剪切——clip-path属性和<clipPath>元素 \n\n[SVG](https://www.w3cplus.com/svg-tutorial)\n\n[clip-path](https://www.w3cplus.com/blog/tags/431.html)\n\n[clipPath](https://www.w3cplus.com/blog/tags/432.html)\n\n> 本文由[大漠](http://www.w3cplus.com/)根据[SaraSoueidan](http://twitter.com/SaraSoueidan)的《[Clipping in CSS and SVG – The clip-path Property and  Element](http://sarasoueidan.com/blog/css-svg-clipping/)》所译，整个译文带有我们自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明原作者相关信息http://sarasoueidan.com/blog/css-svg-clipping/。\n>\n> ——作者：[SaraSoueidan](http://twitter.com/SaraSoueidan)\n>\n> ——译者：[大漠](http://www.w3cplus.com/)\n\nCSS和SVG有很多共同之处。CSS有很多特性都是从SVG中引入过来的。其中就有“剪切”的特性。CSS和SVG都允许我们对一个元素进行非矩形的剪切。在这篇文章中，将介绍CSS和SVG中的剪切技术。\n\n特别声明：本文提供的DEMO可能在你的浏览器中不能正常的演示，你应该查看这个[表格](https://github.com/awgreenblatt/css-graphics)了解更多相关的信息。你在阅读这篇文章之时没有必要查看提供的DEMO。不是所有的剪切特性都可以实现或者说只能实现部分剪切特性。本文的最大目的是告诉你CSS和SVG中的剪切是如何工作？仅用来做为参考。在文章中的代码不带有任何浏览器的私有前缀，但在示例中还是带了浏览器的私有前缀。\n\n## 剪切是什么\n\n剪切是一个图形化操作，你可以部分或者完全隐藏一个元素。**被剪切的元素可以是一个容器也可以是一个图像元素。**元素的哪些部分显示或隐藏是由剪切的路径来决定的。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-1.jpg)\n\n**剪切路径**定义了一个区域，在这个区域内的内容将会显示，而不在这个区域内的内容不会显示。这个区域被称之为“裁剪区域”。只要在这个区域之外的任何元素都不会显示。包括元素的内容、背景、边框、文本、轮廓等，甚至还包括他的子元素。\n\n> 剪切的元素可以是任何容器和图片元素。\n\n剪切路径的概念就相当于在元素上定义了一个视窗。它决定了元素哪些部分在这个“视窗”中显示，哪些部分不在这个“视窗”中显示。但他不会影响自身文档流和其他文档流，因为他通常还是以一个矩形区域显示在其他文档流前面，哪怕是剪切出来的区域是不规则的矩形。如果你想改变周围内容元素围绕剪切出来的图形，那就需要使用[CSS的图形](http://www.w3.org/TR/css-shapes/)属性。如果你对这方面知识感兴趣，可以阅读我早前写的[相关](http://alistapart.com/article/css-shapes-101)[文章](http://sarasoueidan.com/blog/css-shapes/)。\n\n> 有关于CSS3 Shapes相关中文教程，可以阅读早前翻译的两篇文章：\n>\n> - [使用CSS Shapes的Regions创建更好的阅读体验](http://www.w3cplus.com/css3/css-regions-with-shapes-for-readability.html)\n> - [CSS Shapes 101](http://www.w3cplus.com/css3/css-shapes-101.html)\n\n## CSS中的剪切——`clip-path`属性\n\n`clip-path`属性是[CSS Masking模块](http://www.w3.org/TR/2014/WD-css-masking-1-20140213/)的一部分。自从2000年以来，剪切都只是SVG中的一部分，现在将这个功能引入到CSS的Msking模块中，所以现在可以对HTML元素和SVG元素进行剪切。\n\n`clip-path`属性是指定一个应用到元素上的剪切路径。应用在SVG中`<clipPath>`元素上的属性值可以完全运用在`clip-path`的属性上。你还可以使用CSS Shapes模块中的[基本形状](http://dev.w3.org/csswg/css-shapes-2/#ltbasic-shapegt)来定义剪切路径。这些形状你可以使用形状函数来创建。这些形状态函数包括`polygon()`、`circle()`、`inset()`(用来定义嵌入的矩形)和`ellipse()`。\n\n使用`clip-path`属性将一个剪切路径运用在一个元素上非常的简单：\n\n```css\n/* SVG中的clipPath的使用 */\n.element {\n    clip-path: url(#svgClipPathID);\n}\n\n/* 使用CSS中的基本图形函数 */\n.element {\n    clip-path: polygon(...); /* 或者其他的图形函数 */\n}\n```\n\n例如，我们使用`polygon()`函数定义一个多边形的剪切路径，并且把这个路径应用到一个图像上，代码看起来像这样：\n\n```css\nimg {\n    clip-path: polygon(626px 463px,765px 236px,687px 31px,271px 100px,70px 10px,49px 250px,133px 406px,374px 462px,529px 393px);\n}\n```\n\n应用上面的代码之后，图像显示成这样：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-2.jpg)](http://codepen.io/airen/pen/wglAe)\n\n[查看DEMO](http://codepen.io/airen/pen/wglAe)\n\n基本图形函数允许我们创建一定数量的图形，其中最复杂的就是多边形。如果你想创建一个更为复杂的图形，而且图形看起来不是用直线画出来的，这个时候你就需要使用SVG的`<clipPath>`元素。正如`<clipPath>`元素名称所暗示的一样，你可以使用这个元素绘制任意路径的图形。这也意味着，你可以使用`<clipPath>`元素绘制出任意图形来做为一个剪切路径。\n\n在我们第二个示例中，使用SVG的`clipPath`定义一个路径，这个剪切路径看起来像这样：\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\">\n            <path fill=\"#FFFFFF\" stroke=\"#000000\" stroke-width=\"1.5794\" stroke-miterlimit=\"10\" d=\"M215,100.3c97.8-32.6,90.5-71.9,336-77.6　c92.4-2.1,98.1,81.6,121.8,116.4c101.7,149.9,53.5,155.9,14.7,178c-96.4,54.9,5.4,269-257,115.1c-57-33.5-203,46.3-263.7,20.1\n    c-33.5-14.5-132.5-45.5-95-111.1C125.9,246.6,98.6,139.1,215,100.3z\"/>\n        </clipPath>\n    </defs>\n</svg>\n```\n\n这剪切路径看起来就像一个黑色的描边圈了一个不规则的图形，这是一个简单的剪切路径，不带有任何的填充。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-3.jpg)\n\n在下一部分中，我们将着重讨论SVG的`<clipPath>`元素。但现在，我们来看看如何将定义好的路径运用到图片上：\n\n```css\nimg {\n    clip-path: url(#svgPath);\n}\n```\n\n最终效果如下所示：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-4.jpg)](http://codepen.io/airen/pen/Buais)\n\n[查看DEMO](http://codepen.io/airen/pen/Buais)\n\n事实上，`<clipPath>`元素包括很多个基本图形（`<rect>`，`<circle>`等），`<path>`元素，甚至是`<text>`元素。\n\n如果在`<clipPath>`里面通过`<text>`指定文本，那么这个文本就会当成是一个剪切路径，不管文是否可见，文本外的区域都将被剪切掉。\n\n注意，你可以使用任何文本做为剪切路径。这为实现很多效果开启了一扇大门。你可以使用动画图片（比如，gif）,甚至是视频，然后选择你需要的文本进行剪切。这里是没有任何限制的。\n\n下面的示例，就是使用文本做为剪切路径：\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgTextPath\">\n            <text x=\"0\" y=\"300\" textLength=\"800px\" lengthAdjust=\"spacing\" font-family=\"Vollkorn\" font-size=\"230px\" font-weight=\"700\" font-style=\"italic\"> Blossom </text>\n        </clipPath>\n    </defs>\n</svg>\n```\n\nSVG中的`<text>`最酷的特点就是可以使用自定义字体，就像HTML文本。在我们的示例中使用了Google Web Fonts中的[Vollkorn](http://www.google.com/fonts/specimen/Vollkorn)字体。使用`textLength`属性，将文本的宽度设置的和图片宽度一样， 并且通过`x`和`y`来定位文本。注意，`x`和`y`坐标确认了文本左下角的位置（也就是文本的基线baseline）。\n\n使用上面的文本路径剪切图来的图片效果如下：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-5.jpg)](http://codepen.io/airen/pen/vyEzH)\n\n[查看DEMO](http://codepen.io/airen/pen/vyEzH)\n\n正如我们前面提到的，你还可以在`<clipPath>`中使用多个图形形状。在下一节中，将会深入介绍`<clipPath>`，这里我们先简单的了解。在这个示例中，我们使用了多个`<circle>`形状，他们大小不同，位置不同。\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\">\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"50\" cy=\"50\" r=\"40\" />\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"193.949\" cy=\"235\" r=\"74.576\"/>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"426.576\" cy=\"108.305\" r=\"47.034\"/>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"346.915\" cy=\"255.763\" r=\"43.644\"/>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"255.39\" cy=\"82.882\" r=\"35.17\"/>\n            <!-- more circles... -->\n        </clipPath>\n    </defs>\n</svg>\n```\n\n此时，图像只会在圆中显示，圆外就不会显示：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-6.jpg)](http://codepen.io/airen/pen/dfIry)\n\n[查看DEMO](http://codepen.io/airen/pen/dfIry)\n\n正如我们这篇文章中介绍的，你可以使用`clip-path`属性应用在SVG元素绘制的路径。在上面演示的示例，剪切路径都是应用在HTML中的`<img>`元素上。在接下来的示例中，将演示的是一个剪切路径用于`<svg>`的根元素。同样是樱花图片，使用下面SVG的中的`<image>`来引用。\n\nSVG中的`<image>`元素用来引用一个完整的SVG或像素图像。如果你在`<image>`中引用的SVG图像，设置的`width`和`height`属性，将会用来设置SVG视窗的大小。如果你引用的是像素图像（我们这里的例子就是这样做的），图像将会自动缩放到指定的`width`和`height`。所以我们要确认好他们的长宽比例，避免图像扭曲。\n\n当你创建一个SVG时，你可以在`<svg>`元素上指定其宽度和高度的大小，用于创建一个窗口。任何超过这个窗口的内容都将不会显示出来。你可以通过`<clipPath>`元素定制一个窗口。\n\n```html\n<svg height=\"500\" width=\"800\">\n    <image xlink:href=\"flowers.jpg\" x=\"0\" y=\"0\" width=\"800\" height=\"500\"/>\n    <defs>\n        <clipPath id=\"theSVGPath\">\n            <rect x=\"0\" y=\"0\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"108\" height=\"500\"/>\n            <rect x=\"121.5\" y=\"25.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"55\" height=\"455\"/>\n            <rect x=\"192.5\" y=\"9.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"60\" height=\"484\"/>\n            <rect x=\"271.5\" y=\"44.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"63\" height=\"416\"/>\n            <rect x=\"349.5\" y=\"25.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"208\" height=\"447\"/>\n            <rect x=\"574.5\" y=\"44.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"60\" height=\"446\"/>\n            <rect x=\"644.5\" y=\"9.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"68\" height=\"471\"/>\n            <rect x=\"736.5\" y=\"18.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"49\" height=\"462\"/>\n        </clipPath>\n    </defs>\n</svg>\n```\n\n使用`clip-path`将定义好的`<clipPath>`运用到`<svg>`元素上：\n\n```css\nsvg {\n    clip-path: url(#theSVGPath);\n}\n```\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-7.jpg)](http://codepen.io/airen/pen/ghfoE)\n\n[查看DEMO](http://codepen.io/airen/pen/ghfoE)\n\n更多有关于在SVG上使用`clip-path`的示例将会在下面介绍`<clipPath>`部分介绍。\n\n### 一个剪切路径的参考盒子\n\n除了剪切路径本身，还可以给剪切路径应用一个`<basic-shape>`定义一个剪切路径的参考盒子。也就是说，可以使用一个剪切的基本函数创建一个剪切路径。其中参考盒子只能使用CSS的`clip-path`来指定形状路径，而不能使用SVG的`<clipPath>`。对于SVG的`<clipPath>`参考盒子是一个`border-box`元素。\n\n因此剪切路径的参考盒子用`<basic-shape>`来指定。如果是一个HTML元素被剪切，可以使用四种盒模型：`margin-box`、`border-box`、`padding-box`和`content-box`。每种盒模型都有其自己的解释。\n\n如果`<basic-path>`制作的剪切路径运用在一个SVG元素上，参考盒子可以设置为下面三种的其中一种：\n\n- **`fill-box`：**使用对像的边缘做为参考盒子\n- **`stroke-box`：**使用路径做为参考盒子\n- **`view-box`：**如果没有指定`viewBox`将使用最近的SVG视窗做为参考盒子。如果`viewBox`的确创建了，则会根据`viewBox`的原点坐标和维度来创建参考盒子\n\n如果为SVG元素设置CSS盒模型中的任何一种做为参考盒子，则会使用`fill-box`值；如果你使用SVG来做为一个HTML元素的参考盒子，则会使用`border-box`盒模型。\n\n```css\n.element {\n    clip-path: polygon(...) padding-box;\n}\n```\n\n如果参考盒子没有使用`clip-path`来指定——也就是没有定义任何形状——浏览器将会使用指定的盒子的边缘，包括圆角图形（比如说使用了`border-radius`）做为剪切路径。\n\n例如，使用下面的代码片段，使用了`border-radius`指定了一个圆角的剪切路径：\n\n```css\n.el {\n    clip-path: border-box;\n    border-radius: 25%;\n}\n```\n\n**注意，在写这篇文章之时，使用`border-box`指定一个参考盒子，在webkit内核中还无法得以支持，因为它还没有运用于实战当中。**\n\n### 叠加情况、指针事件和动画下的`clip-path`的注意事项\n\n特别注意，要知道，如果任何都设置默认值，`clip-path`属性将会创建一个类似于透明元素。\n\n此外，根据Masking规范，鼠标事件在图形的`clipped-out`区域外是无效的。这意味着，如果没有做剪切，鼠标事件还是有效的。这一部规范中做了详细的描述，只是实现方式不同。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-8.jpg)\n\n绿色区域表示可以响应鼠标事件。左图表示的是标签规范的行为，右图表示非标签规范行为。\n\n为了演示，我在前面示例的基础上，给图片添加了一个`div`容器，使用了SVG的`<clipPath>`制作剪切路径。如果没有使用剪切，你可以看到图像有边框。添加一个`hover`效果，鼠标经过图片时，图片会带有一定的透明度。\n\n如果使用Chrome浏览器（35.0.1916.153版本测试），就算鼠标在图像的剪切之外的区域，图片也会有一琮的透明度。这种行为就是符合标准规范的一种行为。\n\n在Firefox浏览器(30.0版本测试)，除了在可视区域图像不会响应鼠标事件。这意味着，鼠标移到图像剪切区域之外，会失去鼠标事件。（图像不带有透明度）\n\n我必须得说，我更喜欢符合规范规范的那种行为，不知道你喜欢的是哪种行为？\n\n[查看DEMO](http://codepen.io/airen/pen/wqIhC)\n\n剪切路径还可以使用动画效果。如果使用SVG的`<clipPath>`制作剪切路径，可以在其内部设置动画（下一节中将会详细介绍）。如果剪切路径是使用的基本图形函数创建，则何以运用CSS3的`animation`或者`transition`属性。至于如何使用基本图形创建一个动画的路径，感兴趣的可以阅读我前面写的一篇文章：《[Animating CSS Shapes with CSS Animations & Transitions](http://sarasoueidan.com/blog/animating-css-shapes/)》。\n\n## SVG中的剪切——`<clipPath>`元素\n\n在SVG中使用`<clipPath>`元素来定义剪切元素的剪切路径。如果不想使用CSS的`clip-path`来定义元素的剪切路径，可以使用SVG中的`clip-path`属性。\n\n> 你看过或读过我写的“Styling and Animating Scalable Vector Graphics with CSS”的幻灯片？如果没有，你应该看看里面介绍的，如何使用SVG的属性和CSS样式来美化SVG元素。你可以点击[这里](http://sarasoueidan.com/blog/cssconf-2014-talk)阅读.\n\n```html\n<svg>\n    <defs>\n        <clipPath id=\"myClippingPath\">\n            <!-- ... -->\n        </clipPath>\n    </defs>\n    <!-- the element you want to apply the clipPath to can be any SVG element -->\n    <g id=\"my-graphic\" clip-path=\"url(#myClippingPath)\">\n        <!-- ... -->\n    </g>\n</svg>\n```\n\n### `<clipPath>`的内容\n\n我们前面提到过，可以在SVG中的`<clipPath>`内创建任意数量的基本形状，`<path>`和`<text>`元素。它甚至还可以包括很多其他的东西，这正也是SVG很有意思的地方。\n\n`<clipPath>`元素中的内容可以是描述性的（如`<title>`，`<desc>`，`<metadata>`）。也可以是图形（如:`<circle>`, `<ellipse>`, `<line>`, `<path>`, `<polygon>`, `<polyline>`, `<rect>`或者`<text>`）。一个`<clipPath>`可以包含一个`<use>`元素或者`<script>`。注意，在`<clipPath>`元素中使用`<use>`元素，只能引用一些简单的SVG的图形（前面提到的）,例如，它在`<clipPath>`内不能用于群体的参照，它是没办法正常工作的。\n\n最后一部分，但并不是最重要的一部分。`<clipPath>`可以包括一个使用`<animate>`, `<animateColor>`, `<animateMotion>`,`<animateTransform>`或 `<set>`创建的动画。这为很多创造打开了一扇门，只要你敢想，就能做。\n\n使用多个`<circle>`制作的剪路径，并且添加了一个简单的动画效果来做为示例演示。每个`<circle>`都有一个简单的动画。为了保证示例的简单，在所有圆上都使用了同一个简单的动画效果。当然，你可以为每个圆创建不同的动画效果。演示示例的代码如下：\n\n```\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\">\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"50\" cy=\"50\" r=\"40\">\n                <animate attributeName=\"r\" attributeType=\"XML\" from=\"0\" to=\"250\" begin=\"0s\" dur=\"3s\" fill=\"freeze\"  repeatCount=\"indefinite\"/>\n            </circle>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"193.949\" cy=\"235\" r=\"74.576\">\n                <animate attributeName=\"r\" attributeType=\"XML\" from=\"0\" to=\"250\" begin=\"0s\" dur=\"3s\" fill=\"freeze\" repeatCount=\"indefinite\"/>\n            </circle>\n            <!-- ... -->\n        </clipPath>\n    </defs>\n</svg> \n```\n\n这个动画就只指定了每个圆的尺寸大小，圆的半径从0到250px，总共花了3秒时间，并且设置了动画播放次数是无限次。\n\n点击下面的按钮查看示例，使用Chrome或者Safari点击查看案例之前，得告诉您，示例还存在一个bug（详细介绍请点击[这里](https://code.google.com/p/chromium/issues/detail?id=391604)），所以我建议您使用Firefox查看示例，直到这个Bug已修复。\n\n[查看DEMO](http://codepen.io/airen/pen/GAgqw)\n\n请注意，`<clipPath>`的内容也不能包括`<g>`。例如我们给多个圆`<circle>`放在一个组里`<g>`，那么它不能正常工作，剪切路径不会运用到图片上。\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\"> <!-- WILL NOT WORK -->\n            <g> <!-- WILL NOT WORK -->\n                <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"193.949\" cy=\"235\" r=\"74.576\"/>\n                <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"426.576\" cy=\"108.305\" r=\"47.034\"/>\n                <!-- ... -->\n            </g>\n        </clipPath>\n    </defs>\n</svg>\n```\n\n### `clipPathUnits`属性\n\n`<clipPath>`元素包括很多个属性，比如`id`,`class`,`transform`和像`fill`和`stroke`这样的[显示属性](http://www.w3.org/TR/2011/REC-SVG11-20110816/intro.html#TermPresentationAttribute)以及[其他更多属性](http://www.w3.org/TR/2011/REC-SVG11-20110816/styling.html#SVGStylingProperties)。其中最有用的是`clipPathUnits`属性。\n\n`clipPathUnits`主要用来给`<clipPath>`元素内容指定一个坐标系统。它具有两个值：`objectBoundingBox`和`userSpaceOnUse`，其中`userSpaceOnUse`是默认值。\n\n```\nclipPathUnits = \"userSpaceOnUse | objectBoundingBox\"\n```\n\n#### `userSpaceOnUse`\n\n当`clipPath`元素是用来当作参考物时，`clipPath`元素内容是以用户坐标系统作为参考点。（例如：`clipPath`元素的用户坐标系统是通过`clip-path`属性来引用）。\n\n用户坐标系统（局部坐标系统）是目前激活的坐标系统，主要用来如何定位坐标和长度。一个HTML元素的坐标和CSS的盒模型有关，但不同的是SVG元素没有这样的盒模型。\n\n对于CSS盒子的布局，用户的坐标原点就在盒子的左上角，而且一个单位就是一个像素，视窗也可以根据盒子的宽度按百分比计算。我想你对这方面应该非常的熟悉。如果你有一个`<clipPath>`元素包含了一个`<circle>`，而且这个`<circle>`的中心点在`cx=100`和`cy=100`。那么这个中心点就是距盒子左边100px和顶边100px的交汇处。\n\n如果元素是一个SVG元素，因此他是没一个类似于CSS盒模型的东西，用户的坐标原点是距`<svg>`元素视窗左上角最近的一个地方。一般情况之下，最近的视窗的建立，他的宽度和高度接近于`<svg>`的祖先元素。如果你不嵌套`<svg>`元素，它就是你创建的`<svg>`元素。\n\n注意，SVG元素的坐标系统可以使用`viewBox`属性进行修改，其他属性可能有助于改变坐标系统。这一部分的内容超出了本文的内容范围。所以在本文中，我假设`viewBox`没有进行过任何的修改。因此浏览器使用的默认坐标系统原点是在`<svg>`元素的左上角，大小也等于`<svg>`元素。\n\n#### `objectBoundingBox`\n\n坐标系统的原点是在元素的边框盒子的左上角顶点处，同样适于剪切路径。这个边框是SVG元素对象的边框(它只是包含了一个或多个几何图形形状)和一个HTML元素设置`border-box`的盒模型是相关联的。\n\n这个值对`SVG`元素非常有用，因为它允许你应用的元素自身的边界做为剪切路径。下图显示一个图像应用SVG的剪切路径显示的效果，他们分别使用了`userSpaceOnUse`和`objectBoundingBox`。灰色的边框表示的是`SVG`元素创建的一个视窗。右图中的图像，我添加了一个灰色的边框用来表示剪切后的图像边框。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-9.jpg)\n\n在左图中，剪切路径的坐系统定位在SVG的视窗上。当使用了`objectBoundingBox`属性之后，图像自身的边框就会做为剪切路径的坐标系统。\n\n有一点需要特别的注意：**当你设置了`objectBoundingBox`值后，`<clipPath>`元素中的内容必须在指定的坐标[0,1]内。**坐标系统将成为一个单元系统，剪切出来的形状都在这个`clipPath`分值内。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-10.jpg)\n\n例如，如果剪切路径包含一个`<circle>`元素，而且他定位在圆的中心上：\n\n```html\n<clipPath>\n    <circle cx=\"350\" cy=\"350\" r=\"300\" />\n</clipPath>\n```\n\n圆的位置(半径)会用分数表示：\n\n```html\n<clipPath clipPathUnits=\"objectBoundingBox\">\n    <circle cx=\".5\" cy=\".5\" r=\".45\" />\n</clipPath>\n```\n\n在这种情况下，分数就像百分比。\n\n### `<clipPath>`笔记\n\n`<clipPath>`元素不会直接在页面上呈现，他唯一的作用就是可以通过`clip-path`来引用。`display`属性不能运用于`<clipPath>`元素上，因此，就算`display`设置`none`外的其他值，`<clipPath>`元素也不会直接呈现。\n\n还记得我前面提到HTML元素剪切后的鼠标事件吗？相同的标准定义的行为却不同。鼠标事件在SVG的剪切区域外是无效。规范后面提到，可以让SVG定义新属性来控制剪切。\n\nFirefox浏览器实现了相同非标准行为，在剪切区域之外不支持鼠标事件。\n\n尽管Chrome为HTML元素的`clip-path`属笥实现标准行为，当你在一个`<svg>`元素上使用`<clipPath>`时，实现的行为是一样的。只有Firefox在可视区域能响应鼠标事件，我不知道这是一个特性还是一个Bug。\n\n在接下来的示例中，一个SVG的`<clipPath>`应用在一个SVG的`<image>`上。这个剪切路径我们前面使用过，图像剪成很多个矩形。当你的鼠标悬浮在图像上，图像具有一定的透明度。\n\n```css\nimage {\n    clip-path: url(#svgPath);\n}\nimage:hover {\n    opacity: .5;\n}\n```\n\n[查看DEMO](http://codepen.io/airen/pen/iDHfn)\n\n请注意，一个空的剪切路径同样会被`clip-path`应用在元素上。\n\n## 总结\n\n剪切是一种图形化操作，允许我们在一个矩形的页面中创建不规则图形。实际上剪切和CSS的Shapes是一对完美的搭档。如果你有阅读过我[早前写的关于CSS的Shapes的文章](http://alistapart.com/article/css-shapes-101)，你就会看到很多实例中使用了`clip-path`属性。一旦CSS的Shapes可以[运用于SVG的路径上](http://dev.w3.org/csswg/css-shapes-2/#referencing-svg-shapes)（[CSS Shapes Module Level 2](http://dev.w3.org/csswg/css-shapes-2/)）,除了CSS的基本形状之外，CSS的Shapes和剪切配合可以让我们在视觉上制作出引人注目的设计，打破矩形的限制。\n\n著作权归作者所有。\n商业转载请联系作者获得授权,非商业转载请注明出处。\n原文: https://www.w3cplus.com/css3/css-svg-clipping.html © [w3cplus.com](https://www.w3cplus.com/)","source":"_posts/前端/CSS和SVG中的剪切——clip-path属性和clipPath元素.md","raw":"---\ntitle: CSS和SVG中的剪切——clip-path属性和<clipPath>元素 \ndate: 2022-05-29 00:45:23\ntags:\n  - [web]\n  - [css]\ncategories:\n  - [技术]\ndescription: CSS和SVG有很多共同之处。CSS有很多特性都是从SVG中引入过来的。其中就有“剪切”的特性。CSS和SVG都允许我们对一个元素进行非矩形的剪切。在这篇文章中，将介绍CSS和SVG中的剪切技术。\n---\n\n\n\n# CSS和SVG中的剪切——clip-path属性和<clipPath>元素 \n\n[SVG](https://www.w3cplus.com/svg-tutorial)\n\n[clip-path](https://www.w3cplus.com/blog/tags/431.html)\n\n[clipPath](https://www.w3cplus.com/blog/tags/432.html)\n\n> 本文由[大漠](http://www.w3cplus.com/)根据[SaraSoueidan](http://twitter.com/SaraSoueidan)的《[Clipping in CSS and SVG – The clip-path Property and  Element](http://sarasoueidan.com/blog/css-svg-clipping/)》所译，整个译文带有我们自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明原作者相关信息http://sarasoueidan.com/blog/css-svg-clipping/。\n>\n> ——作者：[SaraSoueidan](http://twitter.com/SaraSoueidan)\n>\n> ——译者：[大漠](http://www.w3cplus.com/)\n\nCSS和SVG有很多共同之处。CSS有很多特性都是从SVG中引入过来的。其中就有“剪切”的特性。CSS和SVG都允许我们对一个元素进行非矩形的剪切。在这篇文章中，将介绍CSS和SVG中的剪切技术。\n\n特别声明：本文提供的DEMO可能在你的浏览器中不能正常的演示，你应该查看这个[表格](https://github.com/awgreenblatt/css-graphics)了解更多相关的信息。你在阅读这篇文章之时没有必要查看提供的DEMO。不是所有的剪切特性都可以实现或者说只能实现部分剪切特性。本文的最大目的是告诉你CSS和SVG中的剪切是如何工作？仅用来做为参考。在文章中的代码不带有任何浏览器的私有前缀，但在示例中还是带了浏览器的私有前缀。\n\n## 剪切是什么\n\n剪切是一个图形化操作，你可以部分或者完全隐藏一个元素。**被剪切的元素可以是一个容器也可以是一个图像元素。**元素的哪些部分显示或隐藏是由剪切的路径来决定的。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-1.jpg)\n\n**剪切路径**定义了一个区域，在这个区域内的内容将会显示，而不在这个区域内的内容不会显示。这个区域被称之为“裁剪区域”。只要在这个区域之外的任何元素都不会显示。包括元素的内容、背景、边框、文本、轮廓等，甚至还包括他的子元素。\n\n> 剪切的元素可以是任何容器和图片元素。\n\n剪切路径的概念就相当于在元素上定义了一个视窗。它决定了元素哪些部分在这个“视窗”中显示，哪些部分不在这个“视窗”中显示。但他不会影响自身文档流和其他文档流，因为他通常还是以一个矩形区域显示在其他文档流前面，哪怕是剪切出来的区域是不规则的矩形。如果你想改变周围内容元素围绕剪切出来的图形，那就需要使用[CSS的图形](http://www.w3.org/TR/css-shapes/)属性。如果你对这方面知识感兴趣，可以阅读我早前写的[相关](http://alistapart.com/article/css-shapes-101)[文章](http://sarasoueidan.com/blog/css-shapes/)。\n\n> 有关于CSS3 Shapes相关中文教程，可以阅读早前翻译的两篇文章：\n>\n> - [使用CSS Shapes的Regions创建更好的阅读体验](http://www.w3cplus.com/css3/css-regions-with-shapes-for-readability.html)\n> - [CSS Shapes 101](http://www.w3cplus.com/css3/css-shapes-101.html)\n\n## CSS中的剪切——`clip-path`属性\n\n`clip-path`属性是[CSS Masking模块](http://www.w3.org/TR/2014/WD-css-masking-1-20140213/)的一部分。自从2000年以来，剪切都只是SVG中的一部分，现在将这个功能引入到CSS的Msking模块中，所以现在可以对HTML元素和SVG元素进行剪切。\n\n`clip-path`属性是指定一个应用到元素上的剪切路径。应用在SVG中`<clipPath>`元素上的属性值可以完全运用在`clip-path`的属性上。你还可以使用CSS Shapes模块中的[基本形状](http://dev.w3.org/csswg/css-shapes-2/#ltbasic-shapegt)来定义剪切路径。这些形状你可以使用形状函数来创建。这些形状态函数包括`polygon()`、`circle()`、`inset()`(用来定义嵌入的矩形)和`ellipse()`。\n\n使用`clip-path`属性将一个剪切路径运用在一个元素上非常的简单：\n\n```css\n/* SVG中的clipPath的使用 */\n.element {\n    clip-path: url(#svgClipPathID);\n}\n\n/* 使用CSS中的基本图形函数 */\n.element {\n    clip-path: polygon(...); /* 或者其他的图形函数 */\n}\n```\n\n例如，我们使用`polygon()`函数定义一个多边形的剪切路径，并且把这个路径应用到一个图像上，代码看起来像这样：\n\n```css\nimg {\n    clip-path: polygon(626px 463px,765px 236px,687px 31px,271px 100px,70px 10px,49px 250px,133px 406px,374px 462px,529px 393px);\n}\n```\n\n应用上面的代码之后，图像显示成这样：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-2.jpg)](http://codepen.io/airen/pen/wglAe)\n\n[查看DEMO](http://codepen.io/airen/pen/wglAe)\n\n基本图形函数允许我们创建一定数量的图形，其中最复杂的就是多边形。如果你想创建一个更为复杂的图形，而且图形看起来不是用直线画出来的，这个时候你就需要使用SVG的`<clipPath>`元素。正如`<clipPath>`元素名称所暗示的一样，你可以使用这个元素绘制任意路径的图形。这也意味着，你可以使用`<clipPath>`元素绘制出任意图形来做为一个剪切路径。\n\n在我们第二个示例中，使用SVG的`clipPath`定义一个路径，这个剪切路径看起来像这样：\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\">\n            <path fill=\"#FFFFFF\" stroke=\"#000000\" stroke-width=\"1.5794\" stroke-miterlimit=\"10\" d=\"M215,100.3c97.8-32.6,90.5-71.9,336-77.6　c92.4-2.1,98.1,81.6,121.8,116.4c101.7,149.9,53.5,155.9,14.7,178c-96.4,54.9,5.4,269-257,115.1c-57-33.5-203,46.3-263.7,20.1\n    c-33.5-14.5-132.5-45.5-95-111.1C125.9,246.6,98.6,139.1,215,100.3z\"/>\n        </clipPath>\n    </defs>\n</svg>\n```\n\n这剪切路径看起来就像一个黑色的描边圈了一个不规则的图形，这是一个简单的剪切路径，不带有任何的填充。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-3.jpg)\n\n在下一部分中，我们将着重讨论SVG的`<clipPath>`元素。但现在，我们来看看如何将定义好的路径运用到图片上：\n\n```css\nimg {\n    clip-path: url(#svgPath);\n}\n```\n\n最终效果如下所示：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-4.jpg)](http://codepen.io/airen/pen/Buais)\n\n[查看DEMO](http://codepen.io/airen/pen/Buais)\n\n事实上，`<clipPath>`元素包括很多个基本图形（`<rect>`，`<circle>`等），`<path>`元素，甚至是`<text>`元素。\n\n如果在`<clipPath>`里面通过`<text>`指定文本，那么这个文本就会当成是一个剪切路径，不管文是否可见，文本外的区域都将被剪切掉。\n\n注意，你可以使用任何文本做为剪切路径。这为实现很多效果开启了一扇大门。你可以使用动画图片（比如，gif）,甚至是视频，然后选择你需要的文本进行剪切。这里是没有任何限制的。\n\n下面的示例，就是使用文本做为剪切路径：\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgTextPath\">\n            <text x=\"0\" y=\"300\" textLength=\"800px\" lengthAdjust=\"spacing\" font-family=\"Vollkorn\" font-size=\"230px\" font-weight=\"700\" font-style=\"italic\"> Blossom </text>\n        </clipPath>\n    </defs>\n</svg>\n```\n\nSVG中的`<text>`最酷的特点就是可以使用自定义字体，就像HTML文本。在我们的示例中使用了Google Web Fonts中的[Vollkorn](http://www.google.com/fonts/specimen/Vollkorn)字体。使用`textLength`属性，将文本的宽度设置的和图片宽度一样， 并且通过`x`和`y`来定位文本。注意，`x`和`y`坐标确认了文本左下角的位置（也就是文本的基线baseline）。\n\n使用上面的文本路径剪切图来的图片效果如下：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-5.jpg)](http://codepen.io/airen/pen/vyEzH)\n\n[查看DEMO](http://codepen.io/airen/pen/vyEzH)\n\n正如我们前面提到的，你还可以在`<clipPath>`中使用多个图形形状。在下一节中，将会深入介绍`<clipPath>`，这里我们先简单的了解。在这个示例中，我们使用了多个`<circle>`形状，他们大小不同，位置不同。\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\">\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"50\" cy=\"50\" r=\"40\" />\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"193.949\" cy=\"235\" r=\"74.576\"/>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"426.576\" cy=\"108.305\" r=\"47.034\"/>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"346.915\" cy=\"255.763\" r=\"43.644\"/>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"255.39\" cy=\"82.882\" r=\"35.17\"/>\n            <!-- more circles... -->\n        </clipPath>\n    </defs>\n</svg>\n```\n\n此时，图像只会在圆中显示，圆外就不会显示：\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-6.jpg)](http://codepen.io/airen/pen/dfIry)\n\n[查看DEMO](http://codepen.io/airen/pen/dfIry)\n\n正如我们这篇文章中介绍的，你可以使用`clip-path`属性应用在SVG元素绘制的路径。在上面演示的示例，剪切路径都是应用在HTML中的`<img>`元素上。在接下来的示例中，将演示的是一个剪切路径用于`<svg>`的根元素。同样是樱花图片，使用下面SVG的中的`<image>`来引用。\n\nSVG中的`<image>`元素用来引用一个完整的SVG或像素图像。如果你在`<image>`中引用的SVG图像，设置的`width`和`height`属性，将会用来设置SVG视窗的大小。如果你引用的是像素图像（我们这里的例子就是这样做的），图像将会自动缩放到指定的`width`和`height`。所以我们要确认好他们的长宽比例，避免图像扭曲。\n\n当你创建一个SVG时，你可以在`<svg>`元素上指定其宽度和高度的大小，用于创建一个窗口。任何超过这个窗口的内容都将不会显示出来。你可以通过`<clipPath>`元素定制一个窗口。\n\n```html\n<svg height=\"500\" width=\"800\">\n    <image xlink:href=\"flowers.jpg\" x=\"0\" y=\"0\" width=\"800\" height=\"500\"/>\n    <defs>\n        <clipPath id=\"theSVGPath\">\n            <rect x=\"0\" y=\"0\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"108\" height=\"500\"/>\n            <rect x=\"121.5\" y=\"25.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"55\" height=\"455\"/>\n            <rect x=\"192.5\" y=\"9.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"60\" height=\"484\"/>\n            <rect x=\"271.5\" y=\"44.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"63\" height=\"416\"/>\n            <rect x=\"349.5\" y=\"25.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"208\" height=\"447\"/>\n            <rect x=\"574.5\" y=\"44.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"60\" height=\"446\"/>\n            <rect x=\"644.5\" y=\"9.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"68\" height=\"471\"/>\n            <rect x=\"736.5\" y=\"18.5\" stroke=\"#000000\" stroke-miterlimit=\"10\" width=\"49\" height=\"462\"/>\n        </clipPath>\n    </defs>\n</svg>\n```\n\n使用`clip-path`将定义好的`<clipPath>`运用到`<svg>`元素上：\n\n```css\nsvg {\n    clip-path: url(#theSVGPath);\n}\n```\n\n[![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-7.jpg)](http://codepen.io/airen/pen/ghfoE)\n\n[查看DEMO](http://codepen.io/airen/pen/ghfoE)\n\n更多有关于在SVG上使用`clip-path`的示例将会在下面介绍`<clipPath>`部分介绍。\n\n### 一个剪切路径的参考盒子\n\n除了剪切路径本身，还可以给剪切路径应用一个`<basic-shape>`定义一个剪切路径的参考盒子。也就是说，可以使用一个剪切的基本函数创建一个剪切路径。其中参考盒子只能使用CSS的`clip-path`来指定形状路径，而不能使用SVG的`<clipPath>`。对于SVG的`<clipPath>`参考盒子是一个`border-box`元素。\n\n因此剪切路径的参考盒子用`<basic-shape>`来指定。如果是一个HTML元素被剪切，可以使用四种盒模型：`margin-box`、`border-box`、`padding-box`和`content-box`。每种盒模型都有其自己的解释。\n\n如果`<basic-path>`制作的剪切路径运用在一个SVG元素上，参考盒子可以设置为下面三种的其中一种：\n\n- **`fill-box`：**使用对像的边缘做为参考盒子\n- **`stroke-box`：**使用路径做为参考盒子\n- **`view-box`：**如果没有指定`viewBox`将使用最近的SVG视窗做为参考盒子。如果`viewBox`的确创建了，则会根据`viewBox`的原点坐标和维度来创建参考盒子\n\n如果为SVG元素设置CSS盒模型中的任何一种做为参考盒子，则会使用`fill-box`值；如果你使用SVG来做为一个HTML元素的参考盒子，则会使用`border-box`盒模型。\n\n```css\n.element {\n    clip-path: polygon(...) padding-box;\n}\n```\n\n如果参考盒子没有使用`clip-path`来指定——也就是没有定义任何形状——浏览器将会使用指定的盒子的边缘，包括圆角图形（比如说使用了`border-radius`）做为剪切路径。\n\n例如，使用下面的代码片段，使用了`border-radius`指定了一个圆角的剪切路径：\n\n```css\n.el {\n    clip-path: border-box;\n    border-radius: 25%;\n}\n```\n\n**注意，在写这篇文章之时，使用`border-box`指定一个参考盒子，在webkit内核中还无法得以支持，因为它还没有运用于实战当中。**\n\n### 叠加情况、指针事件和动画下的`clip-path`的注意事项\n\n特别注意，要知道，如果任何都设置默认值，`clip-path`属性将会创建一个类似于透明元素。\n\n此外，根据Masking规范，鼠标事件在图形的`clipped-out`区域外是无效的。这意味着，如果没有做剪切，鼠标事件还是有效的。这一部规范中做了详细的描述，只是实现方式不同。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-8.jpg)\n\n绿色区域表示可以响应鼠标事件。左图表示的是标签规范的行为，右图表示非标签规范行为。\n\n为了演示，我在前面示例的基础上，给图片添加了一个`div`容器，使用了SVG的`<clipPath>`制作剪切路径。如果没有使用剪切，你可以看到图像有边框。添加一个`hover`效果，鼠标经过图片时，图片会带有一定的透明度。\n\n如果使用Chrome浏览器（35.0.1916.153版本测试），就算鼠标在图像的剪切之外的区域，图片也会有一琮的透明度。这种行为就是符合标准规范的一种行为。\n\n在Firefox浏览器(30.0版本测试)，除了在可视区域图像不会响应鼠标事件。这意味着，鼠标移到图像剪切区域之外，会失去鼠标事件。（图像不带有透明度）\n\n我必须得说，我更喜欢符合规范规范的那种行为，不知道你喜欢的是哪种行为？\n\n[查看DEMO](http://codepen.io/airen/pen/wqIhC)\n\n剪切路径还可以使用动画效果。如果使用SVG的`<clipPath>`制作剪切路径，可以在其内部设置动画（下一节中将会详细介绍）。如果剪切路径是使用的基本图形函数创建，则何以运用CSS3的`animation`或者`transition`属性。至于如何使用基本图形创建一个动画的路径，感兴趣的可以阅读我前面写的一篇文章：《[Animating CSS Shapes with CSS Animations & Transitions](http://sarasoueidan.com/blog/animating-css-shapes/)》。\n\n## SVG中的剪切——`<clipPath>`元素\n\n在SVG中使用`<clipPath>`元素来定义剪切元素的剪切路径。如果不想使用CSS的`clip-path`来定义元素的剪切路径，可以使用SVG中的`clip-path`属性。\n\n> 你看过或读过我写的“Styling and Animating Scalable Vector Graphics with CSS”的幻灯片？如果没有，你应该看看里面介绍的，如何使用SVG的属性和CSS样式来美化SVG元素。你可以点击[这里](http://sarasoueidan.com/blog/cssconf-2014-talk)阅读.\n\n```html\n<svg>\n    <defs>\n        <clipPath id=\"myClippingPath\">\n            <!-- ... -->\n        </clipPath>\n    </defs>\n    <!-- the element you want to apply the clipPath to can be any SVG element -->\n    <g id=\"my-graphic\" clip-path=\"url(#myClippingPath)\">\n        <!-- ... -->\n    </g>\n</svg>\n```\n\n### `<clipPath>`的内容\n\n我们前面提到过，可以在SVG中的`<clipPath>`内创建任意数量的基本形状，`<path>`和`<text>`元素。它甚至还可以包括很多其他的东西，这正也是SVG很有意思的地方。\n\n`<clipPath>`元素中的内容可以是描述性的（如`<title>`，`<desc>`，`<metadata>`）。也可以是图形（如:`<circle>`, `<ellipse>`, `<line>`, `<path>`, `<polygon>`, `<polyline>`, `<rect>`或者`<text>`）。一个`<clipPath>`可以包含一个`<use>`元素或者`<script>`。注意，在`<clipPath>`元素中使用`<use>`元素，只能引用一些简单的SVG的图形（前面提到的）,例如，它在`<clipPath>`内不能用于群体的参照，它是没办法正常工作的。\n\n最后一部分，但并不是最重要的一部分。`<clipPath>`可以包括一个使用`<animate>`, `<animateColor>`, `<animateMotion>`,`<animateTransform>`或 `<set>`创建的动画。这为很多创造打开了一扇门，只要你敢想，就能做。\n\n使用多个`<circle>`制作的剪路径，并且添加了一个简单的动画效果来做为示例演示。每个`<circle>`都有一个简单的动画。为了保证示例的简单，在所有圆上都使用了同一个简单的动画效果。当然，你可以为每个圆创建不同的动画效果。演示示例的代码如下：\n\n```\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\">\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"50\" cy=\"50\" r=\"40\">\n                <animate attributeName=\"r\" attributeType=\"XML\" from=\"0\" to=\"250\" begin=\"0s\" dur=\"3s\" fill=\"freeze\"  repeatCount=\"indefinite\"/>\n            </circle>\n            <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"193.949\" cy=\"235\" r=\"74.576\">\n                <animate attributeName=\"r\" attributeType=\"XML\" from=\"0\" to=\"250\" begin=\"0s\" dur=\"3s\" fill=\"freeze\" repeatCount=\"indefinite\"/>\n            </circle>\n            <!-- ... -->\n        </clipPath>\n    </defs>\n</svg> \n```\n\n这个动画就只指定了每个圆的尺寸大小，圆的半径从0到250px，总共花了3秒时间，并且设置了动画播放次数是无限次。\n\n点击下面的按钮查看示例，使用Chrome或者Safari点击查看案例之前，得告诉您，示例还存在一个bug（详细介绍请点击[这里](https://code.google.com/p/chromium/issues/detail?id=391604)），所以我建议您使用Firefox查看示例，直到这个Bug已修复。\n\n[查看DEMO](http://codepen.io/airen/pen/GAgqw)\n\n请注意，`<clipPath>`的内容也不能包括`<g>`。例如我们给多个圆`<circle>`放在一个组里`<g>`，那么它不能正常工作，剪切路径不会运用到图片上。\n\n```html\n<svg height=\"0\" width=\"0\">\n    <defs>\n        <clipPath id=\"svgPath\"> <!-- WILL NOT WORK -->\n            <g> <!-- WILL NOT WORK -->\n                <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"193.949\" cy=\"235\" r=\"74.576\"/>\n                <circle stroke=\"#000000\" stroke-miterlimit=\"10\" cx=\"426.576\" cy=\"108.305\" r=\"47.034\"/>\n                <!-- ... -->\n            </g>\n        </clipPath>\n    </defs>\n</svg>\n```\n\n### `clipPathUnits`属性\n\n`<clipPath>`元素包括很多个属性，比如`id`,`class`,`transform`和像`fill`和`stroke`这样的[显示属性](http://www.w3.org/TR/2011/REC-SVG11-20110816/intro.html#TermPresentationAttribute)以及[其他更多属性](http://www.w3.org/TR/2011/REC-SVG11-20110816/styling.html#SVGStylingProperties)。其中最有用的是`clipPathUnits`属性。\n\n`clipPathUnits`主要用来给`<clipPath>`元素内容指定一个坐标系统。它具有两个值：`objectBoundingBox`和`userSpaceOnUse`，其中`userSpaceOnUse`是默认值。\n\n```\nclipPathUnits = \"userSpaceOnUse | objectBoundingBox\"\n```\n\n#### `userSpaceOnUse`\n\n当`clipPath`元素是用来当作参考物时，`clipPath`元素内容是以用户坐标系统作为参考点。（例如：`clipPath`元素的用户坐标系统是通过`clip-path`属性来引用）。\n\n用户坐标系统（局部坐标系统）是目前激活的坐标系统，主要用来如何定位坐标和长度。一个HTML元素的坐标和CSS的盒模型有关，但不同的是SVG元素没有这样的盒模型。\n\n对于CSS盒子的布局，用户的坐标原点就在盒子的左上角，而且一个单位就是一个像素，视窗也可以根据盒子的宽度按百分比计算。我想你对这方面应该非常的熟悉。如果你有一个`<clipPath>`元素包含了一个`<circle>`，而且这个`<circle>`的中心点在`cx=100`和`cy=100`。那么这个中心点就是距盒子左边100px和顶边100px的交汇处。\n\n如果元素是一个SVG元素，因此他是没一个类似于CSS盒模型的东西，用户的坐标原点是距`<svg>`元素视窗左上角最近的一个地方。一般情况之下，最近的视窗的建立，他的宽度和高度接近于`<svg>`的祖先元素。如果你不嵌套`<svg>`元素，它就是你创建的`<svg>`元素。\n\n注意，SVG元素的坐标系统可以使用`viewBox`属性进行修改，其他属性可能有助于改变坐标系统。这一部分的内容超出了本文的内容范围。所以在本文中，我假设`viewBox`没有进行过任何的修改。因此浏览器使用的默认坐标系统原点是在`<svg>`元素的左上角，大小也等于`<svg>`元素。\n\n#### `objectBoundingBox`\n\n坐标系统的原点是在元素的边框盒子的左上角顶点处，同样适于剪切路径。这个边框是SVG元素对象的边框(它只是包含了一个或多个几何图形形状)和一个HTML元素设置`border-box`的盒模型是相关联的。\n\n这个值对`SVG`元素非常有用，因为它允许你应用的元素自身的边界做为剪切路径。下图显示一个图像应用SVG的剪切路径显示的效果，他们分别使用了`userSpaceOnUse`和`objectBoundingBox`。灰色的边框表示的是`SVG`元素创建的一个视窗。右图中的图像，我添加了一个灰色的边框用来表示剪切后的图像边框。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-9.jpg)\n\n在左图中，剪切路径的坐系统定位在SVG的视窗上。当使用了`objectBoundingBox`属性之后，图像自身的边框就会做为剪切路径的坐标系统。\n\n有一点需要特别的注意：**当你设置了`objectBoundingBox`值后，`<clipPath>`元素中的内容必须在指定的坐标[0,1]内。**坐标系统将成为一个单元系统，剪切出来的形状都在这个`clipPath`分值内。\n\n![CSS和SVG中的剪切](http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-10.jpg)\n\n例如，如果剪切路径包含一个`<circle>`元素，而且他定位在圆的中心上：\n\n```html\n<clipPath>\n    <circle cx=\"350\" cy=\"350\" r=\"300\" />\n</clipPath>\n```\n\n圆的位置(半径)会用分数表示：\n\n```html\n<clipPath clipPathUnits=\"objectBoundingBox\">\n    <circle cx=\".5\" cy=\".5\" r=\".45\" />\n</clipPath>\n```\n\n在这种情况下，分数就像百分比。\n\n### `<clipPath>`笔记\n\n`<clipPath>`元素不会直接在页面上呈现，他唯一的作用就是可以通过`clip-path`来引用。`display`属性不能运用于`<clipPath>`元素上，因此，就算`display`设置`none`外的其他值，`<clipPath>`元素也不会直接呈现。\n\n还记得我前面提到HTML元素剪切后的鼠标事件吗？相同的标准定义的行为却不同。鼠标事件在SVG的剪切区域外是无效。规范后面提到，可以让SVG定义新属性来控制剪切。\n\nFirefox浏览器实现了相同非标准行为，在剪切区域之外不支持鼠标事件。\n\n尽管Chrome为HTML元素的`clip-path`属笥实现标准行为，当你在一个`<svg>`元素上使用`<clipPath>`时，实现的行为是一样的。只有Firefox在可视区域能响应鼠标事件，我不知道这是一个特性还是一个Bug。\n\n在接下来的示例中，一个SVG的`<clipPath>`应用在一个SVG的`<image>`上。这个剪切路径我们前面使用过，图像剪成很多个矩形。当你的鼠标悬浮在图像上，图像具有一定的透明度。\n\n```css\nimage {\n    clip-path: url(#svgPath);\n}\nimage:hover {\n    opacity: .5;\n}\n```\n\n[查看DEMO](http://codepen.io/airen/pen/iDHfn)\n\n请注意，一个空的剪切路径同样会被`clip-path`应用在元素上。\n\n## 总结\n\n剪切是一种图形化操作，允许我们在一个矩形的页面中创建不规则图形。实际上剪切和CSS的Shapes是一对完美的搭档。如果你有阅读过我[早前写的关于CSS的Shapes的文章](http://alistapart.com/article/css-shapes-101)，你就会看到很多实例中使用了`clip-path`属性。一旦CSS的Shapes可以[运用于SVG的路径上](http://dev.w3.org/csswg/css-shapes-2/#referencing-svg-shapes)（[CSS Shapes Module Level 2](http://dev.w3.org/csswg/css-shapes-2/)）,除了CSS的基本形状之外，CSS的Shapes和剪切配合可以让我们在视觉上制作出引人注目的设计，打破矩形的限制。\n\n著作权归作者所有。\n商业转载请联系作者获得授权,非商业转载请注明出处。\n原文: https://www.w3cplus.com/css3/css-svg-clipping.html © [w3cplus.com](https://www.w3cplus.com/)","slug":"前端/CSS和SVG中的剪切——clip-path属性和clipPath元素","published":1,"updated":"2022-08-28T07:38:59.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2d003nscvm89oj90id","content":"<h1 id=\"CSS和SVG中的剪切——clip-path属性和元素\"><a href=\"#CSS和SVG中的剪切——clip-path属性和元素\" class=\"headerlink\" title=\"CSS和SVG中的剪切——clip-path属性和元素\"></a>CSS和SVG中的剪切——clip-path属性和<clipPath>元素</h1><p><a href=\"https://www.w3cplus.com/svg-tutorial\">SVG</a></p>\n<p><a href=\"https://www.w3cplus.com/blog/tags/431.html\">clip-path</a></p>\n<p><a href=\"https://www.w3cplus.com/blog/tags/432.html\">clipPath</a></p>\n<blockquote>\n<p>本文由<a href=\"http://www.w3cplus.com/\">大漠</a>根据<a href=\"http://twitter.com/SaraSoueidan\">SaraSoueidan</a>的《<a href=\"http://sarasoueidan.com/blog/css-svg-clipping/\">Clipping in CSS and SVG – The clip-path Property and  Element</a>》所译，整个译文带有我们自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明原作者相关信息<a href=\"http://sarasoueidan.com/blog/css-svg-clipping/%E3%80%82\">http://sarasoueidan.com/blog/css-svg-clipping/。</a></p>\n<p>——作者：<a href=\"http://twitter.com/SaraSoueidan\">SaraSoueidan</a></p>\n<p>——译者：<a href=\"http://www.w3cplus.com/\">大漠</a></p>\n</blockquote>\n<p>CSS和SVG有很多共同之处。CSS有很多特性都是从SVG中引入过来的。其中就有“剪切”的特性。CSS和SVG都允许我们对一个元素进行非矩形的剪切。在这篇文章中，将介绍CSS和SVG中的剪切技术。</p>\n<p>特别声明：本文提供的DEMO可能在你的浏览器中不能正常的演示，你应该查看这个<a href=\"https://github.com/awgreenblatt/css-graphics\">表格</a>了解更多相关的信息。你在阅读这篇文章之时没有必要查看提供的DEMO。不是所有的剪切特性都可以实现或者说只能实现部分剪切特性。本文的最大目的是告诉你CSS和SVG中的剪切是如何工作？仅用来做为参考。在文章中的代码不带有任何浏览器的私有前缀，但在示例中还是带了浏览器的私有前缀。</p>\n<h2 id=\"剪切是什么\"><a href=\"#剪切是什么\" class=\"headerlink\" title=\"剪切是什么\"></a>剪切是什么</h2><p>剪切是一个图形化操作，你可以部分或者完全隐藏一个元素。<strong>被剪切的元素可以是一个容器也可以是一个图像元素。</strong>元素的哪些部分显示或隐藏是由剪切的路径来决定的。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-1.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p><strong>剪切路径</strong>定义了一个区域，在这个区域内的内容将会显示，而不在这个区域内的内容不会显示。这个区域被称之为“裁剪区域”。只要在这个区域之外的任何元素都不会显示。包括元素的内容、背景、边框、文本、轮廓等，甚至还包括他的子元素。</p>\n<blockquote>\n<p>剪切的元素可以是任何容器和图片元素。</p>\n</blockquote>\n<p>剪切路径的概念就相当于在元素上定义了一个视窗。它决定了元素哪些部分在这个“视窗”中显示，哪些部分不在这个“视窗”中显示。但他不会影响自身文档流和其他文档流，因为他通常还是以一个矩形区域显示在其他文档流前面，哪怕是剪切出来的区域是不规则的矩形。如果你想改变周围内容元素围绕剪切出来的图形，那就需要使用<a href=\"http://www.w3.org/TR/css-shapes/\">CSS的图形</a>属性。如果你对这方面知识感兴趣，可以阅读我早前写的<a href=\"http://alistapart.com/article/css-shapes-101\">相关</a><a href=\"http://sarasoueidan.com/blog/css-shapes/\">文章</a>。</p>\n<blockquote>\n<p>有关于CSS3 Shapes相关中文教程，可以阅读早前翻译的两篇文章：</p>\n<ul>\n<li><a href=\"http://www.w3cplus.com/css3/css-regions-with-shapes-for-readability.html\">使用CSS Shapes的Regions创建更好的阅读体验</a></li>\n<li><a href=\"http://www.w3cplus.com/css3/css-shapes-101.html\">CSS Shapes 101</a></li>\n</ul>\n</blockquote>\n<h2 id=\"CSS中的剪切——clip-path属性\"><a href=\"#CSS中的剪切——clip-path属性\" class=\"headerlink\" title=\"CSS中的剪切——clip-path属性\"></a>CSS中的剪切——<code>clip-path</code>属性</h2><p><code>clip-path</code>属性是<a href=\"http://www.w3.org/TR/2014/WD-css-masking-1-20140213/\">CSS Masking模块</a>的一部分。自从2000年以来，剪切都只是SVG中的一部分，现在将这个功能引入到CSS的Msking模块中，所以现在可以对HTML元素和SVG元素进行剪切。</p>\n<p><code>clip-path</code>属性是指定一个应用到元素上的剪切路径。应用在SVG中<code>&lt;clipPath&gt;</code>元素上的属性值可以完全运用在<code>clip-path</code>的属性上。你还可以使用CSS Shapes模块中的<a href=\"http://dev.w3.org/csswg/css-shapes-2/#ltbasic-shapegt\">基本形状</a>来定义剪切路径。这些形状你可以使用形状函数来创建。这些形状态函数包括<code>polygon()</code>、<code>circle()</code>、<code>inset()</code>(用来定义嵌入的矩形)和<code>ellipse()</code>。</p>\n<p>使用<code>clip-path</code>属性将一个剪切路径运用在一个元素上非常的简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* SVG中的clipPath的使用 */</span><br><span class=\"hljs-selector-class\">.element</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#svgClipPathID</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用CSS中的基本图形函数 */</span><br><span class=\"hljs-selector-class\">.element</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(...); <span class=\"hljs-comment\">/* 或者其他的图形函数 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如，我们使用<code>polygon()</code>函数定义一个多边形的剪切路径，并且把这个路径应用到一个图像上，代码看起来像这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">img</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(<span class=\"hljs-number\">626px</span> <span class=\"hljs-number\">463px</span>,<span class=\"hljs-number\">765px</span> <span class=\"hljs-number\">236px</span>,<span class=\"hljs-number\">687px</span> <span class=\"hljs-number\">31px</span>,<span class=\"hljs-number\">271px</span> <span class=\"hljs-number\">100px</span>,<span class=\"hljs-number\">70px</span> <span class=\"hljs-number\">10px</span>,<span class=\"hljs-number\">49px</span> <span class=\"hljs-number\">250px</span>,<span class=\"hljs-number\">133px</span> <span class=\"hljs-number\">406px</span>,<span class=\"hljs-number\">374px</span> <span class=\"hljs-number\">462px</span>,<span class=\"hljs-number\">529px</span> <span class=\"hljs-number\">393px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>应用上面的代码之后，图像显示成这样：</p>\n<p><a href=\"http://codepen.io/airen/pen/wglAe\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-2.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/wglAe\">查看DEMO</a></p>\n<p>基本图形函数允许我们创建一定数量的图形，其中最复杂的就是多边形。如果你想创建一个更为复杂的图形，而且图形看起来不是用直线画出来的，这个时候你就需要使用SVG的<code>&lt;clipPath&gt;</code>元素。正如<code>&lt;clipPath&gt;</code>元素名称所暗示的一样，你可以使用这个元素绘制任意路径的图形。这也意味着，你可以使用<code>&lt;clipPath&gt;</code>元素绘制出任意图形来做为一个剪切路径。</p>\n<p>在我们第二个示例中，使用SVG的<code>clipPath</code>定义一个路径，这个剪切路径看起来像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">&quot;#FFFFFF&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">&quot;1.5794&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M215,100.3c97.8-32.6,90.5-71.9,336-77.6　c92.4-2.1,98.1,81.6,121.8,116.4c101.7,149.9,53.5,155.9,14.7,178c-96.4,54.9,5.4,269-257,115.1c-57-33.5-203,46.3-263.7,20.1</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">    c-33.5-14.5-132.5-45.5-95-111.1C125.9,246.6,98.6,139.1,215,100.3z&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这剪切路径看起来就像一个黑色的描边圈了一个不规则的图形，这是一个简单的剪切路径，不带有任何的填充。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-3.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>在下一部分中，我们将着重讨论SVG的<code>&lt;clipPath&gt;</code>元素。但现在，我们来看看如何将定义好的路径运用到图片上：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">img</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#svgPath</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最终效果如下所示：</p>\n<p><a href=\"http://codepen.io/airen/pen/Buais\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-4.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/Buais\">查看DEMO</a></p>\n<p>事实上，<code>&lt;clipPath&gt;</code>元素包括很多个基本图形（<code>&lt;rect&gt;</code>，<code>&lt;circle&gt;</code>等），<code>&lt;path&gt;</code>元素，甚至是<code>&lt;text&gt;</code>元素。</p>\n<p>如果在<code>&lt;clipPath&gt;</code>里面通过<code>&lt;text&gt;</code>指定文本，那么这个文本就会当成是一个剪切路径，不管文是否可见，文本外的区域都将被剪切掉。</p>\n<p>注意，你可以使用任何文本做为剪切路径。这为实现很多效果开启了一扇大门。你可以使用动画图片（比如，gif）,甚至是视频，然后选择你需要的文本进行剪切。这里是没有任何限制的。</p>\n<p>下面的示例，就是使用文本做为剪切路径：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgTextPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;300&quot;</span> <span class=\"hljs-attr\">textLength</span>=<span class=\"hljs-string\">&quot;800px&quot;</span> <span class=\"hljs-attr\">lengthAdjust</span>=<span class=\"hljs-string\">&quot;spacing&quot;</span> <span class=\"hljs-attr\">font-family</span>=<span class=\"hljs-string\">&quot;Vollkorn&quot;</span> <span class=\"hljs-attr\">font-size</span>=<span class=\"hljs-string\">&quot;230px&quot;</span> <span class=\"hljs-attr\">font-weight</span>=<span class=\"hljs-string\">&quot;700&quot;</span> <span class=\"hljs-attr\">font-style</span>=<span class=\"hljs-string\">&quot;italic&quot;</span>&gt;</span> Blossom <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>SVG中的<code>&lt;text&gt;</code>最酷的特点就是可以使用自定义字体，就像HTML文本。在我们的示例中使用了Google Web Fonts中的<a href=\"http://www.google.com/fonts/specimen/Vollkorn\">Vollkorn</a>字体。使用<code>textLength</code>属性，将文本的宽度设置的和图片宽度一样， 并且通过<code>x</code>和<code>y</code>来定位文本。注意，<code>x</code>和<code>y</code>坐标确认了文本左下角的位置（也就是文本的基线baseline）。</p>\n<p>使用上面的文本路径剪切图来的图片效果如下：</p>\n<p><a href=\"http://codepen.io/airen/pen/vyEzH\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-5.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/vyEzH\">查看DEMO</a></p>\n<p>正如我们前面提到的，你还可以在<code>&lt;clipPath&gt;</code>中使用多个图形形状。在下一节中，将会深入介绍<code>&lt;clipPath&gt;</code>，这里我们先简单的了解。在这个示例中，我们使用了多个<code>&lt;circle&gt;</code>形状，他们大小不同，位置不同。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;40&quot;</span> /&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;193.949&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;235&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;74.576&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;426.576&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;108.305&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;47.034&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;346.915&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;255.763&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;43.644&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;255.39&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;82.882&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;35.17&quot;</span>/&gt;</span><br>            <span class=\"hljs-comment\">&lt;!-- more circles... --&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>此时，图像只会在圆中显示，圆外就不会显示：</p>\n<p><a href=\"http://codepen.io/airen/pen/dfIry\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-6.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/dfIry\">查看DEMO</a></p>\n<p>正如我们这篇文章中介绍的，你可以使用<code>clip-path</code>属性应用在SVG元素绘制的路径。在上面演示的示例，剪切路径都是应用在HTML中的<code>&lt;img&gt;</code>元素上。在接下来的示例中，将演示的是一个剪切路径用于<code>&lt;svg&gt;</code>的根元素。同样是樱花图片，使用下面SVG的中的<code>&lt;image&gt;</code>来引用。</p>\n<p>SVG中的<code>&lt;image&gt;</code>元素用来引用一个完整的SVG或像素图像。如果你在<code>&lt;image&gt;</code>中引用的SVG图像，设置的<code>width</code>和<code>height</code>属性，将会用来设置SVG视窗的大小。如果你引用的是像素图像（我们这里的例子就是这样做的），图像将会自动缩放到指定的<code>width</code>和<code>height</code>。所以我们要确认好他们的长宽比例，避免图像扭曲。</p>\n<p>当你创建一个SVG时，你可以在<code>&lt;svg&gt;</code>元素上指定其宽度和高度的大小，用于创建一个窗口。任何超过这个窗口的内容都将不会显示出来。你可以通过<code>&lt;clipPath&gt;</code>元素定制一个窗口。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;800&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;flowers.jpg&quot;</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;800&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;theSVGPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;108&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;121.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;25.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;55&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;455&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;192.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;9.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;60&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;484&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;271.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;44.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;63&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;416&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;349.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;25.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;208&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;447&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;574.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;44.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;60&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;446&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;644.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;9.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;68&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;471&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;736.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;18.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;49&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;462&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>使用<code>clip-path</code>将定义好的<code>&lt;clipPath&gt;</code>运用到<code>&lt;svg&gt;</code>元素上：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">svg &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#theSVGPath</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"http://codepen.io/airen/pen/ghfoE\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-7.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/ghfoE\">查看DEMO</a></p>\n<p>更多有关于在SVG上使用<code>clip-path</code>的示例将会在下面介绍<code>&lt;clipPath&gt;</code>部分介绍。</p>\n<h3 id=\"一个剪切路径的参考盒子\"><a href=\"#一个剪切路径的参考盒子\" class=\"headerlink\" title=\"一个剪切路径的参考盒子\"></a>一个剪切路径的参考盒子</h3><p>除了剪切路径本身，还可以给剪切路径应用一个<code>&lt;basic-shape&gt;</code>定义一个剪切路径的参考盒子。也就是说，可以使用一个剪切的基本函数创建一个剪切路径。其中参考盒子只能使用CSS的<code>clip-path</code>来指定形状路径，而不能使用SVG的<code>&lt;clipPath&gt;</code>。对于SVG的<code>&lt;clipPath&gt;</code>参考盒子是一个<code>border-box</code>元素。</p>\n<p>因此剪切路径的参考盒子用<code>&lt;basic-shape&gt;</code>来指定。如果是一个HTML元素被剪切，可以使用四种盒模型：<code>margin-box</code>、<code>border-box</code>、<code>padding-box</code>和<code>content-box</code>。每种盒模型都有其自己的解释。</p>\n<p>如果<code>&lt;basic-path&gt;</code>制作的剪切路径运用在一个SVG元素上，参考盒子可以设置为下面三种的其中一种：</p>\n<ul>\n<li><strong><code>fill-box</code>：</strong>使用对像的边缘做为参考盒子</li>\n<li><strong><code>stroke-box</code>：</strong>使用路径做为参考盒子</li>\n<li><strong><code>view-box</code>：</strong>如果没有指定<code>viewBox</code>将使用最近的SVG视窗做为参考盒子。如果<code>viewBox</code>的确创建了，则会根据<code>viewBox</code>的原点坐标和维度来创建参考盒子</li>\n</ul>\n<p>如果为SVG元素设置CSS盒模型中的任何一种做为参考盒子，则会使用<code>fill-box</code>值；如果你使用SVG来做为一个HTML元素的参考盒子，则会使用<code>border-box</code>盒模型。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.element</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(...) padding-box;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果参考盒子没有使用<code>clip-path</code>来指定——也就是没有定义任何形状——浏览器将会使用指定的盒子的边缘，包括圆角图形（比如说使用了<code>border-radius</code>）做为剪切路径。</p>\n<p>例如，使用下面的代码片段，使用了<code>border-radius</code>指定了一个圆角的剪切路径：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.el</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: border-box;<br>    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">25%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意，在写这篇文章之时，使用<code>border-box</code>指定一个参考盒子，在webkit内核中还无法得以支持，因为它还没有运用于实战当中。</strong></p>\n<h3 id=\"叠加情况、指针事件和动画下的clip-path的注意事项\"><a href=\"#叠加情况、指针事件和动画下的clip-path的注意事项\" class=\"headerlink\" title=\"叠加情况、指针事件和动画下的clip-path的注意事项\"></a>叠加情况、指针事件和动画下的<code>clip-path</code>的注意事项</h3><p>特别注意，要知道，如果任何都设置默认值，<code>clip-path</code>属性将会创建一个类似于透明元素。</p>\n<p>此外，根据Masking规范，鼠标事件在图形的<code>clipped-out</code>区域外是无效的。这意味着，如果没有做剪切，鼠标事件还是有效的。这一部规范中做了详细的描述，只是实现方式不同。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-8.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>绿色区域表示可以响应鼠标事件。左图表示的是标签规范的行为，右图表示非标签规范行为。</p>\n<p>为了演示，我在前面示例的基础上，给图片添加了一个<code>div</code>容器，使用了SVG的<code>&lt;clipPath&gt;</code>制作剪切路径。如果没有使用剪切，你可以看到图像有边框。添加一个<code>hover</code>效果，鼠标经过图片时，图片会带有一定的透明度。</p>\n<p>如果使用Chrome浏览器（35.0.1916.153版本测试），就算鼠标在图像的剪切之外的区域，图片也会有一琮的透明度。这种行为就是符合标准规范的一种行为。</p>\n<p>在Firefox浏览器(30.0版本测试)，除了在可视区域图像不会响应鼠标事件。这意味着，鼠标移到图像剪切区域之外，会失去鼠标事件。（图像不带有透明度）</p>\n<p>我必须得说，我更喜欢符合规范规范的那种行为，不知道你喜欢的是哪种行为？</p>\n<p><a href=\"http://codepen.io/airen/pen/wqIhC\">查看DEMO</a></p>\n<p>剪切路径还可以使用动画效果。如果使用SVG的<code>&lt;clipPath&gt;</code>制作剪切路径，可以在其内部设置动画（下一节中将会详细介绍）。如果剪切路径是使用的基本图形函数创建，则何以运用CSS3的<code>animation</code>或者<code>transition</code>属性。至于如何使用基本图形创建一个动画的路径，感兴趣的可以阅读我前面写的一篇文章：《<a href=\"http://sarasoueidan.com/blog/animating-css-shapes/\">Animating CSS Shapes with CSS Animations &amp; Transitions</a>》。</p>\n<h2 id=\"SVG中的剪切——-lt-clipPath-gt-元素\"><a href=\"#SVG中的剪切——-lt-clipPath-gt-元素\" class=\"headerlink\" title=\"SVG中的剪切——&lt;clipPath&gt;元素\"></a>SVG中的剪切——<code>&lt;clipPath&gt;</code>元素</h2><p>在SVG中使用<code>&lt;clipPath&gt;</code>元素来定义剪切元素的剪切路径。如果不想使用CSS的<code>clip-path</code>来定义元素的剪切路径，可以使用SVG中的<code>clip-path</code>属性。</p>\n<blockquote>\n<p>你看过或读过我写的“Styling and Animating Scalable Vector Graphics with CSS”的幻灯片？如果没有，你应该看看里面介绍的，如何使用SVG的属性和CSS样式来美化SVG元素。你可以点击<a href=\"http://sarasoueidan.com/blog/cssconf-2014-talk\">这里</a>阅读.</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;myClippingPath&quot;</span>&gt;</span><br>            <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- the element you want to apply the clipPath to can be any SVG element --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;my-graphic&quot;</span> <span class=\"hljs-attr\">clip-path</span>=<span class=\"hljs-string\">&quot;url(#myClippingPath)&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"lt-clipPath-gt-的内容\"><a href=\"#lt-clipPath-gt-的内容\" class=\"headerlink\" title=\"&lt;clipPath&gt;的内容\"></a><code>&lt;clipPath&gt;</code>的内容</h3><p>我们前面提到过，可以在SVG中的<code>&lt;clipPath&gt;</code>内创建任意数量的基本形状，<code>&lt;path&gt;</code>和<code>&lt;text&gt;</code>元素。它甚至还可以包括很多其他的东西，这正也是SVG很有意思的地方。</p>\n<p><code>&lt;clipPath&gt;</code>元素中的内容可以是描述性的（如<code>&lt;title&gt;</code>，<code>&lt;desc&gt;</code>，<code>&lt;metadata&gt;</code>）。也可以是图形（如:<code>&lt;circle&gt;</code>, <code>&lt;ellipse&gt;</code>, <code>&lt;line&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;polygon&gt;</code>, <code>&lt;polyline&gt;</code>, <code>&lt;rect&gt;</code>或者<code>&lt;text&gt;</code>）。一个<code>&lt;clipPath&gt;</code>可以包含一个<code>&lt;use&gt;</code>元素或者<code>&lt;script&gt;</code>。注意，在<code>&lt;clipPath&gt;</code>元素中使用<code>&lt;use&gt;</code>元素，只能引用一些简单的SVG的图形（前面提到的）,例如，它在<code>&lt;clipPath&gt;</code>内不能用于群体的参照，它是没办法正常工作的。</p>\n<p>最后一部分，但并不是最重要的一部分。<code>&lt;clipPath&gt;</code>可以包括一个使用<code>&lt;animate&gt;</code>, <code>&lt;animateColor&gt;</code>, <code>&lt;animateMotion&gt;</code>,<code>&lt;animateTransform&gt;</code>或 <code>&lt;set&gt;</code>创建的动画。这为很多创造打开了一扇门，只要你敢想，就能做。</p>\n<p>使用多个<code>&lt;circle&gt;</code>制作的剪路径，并且添加了一个简单的动画效果来做为示例演示。每个<code>&lt;circle&gt;</code>都有一个简单的动画。为了保证示例的简单，在所有圆上都使用了同一个简单的动画效果。当然，你可以为每个圆创建不同的动画效果。演示示例的代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;40&quot;</span>&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animate</span> <span class=\"hljs-attr\">attributeName</span>=<span class=\"hljs-string\">&quot;r&quot;</span> <span class=\"hljs-attr\">attributeType</span>=<span class=\"hljs-string\">&quot;XML&quot;</span> <span class=\"hljs-attr\">from</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;250&quot;</span> <span class=\"hljs-attr\">begin</span>=<span class=\"hljs-string\">&quot;0s&quot;</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">&quot;3s&quot;</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">&quot;freeze&quot;</span>  <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">&quot;indefinite&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">circle</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;193.949&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;235&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;74.576&quot;</span>&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animate</span> <span class=\"hljs-attr\">attributeName</span>=<span class=\"hljs-string\">&quot;r&quot;</span> <span class=\"hljs-attr\">attributeType</span>=<span class=\"hljs-string\">&quot;XML&quot;</span> <span class=\"hljs-attr\">from</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;250&quot;</span> <span class=\"hljs-attr\">begin</span>=<span class=\"hljs-string\">&quot;0s&quot;</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">&quot;3s&quot;</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">&quot;freeze&quot;</span> <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">&quot;indefinite&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">circle</span>&gt;</span><br>            <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span> <br></code></pre></td></tr></table></figure>\n\n<p>这个动画就只指定了每个圆的尺寸大小，圆的半径从0到250px，总共花了3秒时间，并且设置了动画播放次数是无限次。</p>\n<p>点击下面的按钮查看示例，使用Chrome或者Safari点击查看案例之前，得告诉您，示例还存在一个bug（详细介绍请点击<a href=\"https://code.google.com/p/chromium/issues/detail?id=391604\">这里</a>），所以我建议您使用Firefox查看示例，直到这个Bug已修复。</p>\n<p><a href=\"http://codepen.io/airen/pen/GAgqw\">查看DEMO</a></p>\n<p>请注意，<code>&lt;clipPath&gt;</code>的内容也不能包括<code>&lt;g&gt;</code>。例如我们给多个圆<code>&lt;circle&gt;</code>放在一个组里<code>&lt;g&gt;</code>，那么它不能正常工作，剪切路径不会运用到图片上。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- WILL NOT WORK --&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- WILL NOT WORK --&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;193.949&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;235&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;74.576&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;426.576&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;108.305&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;47.034&quot;</span>/&gt;</span><br>                <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"clipPathUnits属性\"><a href=\"#clipPathUnits属性\" class=\"headerlink\" title=\"clipPathUnits属性\"></a><code>clipPathUnits</code>属性</h3><p><code>&lt;clipPath&gt;</code>元素包括很多个属性，比如<code>id</code>,<code>class</code>,<code>transform</code>和像<code>fill</code>和<code>stroke</code>这样的<a href=\"http://www.w3.org/TR/2011/REC-SVG11-20110816/intro.html#TermPresentationAttribute\">显示属性</a>以及<a href=\"http://www.w3.org/TR/2011/REC-SVG11-20110816/styling.html#SVGStylingProperties\">其他更多属性</a>。其中最有用的是<code>clipPathUnits</code>属性。</p>\n<p><code>clipPathUnits</code>主要用来给<code>&lt;clipPath&gt;</code>元素内容指定一个坐标系统。它具有两个值：<code>objectBoundingBox</code>和<code>userSpaceOnUse</code>，其中<code>userSpaceOnUse</code>是默认值。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">clipPathUnits</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;userSpaceOnUse | objectBoundingBox&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"userSpaceOnUse\"><a href=\"#userSpaceOnUse\" class=\"headerlink\" title=\"userSpaceOnUse\"></a><code>userSpaceOnUse</code></h4><p>当<code>clipPath</code>元素是用来当作参考物时，<code>clipPath</code>元素内容是以用户坐标系统作为参考点。（例如：<code>clipPath</code>元素的用户坐标系统是通过<code>clip-path</code>属性来引用）。</p>\n<p>用户坐标系统（局部坐标系统）是目前激活的坐标系统，主要用来如何定位坐标和长度。一个HTML元素的坐标和CSS的盒模型有关，但不同的是SVG元素没有这样的盒模型。</p>\n<p>对于CSS盒子的布局，用户的坐标原点就在盒子的左上角，而且一个单位就是一个像素，视窗也可以根据盒子的宽度按百分比计算。我想你对这方面应该非常的熟悉。如果你有一个<code>&lt;clipPath&gt;</code>元素包含了一个<code>&lt;circle&gt;</code>，而且这个<code>&lt;circle&gt;</code>的中心点在<code>cx=100</code>和<code>cy=100</code>。那么这个中心点就是距盒子左边100px和顶边100px的交汇处。</p>\n<p>如果元素是一个SVG元素，因此他是没一个类似于CSS盒模型的东西，用户的坐标原点是距<code>&lt;svg&gt;</code>元素视窗左上角最近的一个地方。一般情况之下，最近的视窗的建立，他的宽度和高度接近于<code>&lt;svg&gt;</code>的祖先元素。如果你不嵌套<code>&lt;svg&gt;</code>元素，它就是你创建的<code>&lt;svg&gt;</code>元素。</p>\n<p>注意，SVG元素的坐标系统可以使用<code>viewBox</code>属性进行修改，其他属性可能有助于改变坐标系统。这一部分的内容超出了本文的内容范围。所以在本文中，我假设<code>viewBox</code>没有进行过任何的修改。因此浏览器使用的默认坐标系统原点是在<code>&lt;svg&gt;</code>元素的左上角，大小也等于<code>&lt;svg&gt;</code>元素。</p>\n<h4 id=\"objectBoundingBox\"><a href=\"#objectBoundingBox\" class=\"headerlink\" title=\"objectBoundingBox\"></a><code>objectBoundingBox</code></h4><p>坐标系统的原点是在元素的边框盒子的左上角顶点处，同样适于剪切路径。这个边框是SVG元素对象的边框(它只是包含了一个或多个几何图形形状)和一个HTML元素设置<code>border-box</code>的盒模型是相关联的。</p>\n<p>这个值对<code>SVG</code>元素非常有用，因为它允许你应用的元素自身的边界做为剪切路径。下图显示一个图像应用SVG的剪切路径显示的效果，他们分别使用了<code>userSpaceOnUse</code>和<code>objectBoundingBox</code>。灰色的边框表示的是<code>SVG</code>元素创建的一个视窗。右图中的图像，我添加了一个灰色的边框用来表示剪切后的图像边框。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-9.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>在左图中，剪切路径的坐系统定位在SVG的视窗上。当使用了<code>objectBoundingBox</code>属性之后，图像自身的边框就会做为剪切路径的坐标系统。</p>\n<p>有一点需要特别的注意：<strong>当你设置了<code>objectBoundingBox</code>值后，<code>&lt;clipPath&gt;</code>元素中的内容必须在指定的坐标[0,1]内。</strong>坐标系统将成为一个单元系统，剪切出来的形状都在这个<code>clipPath</code>分值内。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-10.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>例如，如果剪切路径包含一个<code>&lt;circle&gt;</code>元素，而且他定位在圆的中心上：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;350&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;350&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;300&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>圆的位置(半径)会用分数表示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">clipPathUnits</span>=<span class=\"hljs-string\">&quot;objectBoundingBox&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;.5&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;.5&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;.45&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>在这种情况下，分数就像百分比。</p>\n<h3 id=\"lt-clipPath-gt-笔记\"><a href=\"#lt-clipPath-gt-笔记\" class=\"headerlink\" title=\"&lt;clipPath&gt;笔记\"></a><code>&lt;clipPath&gt;</code>笔记</h3><p><code>&lt;clipPath&gt;</code>元素不会直接在页面上呈现，他唯一的作用就是可以通过<code>clip-path</code>来引用。<code>display</code>属性不能运用于<code>&lt;clipPath&gt;</code>元素上，因此，就算<code>display</code>设置<code>none</code>外的其他值，<code>&lt;clipPath&gt;</code>元素也不会直接呈现。</p>\n<p>还记得我前面提到HTML元素剪切后的鼠标事件吗？相同的标准定义的行为却不同。鼠标事件在SVG的剪切区域外是无效。规范后面提到，可以让SVG定义新属性来控制剪切。</p>\n<p>Firefox浏览器实现了相同非标准行为，在剪切区域之外不支持鼠标事件。</p>\n<p>尽管Chrome为HTML元素的<code>clip-path</code>属笥实现标准行为，当你在一个<code>&lt;svg&gt;</code>元素上使用<code>&lt;clipPath&gt;</code>时，实现的行为是一样的。只有Firefox在可视区域能响应鼠标事件，我不知道这是一个特性还是一个Bug。</p>\n<p>在接下来的示例中，一个SVG的<code>&lt;clipPath&gt;</code>应用在一个SVG的<code>&lt;image&gt;</code>上。这个剪切路径我们前面使用过，图像剪成很多个矩形。当你的鼠标悬浮在图像上，图像具有一定的透明度。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">image &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#svgPath</span>);<br>&#125;<br>image<span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>    <span class=\"hljs-attribute\">opacity</span>: .<span class=\"hljs-number\">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"http://codepen.io/airen/pen/iDHfn\">查看DEMO</a></p>\n<p>请注意，一个空的剪切路径同样会被<code>clip-path</code>应用在元素上。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>剪切是一种图形化操作，允许我们在一个矩形的页面中创建不规则图形。实际上剪切和CSS的Shapes是一对完美的搭档。如果你有阅读过我<a href=\"http://alistapart.com/article/css-shapes-101\">早前写的关于CSS的Shapes的文章</a>，你就会看到很多实例中使用了<code>clip-path</code>属性。一旦CSS的Shapes可以<a href=\"http://dev.w3.org/csswg/css-shapes-2/#referencing-svg-shapes\">运用于SVG的路径上</a>（<a href=\"http://dev.w3.org/csswg/css-shapes-2/\">CSS Shapes Module Level 2</a>）,除了CSS的基本形状之外，CSS的Shapes和剪切配合可以让我们在视觉上制作出引人注目的设计，打破矩形的限制。</p>\n<p>著作权归作者所有。<br>商业转载请联系作者获得授权,非商业转载请注明出处。<br>原文: <a href=\"https://www.w3cplus.com/css3/css-svg-clipping.html\">https://www.w3cplus.com/css3/css-svg-clipping.html</a> © <a href=\"https://www.w3cplus.com/\">w3cplus.com</a></p>\n","site":{"data":{}},"wordcount":13750,"excerpt":"","more":"<h1 id=\"CSS和SVG中的剪切——clip-path属性和元素\"><a href=\"#CSS和SVG中的剪切——clip-path属性和元素\" class=\"headerlink\" title=\"CSS和SVG中的剪切——clip-path属性和元素\"></a>CSS和SVG中的剪切——clip-path属性和<clipPath>元素</h1><p><a href=\"https://www.w3cplus.com/svg-tutorial\">SVG</a></p>\n<p><a href=\"https://www.w3cplus.com/blog/tags/431.html\">clip-path</a></p>\n<p><a href=\"https://www.w3cplus.com/blog/tags/432.html\">clipPath</a></p>\n<blockquote>\n<p>本文由<a href=\"http://www.w3cplus.com/\">大漠</a>根据<a href=\"http://twitter.com/SaraSoueidan\">SaraSoueidan</a>的《<a href=\"http://sarasoueidan.com/blog/css-svg-clipping/\">Clipping in CSS and SVG – The clip-path Property and  Element</a>》所译，整个译文带有我们自己的理解与思想，如果译得不好或有不对之处还请同行朋友指点。如需转载此译文，需注明原作者相关信息<a href=\"http://sarasoueidan.com/blog/css-svg-clipping/%E3%80%82\">http://sarasoueidan.com/blog/css-svg-clipping/。</a></p>\n<p>——作者：<a href=\"http://twitter.com/SaraSoueidan\">SaraSoueidan</a></p>\n<p>——译者：<a href=\"http://www.w3cplus.com/\">大漠</a></p>\n</blockquote>\n<p>CSS和SVG有很多共同之处。CSS有很多特性都是从SVG中引入过来的。其中就有“剪切”的特性。CSS和SVG都允许我们对一个元素进行非矩形的剪切。在这篇文章中，将介绍CSS和SVG中的剪切技术。</p>\n<p>特别声明：本文提供的DEMO可能在你的浏览器中不能正常的演示，你应该查看这个<a href=\"https://github.com/awgreenblatt/css-graphics\">表格</a>了解更多相关的信息。你在阅读这篇文章之时没有必要查看提供的DEMO。不是所有的剪切特性都可以实现或者说只能实现部分剪切特性。本文的最大目的是告诉你CSS和SVG中的剪切是如何工作？仅用来做为参考。在文章中的代码不带有任何浏览器的私有前缀，但在示例中还是带了浏览器的私有前缀。</p>\n<h2 id=\"剪切是什么\"><a href=\"#剪切是什么\" class=\"headerlink\" title=\"剪切是什么\"></a>剪切是什么</h2><p>剪切是一个图形化操作，你可以部分或者完全隐藏一个元素。<strong>被剪切的元素可以是一个容器也可以是一个图像元素。</strong>元素的哪些部分显示或隐藏是由剪切的路径来决定的。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-1.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p><strong>剪切路径</strong>定义了一个区域，在这个区域内的内容将会显示，而不在这个区域内的内容不会显示。这个区域被称之为“裁剪区域”。只要在这个区域之外的任何元素都不会显示。包括元素的内容、背景、边框、文本、轮廓等，甚至还包括他的子元素。</p>\n<blockquote>\n<p>剪切的元素可以是任何容器和图片元素。</p>\n</blockquote>\n<p>剪切路径的概念就相当于在元素上定义了一个视窗。它决定了元素哪些部分在这个“视窗”中显示，哪些部分不在这个“视窗”中显示。但他不会影响自身文档流和其他文档流，因为他通常还是以一个矩形区域显示在其他文档流前面，哪怕是剪切出来的区域是不规则的矩形。如果你想改变周围内容元素围绕剪切出来的图形，那就需要使用<a href=\"http://www.w3.org/TR/css-shapes/\">CSS的图形</a>属性。如果你对这方面知识感兴趣，可以阅读我早前写的<a href=\"http://alistapart.com/article/css-shapes-101\">相关</a><a href=\"http://sarasoueidan.com/blog/css-shapes/\">文章</a>。</p>\n<blockquote>\n<p>有关于CSS3 Shapes相关中文教程，可以阅读早前翻译的两篇文章：</p>\n<ul>\n<li><a href=\"http://www.w3cplus.com/css3/css-regions-with-shapes-for-readability.html\">使用CSS Shapes的Regions创建更好的阅读体验</a></li>\n<li><a href=\"http://www.w3cplus.com/css3/css-shapes-101.html\">CSS Shapes 101</a></li>\n</ul>\n</blockquote>\n<h2 id=\"CSS中的剪切——clip-path属性\"><a href=\"#CSS中的剪切——clip-path属性\" class=\"headerlink\" title=\"CSS中的剪切——clip-path属性\"></a>CSS中的剪切——<code>clip-path</code>属性</h2><p><code>clip-path</code>属性是<a href=\"http://www.w3.org/TR/2014/WD-css-masking-1-20140213/\">CSS Masking模块</a>的一部分。自从2000年以来，剪切都只是SVG中的一部分，现在将这个功能引入到CSS的Msking模块中，所以现在可以对HTML元素和SVG元素进行剪切。</p>\n<p><code>clip-path</code>属性是指定一个应用到元素上的剪切路径。应用在SVG中<code>&lt;clipPath&gt;</code>元素上的属性值可以完全运用在<code>clip-path</code>的属性上。你还可以使用CSS Shapes模块中的<a href=\"http://dev.w3.org/csswg/css-shapes-2/#ltbasic-shapegt\">基本形状</a>来定义剪切路径。这些形状你可以使用形状函数来创建。这些形状态函数包括<code>polygon()</code>、<code>circle()</code>、<code>inset()</code>(用来定义嵌入的矩形)和<code>ellipse()</code>。</p>\n<p>使用<code>clip-path</code>属性将一个剪切路径运用在一个元素上非常的简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* SVG中的clipPath的使用 */</span><br><span class=\"hljs-selector-class\">.element</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#svgClipPathID</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用CSS中的基本图形函数 */</span><br><span class=\"hljs-selector-class\">.element</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(...); <span class=\"hljs-comment\">/* 或者其他的图形函数 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如，我们使用<code>polygon()</code>函数定义一个多边形的剪切路径，并且把这个路径应用到一个图像上，代码看起来像这样：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">img</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(<span class=\"hljs-number\">626px</span> <span class=\"hljs-number\">463px</span>,<span class=\"hljs-number\">765px</span> <span class=\"hljs-number\">236px</span>,<span class=\"hljs-number\">687px</span> <span class=\"hljs-number\">31px</span>,<span class=\"hljs-number\">271px</span> <span class=\"hljs-number\">100px</span>,<span class=\"hljs-number\">70px</span> <span class=\"hljs-number\">10px</span>,<span class=\"hljs-number\">49px</span> <span class=\"hljs-number\">250px</span>,<span class=\"hljs-number\">133px</span> <span class=\"hljs-number\">406px</span>,<span class=\"hljs-number\">374px</span> <span class=\"hljs-number\">462px</span>,<span class=\"hljs-number\">529px</span> <span class=\"hljs-number\">393px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>应用上面的代码之后，图像显示成这样：</p>\n<p><a href=\"http://codepen.io/airen/pen/wglAe\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-2.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/wglAe\">查看DEMO</a></p>\n<p>基本图形函数允许我们创建一定数量的图形，其中最复杂的就是多边形。如果你想创建一个更为复杂的图形，而且图形看起来不是用直线画出来的，这个时候你就需要使用SVG的<code>&lt;clipPath&gt;</code>元素。正如<code>&lt;clipPath&gt;</code>元素名称所暗示的一样，你可以使用这个元素绘制任意路径的图形。这也意味着，你可以使用<code>&lt;clipPath&gt;</code>元素绘制出任意图形来做为一个剪切路径。</p>\n<p>在我们第二个示例中，使用SVG的<code>clipPath</code>定义一个路径，这个剪切路径看起来像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">&quot;#FFFFFF&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">&quot;1.5794&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M215,100.3c97.8-32.6,90.5-71.9,336-77.6　c92.4-2.1,98.1,81.6,121.8,116.4c101.7,149.9,53.5,155.9,14.7,178c-96.4,54.9,5.4,269-257,115.1c-57-33.5-203,46.3-263.7,20.1</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">    c-33.5-14.5-132.5-45.5-95-111.1C125.9,246.6,98.6,139.1,215,100.3z&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这剪切路径看起来就像一个黑色的描边圈了一个不规则的图形，这是一个简单的剪切路径，不带有任何的填充。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-3.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>在下一部分中，我们将着重讨论SVG的<code>&lt;clipPath&gt;</code>元素。但现在，我们来看看如何将定义好的路径运用到图片上：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">img</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#svgPath</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最终效果如下所示：</p>\n<p><a href=\"http://codepen.io/airen/pen/Buais\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-4.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/Buais\">查看DEMO</a></p>\n<p>事实上，<code>&lt;clipPath&gt;</code>元素包括很多个基本图形（<code>&lt;rect&gt;</code>，<code>&lt;circle&gt;</code>等），<code>&lt;path&gt;</code>元素，甚至是<code>&lt;text&gt;</code>元素。</p>\n<p>如果在<code>&lt;clipPath&gt;</code>里面通过<code>&lt;text&gt;</code>指定文本，那么这个文本就会当成是一个剪切路径，不管文是否可见，文本外的区域都将被剪切掉。</p>\n<p>注意，你可以使用任何文本做为剪切路径。这为实现很多效果开启了一扇大门。你可以使用动画图片（比如，gif）,甚至是视频，然后选择你需要的文本进行剪切。这里是没有任何限制的。</p>\n<p>下面的示例，就是使用文本做为剪切路径：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgTextPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;300&quot;</span> <span class=\"hljs-attr\">textLength</span>=<span class=\"hljs-string\">&quot;800px&quot;</span> <span class=\"hljs-attr\">lengthAdjust</span>=<span class=\"hljs-string\">&quot;spacing&quot;</span> <span class=\"hljs-attr\">font-family</span>=<span class=\"hljs-string\">&quot;Vollkorn&quot;</span> <span class=\"hljs-attr\">font-size</span>=<span class=\"hljs-string\">&quot;230px&quot;</span> <span class=\"hljs-attr\">font-weight</span>=<span class=\"hljs-string\">&quot;700&quot;</span> <span class=\"hljs-attr\">font-style</span>=<span class=\"hljs-string\">&quot;italic&quot;</span>&gt;</span> Blossom <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>SVG中的<code>&lt;text&gt;</code>最酷的特点就是可以使用自定义字体，就像HTML文本。在我们的示例中使用了Google Web Fonts中的<a href=\"http://www.google.com/fonts/specimen/Vollkorn\">Vollkorn</a>字体。使用<code>textLength</code>属性，将文本的宽度设置的和图片宽度一样， 并且通过<code>x</code>和<code>y</code>来定位文本。注意，<code>x</code>和<code>y</code>坐标确认了文本左下角的位置（也就是文本的基线baseline）。</p>\n<p>使用上面的文本路径剪切图来的图片效果如下：</p>\n<p><a href=\"http://codepen.io/airen/pen/vyEzH\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-5.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/vyEzH\">查看DEMO</a></p>\n<p>正如我们前面提到的，你还可以在<code>&lt;clipPath&gt;</code>中使用多个图形形状。在下一节中，将会深入介绍<code>&lt;clipPath&gt;</code>，这里我们先简单的了解。在这个示例中，我们使用了多个<code>&lt;circle&gt;</code>形状，他们大小不同，位置不同。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;40&quot;</span> /&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;193.949&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;235&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;74.576&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;426.576&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;108.305&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;47.034&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;346.915&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;255.763&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;43.644&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;255.39&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;82.882&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;35.17&quot;</span>/&gt;</span><br>            <span class=\"hljs-comment\">&lt;!-- more circles... --&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>此时，图像只会在圆中显示，圆外就不会显示：</p>\n<p><a href=\"http://codepen.io/airen/pen/dfIry\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-6.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/dfIry\">查看DEMO</a></p>\n<p>正如我们这篇文章中介绍的，你可以使用<code>clip-path</code>属性应用在SVG元素绘制的路径。在上面演示的示例，剪切路径都是应用在HTML中的<code>&lt;img&gt;</code>元素上。在接下来的示例中，将演示的是一个剪切路径用于<code>&lt;svg&gt;</code>的根元素。同样是樱花图片，使用下面SVG的中的<code>&lt;image&gt;</code>来引用。</p>\n<p>SVG中的<code>&lt;image&gt;</code>元素用来引用一个完整的SVG或像素图像。如果你在<code>&lt;image&gt;</code>中引用的SVG图像，设置的<code>width</code>和<code>height</code>属性，将会用来设置SVG视窗的大小。如果你引用的是像素图像（我们这里的例子就是这样做的），图像将会自动缩放到指定的<code>width</code>和<code>height</code>。所以我们要确认好他们的长宽比例，避免图像扭曲。</p>\n<p>当你创建一个SVG时，你可以在<code>&lt;svg&gt;</code>元素上指定其宽度和高度的大小，用于创建一个窗口。任何超过这个窗口的内容都将不会显示出来。你可以通过<code>&lt;clipPath&gt;</code>元素定制一个窗口。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;800&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;flowers.jpg&quot;</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;800&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;theSVGPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;108&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;121.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;25.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;55&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;455&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;192.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;9.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;60&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;484&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;271.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;44.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;63&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;416&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;349.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;25.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;208&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;447&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;574.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;44.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;60&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;446&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;644.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;9.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;68&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;471&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;736.5&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;18.5&quot;</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;49&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;462&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>使用<code>clip-path</code>将定义好的<code>&lt;clipPath&gt;</code>运用到<code>&lt;svg&gt;</code>元素上：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">svg &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#theSVGPath</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"http://codepen.io/airen/pen/ghfoE\"><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-7.jpg\" alt=\"CSS和SVG中的剪切\"></a></p>\n<p><a href=\"http://codepen.io/airen/pen/ghfoE\">查看DEMO</a></p>\n<p>更多有关于在SVG上使用<code>clip-path</code>的示例将会在下面介绍<code>&lt;clipPath&gt;</code>部分介绍。</p>\n<h3 id=\"一个剪切路径的参考盒子\"><a href=\"#一个剪切路径的参考盒子\" class=\"headerlink\" title=\"一个剪切路径的参考盒子\"></a>一个剪切路径的参考盒子</h3><p>除了剪切路径本身，还可以给剪切路径应用一个<code>&lt;basic-shape&gt;</code>定义一个剪切路径的参考盒子。也就是说，可以使用一个剪切的基本函数创建一个剪切路径。其中参考盒子只能使用CSS的<code>clip-path</code>来指定形状路径，而不能使用SVG的<code>&lt;clipPath&gt;</code>。对于SVG的<code>&lt;clipPath&gt;</code>参考盒子是一个<code>border-box</code>元素。</p>\n<p>因此剪切路径的参考盒子用<code>&lt;basic-shape&gt;</code>来指定。如果是一个HTML元素被剪切，可以使用四种盒模型：<code>margin-box</code>、<code>border-box</code>、<code>padding-box</code>和<code>content-box</code>。每种盒模型都有其自己的解释。</p>\n<p>如果<code>&lt;basic-path&gt;</code>制作的剪切路径运用在一个SVG元素上，参考盒子可以设置为下面三种的其中一种：</p>\n<ul>\n<li><strong><code>fill-box</code>：</strong>使用对像的边缘做为参考盒子</li>\n<li><strong><code>stroke-box</code>：</strong>使用路径做为参考盒子</li>\n<li><strong><code>view-box</code>：</strong>如果没有指定<code>viewBox</code>将使用最近的SVG视窗做为参考盒子。如果<code>viewBox</code>的确创建了，则会根据<code>viewBox</code>的原点坐标和维度来创建参考盒子</li>\n</ul>\n<p>如果为SVG元素设置CSS盒模型中的任何一种做为参考盒子，则会使用<code>fill-box</code>值；如果你使用SVG来做为一个HTML元素的参考盒子，则会使用<code>border-box</code>盒模型。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.element</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(...) padding-box;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果参考盒子没有使用<code>clip-path</code>来指定——也就是没有定义任何形状——浏览器将会使用指定的盒子的边缘，包括圆角图形（比如说使用了<code>border-radius</code>）做为剪切路径。</p>\n<p>例如，使用下面的代码片段，使用了<code>border-radius</code>指定了一个圆角的剪切路径：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.el</span> &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: border-box;<br>    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">25%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意，在写这篇文章之时，使用<code>border-box</code>指定一个参考盒子，在webkit内核中还无法得以支持，因为它还没有运用于实战当中。</strong></p>\n<h3 id=\"叠加情况、指针事件和动画下的clip-path的注意事项\"><a href=\"#叠加情况、指针事件和动画下的clip-path的注意事项\" class=\"headerlink\" title=\"叠加情况、指针事件和动画下的clip-path的注意事项\"></a>叠加情况、指针事件和动画下的<code>clip-path</code>的注意事项</h3><p>特别注意，要知道，如果任何都设置默认值，<code>clip-path</code>属性将会创建一个类似于透明元素。</p>\n<p>此外，根据Masking规范，鼠标事件在图形的<code>clipped-out</code>区域外是无效的。这意味着，如果没有做剪切，鼠标事件还是有效的。这一部规范中做了详细的描述，只是实现方式不同。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-8.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>绿色区域表示可以响应鼠标事件。左图表示的是标签规范的行为，右图表示非标签规范行为。</p>\n<p>为了演示，我在前面示例的基础上，给图片添加了一个<code>div</code>容器，使用了SVG的<code>&lt;clipPath&gt;</code>制作剪切路径。如果没有使用剪切，你可以看到图像有边框。添加一个<code>hover</code>效果，鼠标经过图片时，图片会带有一定的透明度。</p>\n<p>如果使用Chrome浏览器（35.0.1916.153版本测试），就算鼠标在图像的剪切之外的区域，图片也会有一琮的透明度。这种行为就是符合标准规范的一种行为。</p>\n<p>在Firefox浏览器(30.0版本测试)，除了在可视区域图像不会响应鼠标事件。这意味着，鼠标移到图像剪切区域之外，会失去鼠标事件。（图像不带有透明度）</p>\n<p>我必须得说，我更喜欢符合规范规范的那种行为，不知道你喜欢的是哪种行为？</p>\n<p><a href=\"http://codepen.io/airen/pen/wqIhC\">查看DEMO</a></p>\n<p>剪切路径还可以使用动画效果。如果使用SVG的<code>&lt;clipPath&gt;</code>制作剪切路径，可以在其内部设置动画（下一节中将会详细介绍）。如果剪切路径是使用的基本图形函数创建，则何以运用CSS3的<code>animation</code>或者<code>transition</code>属性。至于如何使用基本图形创建一个动画的路径，感兴趣的可以阅读我前面写的一篇文章：《<a href=\"http://sarasoueidan.com/blog/animating-css-shapes/\">Animating CSS Shapes with CSS Animations &amp; Transitions</a>》。</p>\n<h2 id=\"SVG中的剪切——-lt-clipPath-gt-元素\"><a href=\"#SVG中的剪切——-lt-clipPath-gt-元素\" class=\"headerlink\" title=\"SVG中的剪切——&lt;clipPath&gt;元素\"></a>SVG中的剪切——<code>&lt;clipPath&gt;</code>元素</h2><p>在SVG中使用<code>&lt;clipPath&gt;</code>元素来定义剪切元素的剪切路径。如果不想使用CSS的<code>clip-path</code>来定义元素的剪切路径，可以使用SVG中的<code>clip-path</code>属性。</p>\n<blockquote>\n<p>你看过或读过我写的“Styling and Animating Scalable Vector Graphics with CSS”的幻灯片？如果没有，你应该看看里面介绍的，如何使用SVG的属性和CSS样式来美化SVG元素。你可以点击<a href=\"http://sarasoueidan.com/blog/cssconf-2014-talk\">这里</a>阅读.</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;myClippingPath&quot;</span>&gt;</span><br>            <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- the element you want to apply the clipPath to can be any SVG element --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;my-graphic&quot;</span> <span class=\"hljs-attr\">clip-path</span>=<span class=\"hljs-string\">&quot;url(#myClippingPath)&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"lt-clipPath-gt-的内容\"><a href=\"#lt-clipPath-gt-的内容\" class=\"headerlink\" title=\"&lt;clipPath&gt;的内容\"></a><code>&lt;clipPath&gt;</code>的内容</h3><p>我们前面提到过，可以在SVG中的<code>&lt;clipPath&gt;</code>内创建任意数量的基本形状，<code>&lt;path&gt;</code>和<code>&lt;text&gt;</code>元素。它甚至还可以包括很多其他的东西，这正也是SVG很有意思的地方。</p>\n<p><code>&lt;clipPath&gt;</code>元素中的内容可以是描述性的（如<code>&lt;title&gt;</code>，<code>&lt;desc&gt;</code>，<code>&lt;metadata&gt;</code>）。也可以是图形（如:<code>&lt;circle&gt;</code>, <code>&lt;ellipse&gt;</code>, <code>&lt;line&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;polygon&gt;</code>, <code>&lt;polyline&gt;</code>, <code>&lt;rect&gt;</code>或者<code>&lt;text&gt;</code>）。一个<code>&lt;clipPath&gt;</code>可以包含一个<code>&lt;use&gt;</code>元素或者<code>&lt;script&gt;</code>。注意，在<code>&lt;clipPath&gt;</code>元素中使用<code>&lt;use&gt;</code>元素，只能引用一些简单的SVG的图形（前面提到的）,例如，它在<code>&lt;clipPath&gt;</code>内不能用于群体的参照，它是没办法正常工作的。</p>\n<p>最后一部分，但并不是最重要的一部分。<code>&lt;clipPath&gt;</code>可以包括一个使用<code>&lt;animate&gt;</code>, <code>&lt;animateColor&gt;</code>, <code>&lt;animateMotion&gt;</code>,<code>&lt;animateTransform&gt;</code>或 <code>&lt;set&gt;</code>创建的动画。这为很多创造打开了一扇门，只要你敢想，就能做。</p>\n<p>使用多个<code>&lt;circle&gt;</code>制作的剪路径，并且添加了一个简单的动画效果来做为示例演示。每个<code>&lt;circle&gt;</code>都有一个简单的动画。为了保证示例的简单，在所有圆上都使用了同一个简单的动画效果。当然，你可以为每个圆创建不同的动画效果。演示示例的代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;40&quot;</span>&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animate</span> <span class=\"hljs-attr\">attributeName</span>=<span class=\"hljs-string\">&quot;r&quot;</span> <span class=\"hljs-attr\">attributeType</span>=<span class=\"hljs-string\">&quot;XML&quot;</span> <span class=\"hljs-attr\">from</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;250&quot;</span> <span class=\"hljs-attr\">begin</span>=<span class=\"hljs-string\">&quot;0s&quot;</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">&quot;3s&quot;</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">&quot;freeze&quot;</span>  <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">&quot;indefinite&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">circle</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;193.949&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;235&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;74.576&quot;</span>&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">animate</span> <span class=\"hljs-attr\">attributeName</span>=<span class=\"hljs-string\">&quot;r&quot;</span> <span class=\"hljs-attr\">attributeType</span>=<span class=\"hljs-string\">&quot;XML&quot;</span> <span class=\"hljs-attr\">from</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;250&quot;</span> <span class=\"hljs-attr\">begin</span>=<span class=\"hljs-string\">&quot;0s&quot;</span> <span class=\"hljs-attr\">dur</span>=<span class=\"hljs-string\">&quot;3s&quot;</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">&quot;freeze&quot;</span> <span class=\"hljs-attr\">repeatCount</span>=<span class=\"hljs-string\">&quot;indefinite&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">circle</span>&gt;</span><br>            <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span> <br></code></pre></td></tr></table></figure>\n\n<p>这个动画就只指定了每个圆的尺寸大小，圆的半径从0到250px，总共花了3秒时间，并且设置了动画播放次数是无限次。</p>\n<p>点击下面的按钮查看示例，使用Chrome或者Safari点击查看案例之前，得告诉您，示例还存在一个bug（详细介绍请点击<a href=\"https://code.google.com/p/chromium/issues/detail?id=391604\">这里</a>），所以我建议您使用Firefox查看示例，直到这个Bug已修复。</p>\n<p><a href=\"http://codepen.io/airen/pen/GAgqw\">查看DEMO</a></p>\n<p>请注意，<code>&lt;clipPath&gt;</code>的内容也不能包括<code>&lt;g&gt;</code>。例如我们给多个圆<code>&lt;circle&gt;</code>放在一个组里<code>&lt;g&gt;</code>，那么它不能正常工作，剪切路径不会运用到图片上。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;0&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svgPath&quot;</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- WILL NOT WORK --&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- WILL NOT WORK --&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;193.949&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;235&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;74.576&quot;</span>/&gt;</span><br>                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">&quot;#000000&quot;</span> <span class=\"hljs-attr\">stroke-miterlimit</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;426.576&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;108.305&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;47.034&quot;</span>/&gt;</span><br>                <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"clipPathUnits属性\"><a href=\"#clipPathUnits属性\" class=\"headerlink\" title=\"clipPathUnits属性\"></a><code>clipPathUnits</code>属性</h3><p><code>&lt;clipPath&gt;</code>元素包括很多个属性，比如<code>id</code>,<code>class</code>,<code>transform</code>和像<code>fill</code>和<code>stroke</code>这样的<a href=\"http://www.w3.org/TR/2011/REC-SVG11-20110816/intro.html#TermPresentationAttribute\">显示属性</a>以及<a href=\"http://www.w3.org/TR/2011/REC-SVG11-20110816/styling.html#SVGStylingProperties\">其他更多属性</a>。其中最有用的是<code>clipPathUnits</code>属性。</p>\n<p><code>clipPathUnits</code>主要用来给<code>&lt;clipPath&gt;</code>元素内容指定一个坐标系统。它具有两个值：<code>objectBoundingBox</code>和<code>userSpaceOnUse</code>，其中<code>userSpaceOnUse</code>是默认值。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">clipPathUnits</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;userSpaceOnUse | objectBoundingBox&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"userSpaceOnUse\"><a href=\"#userSpaceOnUse\" class=\"headerlink\" title=\"userSpaceOnUse\"></a><code>userSpaceOnUse</code></h4><p>当<code>clipPath</code>元素是用来当作参考物时，<code>clipPath</code>元素内容是以用户坐标系统作为参考点。（例如：<code>clipPath</code>元素的用户坐标系统是通过<code>clip-path</code>属性来引用）。</p>\n<p>用户坐标系统（局部坐标系统）是目前激活的坐标系统，主要用来如何定位坐标和长度。一个HTML元素的坐标和CSS的盒模型有关，但不同的是SVG元素没有这样的盒模型。</p>\n<p>对于CSS盒子的布局，用户的坐标原点就在盒子的左上角，而且一个单位就是一个像素，视窗也可以根据盒子的宽度按百分比计算。我想你对这方面应该非常的熟悉。如果你有一个<code>&lt;clipPath&gt;</code>元素包含了一个<code>&lt;circle&gt;</code>，而且这个<code>&lt;circle&gt;</code>的中心点在<code>cx=100</code>和<code>cy=100</code>。那么这个中心点就是距盒子左边100px和顶边100px的交汇处。</p>\n<p>如果元素是一个SVG元素，因此他是没一个类似于CSS盒模型的东西，用户的坐标原点是距<code>&lt;svg&gt;</code>元素视窗左上角最近的一个地方。一般情况之下，最近的视窗的建立，他的宽度和高度接近于<code>&lt;svg&gt;</code>的祖先元素。如果你不嵌套<code>&lt;svg&gt;</code>元素，它就是你创建的<code>&lt;svg&gt;</code>元素。</p>\n<p>注意，SVG元素的坐标系统可以使用<code>viewBox</code>属性进行修改，其他属性可能有助于改变坐标系统。这一部分的内容超出了本文的内容范围。所以在本文中，我假设<code>viewBox</code>没有进行过任何的修改。因此浏览器使用的默认坐标系统原点是在<code>&lt;svg&gt;</code>元素的左上角，大小也等于<code>&lt;svg&gt;</code>元素。</p>\n<h4 id=\"objectBoundingBox\"><a href=\"#objectBoundingBox\" class=\"headerlink\" title=\"objectBoundingBox\"></a><code>objectBoundingBox</code></h4><p>坐标系统的原点是在元素的边框盒子的左上角顶点处，同样适于剪切路径。这个边框是SVG元素对象的边框(它只是包含了一个或多个几何图形形状)和一个HTML元素设置<code>border-box</code>的盒模型是相关联的。</p>\n<p>这个值对<code>SVG</code>元素非常有用，因为它允许你应用的元素自身的边界做为剪切路径。下图显示一个图像应用SVG的剪切路径显示的效果，他们分别使用了<code>userSpaceOnUse</code>和<code>objectBoundingBox</code>。灰色的边框表示的是<code>SVG</code>元素创建的一个视窗。右图中的图像，我添加了一个灰色的边框用来表示剪切后的图像边框。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-9.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>在左图中，剪切路径的坐系统定位在SVG的视窗上。当使用了<code>objectBoundingBox</code>属性之后，图像自身的边框就会做为剪切路径的坐标系统。</p>\n<p>有一点需要特别的注意：<strong>当你设置了<code>objectBoundingBox</code>值后，<code>&lt;clipPath&gt;</code>元素中的内容必须在指定的坐标[0,1]内。</strong>坐标系统将成为一个单元系统，剪切出来的形状都在这个<code>clipPath</code>分值内。</p>\n<p><img src=\"http://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1407/clip-path-10.jpg\" alt=\"CSS和SVG中的剪切\"></p>\n<p>例如，如果剪切路径包含一个<code>&lt;circle&gt;</code>元素，而且他定位在圆的中心上：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;350&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;350&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;300&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>圆的位置(半径)会用分数表示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">clipPathUnits</span>=<span class=\"hljs-string\">&quot;objectBoundingBox&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;.5&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;.5&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;.45&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>在这种情况下，分数就像百分比。</p>\n<h3 id=\"lt-clipPath-gt-笔记\"><a href=\"#lt-clipPath-gt-笔记\" class=\"headerlink\" title=\"&lt;clipPath&gt;笔记\"></a><code>&lt;clipPath&gt;</code>笔记</h3><p><code>&lt;clipPath&gt;</code>元素不会直接在页面上呈现，他唯一的作用就是可以通过<code>clip-path</code>来引用。<code>display</code>属性不能运用于<code>&lt;clipPath&gt;</code>元素上，因此，就算<code>display</code>设置<code>none</code>外的其他值，<code>&lt;clipPath&gt;</code>元素也不会直接呈现。</p>\n<p>还记得我前面提到HTML元素剪切后的鼠标事件吗？相同的标准定义的行为却不同。鼠标事件在SVG的剪切区域外是无效。规范后面提到，可以让SVG定义新属性来控制剪切。</p>\n<p>Firefox浏览器实现了相同非标准行为，在剪切区域之外不支持鼠标事件。</p>\n<p>尽管Chrome为HTML元素的<code>clip-path</code>属笥实现标准行为，当你在一个<code>&lt;svg&gt;</code>元素上使用<code>&lt;clipPath&gt;</code>时，实现的行为是一样的。只有Firefox在可视区域能响应鼠标事件，我不知道这是一个特性还是一个Bug。</p>\n<p>在接下来的示例中，一个SVG的<code>&lt;clipPath&gt;</code>应用在一个SVG的<code>&lt;image&gt;</code>上。这个剪切路径我们前面使用过，图像剪成很多个矩形。当你的鼠标悬浮在图像上，图像具有一定的透明度。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">image &#123;<br>    <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">#svgPath</span>);<br>&#125;<br>image<span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>    <span class=\"hljs-attribute\">opacity</span>: .<span class=\"hljs-number\">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"http://codepen.io/airen/pen/iDHfn\">查看DEMO</a></p>\n<p>请注意，一个空的剪切路径同样会被<code>clip-path</code>应用在元素上。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>剪切是一种图形化操作，允许我们在一个矩形的页面中创建不规则图形。实际上剪切和CSS的Shapes是一对完美的搭档。如果你有阅读过我<a href=\"http://alistapart.com/article/css-shapes-101\">早前写的关于CSS的Shapes的文章</a>，你就会看到很多实例中使用了<code>clip-path</code>属性。一旦CSS的Shapes可以<a href=\"http://dev.w3.org/csswg/css-shapes-2/#referencing-svg-shapes\">运用于SVG的路径上</a>（<a href=\"http://dev.w3.org/csswg/css-shapes-2/\">CSS Shapes Module Level 2</a>）,除了CSS的基本形状之外，CSS的Shapes和剪切配合可以让我们在视觉上制作出引人注目的设计，打破矩形的限制。</p>\n<p>著作权归作者所有。<br>商业转载请联系作者获得授权,非商业转载请注明出处。<br>原文: <a href=\"https://www.w3cplus.com/css3/css-svg-clipping.html\">https://www.w3cplus.com/css3/css-svg-clipping.html</a> © <a href=\"https://www.w3cplus.com/\">w3cplus.com</a></p>\n"},{"title":"微信小程序","date":"2022-04-05T07:15:27.000Z","description":"小程序相关文档","_content":"\n# 微信小程序之页面拦截器\n### 场景\n\n1.  小程序有52个页面，其中13个页面无需任何身份，另外39个页面需要系统角色。对于这39个页面，如果微信用户没有系统角色，则跳转到登录页。\n2.  是否有系统角色信息需要通过异步请求来获取。\n\n### 需求分析&实现\n\n对需求进行抽象，其实要的就是一个过滤器，对小程序页面的访问进行过滤，符合条件的通过，不符合条件进行其他处理。\n\n使用过php的laravel框架的童鞋，肯定一下子就联想到了laravel框架的http中间件:  \n`HTTP 中间件提供一个方便的机制来过滤进入应用程序的 HTTP 请求，例如，Laravel 默认包含了一个中间件来检验用户身份验证，如果用户没有经过身份验证，中间件会将用户导向登录页面，然而，如果用户通过身份验证，中间件将会允许这个请求进一步继续前进。当然，除了身份验证之外，中间件也可以被用来执行各式各样的任务，CORS 中间件负责替所有即将离开程序的响应加入适当的响应头，一个日志中间件可以记录所有传入应用程序的请求。`\n\n令人忧桑的是，微信小程序并没有提供针对Page实例的中间件机制。所以只能从Page实例的生命周期处下手。\n\n![mina-lifecycle.png](https://segmentfault.com/img/remote/1460000011044376 \"mina-lifecycle.png\")\n\n对于onLoad,一个页面只会调用一次；对于onShow,每次打开页面(比如小程序从后台转到前台)都会调用一次。\n\n在onLoad或者onShow钩子函数里，对用户身份进行校验，通过后则拉取该页面需要的数据，否则跳转到登录页。\n\n```js\n//orderDetail.js\nonShow: function () {\n    let that = this;\n    //身份校验\n    service.identityCheck(() => {\n          //跳转到登录页\n          wx.redirectTo({\n            url: \"/pages/common/login/login\"\n          });\n        }, () => {    \n          //获取页面数据等等 \n          that.getDetail(this.orderId);\n          ...\n        }\n   );\n  },\n```\n\n不过，每个页面都要这样写，重复代码好多啊，侵入性也强。不如用装饰函数（高大上的说法是装饰者模式）来包装一下：\n\n```js\n//filter.js\nfunction identityFilter(pageObj){\n    if(pageObj.onShow){\n        let _onShow = pageObj.onShow;\n        pageObj.onShow = function(){\n            service.identityCheck(()=>{\n                //跳转到登录页\n                wx.redirectTo({\n                    url: \"/pages/common/login/login\"\n                });\n            },()=>{\n                //获取页面实例，防止this劫持\n                let currentInstance = getPageInstance();\n                _onShow.call(currentInstance);\n            });\n        }\n    }\n    return pageObj;\n}\n\nfunction getPageInstance(){\n    var pages = getCurrentPages();\n    return  pages[pages.length - 1];\n}\n\nexports.identityFilter = identityFilter;\n```\n`filter.js`用以提供过滤器方法，除了现有的用户身份拦截，后续如果需要其他拦截，可以在这个文件增加。然后，在需要用户身份拦截的小程序页面代码里，用`filter.identityFilter`处理一下就可以了:\n```js\n//orderDetail.js\nlet filter = require('filter.js');\nPage(filter.identityFilter({\n    ...\n    onShow: function () {\n        //获取页面数据等等\n        this.getDetail(this.orderId);\n        //...\n    },\n    ...\n}));\n```\n### 使用Promise进行优化\n\n上面的实现中，每次访问页面，都会执行一次获取用户身份的方法（就是上面代码里的`service. identityCheck` ）。其实没有必要，在小程序启动的时候获取一次就行了。也就是说，放在app.js的onLaunch方法里执行。\n\n每个小程序页面实例化时，一般也会执行异步方法，用来获取页面需要的数据。关键在于，我们需要保证，**页面的异步方法** 必须在 **获取用户身份的异步请求** 之后执行。\n\n毋容置疑，Promise最擅长处理异步请求的执行顺序了。主子，快放代码粗来：\n```js\n//app.js\nApp({\n    onLaunch:function(){\n        let p = new Promise(function(resolve,reject){\n            service.identityCheck(resolve,reject);\n        });\n        this.globalData.promise = p; \n    },\n    ...\n    globalData: {\n        promise:null,\n    }   \n});\n\n//filter.js\nconst appData = getApp().globalData;\nfunction identityFilter(pageObj){\n    if(pageObj.onShow){\n        let _onShow = pageObj.onShow;\n        pageObj.onShow = function(){\n            //改动点\n            appData.promise.then(()=>{\n                //跳转到登录页\n                wx.redirectTo({\n                    url: \"/pages/common/login/login\"\n                });\n            },()=>{\n                //获取页面实例，防止this劫持\n                let currentInstance = getPageInstance();\n                _onShow.call(currentInstance);\n            });\n        }\n    }\n    return pageObj;\n}\n```\n### 小结\n\n基本实现了小程序页面的用户身份拦截器，但是比起laravel的http中间件还是逊色一些：\n\n1.  需要对每个页面代码包装一层。\n2.  即使用户身份校验不通过，小程序也并不会阻塞页面的渲染。假如获取用户身份的异步方法一分钟才执行完，小程序页面还是会展示出来，一分钟之后才跳转到登录页。需要自己增加逻辑，比如在这一分钟内，页面展示空白内容。\n\n嗯，对小程序的新特性保持关注，后面看看怎么改进~\n\n# 解决微信小程序`background-attachment: fixed;`在真机上无法生效\n整个页面外包一个`view`\n对该`view`设置样式如下：\n```css\n.all {\n\tbackground-size: cover;\n\tbackground-position: center;\n\theight: 100vh;\n\toverflow: auto;\n\tbackground-repeat: no-repeat;\n\tbackground-image: url(https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202202121406661.jpg);\n\n}\n```\n如果需要给整个背景增加背景模糊效果/遮罩可以通过`::after`伪元素，即如下方式\n```css\n.all::after{\n\twidth: 100%;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\theight: 100vh;\n\toverflow: auto;\n\tbackground: inherit;\n\tfilter: blur(5px);\n\tcontent: '';\n\tz-index: 0;\n\tbackground-color: aliceblue;\n}\n```\n\n\n\n# 全局修改Page对象\n\n在app.js顶部增加如下代码\n\n> 可用作页面拦截/或者给每个页面设置统一的附加函数\n```js\n(function () {\n\t// 设置需要拦截的页面\n\tconst checkRouterPageList = ['pages/explore/explore']\n\t// 小程序原来的Page方法\n\tlet originalPage = Page;\n\t// 我们自定义的Page方法\n\tPage = (config) => {\n\t\tlet originalLoadMethod = config.onLoad;\n\t\tconfig.onLoad = function (e) {\n\t\t\tlet currentPageUrl = getPageUrl()\n\t\t\tif (checkRouterPageList.indexOf(currentPageUrl)) {\n\t\t\t\t// 未登录时进行拦截\n\t\t\t\t// wx.switchTab({\n\t\t\t\t// url: '/pages/myinfo/myinfo',\n\t\t\t\t// })\n\t\t\t}\n\t\t\tif (originalLoadMethod) {\n\t\t\t\toriginalLoadMethod.call(this, e)\n\t\t\t}\n\t\t}\n\t\t// todo 在这里我们可以给配置对象进行加工\n\t\t// 将配置对象继续想下传递给小程序原来的Page方法\n\t\toriginalPage(config);\n\t}\n})();\n```","source":"_posts/微信小程序/微信小程序.md","raw":"---\ntitle: 微信小程序\ndate: 2022-04-05 15:15:27\ntags:\n  - [小程序]\n  - [前端]\ncategories:\n  - [技术]\ndescription: 小程序相关文档\n---\n\n# 微信小程序之页面拦截器\n### 场景\n\n1.  小程序有52个页面，其中13个页面无需任何身份，另外39个页面需要系统角色。对于这39个页面，如果微信用户没有系统角色，则跳转到登录页。\n2.  是否有系统角色信息需要通过异步请求来获取。\n\n### 需求分析&实现\n\n对需求进行抽象，其实要的就是一个过滤器，对小程序页面的访问进行过滤，符合条件的通过，不符合条件进行其他处理。\n\n使用过php的laravel框架的童鞋，肯定一下子就联想到了laravel框架的http中间件:  \n`HTTP 中间件提供一个方便的机制来过滤进入应用程序的 HTTP 请求，例如，Laravel 默认包含了一个中间件来检验用户身份验证，如果用户没有经过身份验证，中间件会将用户导向登录页面，然而，如果用户通过身份验证，中间件将会允许这个请求进一步继续前进。当然，除了身份验证之外，中间件也可以被用来执行各式各样的任务，CORS 中间件负责替所有即将离开程序的响应加入适当的响应头，一个日志中间件可以记录所有传入应用程序的请求。`\n\n令人忧桑的是，微信小程序并没有提供针对Page实例的中间件机制。所以只能从Page实例的生命周期处下手。\n\n![mina-lifecycle.png](https://segmentfault.com/img/remote/1460000011044376 \"mina-lifecycle.png\")\n\n对于onLoad,一个页面只会调用一次；对于onShow,每次打开页面(比如小程序从后台转到前台)都会调用一次。\n\n在onLoad或者onShow钩子函数里，对用户身份进行校验，通过后则拉取该页面需要的数据，否则跳转到登录页。\n\n```js\n//orderDetail.js\nonShow: function () {\n    let that = this;\n    //身份校验\n    service.identityCheck(() => {\n          //跳转到登录页\n          wx.redirectTo({\n            url: \"/pages/common/login/login\"\n          });\n        }, () => {    \n          //获取页面数据等等 \n          that.getDetail(this.orderId);\n          ...\n        }\n   );\n  },\n```\n\n不过，每个页面都要这样写，重复代码好多啊，侵入性也强。不如用装饰函数（高大上的说法是装饰者模式）来包装一下：\n\n```js\n//filter.js\nfunction identityFilter(pageObj){\n    if(pageObj.onShow){\n        let _onShow = pageObj.onShow;\n        pageObj.onShow = function(){\n            service.identityCheck(()=>{\n                //跳转到登录页\n                wx.redirectTo({\n                    url: \"/pages/common/login/login\"\n                });\n            },()=>{\n                //获取页面实例，防止this劫持\n                let currentInstance = getPageInstance();\n                _onShow.call(currentInstance);\n            });\n        }\n    }\n    return pageObj;\n}\n\nfunction getPageInstance(){\n    var pages = getCurrentPages();\n    return  pages[pages.length - 1];\n}\n\nexports.identityFilter = identityFilter;\n```\n`filter.js`用以提供过滤器方法，除了现有的用户身份拦截，后续如果需要其他拦截，可以在这个文件增加。然后，在需要用户身份拦截的小程序页面代码里，用`filter.identityFilter`处理一下就可以了:\n```js\n//orderDetail.js\nlet filter = require('filter.js');\nPage(filter.identityFilter({\n    ...\n    onShow: function () {\n        //获取页面数据等等\n        this.getDetail(this.orderId);\n        //...\n    },\n    ...\n}));\n```\n### 使用Promise进行优化\n\n上面的实现中，每次访问页面，都会执行一次获取用户身份的方法（就是上面代码里的`service. identityCheck` ）。其实没有必要，在小程序启动的时候获取一次就行了。也就是说，放在app.js的onLaunch方法里执行。\n\n每个小程序页面实例化时，一般也会执行异步方法，用来获取页面需要的数据。关键在于，我们需要保证，**页面的异步方法** 必须在 **获取用户身份的异步请求** 之后执行。\n\n毋容置疑，Promise最擅长处理异步请求的执行顺序了。主子，快放代码粗来：\n```js\n//app.js\nApp({\n    onLaunch:function(){\n        let p = new Promise(function(resolve,reject){\n            service.identityCheck(resolve,reject);\n        });\n        this.globalData.promise = p; \n    },\n    ...\n    globalData: {\n        promise:null,\n    }   \n});\n\n//filter.js\nconst appData = getApp().globalData;\nfunction identityFilter(pageObj){\n    if(pageObj.onShow){\n        let _onShow = pageObj.onShow;\n        pageObj.onShow = function(){\n            //改动点\n            appData.promise.then(()=>{\n                //跳转到登录页\n                wx.redirectTo({\n                    url: \"/pages/common/login/login\"\n                });\n            },()=>{\n                //获取页面实例，防止this劫持\n                let currentInstance = getPageInstance();\n                _onShow.call(currentInstance);\n            });\n        }\n    }\n    return pageObj;\n}\n```\n### 小结\n\n基本实现了小程序页面的用户身份拦截器，但是比起laravel的http中间件还是逊色一些：\n\n1.  需要对每个页面代码包装一层。\n2.  即使用户身份校验不通过，小程序也并不会阻塞页面的渲染。假如获取用户身份的异步方法一分钟才执行完，小程序页面还是会展示出来，一分钟之后才跳转到登录页。需要自己增加逻辑，比如在这一分钟内，页面展示空白内容。\n\n嗯，对小程序的新特性保持关注，后面看看怎么改进~\n\n# 解决微信小程序`background-attachment: fixed;`在真机上无法生效\n整个页面外包一个`view`\n对该`view`设置样式如下：\n```css\n.all {\n\tbackground-size: cover;\n\tbackground-position: center;\n\theight: 100vh;\n\toverflow: auto;\n\tbackground-repeat: no-repeat;\n\tbackground-image: url(https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202202121406661.jpg);\n\n}\n```\n如果需要给整个背景增加背景模糊效果/遮罩可以通过`::after`伪元素，即如下方式\n```css\n.all::after{\n\twidth: 100%;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\theight: 100vh;\n\toverflow: auto;\n\tbackground: inherit;\n\tfilter: blur(5px);\n\tcontent: '';\n\tz-index: 0;\n\tbackground-color: aliceblue;\n}\n```\n\n\n\n# 全局修改Page对象\n\n在app.js顶部增加如下代码\n\n> 可用作页面拦截/或者给每个页面设置统一的附加函数\n```js\n(function () {\n\t// 设置需要拦截的页面\n\tconst checkRouterPageList = ['pages/explore/explore']\n\t// 小程序原来的Page方法\n\tlet originalPage = Page;\n\t// 我们自定义的Page方法\n\tPage = (config) => {\n\t\tlet originalLoadMethod = config.onLoad;\n\t\tconfig.onLoad = function (e) {\n\t\t\tlet currentPageUrl = getPageUrl()\n\t\t\tif (checkRouterPageList.indexOf(currentPageUrl)) {\n\t\t\t\t// 未登录时进行拦截\n\t\t\t\t// wx.switchTab({\n\t\t\t\t// url: '/pages/myinfo/myinfo',\n\t\t\t\t// })\n\t\t\t}\n\t\t\tif (originalLoadMethod) {\n\t\t\t\toriginalLoadMethod.call(this, e)\n\t\t\t}\n\t\t}\n\t\t// todo 在这里我们可以给配置对象进行加工\n\t\t// 将配置对象继续想下传递给小程序原来的Page方法\n\t\toriginalPage(config);\n\t}\n})();\n```","slug":"微信小程序/微信小程序","published":1,"updated":"2022-08-28T07:38:59.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2e003qscvmalmgev78","content":"<h1 id=\"微信小程序之页面拦截器\"><a href=\"#微信小程序之页面拦截器\" class=\"headerlink\" title=\"微信小程序之页面拦截器\"></a>微信小程序之页面拦截器</h1><h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><ol>\n<li>小程序有52个页面，其中13个页面无需任何身份，另外39个页面需要系统角色。对于这39个页面，如果微信用户没有系统角色，则跳转到登录页。</li>\n<li>是否有系统角色信息需要通过异步请求来获取。</li>\n</ol>\n<h3 id=\"需求分析-amp-实现\"><a href=\"#需求分析-amp-实现\" class=\"headerlink\" title=\"需求分析&amp;实现\"></a>需求分析&amp;实现</h3><p>对需求进行抽象，其实要的就是一个过滤器，对小程序页面的访问进行过滤，符合条件的通过，不符合条件进行其他处理。</p>\n<p>使用过php的laravel框架的童鞋，肯定一下子就联想到了laravel框架的http中间件:<br><code>HTTP 中间件提供一个方便的机制来过滤进入应用程序的 HTTP 请求，例如，Laravel 默认包含了一个中间件来检验用户身份验证，如果用户没有经过身份验证，中间件会将用户导向登录页面，然而，如果用户通过身份验证，中间件将会允许这个请求进一步继续前进。当然，除了身份验证之外，中间件也可以被用来执行各式各样的任务，CORS 中间件负责替所有即将离开程序的响应加入适当的响应头，一个日志中间件可以记录所有传入应用程序的请求。</code></p>\n<p>令人忧桑的是，微信小程序并没有提供针对Page实例的中间件机制。所以只能从Page实例的生命周期处下手。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000011044376\" alt=\"mina-lifecycle.png\" title=\"mina-lifecycle.png\"></p>\n<p>对于onLoad,一个页面只会调用一次；对于onShow,每次打开页面(比如小程序从后台转到前台)都会调用一次。</p>\n<p>在onLoad或者onShow钩子函数里，对用户身份进行校验，通过后则拉取该页面需要的数据，否则跳转到登录页。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//orderDetail.js</span><br><span class=\"hljs-attr\">onShow</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> that = <span class=\"hljs-variable language_\">this</span>;<br>    <span class=\"hljs-comment\">//身份校验</span><br>    service.<span class=\"hljs-title function_\">identityCheck</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-comment\">//跳转到登录页</span><br>          wx.<span class=\"hljs-title function_\">redirectTo</span>(&#123;<br>            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&quot;/pages/common/login/login&quot;</span><br>          &#125;);<br>        &#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;    <br>          <span class=\"hljs-comment\">//获取页面数据等等 </span><br>          that.<span class=\"hljs-title function_\">getDetail</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">orderId</span>);<br>          ...<br>        &#125;<br>   );<br>  &#125;,<br></code></pre></td></tr></table></figure>\n\n<p>不过，每个页面都要这样写，重复代码好多啊，侵入性也强。不如用装饰函数（高大上的说法是装饰者模式）来包装一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//filter.js</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">identityFilter</span>(<span class=\"hljs-params\">pageObj</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(pageObj.<span class=\"hljs-property\">onShow</span>)&#123;<br>        <span class=\"hljs-keyword\">let</span> _onShow = pageObj.<span class=\"hljs-property\">onShow</span>;<br>        pageObj.<span class=\"hljs-property\">onShow</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>            service.<span class=\"hljs-title function_\">identityCheck</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//跳转到登录页</span><br>                wx.<span class=\"hljs-title function_\">redirectTo</span>(&#123;<br>                    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&quot;/pages/common/login/login&quot;</span><br>                &#125;);<br>            &#125;,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//获取页面实例，防止this劫持</span><br>                <span class=\"hljs-keyword\">let</span> currentInstance = <span class=\"hljs-title function_\">getPageInstance</span>();<br>                _onShow.<span class=\"hljs-title function_\">call</span>(currentInstance);<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pageObj;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPageInstance</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">var</span> pages = <span class=\"hljs-title function_\">getCurrentPages</span>();<br>    <span class=\"hljs-keyword\">return</span>  pages[pages.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">identityFilter</span> = identityFilter;<br></code></pre></td></tr></table></figure>\n<p><code>filter.js</code>用以提供过滤器方法，除了现有的用户身份拦截，后续如果需要其他拦截，可以在这个文件增加。然后，在需要用户身份拦截的小程序页面代码里，用<code>filter.identityFilter</code>处理一下就可以了:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//orderDetail.js</span><br><span class=\"hljs-keyword\">let</span> filter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;filter.js&#x27;</span>);<br><span class=\"hljs-title class_\">Page</span>(filter.<span class=\"hljs-title function_\">identityFilter</span>(&#123;<br>    ...<br>    <span class=\"hljs-attr\">onShow</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">//获取页面数据等等</span><br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getDetail</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">orderId</span>);<br>        <span class=\"hljs-comment\">//...</span><br>    &#125;,<br>    ...<br>&#125;));<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用Promise进行优化\"><a href=\"#使用Promise进行优化\" class=\"headerlink\" title=\"使用Promise进行优化\"></a>使用Promise进行优化</h3><p>上面的实现中，每次访问页面，都会执行一次获取用户身份的方法（就是上面代码里的<code>service. identityCheck</code> ）。其实没有必要，在小程序启动的时候获取一次就行了。也就是说，放在app.js的onLaunch方法里执行。</p>\n<p>每个小程序页面实例化时，一般也会执行异步方法，用来获取页面需要的数据。关键在于，我们需要保证，<strong>页面的异步方法</strong> 必须在 <strong>获取用户身份的异步请求</strong> 之后执行。</p>\n<p>毋容置疑，Promise最擅长处理异步请求的执行顺序了。主子，快放代码粗来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//app.js</span><br><span class=\"hljs-title class_\">App</span>(&#123;<br>    <span class=\"hljs-attr\">onLaunch</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>            service.<span class=\"hljs-title function_\">identityCheck</span>(resolve,reject);<br>        &#125;);<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">globalData</span>.<span class=\"hljs-property\">promise</span> = p; <br>    &#125;,<br>    ...<br>    <span class=\"hljs-attr\">globalData</span>: &#123;<br>        <span class=\"hljs-attr\">promise</span>:<span class=\"hljs-literal\">null</span>,<br>    &#125;   <br>&#125;);<br><br><span class=\"hljs-comment\">//filter.js</span><br><span class=\"hljs-keyword\">const</span> appData = <span class=\"hljs-title function_\">getApp</span>().<span class=\"hljs-property\">globalData</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">identityFilter</span>(<span class=\"hljs-params\">pageObj</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(pageObj.<span class=\"hljs-property\">onShow</span>)&#123;<br>        <span class=\"hljs-keyword\">let</span> _onShow = pageObj.<span class=\"hljs-property\">onShow</span>;<br>        pageObj.<span class=\"hljs-property\">onShow</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>            <span class=\"hljs-comment\">//改动点</span><br>            appData.<span class=\"hljs-property\">promise</span>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//跳转到登录页</span><br>                wx.<span class=\"hljs-title function_\">redirectTo</span>(&#123;<br>                    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&quot;/pages/common/login/login&quot;</span><br>                &#125;);<br>            &#125;,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//获取页面实例，防止this劫持</span><br>                <span class=\"hljs-keyword\">let</span> currentInstance = <span class=\"hljs-title function_\">getPageInstance</span>();<br>                _onShow.<span class=\"hljs-title function_\">call</span>(currentInstance);<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pageObj;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>基本实现了小程序页面的用户身份拦截器，但是比起laravel的http中间件还是逊色一些：</p>\n<ol>\n<li>需要对每个页面代码包装一层。</li>\n<li>即使用户身份校验不通过，小程序也并不会阻塞页面的渲染。假如获取用户身份的异步方法一分钟才执行完，小程序页面还是会展示出来，一分钟之后才跳转到登录页。需要自己增加逻辑，比如在这一分钟内，页面展示空白内容。</li>\n</ol>\n<p>嗯，对小程序的新特性保持关注，后面看看怎么改进~</p>\n<h1 id=\"解决微信小程序background-attachment-fixed-在真机上无法生效\"><a href=\"#解决微信小程序background-attachment-fixed-在真机上无法生效\" class=\"headerlink\" title=\"解决微信小程序background-attachment: fixed;在真机上无法生效\"></a>解决微信小程序<code>background-attachment: fixed;</code>在真机上无法生效</h1><p>整个页面外包一个<code>view</code><br>对该<code>view</code>设置样式如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.all</span> &#123;<br>\t<span class=\"hljs-attribute\">background-size</span>: cover;<br>\t<span class=\"hljs-attribute\">background-position</span>: center;<br>\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100vh</span>;<br>\t<span class=\"hljs-attribute\">overflow</span>: auto;<br>\t<span class=\"hljs-attribute\">background-repeat</span>: no-repeat;<br>\t<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202202121406661.jpg</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果需要给整个背景增加背景模糊效果&#x2F;遮罩可以通过<code>::after</code>伪元素，即如下方式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.all</span><span class=\"hljs-selector-pseudo\">::after</span>&#123;<br>\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span>;<br>\t<span class=\"hljs-attribute\">position</span>: absolute;<br>\t<span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100vh</span>;<br>\t<span class=\"hljs-attribute\">overflow</span>: auto;<br>\t<span class=\"hljs-attribute\">background</span>: inherit;<br>\t<span class=\"hljs-attribute\">filter</span>: <span class=\"hljs-built_in\">blur</span>(<span class=\"hljs-number\">5px</span>);<br>\t<span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>\t<span class=\"hljs-attribute\">z-index</span>: <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-attribute\">background-color</span>: aliceblue;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"全局修改Page对象\"><a href=\"#全局修改Page对象\" class=\"headerlink\" title=\"全局修改Page对象\"></a>全局修改Page对象</h1><p>在app.js顶部增加如下代码</p>\n<blockquote>\n<p>可用作页面拦截&#x2F;或者给每个页面设置统一的附加函数</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>\t<span class=\"hljs-comment\">// 设置需要拦截的页面</span><br>\t<span class=\"hljs-keyword\">const</span> checkRouterPageList = [<span class=\"hljs-string\">&#x27;pages/explore/explore&#x27;</span>]<br>\t<span class=\"hljs-comment\">// 小程序原来的Page方法</span><br>\t<span class=\"hljs-keyword\">let</span> originalPage = <span class=\"hljs-title class_\">Page</span>;<br>\t<span class=\"hljs-comment\">// 我们自定义的Page方法</span><br>\t<span class=\"hljs-title class_\">Page</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">config</span>) =&gt;</span> &#123;<br>\t\t<span class=\"hljs-keyword\">let</span> originalLoadMethod = config.<span class=\"hljs-property\">onLoad</span>;<br>\t\tconfig.<span class=\"hljs-property\">onLoad</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">let</span> currentPageUrl = <span class=\"hljs-title function_\">getPageUrl</span>()<br>\t\t\t<span class=\"hljs-keyword\">if</span> (checkRouterPageList.<span class=\"hljs-title function_\">indexOf</span>(currentPageUrl)) &#123;<br>\t\t\t\t<span class=\"hljs-comment\">// 未登录时进行拦截</span><br>\t\t\t\t<span class=\"hljs-comment\">// wx.switchTab(&#123;</span><br>\t\t\t\t<span class=\"hljs-comment\">// url: &#x27;/pages/myinfo/myinfo&#x27;,</span><br>\t\t\t\t<span class=\"hljs-comment\">// &#125;)</span><br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (originalLoadMethod) &#123;<br>\t\t\t\toriginalLoadMethod.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, e)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// todo 在这里我们可以给配置对象进行加工</span><br>\t\t<span class=\"hljs-comment\">// 将配置对象继续想下传递给小程序原来的Page方法</span><br>\t\t<span class=\"hljs-title function_\">originalPage</span>(config);<br>\t&#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":4066,"excerpt":"","more":"<h1 id=\"微信小程序之页面拦截器\"><a href=\"#微信小程序之页面拦截器\" class=\"headerlink\" title=\"微信小程序之页面拦截器\"></a>微信小程序之页面拦截器</h1><h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><ol>\n<li>小程序有52个页面，其中13个页面无需任何身份，另外39个页面需要系统角色。对于这39个页面，如果微信用户没有系统角色，则跳转到登录页。</li>\n<li>是否有系统角色信息需要通过异步请求来获取。</li>\n</ol>\n<h3 id=\"需求分析-amp-实现\"><a href=\"#需求分析-amp-实现\" class=\"headerlink\" title=\"需求分析&amp;实现\"></a>需求分析&amp;实现</h3><p>对需求进行抽象，其实要的就是一个过滤器，对小程序页面的访问进行过滤，符合条件的通过，不符合条件进行其他处理。</p>\n<p>使用过php的laravel框架的童鞋，肯定一下子就联想到了laravel框架的http中间件:<br><code>HTTP 中间件提供一个方便的机制来过滤进入应用程序的 HTTP 请求，例如，Laravel 默认包含了一个中间件来检验用户身份验证，如果用户没有经过身份验证，中间件会将用户导向登录页面，然而，如果用户通过身份验证，中间件将会允许这个请求进一步继续前进。当然，除了身份验证之外，中间件也可以被用来执行各式各样的任务，CORS 中间件负责替所有即将离开程序的响应加入适当的响应头，一个日志中间件可以记录所有传入应用程序的请求。</code></p>\n<p>令人忧桑的是，微信小程序并没有提供针对Page实例的中间件机制。所以只能从Page实例的生命周期处下手。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000011044376\" alt=\"mina-lifecycle.png\" title=\"mina-lifecycle.png\"></p>\n<p>对于onLoad,一个页面只会调用一次；对于onShow,每次打开页面(比如小程序从后台转到前台)都会调用一次。</p>\n<p>在onLoad或者onShow钩子函数里，对用户身份进行校验，通过后则拉取该页面需要的数据，否则跳转到登录页。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//orderDetail.js</span><br><span class=\"hljs-attr\">onShow</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> that = <span class=\"hljs-variable language_\">this</span>;<br>    <span class=\"hljs-comment\">//身份校验</span><br>    service.<span class=\"hljs-title function_\">identityCheck</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-comment\">//跳转到登录页</span><br>          wx.<span class=\"hljs-title function_\">redirectTo</span>(&#123;<br>            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&quot;/pages/common/login/login&quot;</span><br>          &#125;);<br>        &#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;    <br>          <span class=\"hljs-comment\">//获取页面数据等等 </span><br>          that.<span class=\"hljs-title function_\">getDetail</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">orderId</span>);<br>          ...<br>        &#125;<br>   );<br>  &#125;,<br></code></pre></td></tr></table></figure>\n\n<p>不过，每个页面都要这样写，重复代码好多啊，侵入性也强。不如用装饰函数（高大上的说法是装饰者模式）来包装一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//filter.js</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">identityFilter</span>(<span class=\"hljs-params\">pageObj</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(pageObj.<span class=\"hljs-property\">onShow</span>)&#123;<br>        <span class=\"hljs-keyword\">let</span> _onShow = pageObj.<span class=\"hljs-property\">onShow</span>;<br>        pageObj.<span class=\"hljs-property\">onShow</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>            service.<span class=\"hljs-title function_\">identityCheck</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//跳转到登录页</span><br>                wx.<span class=\"hljs-title function_\">redirectTo</span>(&#123;<br>                    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&quot;/pages/common/login/login&quot;</span><br>                &#125;);<br>            &#125;,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//获取页面实例，防止this劫持</span><br>                <span class=\"hljs-keyword\">let</span> currentInstance = <span class=\"hljs-title function_\">getPageInstance</span>();<br>                _onShow.<span class=\"hljs-title function_\">call</span>(currentInstance);<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pageObj;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPageInstance</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">var</span> pages = <span class=\"hljs-title function_\">getCurrentPages</span>();<br>    <span class=\"hljs-keyword\">return</span>  pages[pages.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">identityFilter</span> = identityFilter;<br></code></pre></td></tr></table></figure>\n<p><code>filter.js</code>用以提供过滤器方法，除了现有的用户身份拦截，后续如果需要其他拦截，可以在这个文件增加。然后，在需要用户身份拦截的小程序页面代码里，用<code>filter.identityFilter</code>处理一下就可以了:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//orderDetail.js</span><br><span class=\"hljs-keyword\">let</span> filter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;filter.js&#x27;</span>);<br><span class=\"hljs-title class_\">Page</span>(filter.<span class=\"hljs-title function_\">identityFilter</span>(&#123;<br>    ...<br>    <span class=\"hljs-attr\">onShow</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">//获取页面数据等等</span><br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getDetail</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">orderId</span>);<br>        <span class=\"hljs-comment\">//...</span><br>    &#125;,<br>    ...<br>&#125;));<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用Promise进行优化\"><a href=\"#使用Promise进行优化\" class=\"headerlink\" title=\"使用Promise进行优化\"></a>使用Promise进行优化</h3><p>上面的实现中，每次访问页面，都会执行一次获取用户身份的方法（就是上面代码里的<code>service. identityCheck</code> ）。其实没有必要，在小程序启动的时候获取一次就行了。也就是说，放在app.js的onLaunch方法里执行。</p>\n<p>每个小程序页面实例化时，一般也会执行异步方法，用来获取页面需要的数据。关键在于，我们需要保证，<strong>页面的异步方法</strong> 必须在 <strong>获取用户身份的异步请求</strong> 之后执行。</p>\n<p>毋容置疑，Promise最擅长处理异步请求的执行顺序了。主子，快放代码粗来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//app.js</span><br><span class=\"hljs-title class_\">App</span>(&#123;<br>    <span class=\"hljs-attr\">onLaunch</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>            service.<span class=\"hljs-title function_\">identityCheck</span>(resolve,reject);<br>        &#125;);<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">globalData</span>.<span class=\"hljs-property\">promise</span> = p; <br>    &#125;,<br>    ...<br>    <span class=\"hljs-attr\">globalData</span>: &#123;<br>        <span class=\"hljs-attr\">promise</span>:<span class=\"hljs-literal\">null</span>,<br>    &#125;   <br>&#125;);<br><br><span class=\"hljs-comment\">//filter.js</span><br><span class=\"hljs-keyword\">const</span> appData = <span class=\"hljs-title function_\">getApp</span>().<span class=\"hljs-property\">globalData</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">identityFilter</span>(<span class=\"hljs-params\">pageObj</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(pageObj.<span class=\"hljs-property\">onShow</span>)&#123;<br>        <span class=\"hljs-keyword\">let</span> _onShow = pageObj.<span class=\"hljs-property\">onShow</span>;<br>        pageObj.<span class=\"hljs-property\">onShow</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>            <span class=\"hljs-comment\">//改动点</span><br>            appData.<span class=\"hljs-property\">promise</span>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//跳转到登录页</span><br>                wx.<span class=\"hljs-title function_\">redirectTo</span>(&#123;<br>                    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&quot;/pages/common/login/login&quot;</span><br>                &#125;);<br>            &#125;,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-comment\">//获取页面实例，防止this劫持</span><br>                <span class=\"hljs-keyword\">let</span> currentInstance = <span class=\"hljs-title function_\">getPageInstance</span>();<br>                _onShow.<span class=\"hljs-title function_\">call</span>(currentInstance);<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> pageObj;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>基本实现了小程序页面的用户身份拦截器，但是比起laravel的http中间件还是逊色一些：</p>\n<ol>\n<li>需要对每个页面代码包装一层。</li>\n<li>即使用户身份校验不通过，小程序也并不会阻塞页面的渲染。假如获取用户身份的异步方法一分钟才执行完，小程序页面还是会展示出来，一分钟之后才跳转到登录页。需要自己增加逻辑，比如在这一分钟内，页面展示空白内容。</li>\n</ol>\n<p>嗯，对小程序的新特性保持关注，后面看看怎么改进~</p>\n<h1 id=\"解决微信小程序background-attachment-fixed-在真机上无法生效\"><a href=\"#解决微信小程序background-attachment-fixed-在真机上无法生效\" class=\"headerlink\" title=\"解决微信小程序background-attachment: fixed;在真机上无法生效\"></a>解决微信小程序<code>background-attachment: fixed;</code>在真机上无法生效</h1><p>整个页面外包一个<code>view</code><br>对该<code>view</code>设置样式如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.all</span> &#123;<br>\t<span class=\"hljs-attribute\">background-size</span>: cover;<br>\t<span class=\"hljs-attribute\">background-position</span>: center;<br>\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100vh</span>;<br>\t<span class=\"hljs-attribute\">overflow</span>: auto;<br>\t<span class=\"hljs-attribute\">background-repeat</span>: no-repeat;<br>\t<span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202202121406661.jpg</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果需要给整个背景增加背景模糊效果&#x2F;遮罩可以通过<code>::after</code>伪元素，即如下方式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.all</span><span class=\"hljs-selector-pseudo\">::after</span>&#123;<br>\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span>;<br>\t<span class=\"hljs-attribute\">position</span>: absolute;<br>\t<span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100vh</span>;<br>\t<span class=\"hljs-attribute\">overflow</span>: auto;<br>\t<span class=\"hljs-attribute\">background</span>: inherit;<br>\t<span class=\"hljs-attribute\">filter</span>: <span class=\"hljs-built_in\">blur</span>(<span class=\"hljs-number\">5px</span>);<br>\t<span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>\t<span class=\"hljs-attribute\">z-index</span>: <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-attribute\">background-color</span>: aliceblue;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"全局修改Page对象\"><a href=\"#全局修改Page对象\" class=\"headerlink\" title=\"全局修改Page对象\"></a>全局修改Page对象</h1><p>在app.js顶部增加如下代码</p>\n<blockquote>\n<p>可用作页面拦截&#x2F;或者给每个页面设置统一的附加函数</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>\t<span class=\"hljs-comment\">// 设置需要拦截的页面</span><br>\t<span class=\"hljs-keyword\">const</span> checkRouterPageList = [<span class=\"hljs-string\">&#x27;pages/explore/explore&#x27;</span>]<br>\t<span class=\"hljs-comment\">// 小程序原来的Page方法</span><br>\t<span class=\"hljs-keyword\">let</span> originalPage = <span class=\"hljs-title class_\">Page</span>;<br>\t<span class=\"hljs-comment\">// 我们自定义的Page方法</span><br>\t<span class=\"hljs-title class_\">Page</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">config</span>) =&gt;</span> &#123;<br>\t\t<span class=\"hljs-keyword\">let</span> originalLoadMethod = config.<span class=\"hljs-property\">onLoad</span>;<br>\t\tconfig.<span class=\"hljs-property\">onLoad</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">let</span> currentPageUrl = <span class=\"hljs-title function_\">getPageUrl</span>()<br>\t\t\t<span class=\"hljs-keyword\">if</span> (checkRouterPageList.<span class=\"hljs-title function_\">indexOf</span>(currentPageUrl)) &#123;<br>\t\t\t\t<span class=\"hljs-comment\">// 未登录时进行拦截</span><br>\t\t\t\t<span class=\"hljs-comment\">// wx.switchTab(&#123;</span><br>\t\t\t\t<span class=\"hljs-comment\">// url: &#x27;/pages/myinfo/myinfo&#x27;,</span><br>\t\t\t\t<span class=\"hljs-comment\">// &#125;)</span><br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (originalLoadMethod) &#123;<br>\t\t\t\toriginalLoadMethod.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, e)<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// todo 在这里我们可以给配置对象进行加工</span><br>\t\t<span class=\"hljs-comment\">// 将配置对象继续想下传递给小程序原来的Page方法</span><br>\t\t<span class=\"hljs-title function_\">originalPage</span>(config);<br>\t&#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>"},{"title":"三亚旅游","date":"2022-04-08T15:35:27.000Z","description":"三亚的七日游","_content":"\n{% gi 11 3-2-3-3 %}\n\n![天空](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330074.jpeg)\n\n![南海观音](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082331874.jpeg)\n\n![IMG_2558](https://sunrise-luckyda.top/image/IMG_2558.jpeg)\n\n![我](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330450.JPG)\n\n![IMG_2803](https://sunrise-luckyda.top/image/IMG_2803.jpeg)\n\n![IMG_2674](https://sunrise-luckyda.top/image/IMG_2674.jpeg)\n\n![IMG_2728](https://sunrise-luckyda.top/image/IMG_2728.jpeg)\n\n![IMG_2801](https://sunrise-luckyda.top/image/IMG_2801.jpeg)\n\n![IMG_2802](https://sunrise-luckyda.top/image/IMG_2802.jpeg)\n\n![IMG_2842](https://sunrise-luckyda.top/image/IMG_2842.jpeg)\n\n![IMG_2859](https://sunrise-luckyda.top/image/IMG_2859.jpeg)\n\n{% endgi %}","source":"_posts/旅游/三亚.md","raw":"---\ntitle: 三亚旅游\ndate: 2022-04-08 23:35:27\ntags:\n  - [三亚]\n  - [旅行]\ncategories:\n  - [生活]\ndescription: 三亚的七日游\n---\n\n{% gi 11 3-2-3-3 %}\n\n![天空](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330074.jpeg)\n\n![南海观音](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082331874.jpeg)\n\n![IMG_2558](https://sunrise-luckyda.top/image/IMG_2558.jpeg)\n\n![我](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330450.JPG)\n\n![IMG_2803](https://sunrise-luckyda.top/image/IMG_2803.jpeg)\n\n![IMG_2674](https://sunrise-luckyda.top/image/IMG_2674.jpeg)\n\n![IMG_2728](https://sunrise-luckyda.top/image/IMG_2728.jpeg)\n\n![IMG_2801](https://sunrise-luckyda.top/image/IMG_2801.jpeg)\n\n![IMG_2802](https://sunrise-luckyda.top/image/IMG_2802.jpeg)\n\n![IMG_2842](https://sunrise-luckyda.top/image/IMG_2842.jpeg)\n\n![IMG_2859](https://sunrise-luckyda.top/image/IMG_2859.jpeg)\n\n{% endgi %}","slug":"旅游/三亚","published":1,"updated":"2022-08-28T07:38:59.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2f003uscvm86zhf5bf","content":"<div class=\"group-image-container\"><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330074.jpeg\" alt=\"天空\"></div><div class=\"group-image-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082331874.jpeg\" alt=\"南海观音\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2558.jpeg\" alt=\"IMG_2558\"></div></div><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330450.JPG\" alt=\"我\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2803.jpeg\" alt=\"IMG_2803\"></div></div><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2674.jpeg\" alt=\"IMG_2674\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2728.jpeg\" alt=\"IMG_2728\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2801.jpeg\" alt=\"IMG_2801\"></div></div><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2802.jpeg\" alt=\"IMG_2802\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2842.jpeg\" alt=\"IMG_2842\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2859.jpeg\" alt=\"IMG_2859\"></div></div></div>","site":{"data":{}},"wordcount":0,"excerpt":"","more":"<div class=\"group-image-container\"><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330074.jpeg\" alt=\"天空\"></div><div class=\"group-image-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082331874.jpeg\" alt=\"南海观音\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2558.jpeg\" alt=\"IMG_2558\"></div></div><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204082330450.JPG\" alt=\"我\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2803.jpeg\" alt=\"IMG_2803\"></div></div><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2674.jpeg\" alt=\"IMG_2674\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2728.jpeg\" alt=\"IMG_2728\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2801.jpeg\" alt=\"IMG_2801\"></div></div><div class=\"group-image-row\"><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2802.jpeg\" alt=\"IMG_2802\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2842.jpeg\" alt=\"IMG_2842\"></div><div class=\"group-image-wrap\"><img src=\"https://sunrise-luckyda.top/image/IMG_2859.jpeg\" alt=\"IMG_2859\"></div></div></div>"},{"title":"模型调优-删除异常值（箱型图）","date":"2022-04-06T12:30:27.000Z","description":"Python做数据分析","_content":"\n## 1.箱线图\n\n**箱形图**（Box plot），是一种用作显示一组数据分散情况资料的[统计图](https://zh.wikipedia.org/wiki/统计图)。\n\n![箱型图](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071304169.png)\n\n箱线图可以深入了解数据的分布特性，上图说明了箱线图的不同特征。\n\n其中**非异常值最常见的定义是[Q1 - 1.5xIQR, Q3 + 1.5xIQR]**，如果是区间外的值就被视为outlier并显示在图上。\n\n- Q1：第一四分位数\n- median：是中位数\n- Q3：第三四分位数\n- IQR：四分位间距\n\n## 2.随机生成数据\n\n- 随机生成一组以正态分布均值等于10的数据\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n# 解决中文乱码问题\nplt.rcParams['font.sans-serif'] = ['Simhei']\n\ndata = np.random.normal(loc = 10, scale = 1, size = 1000)\nsns.distplot(data, bins=100, color='r')\n```\n\n如下图：正态的标准化直方图于密度估计\n\n![正态分布直方图](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071305649.png)\n\n## 3.寻找异常值\n\n- 找到异常值所在范围：`[Q1 - 1.5 x IQR, Q3 + 1.5 x IQR]`\n- 直接使用`matplotlib.pyplot.boxplot`的返回值whiskers获取两极端的非异常数据点\n- 绘图后获取它们，当绘制箱线图完成时，使用`get_ydata()`方法\n- 它的返回值返回一个二维数组，第二个元素就是我们想要的值（上边缘和下边缘）\n\n```python\nfig = plt.figure(figsize=(10,8))\nax1 = fig.add_subplot(1,2,1)\nbp = ax1.boxplot(data)\n\nlower_whisker = [item.get_ydata()[1] for item in bp['whiskers']][0]\nupper_whisker = [item.get_ydata()[1] for item in bp['whiskers']][1]\nprint(\"上边缘：\", upper_whisker)\nprint(\"下边缘：\", lower_whisker)\nprint(\"非异常范围：\", [lower_whisker,upper_whisker])\n\n##### 寻找异常值 #####\noutlier = data[(data < lower_whisker) | (data > upper_whisker)]\nprint(\"异常值（离散值）：\", outlier)\n\"\"\"\n上边缘： 12.610201767794644\n下边缘： 7.4427962773205625\n非异常范围： [7.4427962773205625, 12.610201767794644]\n异常值（离散值）： [13.10837006  7.14081742 12.71635149 12.66670042  7.25470382  6.8162954 7.05752588]\n\"\"\"\n```\n\n## 4.删除异常值\n\n```python\n##### 删除异常值 ######\nnot_outlier = data[(data > lower_whisker) & (data < upper_whisker)]\n\n##### 重新检查是否还有异常值 #####\nax2 = fig.add_subplot(1,2,2,sharey =ax1)\nax2.boxplot(not_outlier,\n            boxprops={'color':'red'},\n            #设置上下边缘的显示样式\n            capprops={'color':'green', 'lw':4, 'ls':'--'},\n            #设置异常值的显示样式\n            flierprops={'marker':'*', 'markersize': 8})\nax1.set_xlabel('删除异常值前')\nax2.set_xlabel('删除异常值后')\n```\n\n![删除异常值前后对比](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071306550.png)\n\n## 总结\n\n上面的例子以一维数组展开操作，如果你的是二维数组，你想解决这类问题或者有多个箱线图，想批量删除异常值该怎么做，可以参考最后附上的相关参考，希望对你有所帮助。\n\n","source":"_posts/数据分析/模型调优 - 删除异常值（箱线图）.md","raw":"---\ntitle: 模型调优-删除异常值（箱型图）\ndate: 2022-04-06 20:30:27\ntags:\n  - [数据分析]\n  - [python]\ncategories:\n  - [技术]\ndescription: Python做数据分析\n---\n\n## 1.箱线图\n\n**箱形图**（Box plot），是一种用作显示一组数据分散情况资料的[统计图](https://zh.wikipedia.org/wiki/统计图)。\n\n![箱型图](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071304169.png)\n\n箱线图可以深入了解数据的分布特性，上图说明了箱线图的不同特征。\n\n其中**非异常值最常见的定义是[Q1 - 1.5xIQR, Q3 + 1.5xIQR]**，如果是区间外的值就被视为outlier并显示在图上。\n\n- Q1：第一四分位数\n- median：是中位数\n- Q3：第三四分位数\n- IQR：四分位间距\n\n## 2.随机生成数据\n\n- 随机生成一组以正态分布均值等于10的数据\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n# 解决中文乱码问题\nplt.rcParams['font.sans-serif'] = ['Simhei']\n\ndata = np.random.normal(loc = 10, scale = 1, size = 1000)\nsns.distplot(data, bins=100, color='r')\n```\n\n如下图：正态的标准化直方图于密度估计\n\n![正态分布直方图](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071305649.png)\n\n## 3.寻找异常值\n\n- 找到异常值所在范围：`[Q1 - 1.5 x IQR, Q3 + 1.5 x IQR]`\n- 直接使用`matplotlib.pyplot.boxplot`的返回值whiskers获取两极端的非异常数据点\n- 绘图后获取它们，当绘制箱线图完成时，使用`get_ydata()`方法\n- 它的返回值返回一个二维数组，第二个元素就是我们想要的值（上边缘和下边缘）\n\n```python\nfig = plt.figure(figsize=(10,8))\nax1 = fig.add_subplot(1,2,1)\nbp = ax1.boxplot(data)\n\nlower_whisker = [item.get_ydata()[1] for item in bp['whiskers']][0]\nupper_whisker = [item.get_ydata()[1] for item in bp['whiskers']][1]\nprint(\"上边缘：\", upper_whisker)\nprint(\"下边缘：\", lower_whisker)\nprint(\"非异常范围：\", [lower_whisker,upper_whisker])\n\n##### 寻找异常值 #####\noutlier = data[(data < lower_whisker) | (data > upper_whisker)]\nprint(\"异常值（离散值）：\", outlier)\n\"\"\"\n上边缘： 12.610201767794644\n下边缘： 7.4427962773205625\n非异常范围： [7.4427962773205625, 12.610201767794644]\n异常值（离散值）： [13.10837006  7.14081742 12.71635149 12.66670042  7.25470382  6.8162954 7.05752588]\n\"\"\"\n```\n\n## 4.删除异常值\n\n```python\n##### 删除异常值 ######\nnot_outlier = data[(data > lower_whisker) & (data < upper_whisker)]\n\n##### 重新检查是否还有异常值 #####\nax2 = fig.add_subplot(1,2,2,sharey =ax1)\nax2.boxplot(not_outlier,\n            boxprops={'color':'red'},\n            #设置上下边缘的显示样式\n            capprops={'color':'green', 'lw':4, 'ls':'--'},\n            #设置异常值的显示样式\n            flierprops={'marker':'*', 'markersize': 8})\nax1.set_xlabel('删除异常值前')\nax2.set_xlabel('删除异常值后')\n```\n\n![删除异常值前后对比](https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071306550.png)\n\n## 总结\n\n上面的例子以一维数组展开操作，如果你的是二维数组，你想解决这类问题或者有多个箱线图，想批量删除异常值该怎么做，可以参考最后附上的相关参考，希望对你有所帮助。\n\n","slug":"数据分析/模型调优 - 删除异常值（箱线图）","published":1,"updated":"2022-08-28T07:38:59.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2f003xscvmd82p7eil","content":"<h2 id=\"1-箱线图\"><a href=\"#1-箱线图\" class=\"headerlink\" title=\"1.箱线图\"></a>1.箱线图</h2><p><strong>箱形图</strong>（Box plot），是一种用作显示一组数据分散情况资料的<a href=\"https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%9B%BE\">统计图</a>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071304169.png\" alt=\"箱型图\"></p>\n<p>箱线图可以深入了解数据的分布特性，上图说明了箱线图的不同特征。</p>\n<p>其中**非异常值最常见的定义是[Q1 - 1.5xIQR, Q3 + 1.5xIQR]**，如果是区间外的值就被视为outlier并显示在图上。</p>\n<ul>\n<li>Q1：第一四分位数</li>\n<li>median：是中位数</li>\n<li>Q3：第三四分位数</li>\n<li>IQR：四分位间距</li>\n</ul>\n<h2 id=\"2-随机生成数据\"><a href=\"#2-随机生成数据\" class=\"headerlink\" title=\"2.随机生成数据\"></a>2.随机生成数据</h2><ul>\n<li>随机生成一组以正态分布均值等于10的数据</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns<br><span class=\"hljs-comment\"># 解决中文乱码问题</span><br>plt.rcParams[<span class=\"hljs-string\">&#x27;font.sans-serif&#x27;</span>] = [<span class=\"hljs-string\">&#x27;Simhei&#x27;</span>]<br><br>data = np.random.normal(loc = <span class=\"hljs-number\">10</span>, scale = <span class=\"hljs-number\">1</span>, size = <span class=\"hljs-number\">1000</span>)<br>sns.distplot(data, bins=<span class=\"hljs-number\">100</span>, color=<span class=\"hljs-string\">&#x27;r&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如下图：正态的标准化直方图于密度估计</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071305649.png\" alt=\"正态分布直方图\"></p>\n<h2 id=\"3-寻找异常值\"><a href=\"#3-寻找异常值\" class=\"headerlink\" title=\"3.寻找异常值\"></a>3.寻找异常值</h2><ul>\n<li>找到异常值所在范围：<code>[Q1 - 1.5 x IQR, Q3 + 1.5 x IQR]</code></li>\n<li>直接使用<code>matplotlib.pyplot.boxplot</code>的返回值whiskers获取两极端的非异常数据点</li>\n<li>绘图后获取它们，当绘制箱线图完成时，使用<code>get_ydata()</code>方法</li>\n<li>它的返回值返回一个二维数组，第二个元素就是我们想要的值（上边缘和下边缘）</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fig = plt.figure(figsize=(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">8</span>))<br>ax1 = fig.add_subplot(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>)<br>bp = ax1.boxplot(data)<br><br>lower_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">0</span>]<br>upper_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">1</span>]<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;上边缘：&quot;</span>, upper_whisker)<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;下边缘：&quot;</span>, lower_whisker)<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;非异常范围：&quot;</span>, [lower_whisker,upper_whisker])<br><br><span class=\"hljs-comment\">##### 寻找异常值 #####</span><br>outlier = data[(data &lt; lower_whisker) | (data &gt; upper_whisker)]<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;异常值（离散值）：&quot;</span>, outlier)<br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">上边缘： 12.610201767794644</span><br><span class=\"hljs-string\">下边缘： 7.4427962773205625</span><br><span class=\"hljs-string\">非异常范围： [7.4427962773205625, 12.610201767794644]</span><br><span class=\"hljs-string\">异常值（离散值）： [13.10837006  7.14081742 12.71635149 12.66670042  7.25470382  6.8162954 7.05752588]</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-删除异常值\"><a href=\"#4-删除异常值\" class=\"headerlink\" title=\"4.删除异常值\"></a>4.删除异常值</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">##### 删除异常值 ######</span><br>not_outlier = data[(data &gt; lower_whisker) &amp; (data &lt; upper_whisker)]<br><br><span class=\"hljs-comment\">##### 重新检查是否还有异常值 #####</span><br>ax2 = fig.add_subplot(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>,sharey =ax1)<br>ax2.boxplot(not_outlier,<br>            boxprops=&#123;<span class=\"hljs-string\">&#x27;color&#x27;</span>:<span class=\"hljs-string\">&#x27;red&#x27;</span>&#125;,<br>            <span class=\"hljs-comment\">#设置上下边缘的显示样式</span><br>            capprops=&#123;<span class=\"hljs-string\">&#x27;color&#x27;</span>:<span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;lw&#x27;</span>:<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ls&#x27;</span>:<span class=\"hljs-string\">&#x27;--&#x27;</span>&#125;,<br>            <span class=\"hljs-comment\">#设置异常值的显示样式</span><br>            flierprops=&#123;<span class=\"hljs-string\">&#x27;marker&#x27;</span>:<span class=\"hljs-string\">&#x27;*&#x27;</span>, <span class=\"hljs-string\">&#x27;markersize&#x27;</span>: <span class=\"hljs-number\">8</span>&#125;)<br>ax1.set_xlabel(<span class=\"hljs-string\">&#x27;删除异常值前&#x27;</span>)<br>ax2.set_xlabel(<span class=\"hljs-string\">&#x27;删除异常值后&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071306550.png\" alt=\"删除异常值前后对比\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面的例子以一维数组展开操作，如果你的是二维数组，你想解决这类问题或者有多个箱线图，想批量删除异常值该怎么做，可以参考最后附上的相关参考，希望对你有所帮助。</p>\n","site":{"data":{}},"wordcount":1933,"excerpt":"","more":"<h2 id=\"1-箱线图\"><a href=\"#1-箱线图\" class=\"headerlink\" title=\"1.箱线图\"></a>1.箱线图</h2><p><strong>箱形图</strong>（Box plot），是一种用作显示一组数据分散情况资料的<a href=\"https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%9B%BE\">统计图</a>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071304169.png\" alt=\"箱型图\"></p>\n<p>箱线图可以深入了解数据的分布特性，上图说明了箱线图的不同特征。</p>\n<p>其中**非异常值最常见的定义是[Q1 - 1.5xIQR, Q3 + 1.5xIQR]**，如果是区间外的值就被视为outlier并显示在图上。</p>\n<ul>\n<li>Q1：第一四分位数</li>\n<li>median：是中位数</li>\n<li>Q3：第三四分位数</li>\n<li>IQR：四分位间距</li>\n</ul>\n<h2 id=\"2-随机生成数据\"><a href=\"#2-随机生成数据\" class=\"headerlink\" title=\"2.随机生成数据\"></a>2.随机生成数据</h2><ul>\n<li>随机生成一组以正态分布均值等于10的数据</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt<br><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns<br><span class=\"hljs-comment\"># 解决中文乱码问题</span><br>plt.rcParams[<span class=\"hljs-string\">&#x27;font.sans-serif&#x27;</span>] = [<span class=\"hljs-string\">&#x27;Simhei&#x27;</span>]<br><br>data = np.random.normal(loc = <span class=\"hljs-number\">10</span>, scale = <span class=\"hljs-number\">1</span>, size = <span class=\"hljs-number\">1000</span>)<br>sns.distplot(data, bins=<span class=\"hljs-number\">100</span>, color=<span class=\"hljs-string\">&#x27;r&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如下图：正态的标准化直方图于密度估计</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071305649.png\" alt=\"正态分布直方图\"></p>\n<h2 id=\"3-寻找异常值\"><a href=\"#3-寻找异常值\" class=\"headerlink\" title=\"3.寻找异常值\"></a>3.寻找异常值</h2><ul>\n<li>找到异常值所在范围：<code>[Q1 - 1.5 x IQR, Q3 + 1.5 x IQR]</code></li>\n<li>直接使用<code>matplotlib.pyplot.boxplot</code>的返回值whiskers获取两极端的非异常数据点</li>\n<li>绘图后获取它们，当绘制箱线图完成时，使用<code>get_ydata()</code>方法</li>\n<li>它的返回值返回一个二维数组，第二个元素就是我们想要的值（上边缘和下边缘）</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fig = plt.figure(figsize=(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">8</span>))<br>ax1 = fig.add_subplot(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>)<br>bp = ax1.boxplot(data)<br><br>lower_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">0</span>]<br>upper_whisker = [item.get_ydata()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> bp[<span class=\"hljs-string\">&#x27;whiskers&#x27;</span>]][<span class=\"hljs-number\">1</span>]<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;上边缘：&quot;</span>, upper_whisker)<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;下边缘：&quot;</span>, lower_whisker)<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;非异常范围：&quot;</span>, [lower_whisker,upper_whisker])<br><br><span class=\"hljs-comment\">##### 寻找异常值 #####</span><br>outlier = data[(data &lt; lower_whisker) | (data &gt; upper_whisker)]<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;异常值（离散值）：&quot;</span>, outlier)<br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">上边缘： 12.610201767794644</span><br><span class=\"hljs-string\">下边缘： 7.4427962773205625</span><br><span class=\"hljs-string\">非异常范围： [7.4427962773205625, 12.610201767794644]</span><br><span class=\"hljs-string\">异常值（离散值）： [13.10837006  7.14081742 12.71635149 12.66670042  7.25470382  6.8162954 7.05752588]</span><br><span class=\"hljs-string\">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-删除异常值\"><a href=\"#4-删除异常值\" class=\"headerlink\" title=\"4.删除异常值\"></a>4.删除异常值</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">##### 删除异常值 ######</span><br>not_outlier = data[(data &gt; lower_whisker) &amp; (data &lt; upper_whisker)]<br><br><span class=\"hljs-comment\">##### 重新检查是否还有异常值 #####</span><br>ax2 = fig.add_subplot(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>,sharey =ax1)<br>ax2.boxplot(not_outlier,<br>            boxprops=&#123;<span class=\"hljs-string\">&#x27;color&#x27;</span>:<span class=\"hljs-string\">&#x27;red&#x27;</span>&#125;,<br>            <span class=\"hljs-comment\">#设置上下边缘的显示样式</span><br>            capprops=&#123;<span class=\"hljs-string\">&#x27;color&#x27;</span>:<span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;lw&#x27;</span>:<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ls&#x27;</span>:<span class=\"hljs-string\">&#x27;--&#x27;</span>&#125;,<br>            <span class=\"hljs-comment\">#设置异常值的显示样式</span><br>            flierprops=&#123;<span class=\"hljs-string\">&#x27;marker&#x27;</span>:<span class=\"hljs-string\">&#x27;*&#x27;</span>, <span class=\"hljs-string\">&#x27;markersize&#x27;</span>: <span class=\"hljs-number\">8</span>&#125;)<br>ax1.set_xlabel(<span class=\"hljs-string\">&#x27;删除异常值前&#x27;</span>)<br>ax2.set_xlabel(<span class=\"hljs-string\">&#x27;删除异常值后&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202204071306550.png\" alt=\"删除异常值前后对比\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面的例子以一维数组展开操作，如果你的是二维数组，你想解决这类问题或者有多个箱线图，想批量删除异常值该怎么做，可以参考最后附上的相关参考，希望对你有所帮助。</p>\n"},{"title":"SSH 三步解决免密登录","date":"2022-04-25T16:31:27.000Z","description":"SSH 三步解决免密登录","_content":"\n# SSH 三步解决免密登录\n\n> [原文链接](https://blog.csdn.net/jeikerxiao/article/details/84105529)\n\n## 客户端生成公私钥\n\n本地客户端生成公私钥：（一路回车默认即可）\n\n```sh\nssh-keygen\n```\n\n上面这个命令会在用户目录.ssh文件夹下创建公私钥\n\n```sh\ncd ~/.ssh\nls\n```\n\n对应下会多出两个密钥：\n\nid_rsa （私钥）\n\nid_rsa.pub (公钥)\n\n## 上传公钥到服务器\n\n这里测试用的服务器地址为：192.168.235.22\n用户为：root\n\n```sh\nssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.235.22\n```\n\n上面这条命令是写到服务器上的ssh目录下去了\n\n```sh\ncd ~/.ssh\nvim authorized_keys\n```\n\n可以看到客户端写入到服务器的 id_rsa.pub （公钥）内容。\n\n## 测试免密登录\n\n客户端通过ssh连接远程服务器，就可以免密登录了。\n\n```sh\nssh root@192.168.235.22\n```","source":"_posts/服务器/免密登录服务器.md","raw":"---\ntitle: SSH 三步解决免密登录\ndate: 2022-04-26 00:31:27\ntags:\n  - [SSH]\n  - [服务器]\ncategories:\n  - [技术]\ndescription: SSH 三步解决免密登录\n---\n\n# SSH 三步解决免密登录\n\n> [原文链接](https://blog.csdn.net/jeikerxiao/article/details/84105529)\n\n## 客户端生成公私钥\n\n本地客户端生成公私钥：（一路回车默认即可）\n\n```sh\nssh-keygen\n```\n\n上面这个命令会在用户目录.ssh文件夹下创建公私钥\n\n```sh\ncd ~/.ssh\nls\n```\n\n对应下会多出两个密钥：\n\nid_rsa （私钥）\n\nid_rsa.pub (公钥)\n\n## 上传公钥到服务器\n\n这里测试用的服务器地址为：192.168.235.22\n用户为：root\n\n```sh\nssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.235.22\n```\n\n上面这条命令是写到服务器上的ssh目录下去了\n\n```sh\ncd ~/.ssh\nvim authorized_keys\n```\n\n可以看到客户端写入到服务器的 id_rsa.pub （公钥）内容。\n\n## 测试免密登录\n\n客户端通过ssh连接远程服务器，就可以免密登录了。\n\n```sh\nssh root@192.168.235.22\n```","slug":"服务器/免密登录服务器","published":1,"updated":"2022-08-28T07:38:59.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2g0041scvm8it50wio","content":"<h1 id=\"SSH-三步解决免密登录\"><a href=\"#SSH-三步解决免密登录\" class=\"headerlink\" title=\"SSH 三步解决免密登录\"></a>SSH 三步解决免密登录</h1><blockquote>\n<p><a href=\"https://blog.csdn.net/jeikerxiao/article/details/84105529\">原文链接</a></p>\n</blockquote>\n<h2 id=\"客户端生成公私钥\"><a href=\"#客户端生成公私钥\" class=\"headerlink\" title=\"客户端生成公私钥\"></a>客户端生成公私钥</h2><p>本地客户端生成公私钥：（一路回车默认即可）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs sh\">ssh-keygen<br></code></pre></td></tr></table></figure>\n\n<p>上面这个命令会在用户目录.ssh文件夹下创建公私钥</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">cd</span> ~/.ssh<br><span class=\"hljs-built_in\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>对应下会多出两个密钥：</p>\n<p>id_rsa （私钥）</p>\n<p>id_rsa.pub (公钥)</p>\n<h2 id=\"上传公钥到服务器\"><a href=\"#上传公钥到服务器\" class=\"headerlink\" title=\"上传公钥到服务器\"></a>上传公钥到服务器</h2><p>这里测试用的服务器地址为：192.168.235.22<br>用户为：root</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.235.22<br></code></pre></td></tr></table></figure>\n\n<p>上面这条命令是写到服务器上的ssh目录下去了</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">cd</span> ~/.ssh<br>vim authorized_keys<br></code></pre></td></tr></table></figure>\n\n<p>可以看到客户端写入到服务器的 id_rsa.pub （公钥）内容。</p>\n<h2 id=\"测试免密登录\"><a href=\"#测试免密登录\" class=\"headerlink\" title=\"测试免密登录\"></a>测试免密登录</h2><p>客户端通过ssh连接远程服务器，就可以免密登录了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">ssh root@192.168.235.22<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":355,"excerpt":"","more":"<h1 id=\"SSH-三步解决免密登录\"><a href=\"#SSH-三步解决免密登录\" class=\"headerlink\" title=\"SSH 三步解决免密登录\"></a>SSH 三步解决免密登录</h1><blockquote>\n<p><a href=\"https://blog.csdn.net/jeikerxiao/article/details/84105529\">原文链接</a></p>\n</blockquote>\n<h2 id=\"客户端生成公私钥\"><a href=\"#客户端生成公私钥\" class=\"headerlink\" title=\"客户端生成公私钥\"></a>客户端生成公私钥</h2><p>本地客户端生成公私钥：（一路回车默认即可）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">ssh-keygen<br></code></pre></td></tr></table></figure>\n\n<p>上面这个命令会在用户目录.ssh文件夹下创建公私钥</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">cd</span> ~/.ssh<br><span class=\"hljs-built_in\">ls</span><br></code></pre></td></tr></table></figure>\n\n<p>对应下会多出两个密钥：</p>\n<p>id_rsa （私钥）</p>\n<p>id_rsa.pub (公钥)</p>\n<h2 id=\"上传公钥到服务器\"><a href=\"#上传公钥到服务器\" class=\"headerlink\" title=\"上传公钥到服务器\"></a>上传公钥到服务器</h2><p>这里测试用的服务器地址为：192.168.235.22<br>用户为：root</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.235.22<br></code></pre></td></tr></table></figure>\n\n<p>上面这条命令是写到服务器上的ssh目录下去了</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">cd</span> ~/.ssh<br>vim authorized_keys<br></code></pre></td></tr></table></figure>\n\n<p>可以看到客户端写入到服务器的 id_rsa.pub （公钥）内容。</p>\n<h2 id=\"测试免密登录\"><a href=\"#测试免密登录\" class=\"headerlink\" title=\"测试免密登录\"></a>测试免密登录</h2><p>客户端通过ssh连接远程服务器，就可以免密登录了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">ssh root@192.168.235.22<br></code></pre></td></tr></table></figure>"},{"title":"mitmproxy","date":"2022-04-05T07:15:27.000Z","description":"爬虫相关文档","_content":"\n\n\n# 工具：mitmproxy\n\n> 官网地址：https://mitmproxy.org\n\n# 操作步骤\n## 1.安装\n**MAC：**\n```shell\nbrew install mitmproxy\n```\n**MAC/WINDOWS/LINUX**\n```shell\npip install mitmproxy\n```\n## 2.开启监测\n开启mitmproxy的设备：\n```shell\nmitmproxy -p 端口号\n```\n有三种方式可以开启mitmproxy监测\n-   **mitmproxy** 终端可交互界面\n-   **mitmweb** 浏览器版GUI可交互界面\n-   **mitmdump** 终端输出（不可交互）\n## 3.网络环境配置\n> 被监测的设备（一般是你的手机）和开启mitmproxy的设备（一般是电脑）要在同一片局域网内。\n\n手机进入局域网后（可以通过连接热点）后 ，在热点模块里开启自定义代理，端口号指定同开启mitmproxy服务时确定的端口号。\n\n**手机（此处IOS举例）具体操作：**\nSettings=>WLAN=>局域网网络（一般也就是你的热点）右侧感叹号=>Configure Proxy=>Manaul（填入你开启mitmproxy监测服务的设备的ip以及端口号）\n\n此时访问任何站点由于没有证书，都会显示证书不可信任\n接下来访问(http://mitm.it) 下载配置文件（此处一定要先进入开启mitmproxy的设备所在局域网并且设置好代理后才可以正常访问这个站点！）。\n\n在设置里下载证书\n**Settings=>General=>VPN&DeviceManagement=>mitmproxy=>Install**\n\n启用证书（注意，下载证书还不够！一定要开启！）\n**Settings=>General=>About=>Certificate Trust Settings=>开启mitmproxy**\n\n之后访问网站就会正常，同时电脑终端也可以看到请求\n如果要针对不同请求做不同处理/记录日志，则可以通过python脚本的方式\n\n**脚本范例：**\n```python\n#addon.py\n\nfrom mitmproxy import http\n\ndef request(flow: http.HTTPFlow):\n    # redirect to different host\n    if flow.request.pretty_host == \"example.com\":\n        flow.request.host = \"mitmproxy.org\"\n    # answer from proxy\n    elif flow.request.path.endswith(\"/brew\"):\n    \tflow.response = http.HTTPResponse.make(\n            418, **b**\"I'm a teapot\",\n        )\n```\n\n启动方式：\n```shell\nmitmproxy -s ./app.py\n```","source":"_posts/爬虫/mitmproxy.md","raw":"---\ntitle: mitmproxy\ndate: 2022-04-05 15:15:27\ntags:\n  - [python]\n  - [爬虫]\ncategories:\n  - [技术]\ndescription: 爬虫相关文档\n---\n\n\n\n# 工具：mitmproxy\n\n> 官网地址：https://mitmproxy.org\n\n# 操作步骤\n## 1.安装\n**MAC：**\n```shell\nbrew install mitmproxy\n```\n**MAC/WINDOWS/LINUX**\n```shell\npip install mitmproxy\n```\n## 2.开启监测\n开启mitmproxy的设备：\n```shell\nmitmproxy -p 端口号\n```\n有三种方式可以开启mitmproxy监测\n-   **mitmproxy** 终端可交互界面\n-   **mitmweb** 浏览器版GUI可交互界面\n-   **mitmdump** 终端输出（不可交互）\n## 3.网络环境配置\n> 被监测的设备（一般是你的手机）和开启mitmproxy的设备（一般是电脑）要在同一片局域网内。\n\n手机进入局域网后（可以通过连接热点）后 ，在热点模块里开启自定义代理，端口号指定同开启mitmproxy服务时确定的端口号。\n\n**手机（此处IOS举例）具体操作：**\nSettings=>WLAN=>局域网网络（一般也就是你的热点）右侧感叹号=>Configure Proxy=>Manaul（填入你开启mitmproxy监测服务的设备的ip以及端口号）\n\n此时访问任何站点由于没有证书，都会显示证书不可信任\n接下来访问(http://mitm.it) 下载配置文件（此处一定要先进入开启mitmproxy的设备所在局域网并且设置好代理后才可以正常访问这个站点！）。\n\n在设置里下载证书\n**Settings=>General=>VPN&DeviceManagement=>mitmproxy=>Install**\n\n启用证书（注意，下载证书还不够！一定要开启！）\n**Settings=>General=>About=>Certificate Trust Settings=>开启mitmproxy**\n\n之后访问网站就会正常，同时电脑终端也可以看到请求\n如果要针对不同请求做不同处理/记录日志，则可以通过python脚本的方式\n\n**脚本范例：**\n```python\n#addon.py\n\nfrom mitmproxy import http\n\ndef request(flow: http.HTTPFlow):\n    # redirect to different host\n    if flow.request.pretty_host == \"example.com\":\n        flow.request.host = \"mitmproxy.org\"\n    # answer from proxy\n    elif flow.request.path.endswith(\"/brew\"):\n    \tflow.response = http.HTTPResponse.make(\n            418, **b**\"I'm a teapot\",\n        )\n```\n\n启动方式：\n```shell\nmitmproxy -s ./app.py\n```","slug":"爬虫/mitmproxy","published":1,"updated":"2022-08-28T07:38:59.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2h0045scvm092adh7z","content":"<h1 id=\"工具：mitmproxy\"><a href=\"#工具：mitmproxy\" class=\"headerlink\" title=\"工具：mitmproxy\"></a>工具：mitmproxy</h1><blockquote>\n<p>官网地址：<a href=\"https://mitmproxy.org/\">https://mitmproxy.org</a></p>\n</blockquote>\n<h1 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h1><h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h2><p><strong>MAC：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs shell\">brew install mitmproxy<br></code></pre></td></tr></table></figure>\n<p><strong>MAC&#x2F;WINDOWS&#x2F;LINUX</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">pip install mitmproxy<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-开启监测\"><a href=\"#2-开启监测\" class=\"headerlink\" title=\"2.开启监测\"></a>2.开启监测</h2><p>开启mitmproxy的设备：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mitmproxy -p 端口号<br></code></pre></td></tr></table></figure>\n<p>有三种方式可以开启mitmproxy监测</p>\n<ul>\n<li><strong>mitmproxy</strong> 终端可交互界面</li>\n<li><strong>mitmweb</strong> 浏览器版GUI可交互界面</li>\n<li><strong>mitmdump</strong> 终端输出（不可交互）<h2 id=\"3-网络环境配置\"><a href=\"#3-网络环境配置\" class=\"headerlink\" title=\"3.网络环境配置\"></a>3.网络环境配置</h2><blockquote>\n<p>被监测的设备（一般是你的手机）和开启mitmproxy的设备（一般是电脑）要在同一片局域网内。</p>\n</blockquote>\n</li>\n</ul>\n<p>手机进入局域网后（可以通过连接热点）后 ，在热点模块里开启自定义代理，端口号指定同开启mitmproxy服务时确定的端口号。</p>\n<p><strong>手机（此处IOS举例）具体操作：</strong><br>Settings&#x3D;&gt;WLAN&#x3D;&gt;局域网网络（一般也就是你的热点）右侧感叹号&#x3D;&gt;Configure Proxy&#x3D;&gt;Manaul（填入你开启mitmproxy监测服务的设备的ip以及端口号）</p>\n<p>此时访问任何站点由于没有证书，都会显示证书不可信任<br>接下来访问(<a href=\"http://mitm.it/\">http://mitm.it</a>) 下载配置文件（此处一定要先进入开启mitmproxy的设备所在局域网并且设置好代理后才可以正常访问这个站点！）。</p>\n<p>在设置里下载证书<br><strong>Settings&#x3D;&gt;General&#x3D;&gt;VPN&amp;DeviceManagement&#x3D;&gt;mitmproxy&#x3D;&gt;Install</strong></p>\n<p>启用证书（注意，下载证书还不够！一定要开启！）<br><strong>Settings&#x3D;&gt;General&#x3D;&gt;About&#x3D;&gt;Certificate Trust Settings&#x3D;&gt;开启mitmproxy</strong></p>\n<p>之后访问网站就会正常，同时电脑终端也可以看到请求<br>如果要针对不同请求做不同处理&#x2F;记录日志，则可以通过python脚本的方式</p>\n<p><strong>脚本范例：</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#addon.py</span><br><br><span class=\"hljs-keyword\">from</span> mitmproxy <span class=\"hljs-keyword\">import</span> http<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">request</span>(<span class=\"hljs-params\">flow: http.HTTPFlow</span>):<br>    <span class=\"hljs-comment\"># redirect to different host</span><br>    <span class=\"hljs-keyword\">if</span> flow.request.pretty_host == <span class=\"hljs-string\">&quot;example.com&quot;</span>:<br>        flow.request.host = <span class=\"hljs-string\">&quot;mitmproxy.org&quot;</span><br>    <span class=\"hljs-comment\"># answer from proxy</span><br>    <span class=\"hljs-keyword\">elif</span> flow.request.path.endswith(<span class=\"hljs-string\">&quot;/brew&quot;</span>):<br>    \tflow.response = http.HTTPResponse.make(<br>            <span class=\"hljs-number\">418</span>, **b**<span class=\"hljs-string\">&quot;I&#x27;m a teapot&quot;</span>,<br>        )<br></code></pre></td></tr></table></figure>\n\n<p>启动方式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mitmproxy -s ./app.py<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":1241,"excerpt":"","more":"<h1 id=\"工具：mitmproxy\"><a href=\"#工具：mitmproxy\" class=\"headerlink\" title=\"工具：mitmproxy\"></a>工具：mitmproxy</h1><blockquote>\n<p>官网地址：<a href=\"https://mitmproxy.org/\">https://mitmproxy.org</a></p>\n</blockquote>\n<h1 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h1><h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h2><p><strong>MAC：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">brew install mitmproxy<br></code></pre></td></tr></table></figure>\n<p><strong>MAC&#x2F;WINDOWS&#x2F;LINUX</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">pip install mitmproxy<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-开启监测\"><a href=\"#2-开启监测\" class=\"headerlink\" title=\"2.开启监测\"></a>2.开启监测</h2><p>开启mitmproxy的设备：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mitmproxy -p 端口号<br></code></pre></td></tr></table></figure>\n<p>有三种方式可以开启mitmproxy监测</p>\n<ul>\n<li><strong>mitmproxy</strong> 终端可交互界面</li>\n<li><strong>mitmweb</strong> 浏览器版GUI可交互界面</li>\n<li><strong>mitmdump</strong> 终端输出（不可交互）<h2 id=\"3-网络环境配置\"><a href=\"#3-网络环境配置\" class=\"headerlink\" title=\"3.网络环境配置\"></a>3.网络环境配置</h2><blockquote>\n<p>被监测的设备（一般是你的手机）和开启mitmproxy的设备（一般是电脑）要在同一片局域网内。</p>\n</blockquote>\n</li>\n</ul>\n<p>手机进入局域网后（可以通过连接热点）后 ，在热点模块里开启自定义代理，端口号指定同开启mitmproxy服务时确定的端口号。</p>\n<p><strong>手机（此处IOS举例）具体操作：</strong><br>Settings&#x3D;&gt;WLAN&#x3D;&gt;局域网网络（一般也就是你的热点）右侧感叹号&#x3D;&gt;Configure Proxy&#x3D;&gt;Manaul（填入你开启mitmproxy监测服务的设备的ip以及端口号）</p>\n<p>此时访问任何站点由于没有证书，都会显示证书不可信任<br>接下来访问(<a href=\"http://mitm.it/\">http://mitm.it</a>) 下载配置文件（此处一定要先进入开启mitmproxy的设备所在局域网并且设置好代理后才可以正常访问这个站点！）。</p>\n<p>在设置里下载证书<br><strong>Settings&#x3D;&gt;General&#x3D;&gt;VPN&amp;DeviceManagement&#x3D;&gt;mitmproxy&#x3D;&gt;Install</strong></p>\n<p>启用证书（注意，下载证书还不够！一定要开启！）<br><strong>Settings&#x3D;&gt;General&#x3D;&gt;About&#x3D;&gt;Certificate Trust Settings&#x3D;&gt;开启mitmproxy</strong></p>\n<p>之后访问网站就会正常，同时电脑终端也可以看到请求<br>如果要针对不同请求做不同处理&#x2F;记录日志，则可以通过python脚本的方式</p>\n<p><strong>脚本范例：</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#addon.py</span><br><br><span class=\"hljs-keyword\">from</span> mitmproxy <span class=\"hljs-keyword\">import</span> http<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">request</span>(<span class=\"hljs-params\">flow: http.HTTPFlow</span>):<br>    <span class=\"hljs-comment\"># redirect to different host</span><br>    <span class=\"hljs-keyword\">if</span> flow.request.pretty_host == <span class=\"hljs-string\">&quot;example.com&quot;</span>:<br>        flow.request.host = <span class=\"hljs-string\">&quot;mitmproxy.org&quot;</span><br>    <span class=\"hljs-comment\"># answer from proxy</span><br>    <span class=\"hljs-keyword\">elif</span> flow.request.path.endswith(<span class=\"hljs-string\">&quot;/brew&quot;</span>):<br>    \tflow.response = http.HTTPResponse.make(<br>            <span class=\"hljs-number\">418</span>, **b**<span class=\"hljs-string\">&quot;I&#x27;m a teapot&quot;</span>,<br>        )<br></code></pre></td></tr></table></figure>\n\n<p>启动方式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mitmproxy -s ./app.py<br></code></pre></td></tr></table></figure>"},{"title":"HTTP或HTTPS内网穿透服务","date":"2022-04-24T15:50:59.000Z","description":"supervisor+frp+nginx搭建HTTP/HTTPS内网穿透服务","_content":"# supervisor+frp+nginx搭建HTTP/HTTPS内网穿透服务\n\n> frp开源仓库：https://github.com/fatedier/frp\n>\n> supervisor开源仓库：https://github.com/Supervisor/supervisor\n>\n> nginx开源仓库：https://github.com/nginx/nginx\n\n## 前言\n\n在做微信小程序的时候发现每次都要传文件到服务器上，然后再跑起来服务，调用接口的时候想看日志还得要去服务器上看，整个流程实在是非常的麻烦，程序员的懒本质让我去想了一下该怎么处理这个问题，结合之前用过的frp可以做内网穿透，那么能不能用nginx转发到frp的服务端口呢？\n\n## 服务端配置\n\n### frp配置\n\n服务端`frps.ini`文件\n\n```ini\n[common]\n;tcp信号传输端口\nbind_port = 7000\n;接收http服务的端口\nvhost_http_port = 8006\n;用来验证是自己的信号的token\nauth_token = token\n\n;服务类型\ntype = http\n;你的服务器地址，此处由于做了nginx转发，且转发到的是127.0.0.1，所以这里就写127.0.0.1\ncustom_domains = 127.0.0.1\n```\n\n### supervisor配置\n\n`supervisor.conf`配置载入子文件夹中的所有`.ini`文件\n\n```\n[include]\nfiles = supervisord.d/*.ini\n```\n\n`frps.ini`文件配置如下\n\n```ini\n[program:frps]\n;启动用户\nuser=root\n;启动路径\ndirectory=/root/frp_0.42.0_linux_amd64\n;具体命令\ncommand=/usr/bin/zsh -c './frps -c ./frps.ini'\n;是否开机自启动\nautostart=true\n;遇到错误是否重启\nautorestart=true\n```\n\n### nginx配置\n\n```conf\nuser root;\nworker_processes  1;\nerror_log  logs/error.log  info;\n\n# pid  logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    # 防止带有下划线的请求头被忽略\n    underscores_in_headers on;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                     '$status $body_bytes_sent \"$http_referer\" '\n                     '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    # access_log  logs/access.log  main;\n\n    sendfile        on;\n    # tcp_nopush     on;\n\n    keepalive_timeout  65;\n    client_max_body_size 10m;  \n    # gzip  on;\n    # HTTP server\n    server {\n        listen  80;\n        server_name  your.domain.com;\n        return 301 https://your.domain.com$request_uri;\n    }\n    # HTTPS server\n    server {\n        listen       443 ssl;\n        server_name  alnda.cn;\n\n        ssl_certificate      /ssl/cert/ssl.cn.pem;\n        ssl_certificate_key  /ssl/cert/ssl.cn.key;\n\n        ssl_session_cache    shared:SSL:1m;\n        ssl_session_timeout  10m;\n    \n        ssl_ciphers  HIGH:!aNULL:!MD5;\n        ssl_prefer_server_ciphers  on;\n        location /frp/ {\n            proxy_pass http://127.0.0.1:8006/;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto https;\n            proxy_set_header X-Forwarded-Host $remote_addr;\n        }\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n}\n\n```\n\n## 本地（客户端）配置\n\n### frp配置\n\n客户端`frpc.ini`文件\n\n```ini\n[common]\n;你的远程服务器ip地址\nserver_addr = 43.231.52.81\n;不要动，这是固定tcp端口号\nserver_port = 7000\n;用来验证是你的服务器的token，和服务器上的保持一致\nauth_token = token\t\n\n[web]\ntype = http\nlocal_port = 8000\ncustom_domains = 127.0.0.1\n```\n\n通过如下命令启动\n\n```sh\n./frpc -c ./frpc.ini\n```\n\n## 结果\n\n由于nginx开启啦https，所以访问服务器域名即可访问到本地服务\n\n开始快乐的穿透模式吧！\n\n还可以用来做调试哦～","source":"_posts/计网/内网穿透.md","raw":"---\ntitle: HTTP或HTTPS内网穿透服务\ndate: 2022-04-24 23:50:59\ntags:\n  - [内网穿透]\n  - [nginx]\n  - [frp]\n  - [supervisor]\ncategories:\n  - [技术]\ndescription: supervisor+frp+nginx搭建HTTP/HTTPS内网穿透服务\n---\n# supervisor+frp+nginx搭建HTTP/HTTPS内网穿透服务\n\n> frp开源仓库：https://github.com/fatedier/frp\n>\n> supervisor开源仓库：https://github.com/Supervisor/supervisor\n>\n> nginx开源仓库：https://github.com/nginx/nginx\n\n## 前言\n\n在做微信小程序的时候发现每次都要传文件到服务器上，然后再跑起来服务，调用接口的时候想看日志还得要去服务器上看，整个流程实在是非常的麻烦，程序员的懒本质让我去想了一下该怎么处理这个问题，结合之前用过的frp可以做内网穿透，那么能不能用nginx转发到frp的服务端口呢？\n\n## 服务端配置\n\n### frp配置\n\n服务端`frps.ini`文件\n\n```ini\n[common]\n;tcp信号传输端口\nbind_port = 7000\n;接收http服务的端口\nvhost_http_port = 8006\n;用来验证是自己的信号的token\nauth_token = token\n\n;服务类型\ntype = http\n;你的服务器地址，此处由于做了nginx转发，且转发到的是127.0.0.1，所以这里就写127.0.0.1\ncustom_domains = 127.0.0.1\n```\n\n### supervisor配置\n\n`supervisor.conf`配置载入子文件夹中的所有`.ini`文件\n\n```\n[include]\nfiles = supervisord.d/*.ini\n```\n\n`frps.ini`文件配置如下\n\n```ini\n[program:frps]\n;启动用户\nuser=root\n;启动路径\ndirectory=/root/frp_0.42.0_linux_amd64\n;具体命令\ncommand=/usr/bin/zsh -c './frps -c ./frps.ini'\n;是否开机自启动\nautostart=true\n;遇到错误是否重启\nautorestart=true\n```\n\n### nginx配置\n\n```conf\nuser root;\nworker_processes  1;\nerror_log  logs/error.log  info;\n\n# pid  logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    # 防止带有下划线的请求头被忽略\n    underscores_in_headers on;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                     '$status $body_bytes_sent \"$http_referer\" '\n                     '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    # access_log  logs/access.log  main;\n\n    sendfile        on;\n    # tcp_nopush     on;\n\n    keepalive_timeout  65;\n    client_max_body_size 10m;  \n    # gzip  on;\n    # HTTP server\n    server {\n        listen  80;\n        server_name  your.domain.com;\n        return 301 https://your.domain.com$request_uri;\n    }\n    # HTTPS server\n    server {\n        listen       443 ssl;\n        server_name  alnda.cn;\n\n        ssl_certificate      /ssl/cert/ssl.cn.pem;\n        ssl_certificate_key  /ssl/cert/ssl.cn.key;\n\n        ssl_session_cache    shared:SSL:1m;\n        ssl_session_timeout  10m;\n    \n        ssl_ciphers  HIGH:!aNULL:!MD5;\n        ssl_prefer_server_ciphers  on;\n        location /frp/ {\n            proxy_pass http://127.0.0.1:8006/;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto https;\n            proxy_set_header X-Forwarded-Host $remote_addr;\n        }\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n}\n\n```\n\n## 本地（客户端）配置\n\n### frp配置\n\n客户端`frpc.ini`文件\n\n```ini\n[common]\n;你的远程服务器ip地址\nserver_addr = 43.231.52.81\n;不要动，这是固定tcp端口号\nserver_port = 7000\n;用来验证是你的服务器的token，和服务器上的保持一致\nauth_token = token\t\n\n[web]\ntype = http\nlocal_port = 8000\ncustom_domains = 127.0.0.1\n```\n\n通过如下命令启动\n\n```sh\n./frpc -c ./frpc.ini\n```\n\n## 结果\n\n由于nginx开启啦https，所以访问服务器域名即可访问到本地服务\n\n开始快乐的穿透模式吧！\n\n还可以用来做调试哦～","slug":"计网/内网穿透","published":1,"updated":"2022-08-28T07:38:59.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2h0049scvm7v1i4a6e","content":"<h1 id=\"supervisor-frp-nginx搭建HTTP-x2F-HTTPS内网穿透服务\"><a href=\"#supervisor-frp-nginx搭建HTTP-x2F-HTTPS内网穿透服务\" class=\"headerlink\" title=\"supervisor+frp+nginx搭建HTTP&#x2F;HTTPS内网穿透服务\"></a>supervisor+frp+nginx搭建HTTP&#x2F;HTTPS内网穿透服务</h1><blockquote>\n<p>frp开源仓库：<a href=\"https://github.com/fatedier/frp\">https://github.com/fatedier/frp</a></p>\n<p>supervisor开源仓库：<a href=\"https://github.com/Supervisor/supervisor\">https://github.com/Supervisor/supervisor</a></p>\n<p>nginx开源仓库：<a href=\"https://github.com/nginx/nginx\">https://github.com/nginx/nginx</a></p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在做微信小程序的时候发现每次都要传文件到服务器上，然后再跑起来服务，调用接口的时候想看日志还得要去服务器上看，整个流程实在是非常的麻烦，程序员的懒本质让我去想了一下该怎么处理这个问题，结合之前用过的frp可以做内网穿透，那么能不能用nginx转发到frp的服务端口呢？</p>\n<h2 id=\"服务端配置\"><a href=\"#服务端配置\" class=\"headerlink\" title=\"服务端配置\"></a>服务端配置</h2><h3 id=\"frp配置\"><a href=\"#frp配置\" class=\"headerlink\" title=\"frp配置\"></a>frp配置</h3><p>服务端<code>frps.ini</code>文件</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[common]</span><br><span class=\"hljs-comment\">;tcp信号传输端口</span><br><span class=\"hljs-attr\">bind_port</span> = <span class=\"hljs-number\">7000</span><br><span class=\"hljs-comment\">;接收http服务的端口</span><br><span class=\"hljs-attr\">vhost_http_port</span> = <span class=\"hljs-number\">8006</span><br><span class=\"hljs-comment\">;用来验证是自己的信号的token</span><br><span class=\"hljs-attr\">auth_token</span> = token<br><br><span class=\"hljs-comment\">;服务类型</span><br><span class=\"hljs-attr\">type</span> = http<br><span class=\"hljs-comment\">;你的服务器地址，此处由于做了nginx转发，且转发到的是127.0.0.1，所以这里就写127.0.0.1</span><br><span class=\"hljs-attr\">custom_domains</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"supervisor配置\"><a href=\"#supervisor配置\" class=\"headerlink\" title=\"supervisor配置\"></a>supervisor配置</h3><p><code>supervisor.conf</code>配置载入子文件夹中的所有<code>.ini</code>文件</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[include]</span><br><span class=\"hljs-attr\">files</span> = supervisord.d/*.ini<br></code></pre></td></tr></table></figure>\n\n<p><code>frps.ini</code>文件配置如下</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[program:frps]</span><br><span class=\"hljs-comment\">;启动用户</span><br><span class=\"hljs-attr\">user</span>=root<br><span class=\"hljs-comment\">;启动路径</span><br><span class=\"hljs-attr\">directory</span>=/root/frp_0.<span class=\"hljs-number\">42.0</span>_linux_amd64<br><span class=\"hljs-comment\">;具体命令</span><br><span class=\"hljs-attr\">command</span>=/usr/bin/zsh -c <span class=\"hljs-string\">&#x27;./frps -c ./frps.ini&#x27;</span><br><span class=\"hljs-comment\">;是否开机自启动</span><br><span class=\"hljs-attr\">autostart</span>=<span class=\"hljs-literal\">true</span><br><span class=\"hljs-comment\">;遇到错误是否重启</span><br><span class=\"hljs-attr\">autorestart</span>=<span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs conf\">user root;<br>worker_processes  1;<br>error_log  logs/error.log  info;<br><br># pid  logs/nginx.pid;<br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br>http &#123;<br>    include       mime.types;<br>    default_type  application/octet-stream;<br><br>    # 防止带有下划线的请求头被忽略<br>    underscores_in_headers on;<br><br>    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>                     &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>                     &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>    # access_log  logs/access.log  main;<br><br>    sendfile        on;<br>    # tcp_nopush     on;<br><br>    keepalive_timeout  65;<br>    client_max_body_size 10m;  <br>    # gzip  on;<br>    # HTTP server<br>    server &#123;<br>        listen  80;<br>        server_name  your.domain.com;<br>        return 301 https://your.domain.com$request_uri;<br>    &#125;<br>    # HTTPS server<br>    server &#123;<br>        listen       443 ssl;<br>        server_name  alnda.cn;<br><br>        ssl_certificate      /ssl/cert/ssl.cn.pem;<br>        ssl_certificate_key  /ssl/cert/ssl.cn.key;<br><br>        ssl_session_cache    shared:SSL:1m;<br>        ssl_session_timeout  10m;<br>    <br>        ssl_ciphers  HIGH:!aNULL:!MD5;<br>        ssl_prefer_server_ciphers  on;<br>        location /frp/ &#123;<br>            proxy_pass http://127.0.0.1:8006/;<br>            proxy_set_header X-Real-IP $remote_addr;<br>            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>            proxy_set_header X-Forwarded-Proto https;<br>            proxy_set_header X-Forwarded-Host $remote_addr;<br>        &#125;<br>        error_page 500 502 503 504 /50x.html;<br>            location = /50x.html &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"本地（客户端）配置\"><a href=\"#本地（客户端）配置\" class=\"headerlink\" title=\"本地（客户端）配置\"></a>本地（客户端）配置</h2><h3 id=\"frp配置-1\"><a href=\"#frp配置-1\" class=\"headerlink\" title=\"frp配置\"></a>frp配置</h3><p>客户端<code>frpc.ini</code>文件</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[common]</span><br><span class=\"hljs-comment\">;你的远程服务器ip地址</span><br><span class=\"hljs-attr\">server_addr</span> = <span class=\"hljs-number\">43.231</span>.<span class=\"hljs-number\">52.81</span><br><span class=\"hljs-comment\">;不要动，这是固定tcp端口号</span><br><span class=\"hljs-attr\">server_port</span> = <span class=\"hljs-number\">7000</span><br><span class=\"hljs-comment\">;用来验证是你的服务器的token，和服务器上的保持一致</span><br><span class=\"hljs-attr\">auth_token</span> = token\t<br><br><span class=\"hljs-section\">[web]</span><br><span class=\"hljs-attr\">type</span> = http<br><span class=\"hljs-attr\">local_port</span> = <span class=\"hljs-number\">8000</span><br><span class=\"hljs-attr\">custom_domains</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br></code></pre></td></tr></table></figure>\n\n<p>通过如下命令启动</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">./frpc -c ./frpc.ini<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>由于nginx开启啦https，所以访问服务器域名即可访问到本地服务</p>\n<p>开始快乐的穿透模式吧！</p>\n<p>还可以用来做调试哦～</p>\n","site":{"data":{}},"wordcount":2452,"excerpt":"","more":"<h1 id=\"supervisor-frp-nginx搭建HTTP-x2F-HTTPS内网穿透服务\"><a href=\"#supervisor-frp-nginx搭建HTTP-x2F-HTTPS内网穿透服务\" class=\"headerlink\" title=\"supervisor+frp+nginx搭建HTTP&#x2F;HTTPS内网穿透服务\"></a>supervisor+frp+nginx搭建HTTP&#x2F;HTTPS内网穿透服务</h1><blockquote>\n<p>frp开源仓库：<a href=\"https://github.com/fatedier/frp\">https://github.com/fatedier/frp</a></p>\n<p>supervisor开源仓库：<a href=\"https://github.com/Supervisor/supervisor\">https://github.com/Supervisor/supervisor</a></p>\n<p>nginx开源仓库：<a href=\"https://github.com/nginx/nginx\">https://github.com/nginx/nginx</a></p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在做微信小程序的时候发现每次都要传文件到服务器上，然后再跑起来服务，调用接口的时候想看日志还得要去服务器上看，整个流程实在是非常的麻烦，程序员的懒本质让我去想了一下该怎么处理这个问题，结合之前用过的frp可以做内网穿透，那么能不能用nginx转发到frp的服务端口呢？</p>\n<h2 id=\"服务端配置\"><a href=\"#服务端配置\" class=\"headerlink\" title=\"服务端配置\"></a>服务端配置</h2><h3 id=\"frp配置\"><a href=\"#frp配置\" class=\"headerlink\" title=\"frp配置\"></a>frp配置</h3><p>服务端<code>frps.ini</code>文件</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[common]</span><br><span class=\"hljs-comment\">;tcp信号传输端口</span><br><span class=\"hljs-attr\">bind_port</span> = <span class=\"hljs-number\">7000</span><br><span class=\"hljs-comment\">;接收http服务的端口</span><br><span class=\"hljs-attr\">vhost_http_port</span> = <span class=\"hljs-number\">8006</span><br><span class=\"hljs-comment\">;用来验证是自己的信号的token</span><br><span class=\"hljs-attr\">auth_token</span> = token<br><br><span class=\"hljs-comment\">;服务类型</span><br><span class=\"hljs-attr\">type</span> = http<br><span class=\"hljs-comment\">;你的服务器地址，此处由于做了nginx转发，且转发到的是127.0.0.1，所以这里就写127.0.0.1</span><br><span class=\"hljs-attr\">custom_domains</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"supervisor配置\"><a href=\"#supervisor配置\" class=\"headerlink\" title=\"supervisor配置\"></a>supervisor配置</h3><p><code>supervisor.conf</code>配置载入子文件夹中的所有<code>.ini</code>文件</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[include]</span><br><span class=\"hljs-attr\">files</span> = supervisord.d/*.ini<br></code></pre></td></tr></table></figure>\n\n<p><code>frps.ini</code>文件配置如下</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[program:frps]</span><br><span class=\"hljs-comment\">;启动用户</span><br><span class=\"hljs-attr\">user</span>=root<br><span class=\"hljs-comment\">;启动路径</span><br><span class=\"hljs-attr\">directory</span>=/root/frp_0.<span class=\"hljs-number\">42.0</span>_linux_amd64<br><span class=\"hljs-comment\">;具体命令</span><br><span class=\"hljs-attr\">command</span>=/usr/bin/zsh -c <span class=\"hljs-string\">&#x27;./frps -c ./frps.ini&#x27;</span><br><span class=\"hljs-comment\">;是否开机自启动</span><br><span class=\"hljs-attr\">autostart</span>=<span class=\"hljs-literal\">true</span><br><span class=\"hljs-comment\">;遇到错误是否重启</span><br><span class=\"hljs-attr\">autorestart</span>=<span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs conf\">user root;<br>worker_processes  1;<br>error_log  logs/error.log  info;<br><br># pid  logs/nginx.pid;<br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br>http &#123;<br>    include       mime.types;<br>    default_type  application/octet-stream;<br><br>    # 防止带有下划线的请求头被忽略<br>    underscores_in_headers on;<br><br>    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>                     &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>                     &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>    # access_log  logs/access.log  main;<br><br>    sendfile        on;<br>    # tcp_nopush     on;<br><br>    keepalive_timeout  65;<br>    client_max_body_size 10m;  <br>    # gzip  on;<br>    # HTTP server<br>    server &#123;<br>        listen  80;<br>        server_name  your.domain.com;<br>        return 301 https://your.domain.com$request_uri;<br>    &#125;<br>    # HTTPS server<br>    server &#123;<br>        listen       443 ssl;<br>        server_name  alnda.cn;<br><br>        ssl_certificate      /ssl/cert/ssl.cn.pem;<br>        ssl_certificate_key  /ssl/cert/ssl.cn.key;<br><br>        ssl_session_cache    shared:SSL:1m;<br>        ssl_session_timeout  10m;<br>    <br>        ssl_ciphers  HIGH:!aNULL:!MD5;<br>        ssl_prefer_server_ciphers  on;<br>        location /frp/ &#123;<br>            proxy_pass http://127.0.0.1:8006/;<br>            proxy_set_header X-Real-IP $remote_addr;<br>            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>            proxy_set_header X-Forwarded-Proto https;<br>            proxy_set_header X-Forwarded-Host $remote_addr;<br>        &#125;<br>        error_page 500 502 503 504 /50x.html;<br>            location = /50x.html &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"本地（客户端）配置\"><a href=\"#本地（客户端）配置\" class=\"headerlink\" title=\"本地（客户端）配置\"></a>本地（客户端）配置</h2><h3 id=\"frp配置-1\"><a href=\"#frp配置-1\" class=\"headerlink\" title=\"frp配置\"></a>frp配置</h3><p>客户端<code>frpc.ini</code>文件</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[common]</span><br><span class=\"hljs-comment\">;你的远程服务器ip地址</span><br><span class=\"hljs-attr\">server_addr</span> = <span class=\"hljs-number\">43.231</span>.<span class=\"hljs-number\">52.81</span><br><span class=\"hljs-comment\">;不要动，这是固定tcp端口号</span><br><span class=\"hljs-attr\">server_port</span> = <span class=\"hljs-number\">7000</span><br><span class=\"hljs-comment\">;用来验证是你的服务器的token，和服务器上的保持一致</span><br><span class=\"hljs-attr\">auth_token</span> = token\t<br><br><span class=\"hljs-section\">[web]</span><br><span class=\"hljs-attr\">type</span> = http<br><span class=\"hljs-attr\">local_port</span> = <span class=\"hljs-number\">8000</span><br><span class=\"hljs-attr\">custom_domains</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br></code></pre></td></tr></table></figure>\n\n<p>通过如下命令启动</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">./frpc -c ./frpc.ini<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>由于nginx开启啦https，所以访问服务器域名即可访问到本地服务</p>\n<p>开始快乐的穿透模式吧！</p>\n<p>还可以用来做调试哦～</p>\n"},{"title":"人人都是自媒体","date":"2022-04-05T11:17:27.000Z","description":"互联网时代下，你真的看清自己了吗？","_content":"\n# 互联网时代下，你真的看清自己了吗？\n\n身处互联网时代，形形色色的信息流目不暇接——抖音、B站、小红书、头条，各种平台一个一个出现在我们面前对我们说着用我用我，大量的新奇功能也确实吸引了很多的猎奇用户，这部分猎奇用户又为了能够从平台提供的活动中获取更多利益，向更多的人开始宣传平台，随着这种疯狂的传递，平台使用人数疯狂增长。\n\n在密密麻麻的信息留下，我们变得过于的急躁，什么东西都渴求速成——绘画速成班、前端速成班、20天上岗，各种”速成“总是更容易吸引人的注目，这都是因为目前过于快的生活节奏，大家都希望能短时间内完成一个需求。\n\n现在如果让你将你的手机放在一个地方锁起来一天不去接触，你愿意吗？现在的你还能够静下心来，靠在窗边认真读一本书吗？别说青少年了，现在连小孩子都已经满目电子产品了。\n\n但这样带来的弊端、问题是巨大的——我们已经无法看清自己，看清生活了！你到底想要什么？在这个时代，每个人都在问自己到底想要什么？有时候甚至连问自己到底想要什么的时间都没有！\n\n国内的互联网大厂，有哪一家是在五点前能下班的？996盛行的时代下，人们早已经失去了自己的空间。\n\n希望我们都能活成自己想活的样子，都能活在自己热爱的世界。\n\n希望这个世界能变成我们喜欢的样子。","source":"_posts/随笔/人人都是自媒体.md","raw":"---\ntitle: 人人都是自媒体\ndate: 2022-04-05 19:17:27\ntags:\n  - [自媒体]\ncategories:\n  - [随笔]\ndescription: 互联网时代下，你真的看清自己了吗？\n---\n\n# 互联网时代下，你真的看清自己了吗？\n\n身处互联网时代，形形色色的信息流目不暇接——抖音、B站、小红书、头条，各种平台一个一个出现在我们面前对我们说着用我用我，大量的新奇功能也确实吸引了很多的猎奇用户，这部分猎奇用户又为了能够从平台提供的活动中获取更多利益，向更多的人开始宣传平台，随着这种疯狂的传递，平台使用人数疯狂增长。\n\n在密密麻麻的信息留下，我们变得过于的急躁，什么东西都渴求速成——绘画速成班、前端速成班、20天上岗，各种”速成“总是更容易吸引人的注目，这都是因为目前过于快的生活节奏，大家都希望能短时间内完成一个需求。\n\n现在如果让你将你的手机放在一个地方锁起来一天不去接触，你愿意吗？现在的你还能够静下心来，靠在窗边认真读一本书吗？别说青少年了，现在连小孩子都已经满目电子产品了。\n\n但这样带来的弊端、问题是巨大的——我们已经无法看清自己，看清生活了！你到底想要什么？在这个时代，每个人都在问自己到底想要什么？有时候甚至连问自己到底想要什么的时间都没有！\n\n国内的互联网大厂，有哪一家是在五点前能下班的？996盛行的时代下，人们早已经失去了自己的空间。\n\n希望我们都能活成自己想活的样子，都能活在自己热爱的世界。\n\n希望这个世界能变成我们喜欢的样子。","slug":"随笔/人人都是自媒体","published":1,"updated":"2022-08-28T07:38:59.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2i004cscvm04ps04nn","content":"<h1 id=\"互联网时代下，你真的看清自己了吗？\"><a href=\"#互联网时代下，你真的看清自己了吗？\" class=\"headerlink\" title=\"互联网时代下，你真的看清自己了吗？\"></a>互联网时代下，你真的看清自己了吗？</h1><p>身处互联网时代，形形色色的信息流目不暇接——抖音、B站、小红书、头条，各种平台一个一个出现在我们面前对我们说着用我用我，大量的新奇功能也确实吸引了很多的猎奇用户，这部分猎奇用户又为了能够从平台提供的活动中获取更多利益，向更多的人开始宣传平台，随着这种疯狂的传递，平台使用人数疯狂增长。</p>\n<p>在密密麻麻的信息留下，我们变得过于的急躁，什么东西都渴求速成——绘画速成班、前端速成班、20天上岗，各种”速成“总是更容易吸引人的注目，这都是因为目前过于快的生活节奏，大家都希望能短时间内完成一个需求。</p>\n<p>现在如果让你将你的手机放在一个地方锁起来一天不去接触，你愿意吗？现在的你还能够静下心来，靠在窗边认真读一本书吗？别说青少年了，现在连小孩子都已经满目电子产品了。</p>\n<p>但这样带来的弊端、问题是巨大的——我们已经无法看清自己，看清生活了！你到底想要什么？在这个时代，每个人都在问自己到底想要什么？有时候甚至连问自己到底想要什么的时间都没有！</p>\n<p>国内的互联网大厂，有哪一家是在五点前能下班的？996盛行的时代下，人们早已经失去了自己的空间。</p>\n<p>希望我们都能活成自己想活的样子，都能活在自己热爱的世界。</p>\n<p>希望这个世界能变成我们喜欢的样子。</p>\n","site":{"data":{}},"wordcount":517,"excerpt":"","more":"<h1 id=\"互联网时代下，你真的看清自己了吗？\"><a href=\"#互联网时代下，你真的看清自己了吗？\" class=\"headerlink\" title=\"互联网时代下，你真的看清自己了吗？\"></a>互联网时代下，你真的看清自己了吗？</h1><p>身处互联网时代，形形色色的信息流目不暇接——抖音、B站、小红书、头条，各种平台一个一个出现在我们面前对我们说着用我用我，大量的新奇功能也确实吸引了很多的猎奇用户，这部分猎奇用户又为了能够从平台提供的活动中获取更多利益，向更多的人开始宣传平台，随着这种疯狂的传递，平台使用人数疯狂增长。</p>\n<p>在密密麻麻的信息留下，我们变得过于的急躁，什么东西都渴求速成——绘画速成班、前端速成班、20天上岗，各种”速成“总是更容易吸引人的注目，这都是因为目前过于快的生活节奏，大家都希望能短时间内完成一个需求。</p>\n<p>现在如果让你将你的手机放在一个地方锁起来一天不去接触，你愿意吗？现在的你还能够静下心来，靠在窗边认真读一本书吗？别说青少年了，现在连小孩子都已经满目电子产品了。</p>\n<p>但这样带来的弊端、问题是巨大的——我们已经无法看清自己，看清生活了！你到底想要什么？在这个时代，每个人都在问自己到底想要什么？有时候甚至连问自己到底想要什么的时间都没有！</p>\n<p>国内的互联网大厂，有哪一家是在五点前能下班的？996盛行的时代下，人们早已经失去了自己的空间。</p>\n<p>希望我们都能活成自己想活的样子，都能活在自己热爱的世界。</p>\n<p>希望这个世界能变成我们喜欢的样子。</p>\n"},{"title":"TCP","date":"2022-04-05T09:30:27.000Z","description":"TCP面试常问","_content":"\n# TCP\n\nTCP 的三次握手和四次挥手，可以说是老生常谈的经典问题了，通常也作为各大公司常见的面试考题，具有一定的水平区分度。看似是简单的面试问题，如果你的回答不符合面试官期待的水准，有可能就直接凉凉了。  \n\n本文会围绕，三次握手和四次挥手相关的一些列核心问题，分享如何更准确的回答和应对常见的面试问题，以后面对再刁钻的面试官，你都可以随意地跟他扯皮了。\n\n## 面试TCP的意义\n\n我想要先说明一个重要问题，到底面试 TCP 的意义何在？\n\n经常会听到这样抱怨：我是做业务程序开发的，面试官竟然问我 TCP 三次握手、TCP 拥塞控制的问题，还问的这么细致？\n\n这些同学会觉着面试官是闲的淡疼，或是故意刁难候选人，更有同学认为面试官是为了防止自己技术退步拿来练手的，这种想法我也是醉了。\n\n当然，不同人对此可能会有不同的想法，但我们技术人应该以积极的心态来理解和面对这个问题，在我看来面试 TCP 有重要的意义：\n\n_1._ 从面试官的角度，可以快速考察候选人对基础知识的掌握程度，以及候选人对待技术的那种知其所以然的态度。\n\n_2._ 从求职者的角度，即使工作内容中没有直接用到 TCP 协议，但在遇到网络故障，调试和分析问题时，熟悉 TCP 显得十分重要，要不抓包都看不懂。\n\n_3._ 从学习的角度，我们可以学习 TCP 的设计理念，比如 TCP 重传、拥塞控制，以及如何在性能和原理之间做权衡和取舍的，举一反三，将这些原理细节应用到我们平时的软件设计上，也是一种思维上的学习成长。\n\n_4._ 如果想要调整 TCP 参数来提升传输速度，可服务器上相关的系统参数有几十个，究竟该怎么调整呢？\n\n_5._ 在服务器本地的 TCP 连接状态出现了类似 `fin_wait`、`time_wait`，该怎么解决，是什么原因引起的？如果不懂 TCP，即使别人告诉你解决方案，你也不能够真正理解的。\n\n所以，我们非常有必要认真学习 TCP 协议，对 TCP 熟悉程度，在某种意义上也是你与别人拉开距离的重要标识。\n\n## TCP 基础\n\n这里先帮小伙伴们熟悉和回顾下 TCP 的基本概念，以至于能够更好的理解文章后边的内容。\n\nTCP 其实是非常复杂的协议，我们先聊一些基础的。我们知道 TCP 是一种可靠的协议，它主要通过解决这几个问题来实现可靠性的，分别是：乱序、丢包重传、流控、拥塞控制。通过从图中报文格式的字段，也能够简单了解到 TCP 的相关概念。\n\n![](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/77fiE3.jpeg)\n\n-   TCP 在网络 OSI 七层模型中的第四层，TCP 包是没有 IP 地址的，但有源端口和目的端口，用来标识通信的进程。\n    \n-   `Sequence Number` 是记录包的序号，TCP 会按照报文字节进行编号，它是用来解决包在网络中乱序的问题。\n    \n-   `Acknowledgement Number` 确认序列号，是用于向发送方确认已经收到了哪些包，用来解决不丢包的问题。\n    \n-   `Windows` 也叫 `Advertised-Windows`，也就是著名的滑动窗口，主要是用来解决流控的。\n    \n-   `TCP Flag` 就是包的类型，主要是用于操控 TCP 状态机的。\n    \n\n## 三次握手\n\n**三次握手**是各个公司常见的面试考点。以过来人经验来讲，虽然该问题看似简单，但你还真不一定能够回答的好。\n\n见过比较典型面试问答场景：\n\n> _面试官_：请描述一下三次握手的过程吧    \n> _求职者_：第一次客户端给服务端发送一个报文，第二次是服务器收到包之后，也给客户端应答一个报文，第三次是客户端再给服务器发送一个回复报文，TCP 三次握手成功。   \n> _面试官_：还有吗？   \n> _求职者_：说完了哈，这就是三次握手，很简单的  \n> _面试官_：嗯，我没什么问的了，你还有什么问题吗？\n\n这时求职者紧张的心终于平静了，因为面试官没有深入下去的意思，继续问下去可能也不懂，皆大欢喜！当然本次面试基本上也就 `game over`了。\n\n求职者回答的不正确么？正确，但是回答的过于简单，离面试官的期望的答案还有一定的距离，我们该怎么回答呢？\n\n![](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/uqEjMv.png)\n\nTCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。\n\n-   第一次握手：客户端发送 `SYN` 报文，并进入 `SYN_SENT` 状态，等待服务器的确认；\n    \n-   第二次握手：服务器收到 `SYN` 报文，需要给客户端发送 `ACK` 确认报文，同时服务器也要向客户端发送一个 `SYN` 报文，所以也就是向客户端发送 `SYN + ACK` 报文，此时服务器进入 `SYN_RCVD` 状态；\n    \n-   第三次握手：客户端收到 `SYN + ACK` 报文，向服务器发送确认包，客户端进入 `ESTABLISHED` 状态。待服务器收到客户端发送的 `ACK` 包也会进入 `ESTABLISHED` 状态，完成三次握手。\n    \n\n我们回答时，可以先简单概述 TCP 过程，然后三次握手具体描述时，需要说明状态的基本转换。\n\nTCP 三次握手，其实就是 TCP 应用在发送数据前，通过 TCP 协议跟通信对方协商好连接信息，建立起TCP的连接关系。\n\n我们需要知道，TCP 连接并非是在通信设备两端之间建立信号隧道，而本质上就是双方各自维护所需的状态状态，以达到 TCP 连接的效果。所以 TCP 状态机是 TCP 的核心内容，学习 TCP 一定要搞懂这些状态机之间的转换。\n\n## 二次握手可以吗\n\n> 问：为什么 TCP 采用三次握手，二次握手可以吗？\n\n我们可以从几个方面来解释：\n\n**（一）确认双方的收发能力**\n\nTCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。\n\n_1._ 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n\n_2._ 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。\n\n_3._ 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\n\n所以，只有三次握手才能确认双方的接收与发送能力是否正常。\n\n**（二）序列号可靠同步**\n\n如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。\n\n**（三）阻止重复历史连接的初始化**\n\n客户端由于某种原因发送了两个不同序号的 `SYN` 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 `SYN` 就会立刻建立连接，那么会造成网络异常。\n\n如果是三次握手，服务器需要回复 `SYN+ACK` 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 `RST` 报文，直到正常的 `SYN` 到达服务器后才正常建立连接。\n\n所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。\n\n**（四）安全问题**\n\n我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。\n\nTCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！\n\n## 初始序列号（ISN）\n\n> 问：ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN为何要动态随机？\n\n**ISN 是什么？**\n\n答：`ISN` 全称是 `Initial Sequence Number`，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号\n\n**ISN 是固定不变的吗？**\n\n答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 `RST` 报文，因此 ISN 是动态生成的\n\n## 半连接队列\n\n> 什么是半连接队列？\n\n答：服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。\n\n当然还有一个_全连接队列_，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\n\n## 三次握手可以携带数据吗？\n\n> 问：三次握手过程中，可以携带数据吗？\n\n答：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。\n\n我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。\n\n对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。\n\n## TCP 四次挥手\n\n当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。\n\n![](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/UzARVz.png)\n\n-   第一次挥手。客户端发起 `FIN` 包（FIN = 1）,客户端进入 `FIN_WAIT_1` 状态。TCP 规定，即使 `FIN` 包不携带数据，也要消耗一个序号。\n    \n-   第二次挥手。服务器端收到 `FIN` 包，发出确认包 `ACK`（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 `CLOSE_WAIT` 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 `ACK` 后，进入了 `FIN_WAIT_2` 状态。\n    \n-   第三次挥手。服务器端数据发送完毕后，向客户端发送 `FIN` 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 `LAST_ACK` 状态。\n    \n-   第四次挥手。客户端收到服务器的 `FIN` 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 `TIME_WAIT` 状态。注意此时 TCP 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。\n    \n\n> 问：为什么建立连接握手三次，关闭连接时需要是四次呢？\n\n答：其实在 TCP 握手的时候，接收端发送 `SYN+ACK` 的包是将一个 `ACK` 和一个 `SYN`合并到一个包中，所以减少了一次包的发送，三次完成握手。\n\n对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 `FIN` 包与对客户端的 `ACK` 包合并发送，只能先确认 `ACK`，然后服务器待无需发送数据时再发送 `FIN` 包，所以四次挥手时必须是四次数据包的交互。\n\n> 问：为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？\n\n答：`MSL` 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 `FIN` 的确认包 `ACK` 后，这个 `ACK` 包是有可能不可达的，服务器端如果收不到 `ACK` 的话需要重新发送 `FIN` 包。\n\n所以客户端发送 `ACK` 后需要留出 `2MSL` 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。\n\n也就是说客户端如果等待 `2MSL` 时间也没有收到服务器端的重传包 `FIN`，说明可以确认服务器已经收到客户端发送的 `ACK`。\n\n还有第 _2_ 个理由，避免新旧连接混淆。\n\n在客户端发送完最后一个 `ACK` 报文段后，在经过 `2MSL` 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。\n\n你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。\n\n## 总结\n\n本篇文章以 TCP 三次握手和四次挥手这个经典问题为主题，初步窥探了 TCP 协议的入门知识点，后边会有一系列的文章，来分享 TCP 协议相关的方方面面，如果感兴趣请关注我，我们一起把 TCP 协议彻底搞透彻了。\n\n最后，帮大家总结一下 TCP 的核心知识点。我们知道 TCP 协议是可靠的，它主要是通过解决如下几个问题来保证可靠性的：\n\n-   _乱序_\n    \n-   _丢包_\n    \n-   _流控_\n    \n-   _拥塞控制_\n    \n\nTCP 是一个巨复杂的协议，基本上 TCP 涉及的所有内容都是围绕解决这几个问题的，请务必时刻认真牢记。\n\n","source":"_posts/面试/TCP.md","raw":"---\ntitle: TCP\ndate: 2022-04-05 17:30:27\ntags:\n  - [面试]\n  - [tcp]\ncategories:\n  - [技术]\ndescription: TCP面试常问\n---\n\n# TCP\n\nTCP 的三次握手和四次挥手，可以说是老生常谈的经典问题了，通常也作为各大公司常见的面试考题，具有一定的水平区分度。看似是简单的面试问题，如果你的回答不符合面试官期待的水准，有可能就直接凉凉了。  \n\n本文会围绕，三次握手和四次挥手相关的一些列核心问题，分享如何更准确的回答和应对常见的面试问题，以后面对再刁钻的面试官，你都可以随意地跟他扯皮了。\n\n## 面试TCP的意义\n\n我想要先说明一个重要问题，到底面试 TCP 的意义何在？\n\n经常会听到这样抱怨：我是做业务程序开发的，面试官竟然问我 TCP 三次握手、TCP 拥塞控制的问题，还问的这么细致？\n\n这些同学会觉着面试官是闲的淡疼，或是故意刁难候选人，更有同学认为面试官是为了防止自己技术退步拿来练手的，这种想法我也是醉了。\n\n当然，不同人对此可能会有不同的想法，但我们技术人应该以积极的心态来理解和面对这个问题，在我看来面试 TCP 有重要的意义：\n\n_1._ 从面试官的角度，可以快速考察候选人对基础知识的掌握程度，以及候选人对待技术的那种知其所以然的态度。\n\n_2._ 从求职者的角度，即使工作内容中没有直接用到 TCP 协议，但在遇到网络故障，调试和分析问题时，熟悉 TCP 显得十分重要，要不抓包都看不懂。\n\n_3._ 从学习的角度，我们可以学习 TCP 的设计理念，比如 TCP 重传、拥塞控制，以及如何在性能和原理之间做权衡和取舍的，举一反三，将这些原理细节应用到我们平时的软件设计上，也是一种思维上的学习成长。\n\n_4._ 如果想要调整 TCP 参数来提升传输速度，可服务器上相关的系统参数有几十个，究竟该怎么调整呢？\n\n_5._ 在服务器本地的 TCP 连接状态出现了类似 `fin_wait`、`time_wait`，该怎么解决，是什么原因引起的？如果不懂 TCP，即使别人告诉你解决方案，你也不能够真正理解的。\n\n所以，我们非常有必要认真学习 TCP 协议，对 TCP 熟悉程度，在某种意义上也是你与别人拉开距离的重要标识。\n\n## TCP 基础\n\n这里先帮小伙伴们熟悉和回顾下 TCP 的基本概念，以至于能够更好的理解文章后边的内容。\n\nTCP 其实是非常复杂的协议，我们先聊一些基础的。我们知道 TCP 是一种可靠的协议，它主要通过解决这几个问题来实现可靠性的，分别是：乱序、丢包重传、流控、拥塞控制。通过从图中报文格式的字段，也能够简单了解到 TCP 的相关概念。\n\n![](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/77fiE3.jpeg)\n\n-   TCP 在网络 OSI 七层模型中的第四层，TCP 包是没有 IP 地址的，但有源端口和目的端口，用来标识通信的进程。\n    \n-   `Sequence Number` 是记录包的序号，TCP 会按照报文字节进行编号，它是用来解决包在网络中乱序的问题。\n    \n-   `Acknowledgement Number` 确认序列号，是用于向发送方确认已经收到了哪些包，用来解决不丢包的问题。\n    \n-   `Windows` 也叫 `Advertised-Windows`，也就是著名的滑动窗口，主要是用来解决流控的。\n    \n-   `TCP Flag` 就是包的类型，主要是用于操控 TCP 状态机的。\n    \n\n## 三次握手\n\n**三次握手**是各个公司常见的面试考点。以过来人经验来讲，虽然该问题看似简单，但你还真不一定能够回答的好。\n\n见过比较典型面试问答场景：\n\n> _面试官_：请描述一下三次握手的过程吧    \n> _求职者_：第一次客户端给服务端发送一个报文，第二次是服务器收到包之后，也给客户端应答一个报文，第三次是客户端再给服务器发送一个回复报文，TCP 三次握手成功。   \n> _面试官_：还有吗？   \n> _求职者_：说完了哈，这就是三次握手，很简单的  \n> _面试官_：嗯，我没什么问的了，你还有什么问题吗？\n\n这时求职者紧张的心终于平静了，因为面试官没有深入下去的意思，继续问下去可能也不懂，皆大欢喜！当然本次面试基本上也就 `game over`了。\n\n求职者回答的不正确么？正确，但是回答的过于简单，离面试官的期望的答案还有一定的距离，我们该怎么回答呢？\n\n![](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/uqEjMv.png)\n\nTCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。\n\n-   第一次握手：客户端发送 `SYN` 报文，并进入 `SYN_SENT` 状态，等待服务器的确认；\n    \n-   第二次握手：服务器收到 `SYN` 报文，需要给客户端发送 `ACK` 确认报文，同时服务器也要向客户端发送一个 `SYN` 报文，所以也就是向客户端发送 `SYN + ACK` 报文，此时服务器进入 `SYN_RCVD` 状态；\n    \n-   第三次握手：客户端收到 `SYN + ACK` 报文，向服务器发送确认包，客户端进入 `ESTABLISHED` 状态。待服务器收到客户端发送的 `ACK` 包也会进入 `ESTABLISHED` 状态，完成三次握手。\n    \n\n我们回答时，可以先简单概述 TCP 过程，然后三次握手具体描述时，需要说明状态的基本转换。\n\nTCP 三次握手，其实就是 TCP 应用在发送数据前，通过 TCP 协议跟通信对方协商好连接信息，建立起TCP的连接关系。\n\n我们需要知道，TCP 连接并非是在通信设备两端之间建立信号隧道，而本质上就是双方各自维护所需的状态状态，以达到 TCP 连接的效果。所以 TCP 状态机是 TCP 的核心内容，学习 TCP 一定要搞懂这些状态机之间的转换。\n\n## 二次握手可以吗\n\n> 问：为什么 TCP 采用三次握手，二次握手可以吗？\n\n我们可以从几个方面来解释：\n\n**（一）确认双方的收发能力**\n\nTCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。\n\n_1._ 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n\n_2._ 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。\n\n_3._ 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\n\n所以，只有三次握手才能确认双方的接收与发送能力是否正常。\n\n**（二）序列号可靠同步**\n\n如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。\n\n**（三）阻止重复历史连接的初始化**\n\n客户端由于某种原因发送了两个不同序号的 `SYN` 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 `SYN` 就会立刻建立连接，那么会造成网络异常。\n\n如果是三次握手，服务器需要回复 `SYN+ACK` 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 `RST` 报文，直到正常的 `SYN` 到达服务器后才正常建立连接。\n\n所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。\n\n**（四）安全问题**\n\n我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。\n\nTCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！\n\n## 初始序列号（ISN）\n\n> 问：ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN为何要动态随机？\n\n**ISN 是什么？**\n\n答：`ISN` 全称是 `Initial Sequence Number`，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号\n\n**ISN 是固定不变的吗？**\n\n答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 `RST` 报文，因此 ISN 是动态生成的\n\n## 半连接队列\n\n> 什么是半连接队列？\n\n答：服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。\n\n当然还有一个_全连接队列_，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\n\n## 三次握手可以携带数据吗？\n\n> 问：三次握手过程中，可以携带数据吗？\n\n答：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。\n\n我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。\n\n对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。\n\n## TCP 四次挥手\n\n当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。\n\n![](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/UzARVz.png)\n\n-   第一次挥手。客户端发起 `FIN` 包（FIN = 1）,客户端进入 `FIN_WAIT_1` 状态。TCP 规定，即使 `FIN` 包不携带数据，也要消耗一个序号。\n    \n-   第二次挥手。服务器端收到 `FIN` 包，发出确认包 `ACK`（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 `CLOSE_WAIT` 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 `ACK` 后，进入了 `FIN_WAIT_2` 状态。\n    \n-   第三次挥手。服务器端数据发送完毕后，向客户端发送 `FIN` 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 `LAST_ACK` 状态。\n    \n-   第四次挥手。客户端收到服务器的 `FIN` 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 `TIME_WAIT` 状态。注意此时 TCP 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。\n    \n\n> 问：为什么建立连接握手三次，关闭连接时需要是四次呢？\n\n答：其实在 TCP 握手的时候，接收端发送 `SYN+ACK` 的包是将一个 `ACK` 和一个 `SYN`合并到一个包中，所以减少了一次包的发送，三次完成握手。\n\n对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 `FIN` 包与对客户端的 `ACK` 包合并发送，只能先确认 `ACK`，然后服务器待无需发送数据时再发送 `FIN` 包，所以四次挥手时必须是四次数据包的交互。\n\n> 问：为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？\n\n答：`MSL` 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 `FIN` 的确认包 `ACK` 后，这个 `ACK` 包是有可能不可达的，服务器端如果收不到 `ACK` 的话需要重新发送 `FIN` 包。\n\n所以客户端发送 `ACK` 后需要留出 `2MSL` 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。\n\n也就是说客户端如果等待 `2MSL` 时间也没有收到服务器端的重传包 `FIN`，说明可以确认服务器已经收到客户端发送的 `ACK`。\n\n还有第 _2_ 个理由，避免新旧连接混淆。\n\n在客户端发送完最后一个 `ACK` 报文段后，在经过 `2MSL` 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。\n\n你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。\n\n## 总结\n\n本篇文章以 TCP 三次握手和四次挥手这个经典问题为主题，初步窥探了 TCP 协议的入门知识点，后边会有一系列的文章，来分享 TCP 协议相关的方方面面，如果感兴趣请关注我，我们一起把 TCP 协议彻底搞透彻了。\n\n最后，帮大家总结一下 TCP 的核心知识点。我们知道 TCP 协议是可靠的，它主要是通过解决如下几个问题来保证可靠性的：\n\n-   _乱序_\n    \n-   _丢包_\n    \n-   _流控_\n    \n-   _拥塞控制_\n    \n\nTCP 是一个巨复杂的协议，基本上 TCP 涉及的所有内容都是围绕解决这几个问题的，请务必时刻认真牢记。\n\n","slug":"面试/TCP","published":1,"updated":"2022-08-28T07:38:59.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2j004gscvm7bn40gaw","content":"<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p>TCP 的三次握手和四次挥手，可以说是老生常谈的经典问题了，通常也作为各大公司常见的面试考题，具有一定的水平区分度。看似是简单的面试问题，如果你的回答不符合面试官期待的水准，有可能就直接凉凉了。  </p>\n<p>本文会围绕，三次握手和四次挥手相关的一些列核心问题，分享如何更准确的回答和应对常见的面试问题，以后面对再刁钻的面试官，你都可以随意地跟他扯皮了。</p>\n<h2 id=\"面试TCP的意义\"><a href=\"#面试TCP的意义\" class=\"headerlink\" title=\"面试TCP的意义\"></a>面试TCP的意义</h2><p>我想要先说明一个重要问题，到底面试 TCP 的意义何在？</p>\n<p>经常会听到这样抱怨：我是做业务程序开发的，面试官竟然问我 TCP 三次握手、TCP 拥塞控制的问题，还问的这么细致？</p>\n<p>这些同学会觉着面试官是闲的淡疼，或是故意刁难候选人，更有同学认为面试官是为了防止自己技术退步拿来练手的，这种想法我也是醉了。</p>\n<p>当然，不同人对此可能会有不同的想法，但我们技术人应该以积极的心态来理解和面对这个问题，在我看来面试 TCP 有重要的意义：</p>\n<p><em>1.</em> 从面试官的角度，可以快速考察候选人对基础知识的掌握程度，以及候选人对待技术的那种知其所以然的态度。</p>\n<p><em>2.</em> 从求职者的角度，即使工作内容中没有直接用到 TCP 协议，但在遇到网络故障，调试和分析问题时，熟悉 TCP 显得十分重要，要不抓包都看不懂。</p>\n<p><em>3.</em> 从学习的角度，我们可以学习 TCP 的设计理念，比如 TCP 重传、拥塞控制，以及如何在性能和原理之间做权衡和取舍的，举一反三，将这些原理细节应用到我们平时的软件设计上，也是一种思维上的学习成长。</p>\n<p><em>4.</em> 如果想要调整 TCP 参数来提升传输速度，可服务器上相关的系统参数有几十个，究竟该怎么调整呢？</p>\n<p><em>5.</em> 在服务器本地的 TCP 连接状态出现了类似 <code>fin_wait</code>、<code>time_wait</code>，该怎么解决，是什么原因引起的？如果不懂 TCP，即使别人告诉你解决方案，你也不能够真正理解的。</p>\n<p>所以，我们非常有必要认真学习 TCP 协议，对 TCP 熟悉程度，在某种意义上也是你与别人拉开距离的重要标识。</p>\n<h2 id=\"TCP-基础\"><a href=\"#TCP-基础\" class=\"headerlink\" title=\"TCP 基础\"></a>TCP 基础</h2><p>这里先帮小伙伴们熟悉和回顾下 TCP 的基本概念，以至于能够更好的理解文章后边的内容。</p>\n<p>TCP 其实是非常复杂的协议，我们先聊一些基础的。我们知道 TCP 是一种可靠的协议，它主要通过解决这几个问题来实现可靠性的，分别是：乱序、丢包重传、流控、拥塞控制。通过从图中报文格式的字段，也能够简单了解到 TCP 的相关概念。</p>\n<p><img src=\"https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/77fiE3.jpeg\"></p>\n<ul>\n<li><p>TCP 在网络 OSI 七层模型中的第四层，TCP 包是没有 IP 地址的，但有源端口和目的端口，用来标识通信的进程。</p>\n</li>\n<li><p><code>Sequence Number</code> 是记录包的序号，TCP 会按照报文字节进行编号，它是用来解决包在网络中乱序的问题。</p>\n</li>\n<li><p><code>Acknowledgement Number</code> 确认序列号，是用于向发送方确认已经收到了哪些包，用来解决不丢包的问题。</p>\n</li>\n<li><p><code>Windows</code> 也叫 <code>Advertised-Windows</code>，也就是著名的滑动窗口，主要是用来解决流控的。</p>\n</li>\n<li><p><code>TCP Flag</code> 就是包的类型，主要是用于操控 TCP 状态机的。</p>\n</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><strong>三次握手</strong>是各个公司常见的面试考点。以过来人经验来讲，虽然该问题看似简单，但你还真不一定能够回答的好。</p>\n<p>见过比较典型面试问答场景：</p>\n<blockquote>\n<p>_面试官_：请描述一下三次握手的过程吧<br>_求职者_：第一次客户端给服务端发送一个报文，第二次是服务器收到包之后，也给客户端应答一个报文，第三次是客户端再给服务器发送一个回复报文，TCP 三次握手成功。<br>_面试官_：还有吗？<br>_求职者_：说完了哈，这就是三次握手，很简单的<br>_面试官_：嗯，我没什么问的了，你还有什么问题吗？</p>\n</blockquote>\n<p>这时求职者紧张的心终于平静了，因为面试官没有深入下去的意思，继续问下去可能也不懂，皆大欢喜！当然本次面试基本上也就 <code>game over</code>了。</p>\n<p>求职者回答的不正确么？正确，但是回答的过于简单，离面试官的期望的答案还有一定的距离，我们该怎么回答呢？</p>\n<p><img src=\"https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/uqEjMv.png\"></p>\n<p>TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。</p>\n<ul>\n<li><p>第一次握手：客户端发送 <code>SYN</code> 报文，并进入 <code>SYN_SENT</code> 状态，等待服务器的确认；</p>\n</li>\n<li><p>第二次握手：服务器收到 <code>SYN</code> 报文，需要给客户端发送 <code>ACK</code> 确认报文，同时服务器也要向客户端发送一个 <code>SYN</code> 报文，所以也就是向客户端发送 <code>SYN + ACK</code> 报文，此时服务器进入 <code>SYN_RCVD</code> 状态；</p>\n</li>\n<li><p>第三次握手：客户端收到 <code>SYN + ACK</code> 报文，向服务器发送确认包，客户端进入 <code>ESTABLISHED</code> 状态。待服务器收到客户端发送的 <code>ACK</code> 包也会进入 <code>ESTABLISHED</code> 状态，完成三次握手。</p>\n</li>\n</ul>\n<p>我们回答时，可以先简单概述 TCP 过程，然后三次握手具体描述时，需要说明状态的基本转换。</p>\n<p>TCP 三次握手，其实就是 TCP 应用在发送数据前，通过 TCP 协议跟通信对方协商好连接信息，建立起TCP的连接关系。</p>\n<p>我们需要知道，TCP 连接并非是在通信设备两端之间建立信号隧道，而本质上就是双方各自维护所需的状态状态，以达到 TCP 连接的效果。所以 TCP 状态机是 TCP 的核心内容，学习 TCP 一定要搞懂这些状态机之间的转换。</p>\n<h2 id=\"二次握手可以吗\"><a href=\"#二次握手可以吗\" class=\"headerlink\" title=\"二次握手可以吗\"></a>二次握手可以吗</h2><blockquote>\n<p>问：为什么 TCP 采用三次握手，二次握手可以吗？</p>\n</blockquote>\n<p>我们可以从几个方面来解释：</p>\n<p><strong>（一）确认双方的收发能力</strong></p>\n<p>TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。</p>\n<p><em>1.</em> 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>\n<p><em>2.</em> 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>\n<p><em>3.</em> 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>\n<p>所以，只有三次握手才能确认双方的接收与发送能力是否正常。</p>\n<p><strong>（二）序列号可靠同步</strong></p>\n<p>如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。</p>\n<p><strong>（三）阻止重复历史连接的初始化</strong></p>\n<p>客户端由于某种原因发送了两个不同序号的 <code>SYN</code> 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 <code>SYN</code> 就会立刻建立连接，那么会造成网络异常。</p>\n<p>如果是三次握手，服务器需要回复 <code>SYN+ACK</code> 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 <code>RST</code> 报文，直到正常的 <code>SYN</code> 到达服务器后才正常建立连接。</p>\n<p>所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。</p>\n<p><strong>（四）安全问题</strong></p>\n<p>我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。</p>\n<p>TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！</p>\n<h2 id=\"初始序列号（ISN）\"><a href=\"#初始序列号（ISN）\" class=\"headerlink\" title=\"初始序列号（ISN）\"></a>初始序列号（ISN）</h2><blockquote>\n<p>问：ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN为何要动态随机？</p>\n</blockquote>\n<p><strong>ISN 是什么？</strong></p>\n<p>答：<code>ISN</code> 全称是 <code>Initial Sequence Number</code>，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号</p>\n<p><strong>ISN 是固定不变的吗？</strong></p>\n<p>答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 <code>RST</code> 报文，因此 ISN 是动态生成的</p>\n<h2 id=\"半连接队列\"><a href=\"#半连接队列\" class=\"headerlink\" title=\"半连接队列\"></a>半连接队列</h2><blockquote>\n<p>什么是半连接队列？</p>\n</blockquote>\n<p>答：服务器第一次收到客户端的 <code>SYN</code> 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>\n<p>当然还有一个_全连接队列_，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>\n<h2 id=\"三次握手可以携带数据吗？\"><a href=\"#三次握手可以携带数据吗？\" class=\"headerlink\" title=\"三次握手可以携带数据吗？\"></a>三次握手可以携带数据吗？</h2><blockquote>\n<p>问：三次握手过程中，可以携带数据吗？</p>\n</blockquote>\n<p>答：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>\n<p>我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。</p>\n<p>对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。</p>\n<h2 id=\"TCP-四次挥手\"><a href=\"#TCP-四次挥手\" class=\"headerlink\" title=\"TCP 四次挥手\"></a>TCP 四次挥手</h2><p>当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。</p>\n<p><img src=\"https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/UzARVz.png\"></p>\n<ul>\n<li><p>第一次挥手。客户端发起 <code>FIN</code> 包（FIN &#x3D; 1）,客户端进入 <code>FIN_WAIT_1</code> 状态。TCP 规定，即使 <code>FIN</code> 包不携带数据，也要消耗一个序号。</p>\n</li>\n<li><p>第二次挥手。服务器端收到 <code>FIN</code> 包，发出确认包 <code>ACK</code>（ack &#x3D; u + 1），并带上自己的序号 seq&#x3D;v，服务器端进入了 <code>CLOSE_WAIT</code> 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 <code>ACK</code> 后，进入了 <code>FIN_WAIT_2</code> 状态。</p>\n</li>\n<li><p>第三次挥手。服务器端数据发送完毕后，向客户端发送 <code>FIN</code> 包（seq&#x3D;w ack&#x3D;u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 <code>LAST_ACK</code> 状态。</p>\n</li>\n<li><p>第四次挥手。客户端收到服务器的 <code>FIN</code> 包后，发出确认包（ACK&#x3D;1，ack&#x3D;w+1），此时客户端就进入了 <code>TIME_WAIT</code> 状态。注意此时 TCP 连接还没有释放，必须经过 <code>2*MSL</code> 后，才进入 <code>CLOSED</code> 状态。而服务器端收到客户端的确认包 <code>ACK</code> 后就进入了 <code>CLOSED</code> 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。</p>\n</li>\n</ul>\n<blockquote>\n<p>问：为什么建立连接握手三次，关闭连接时需要是四次呢？</p>\n</blockquote>\n<p>答：其实在 TCP 握手的时候，接收端发送 <code>SYN+ACK</code> 的包是将一个 <code>ACK</code> 和一个 <code>SYN</code>合并到一个包中，所以减少了一次包的发送，三次完成握手。</p>\n<p>对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 <code>FIN</code> 包与对客户端的 <code>ACK</code> 包合并发送，只能先确认 <code>ACK</code>，然后服务器待无需发送数据时再发送 <code>FIN</code> 包，所以四次挥手时必须是四次数据包的交互。</p>\n<blockquote>\n<p>问：为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？</p>\n</blockquote>\n<p>答：<code>MSL</code> 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 <code>FIN</code> 的确认包 <code>ACK</code> 后，这个 <code>ACK</code> 包是有可能不可达的，服务器端如果收不到 <code>ACK</code> 的话需要重新发送 <code>FIN</code> 包。</p>\n<p>所以客户端发送 <code>ACK</code> 后需要留出 <code>2MSL</code> 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。</p>\n<p>也就是说客户端如果等待 <code>2MSL</code> 时间也没有收到服务器端的重传包 <code>FIN</code>，说明可以确认服务器已经收到客户端发送的 <code>ACK</code>。</p>\n<p>还有第 <em>2</em> 个理由，避免新旧连接混淆。</p>\n<p>在客户端发送完最后一个 <code>ACK</code> 报文段后，在经过 <code>2MSL</code> 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。</p>\n<p>你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇文章以 TCP 三次握手和四次挥手这个经典问题为主题，初步窥探了 TCP 协议的入门知识点，后边会有一系列的文章，来分享 TCP 协议相关的方方面面，如果感兴趣请关注我，我们一起把 TCP 协议彻底搞透彻了。</p>\n<p>最后，帮大家总结一下 TCP 的核心知识点。我们知道 TCP 协议是可靠的，它主要是通过解决如下几个问题来保证可靠性的：</p>\n<ul>\n<li><p><em>乱序</em></p>\n</li>\n<li><p><em>丢包</em></p>\n</li>\n<li><p><em>流控</em></p>\n</li>\n<li><p><em>拥塞控制</em></p>\n</li>\n</ul>\n<p>TCP 是一个巨复杂的协议，基本上 TCP 涉及的所有内容都是围绕解决这几个问题的，请务必时刻认真牢记。</p>\n","site":{"data":{}},"wordcount":4808,"excerpt":"","more":"<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p>TCP 的三次握手和四次挥手，可以说是老生常谈的经典问题了，通常也作为各大公司常见的面试考题，具有一定的水平区分度。看似是简单的面试问题，如果你的回答不符合面试官期待的水准，有可能就直接凉凉了。  </p>\n<p>本文会围绕，三次握手和四次挥手相关的一些列核心问题，分享如何更准确的回答和应对常见的面试问题，以后面对再刁钻的面试官，你都可以随意地跟他扯皮了。</p>\n<h2 id=\"面试TCP的意义\"><a href=\"#面试TCP的意义\" class=\"headerlink\" title=\"面试TCP的意义\"></a>面试TCP的意义</h2><p>我想要先说明一个重要问题，到底面试 TCP 的意义何在？</p>\n<p>经常会听到这样抱怨：我是做业务程序开发的，面试官竟然问我 TCP 三次握手、TCP 拥塞控制的问题，还问的这么细致？</p>\n<p>这些同学会觉着面试官是闲的淡疼，或是故意刁难候选人，更有同学认为面试官是为了防止自己技术退步拿来练手的，这种想法我也是醉了。</p>\n<p>当然，不同人对此可能会有不同的想法，但我们技术人应该以积极的心态来理解和面对这个问题，在我看来面试 TCP 有重要的意义：</p>\n<p><em>1.</em> 从面试官的角度，可以快速考察候选人对基础知识的掌握程度，以及候选人对待技术的那种知其所以然的态度。</p>\n<p><em>2.</em> 从求职者的角度，即使工作内容中没有直接用到 TCP 协议，但在遇到网络故障，调试和分析问题时，熟悉 TCP 显得十分重要，要不抓包都看不懂。</p>\n<p><em>3.</em> 从学习的角度，我们可以学习 TCP 的设计理念，比如 TCP 重传、拥塞控制，以及如何在性能和原理之间做权衡和取舍的，举一反三，将这些原理细节应用到我们平时的软件设计上，也是一种思维上的学习成长。</p>\n<p><em>4.</em> 如果想要调整 TCP 参数来提升传输速度，可服务器上相关的系统参数有几十个，究竟该怎么调整呢？</p>\n<p><em>5.</em> 在服务器本地的 TCP 连接状态出现了类似 <code>fin_wait</code>、<code>time_wait</code>，该怎么解决，是什么原因引起的？如果不懂 TCP，即使别人告诉你解决方案，你也不能够真正理解的。</p>\n<p>所以，我们非常有必要认真学习 TCP 协议，对 TCP 熟悉程度，在某种意义上也是你与别人拉开距离的重要标识。</p>\n<h2 id=\"TCP-基础\"><a href=\"#TCP-基础\" class=\"headerlink\" title=\"TCP 基础\"></a>TCP 基础</h2><p>这里先帮小伙伴们熟悉和回顾下 TCP 的基本概念，以至于能够更好的理解文章后边的内容。</p>\n<p>TCP 其实是非常复杂的协议，我们先聊一些基础的。我们知道 TCP 是一种可靠的协议，它主要通过解决这几个问题来实现可靠性的，分别是：乱序、丢包重传、流控、拥塞控制。通过从图中报文格式的字段，也能够简单了解到 TCP 的相关概念。</p>\n<p><img src=\"https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/77fiE3.jpeg\"></p>\n<ul>\n<li><p>TCP 在网络 OSI 七层模型中的第四层，TCP 包是没有 IP 地址的，但有源端口和目的端口，用来标识通信的进程。</p>\n</li>\n<li><p><code>Sequence Number</code> 是记录包的序号，TCP 会按照报文字节进行编号，它是用来解决包在网络中乱序的问题。</p>\n</li>\n<li><p><code>Acknowledgement Number</code> 确认序列号，是用于向发送方确认已经收到了哪些包，用来解决不丢包的问题。</p>\n</li>\n<li><p><code>Windows</code> 也叫 <code>Advertised-Windows</code>，也就是著名的滑动窗口，主要是用来解决流控的。</p>\n</li>\n<li><p><code>TCP Flag</code> 就是包的类型，主要是用于操控 TCP 状态机的。</p>\n</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><strong>三次握手</strong>是各个公司常见的面试考点。以过来人经验来讲，虽然该问题看似简单，但你还真不一定能够回答的好。</p>\n<p>见过比较典型面试问答场景：</p>\n<blockquote>\n<p>_面试官_：请描述一下三次握手的过程吧<br>_求职者_：第一次客户端给服务端发送一个报文，第二次是服务器收到包之后，也给客户端应答一个报文，第三次是客户端再给服务器发送一个回复报文，TCP 三次握手成功。<br>_面试官_：还有吗？<br>_求职者_：说完了哈，这就是三次握手，很简单的<br>_面试官_：嗯，我没什么问的了，你还有什么问题吗？</p>\n</blockquote>\n<p>这时求职者紧张的心终于平静了，因为面试官没有深入下去的意思，继续问下去可能也不懂，皆大欢喜！当然本次面试基本上也就 <code>game over</code>了。</p>\n<p>求职者回答的不正确么？正确，但是回答的过于简单，离面试官的期望的答案还有一定的距离，我们该怎么回答呢？</p>\n<p><img src=\"https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/uqEjMv.png\"></p>\n<p>TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。</p>\n<ul>\n<li><p>第一次握手：客户端发送 <code>SYN</code> 报文，并进入 <code>SYN_SENT</code> 状态，等待服务器的确认；</p>\n</li>\n<li><p>第二次握手：服务器收到 <code>SYN</code> 报文，需要给客户端发送 <code>ACK</code> 确认报文，同时服务器也要向客户端发送一个 <code>SYN</code> 报文，所以也就是向客户端发送 <code>SYN + ACK</code> 报文，此时服务器进入 <code>SYN_RCVD</code> 状态；</p>\n</li>\n<li><p>第三次握手：客户端收到 <code>SYN + ACK</code> 报文，向服务器发送确认包，客户端进入 <code>ESTABLISHED</code> 状态。待服务器收到客户端发送的 <code>ACK</code> 包也会进入 <code>ESTABLISHED</code> 状态，完成三次握手。</p>\n</li>\n</ul>\n<p>我们回答时，可以先简单概述 TCP 过程，然后三次握手具体描述时，需要说明状态的基本转换。</p>\n<p>TCP 三次握手，其实就是 TCP 应用在发送数据前，通过 TCP 协议跟通信对方协商好连接信息，建立起TCP的连接关系。</p>\n<p>我们需要知道，TCP 连接并非是在通信设备两端之间建立信号隧道，而本质上就是双方各自维护所需的状态状态，以达到 TCP 连接的效果。所以 TCP 状态机是 TCP 的核心内容，学习 TCP 一定要搞懂这些状态机之间的转换。</p>\n<h2 id=\"二次握手可以吗\"><a href=\"#二次握手可以吗\" class=\"headerlink\" title=\"二次握手可以吗\"></a>二次握手可以吗</h2><blockquote>\n<p>问：为什么 TCP 采用三次握手，二次握手可以吗？</p>\n</blockquote>\n<p>我们可以从几个方面来解释：</p>\n<p><strong>（一）确认双方的收发能力</strong></p>\n<p>TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。</p>\n<p><em>1.</em> 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>\n<p><em>2.</em> 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>\n<p><em>3.</em> 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>\n<p>所以，只有三次握手才能确认双方的接收与发送能力是否正常。</p>\n<p><strong>（二）序列号可靠同步</strong></p>\n<p>如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。</p>\n<p><strong>（三）阻止重复历史连接的初始化</strong></p>\n<p>客户端由于某种原因发送了两个不同序号的 <code>SYN</code> 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 <code>SYN</code> 就会立刻建立连接，那么会造成网络异常。</p>\n<p>如果是三次握手，服务器需要回复 <code>SYN+ACK</code> 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 <code>RST</code> 报文，直到正常的 <code>SYN</code> 到达服务器后才正常建立连接。</p>\n<p>所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。</p>\n<p><strong>（四）安全问题</strong></p>\n<p>我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。</p>\n<p>TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！</p>\n<h2 id=\"初始序列号（ISN）\"><a href=\"#初始序列号（ISN）\" class=\"headerlink\" title=\"初始序列号（ISN）\"></a>初始序列号（ISN）</h2><blockquote>\n<p>问：ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN为何要动态随机？</p>\n</blockquote>\n<p><strong>ISN 是什么？</strong></p>\n<p>答：<code>ISN</code> 全称是 <code>Initial Sequence Number</code>，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号</p>\n<p><strong>ISN 是固定不变的吗？</strong></p>\n<p>答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 <code>RST</code> 报文，因此 ISN 是动态生成的</p>\n<h2 id=\"半连接队列\"><a href=\"#半连接队列\" class=\"headerlink\" title=\"半连接队列\"></a>半连接队列</h2><blockquote>\n<p>什么是半连接队列？</p>\n</blockquote>\n<p>答：服务器第一次收到客户端的 <code>SYN</code> 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>\n<p>当然还有一个_全连接队列_，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>\n<h2 id=\"三次握手可以携带数据吗？\"><a href=\"#三次握手可以携带数据吗？\" class=\"headerlink\" title=\"三次握手可以携带数据吗？\"></a>三次握手可以携带数据吗？</h2><blockquote>\n<p>问：三次握手过程中，可以携带数据吗？</p>\n</blockquote>\n<p>答：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>\n<p>我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。</p>\n<p>对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。</p>\n<h2 id=\"TCP-四次挥手\"><a href=\"#TCP-四次挥手\" class=\"headerlink\" title=\"TCP 四次挥手\"></a>TCP 四次挥手</h2><p>当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。</p>\n<p><img src=\"https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/3/UzARVz.png\"></p>\n<ul>\n<li><p>第一次挥手。客户端发起 <code>FIN</code> 包（FIN &#x3D; 1）,客户端进入 <code>FIN_WAIT_1</code> 状态。TCP 规定，即使 <code>FIN</code> 包不携带数据，也要消耗一个序号。</p>\n</li>\n<li><p>第二次挥手。服务器端收到 <code>FIN</code> 包，发出确认包 <code>ACK</code>（ack &#x3D; u + 1），并带上自己的序号 seq&#x3D;v，服务器端进入了 <code>CLOSE_WAIT</code> 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 <code>ACK</code> 后，进入了 <code>FIN_WAIT_2</code> 状态。</p>\n</li>\n<li><p>第三次挥手。服务器端数据发送完毕后，向客户端发送 <code>FIN</code> 包（seq&#x3D;w ack&#x3D;u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 <code>LAST_ACK</code> 状态。</p>\n</li>\n<li><p>第四次挥手。客户端收到服务器的 <code>FIN</code> 包后，发出确认包（ACK&#x3D;1，ack&#x3D;w+1），此时客户端就进入了 <code>TIME_WAIT</code> 状态。注意此时 TCP 连接还没有释放，必须经过 <code>2*MSL</code> 后，才进入 <code>CLOSED</code> 状态。而服务器端收到客户端的确认包 <code>ACK</code> 后就进入了 <code>CLOSED</code> 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。</p>\n</li>\n</ul>\n<blockquote>\n<p>问：为什么建立连接握手三次，关闭连接时需要是四次呢？</p>\n</blockquote>\n<p>答：其实在 TCP 握手的时候，接收端发送 <code>SYN+ACK</code> 的包是将一个 <code>ACK</code> 和一个 <code>SYN</code>合并到一个包中，所以减少了一次包的发送，三次完成握手。</p>\n<p>对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 <code>FIN</code> 包与对客户端的 <code>ACK</code> 包合并发送，只能先确认 <code>ACK</code>，然后服务器待无需发送数据时再发送 <code>FIN</code> 包，所以四次挥手时必须是四次数据包的交互。</p>\n<blockquote>\n<p>问：为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？</p>\n</blockquote>\n<p>答：<code>MSL</code> 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 <code>FIN</code> 的确认包 <code>ACK</code> 后，这个 <code>ACK</code> 包是有可能不可达的，服务器端如果收不到 <code>ACK</code> 的话需要重新发送 <code>FIN</code> 包。</p>\n<p>所以客户端发送 <code>ACK</code> 后需要留出 <code>2MSL</code> 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。</p>\n<p>也就是说客户端如果等待 <code>2MSL</code> 时间也没有收到服务器端的重传包 <code>FIN</code>，说明可以确认服务器已经收到客户端发送的 <code>ACK</code>。</p>\n<p>还有第 <em>2</em> 个理由，避免新旧连接混淆。</p>\n<p>在客户端发送完最后一个 <code>ACK</code> 报文段后，在经过 <code>2MSL</code> 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。</p>\n<p>你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇文章以 TCP 三次握手和四次挥手这个经典问题为主题，初步窥探了 TCP 协议的入门知识点，后边会有一系列的文章，来分享 TCP 协议相关的方方面面，如果感兴趣请关注我，我们一起把 TCP 协议彻底搞透彻了。</p>\n<p>最后，帮大家总结一下 TCP 的核心知识点。我们知道 TCP 协议是可靠的，它主要是通过解决如下几个问题来保证可靠性的：</p>\n<ul>\n<li><p><em>乱序</em></p>\n</li>\n<li><p><em>丢包</em></p>\n</li>\n<li><p><em>流控</em></p>\n</li>\n<li><p><em>拥塞控制</em></p>\n</li>\n</ul>\n<p>TCP 是一个巨复杂的协议，基本上 TCP 涉及的所有内容都是围绕解决这几个问题的，请务必时刻认真牢记。</p>\n"},{"title":"面试题","date":"2022-04-05T09:30:27.000Z","description":"面试常问","_content":"\n## （简答题）请简述一下你对前端工程化的理解（300字以内）\n\n如果以以前的逻辑前端三件套（html、css、js），当一个项目在越做越大的过程中，本身会极其容易产生冗余代码。如今一个项目的前端已经不可能是会jquery行天下了。\n在更多人一起合作做一个项目的过程中，基于大家要相互配合，更讲究的是模块化，组件化，通过模块与组件的复用来大大地提高项目的开发效率。且不说现在ES规范本身已经有了模块的导入导出方法，在之前还没有官方规范之前，便已经存在各种各样的模块引入导出规范，CommonJs便是一个显而易见的例子，如今的很多npm包中require依然是很常见的引入方式。无论是模块化还是组件化，都大大降低了代码的冗余，同时提高了多人协同开发的效率，减少了不必要的重复造轮子的时间浪费。\n同时，在如今的框架盛行的情况下，无论是Vue、React这些前端框架，还是Webpack、Vite这些打包框架，都有着自己的一套规范，这里能够深刻体会到规范的重要性，较好的规范，比如文件目录的配置，参数的配置，API的设计，都能够大大的降低学习成本以及理解成本，从而更好的上手项目，进行实践。\n\n## （简答题）请简述一下你在前端不同方向(WebGL、小程序、WebAssembly、跨端等)所做的技术尝试（300字以内）\n在小程序方面：由于创业项目本身就是基于小程序起家的，所以在小程序方面有着较深的耕耘，对其框架、代码结构、API都有比较多的了解和学习以及实践。\n在跨端方面：从Web适配不同终端的角度来讲，比较常用到的是@media来判断是何种设备以及其宽高，并基于此来做响应式调整css样式。从一套代码多种终端来讲，尝试过Flutter和uniapp，uniapp个人感觉在小程序方面的性能表现还不错的，Flutter的话只初步尝试过一下，做了个简单的天气Demo（还是自己用Django粗略搭的一个后端服务=。=），当然不得不说一句，dart语言的代码结构实在是太容易让人诟病了（无限套娃）。这一部分由于时间和精力因素没有比较深入的学习探索。\nAPP方面：基于兴趣爱好，订阅了苹果的开发者账号，并在100Days of Swift上学习了一阵子，个人感觉苹果的一套自家的UI确实很简单又好看0.0，使用起来也很好操作，除了和dart语言一样有着代码格式较为混乱的问题。","source":"_posts/面试/面试题.md","raw":"---\ntitle: 面试题\ndate: 2022-04-05 17:30:27\ntags:\n  - [面试]\ncategories:\n  - [技术] \ndescription: 面试常问\n---\n\n## （简答题）请简述一下你对前端工程化的理解（300字以内）\n\n如果以以前的逻辑前端三件套（html、css、js），当一个项目在越做越大的过程中，本身会极其容易产生冗余代码。如今一个项目的前端已经不可能是会jquery行天下了。\n在更多人一起合作做一个项目的过程中，基于大家要相互配合，更讲究的是模块化，组件化，通过模块与组件的复用来大大地提高项目的开发效率。且不说现在ES规范本身已经有了模块的导入导出方法，在之前还没有官方规范之前，便已经存在各种各样的模块引入导出规范，CommonJs便是一个显而易见的例子，如今的很多npm包中require依然是很常见的引入方式。无论是模块化还是组件化，都大大降低了代码的冗余，同时提高了多人协同开发的效率，减少了不必要的重复造轮子的时间浪费。\n同时，在如今的框架盛行的情况下，无论是Vue、React这些前端框架，还是Webpack、Vite这些打包框架，都有着自己的一套规范，这里能够深刻体会到规范的重要性，较好的规范，比如文件目录的配置，参数的配置，API的设计，都能够大大的降低学习成本以及理解成本，从而更好的上手项目，进行实践。\n\n## （简答题）请简述一下你在前端不同方向(WebGL、小程序、WebAssembly、跨端等)所做的技术尝试（300字以内）\n在小程序方面：由于创业项目本身就是基于小程序起家的，所以在小程序方面有着较深的耕耘，对其框架、代码结构、API都有比较多的了解和学习以及实践。\n在跨端方面：从Web适配不同终端的角度来讲，比较常用到的是@media来判断是何种设备以及其宽高，并基于此来做响应式调整css样式。从一套代码多种终端来讲，尝试过Flutter和uniapp，uniapp个人感觉在小程序方面的性能表现还不错的，Flutter的话只初步尝试过一下，做了个简单的天气Demo（还是自己用Django粗略搭的一个后端服务=。=），当然不得不说一句，dart语言的代码结构实在是太容易让人诟病了（无限套娃）。这一部分由于时间和精力因素没有比较深入的学习探索。\nAPP方面：基于兴趣爱好，订阅了苹果的开发者账号，并在100Days of Swift上学习了一阵子，个人感觉苹果的一套自家的UI确实很简单又好看0.0，使用起来也很好操作，除了和dart语言一样有着代码格式较为混乱的问题。","slug":"面试/面试题","published":1,"updated":"2022-08-28T07:38:59.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2j004jscvm8czhfjg9","content":"<h2 id=\"（简答题）请简述一下你对前端工程化的理解（300字以内）\"><a href=\"#（简答题）请简述一下你对前端工程化的理解（300字以内）\" class=\"headerlink\" title=\"（简答题）请简述一下你对前端工程化的理解（300字以内）\"></a>（简答题）请简述一下你对前端工程化的理解（300字以内）</h2><p>如果以以前的逻辑前端三件套（html、css、js），当一个项目在越做越大的过程中，本身会极其容易产生冗余代码。如今一个项目的前端已经不可能是会jquery行天下了。<br>在更多人一起合作做一个项目的过程中，基于大家要相互配合，更讲究的是模块化，组件化，通过模块与组件的复用来大大地提高项目的开发效率。且不说现在ES规范本身已经有了模块的导入导出方法，在之前还没有官方规范之前，便已经存在各种各样的模块引入导出规范，CommonJs便是一个显而易见的例子，如今的很多npm包中require依然是很常见的引入方式。无论是模块化还是组件化，都大大降低了代码的冗余，同时提高了多人协同开发的效率，减少了不必要的重复造轮子的时间浪费。<br>同时，在如今的框架盛行的情况下，无论是Vue、React这些前端框架，还是Webpack、Vite这些打包框架，都有着自己的一套规范，这里能够深刻体会到规范的重要性，较好的规范，比如文件目录的配置，参数的配置，API的设计，都能够大大的降低学习成本以及理解成本，从而更好的上手项目，进行实践。</p>\n<h2 id=\"（简答题）请简述一下你在前端不同方向-WebGL、小程序、WebAssembly、跨端等-所做的技术尝试（300字以内）\"><a href=\"#（简答题）请简述一下你在前端不同方向-WebGL、小程序、WebAssembly、跨端等-所做的技术尝试（300字以内）\" class=\"headerlink\" title=\"（简答题）请简述一下你在前端不同方向(WebGL、小程序、WebAssembly、跨端等)所做的技术尝试（300字以内）\"></a>（简答题）请简述一下你在前端不同方向(WebGL、小程序、WebAssembly、跨端等)所做的技术尝试（300字以内）</h2><p>在小程序方面：由于创业项目本身就是基于小程序起家的，所以在小程序方面有着较深的耕耘，对其框架、代码结构、API都有比较多的了解和学习以及实践。<br>在跨端方面：从Web适配不同终端的角度来讲，比较常用到的是@media来判断是何种设备以及其宽高，并基于此来做响应式调整css样式。从一套代码多种终端来讲，尝试过Flutter和uniapp，uniapp个人感觉在小程序方面的性能表现还不错的，Flutter的话只初步尝试过一下，做了个简单的天气Demo（还是自己用Django粗略搭的一个后端服务&#x3D;。&#x3D;），当然不得不说一句，dart语言的代码结构实在是太容易让人诟病了（无限套娃）。这一部分由于时间和精力因素没有比较深入的学习探索。<br>APP方面：基于兴趣爱好，订阅了苹果的开发者账号，并在100Days of Swift上学习了一阵子，个人感觉苹果的一套自家的UI确实很简单又好看0.0，使用起来也很好操作，除了和dart语言一样有着代码格式较为混乱的问题。</p>\n","site":{"data":{}},"wordcount":978,"excerpt":"","more":"<h2 id=\"（简答题）请简述一下你对前端工程化的理解（300字以内）\"><a href=\"#（简答题）请简述一下你对前端工程化的理解（300字以内）\" class=\"headerlink\" title=\"（简答题）请简述一下你对前端工程化的理解（300字以内）\"></a>（简答题）请简述一下你对前端工程化的理解（300字以内）</h2><p>如果以以前的逻辑前端三件套（html、css、js），当一个项目在越做越大的过程中，本身会极其容易产生冗余代码。如今一个项目的前端已经不可能是会jquery行天下了。<br>在更多人一起合作做一个项目的过程中，基于大家要相互配合，更讲究的是模块化，组件化，通过模块与组件的复用来大大地提高项目的开发效率。且不说现在ES规范本身已经有了模块的导入导出方法，在之前还没有官方规范之前，便已经存在各种各样的模块引入导出规范，CommonJs便是一个显而易见的例子，如今的很多npm包中require依然是很常见的引入方式。无论是模块化还是组件化，都大大降低了代码的冗余，同时提高了多人协同开发的效率，减少了不必要的重复造轮子的时间浪费。<br>同时，在如今的框架盛行的情况下，无论是Vue、React这些前端框架，还是Webpack、Vite这些打包框架，都有着自己的一套规范，这里能够深刻体会到规范的重要性，较好的规范，比如文件目录的配置，参数的配置，API的设计，都能够大大的降低学习成本以及理解成本，从而更好的上手项目，进行实践。</p>\n<h2 id=\"（简答题）请简述一下你在前端不同方向-WebGL、小程序、WebAssembly、跨端等-所做的技术尝试（300字以内）\"><a href=\"#（简答题）请简述一下你在前端不同方向-WebGL、小程序、WebAssembly、跨端等-所做的技术尝试（300字以内）\" class=\"headerlink\" title=\"（简答题）请简述一下你在前端不同方向(WebGL、小程序、WebAssembly、跨端等)所做的技术尝试（300字以内）\"></a>（简答题）请简述一下你在前端不同方向(WebGL、小程序、WebAssembly、跨端等)所做的技术尝试（300字以内）</h2><p>在小程序方面：由于创业项目本身就是基于小程序起家的，所以在小程序方面有着较深的耕耘，对其框架、代码结构、API都有比较多的了解和学习以及实践。<br>在跨端方面：从Web适配不同终端的角度来讲，比较常用到的是@media来判断是何种设备以及其宽高，并基于此来做响应式调整css样式。从一套代码多种终端来讲，尝试过Flutter和uniapp，uniapp个人感觉在小程序方面的性能表现还不错的，Flutter的话只初步尝试过一下，做了个简单的天气Demo（还是自己用Django粗略搭的一个后端服务&#x3D;。&#x3D;），当然不得不说一句，dart语言的代码结构实在是太容易让人诟病了（无限套娃）。这一部分由于时间和精力因素没有比较深入的学习探索。<br>APP方面：基于兴趣爱好，订阅了苹果的开发者账号，并在100Days of Swift上学习了一阵子，个人感觉苹果的一套自家的UI确实很简单又好看0.0，使用起来也很好操作，除了和dart语言一样有着代码格式较为混乱的问题。</p>\n"},{"title":"Django","date":"2022-04-05T05:17:27.000Z","description":"Django相关文档","_content":"\n## 官方文档（含教程）\n\n[Django](https://www.djangoproject.com/)\n\n[Home - Django REST framework](https://www.django-rest-framework.org/)\n\n## 基本操作（终端中执行）\n\n新建一个Django项目\n\n```bash\ndjango-admin startproject mysite\n```\n\n新建一个接口组\n\n```bash\ndjango-admin startapp test_app\n```\n\n启动Django项目\n\n```bash\npython manage.py runserver\n```\n\n创建管理员账户\n\n```bash\npython manage.py createsuperuser\n```\n\n## rest_framework\n\n```python\nINSTALLED_APPS = [\n\t\t'rest_framework', #增加这一行\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n```\n\n## 解决时区问题\n\n在`settings.py`中修改\n\n```python\nTIME_ZONE = 'Asia/Shanghai' #时区改成上海\n# USE_TZ = True #这行注释\n```\n\n## 解决跨域\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n\nMIDDLEWARE = [\n\t\t#中间件修改成如下\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n```\n\n## Django默认样式不好看\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'simpleui', #增加这一行\n    'mall.apps.MallConfig',\n    'rest_framework',\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n```\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n```python\n# 去掉默认Logo或换成自己Logo链接\nSIMPLEUI_LOGO = '<https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png>'\n# 默认语言换成中文\nLANGUAGE_CODE = 'zh-hans'\n```\n\n## Django的时间返回中间带`T`\n\n`settings.py`中增加如下配置\n\n```python\nREST_FRAMEWORK = {\n    'DATETIME_FORMAT': \"%Y-%m-%d %H:%M:%S\",\n}\n```","source":"_posts/Server/Django/index.md","raw":"---\ntitle: Django\ndate: 2022-04-05 13:17:27\ntags:\n  - [django]\ncategories:\n  - [技术]\ndescription: Django相关文档\n\n---\n\n## 官方文档（含教程）\n\n[Django](https://www.djangoproject.com/)\n\n[Home - Django REST framework](https://www.django-rest-framework.org/)\n\n## 基本操作（终端中执行）\n\n新建一个Django项目\n\n```bash\ndjango-admin startproject mysite\n```\n\n新建一个接口组\n\n```bash\ndjango-admin startapp test_app\n```\n\n启动Django项目\n\n```bash\npython manage.py runserver\n```\n\n创建管理员账户\n\n```bash\npython manage.py createsuperuser\n```\n\n## rest_framework\n\n```python\nINSTALLED_APPS = [\n\t\t'rest_framework', #增加这一行\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n```\n\n## 解决时区问题\n\n在`settings.py`中修改\n\n```python\nTIME_ZONE = 'Asia/Shanghai' #时区改成上海\n# USE_TZ = True #这行注释\n```\n\n## 解决跨域\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n\nMIDDLEWARE = [\n\t\t#中间件修改成如下\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n```\n\n## Django默认样式不好看\n\n在`settings.py`中修改\n\n```python\nINSTALLED_APPS = [\n    'simpleui', #增加这一行\n    'mall.apps.MallConfig',\n    'rest_framework',\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'corsheaders',  # 这里增加允许跨域请求头配置\n]\n```\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n```python\n# 去掉默认Logo或换成自己Logo链接\nSIMPLEUI_LOGO = '<https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png>'\n# 默认语言换成中文\nLANGUAGE_CODE = 'zh-hans'\n```\n\n## Django的时间返回中间带`T`\n\n`settings.py`中增加如下配置\n\n```python\nREST_FRAMEWORK = {\n    'DATETIME_FORMAT': \"%Y-%m-%d %H:%M:%S\",\n}\n```","slug":"Server/Django/index","published":1,"updated":"2022-08-28T07:38:59.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2k004oscvmdjoj6joj","content":"<h2 id=\"官方文档（含教程）\"><a href=\"#官方文档（含教程）\" class=\"headerlink\" title=\"官方文档（含教程）\"></a>官方文档（含教程）</h2><p><a href=\"https://www.djangoproject.com/\">Django</a></p>\n<p><a href=\"https://www.django-rest-framework.org/\">Home - Django REST framework</a></p>\n<h2 id=\"基本操作（终端中执行）\"><a href=\"#基本操作（终端中执行）\" class=\"headerlink\" title=\"基本操作（终端中执行）\"></a>基本操作（终端中执行）</h2><p>新建一个Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startproject mysite<br></code></pre></td></tr></table></figure>\n\n<p>新建一个接口组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startapp test_app<br></code></pre></td></tr></table></figure>\n\n<p>启动Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py runserver<br></code></pre></td></tr></table></figure>\n\n<p>创建管理员账户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py createsuperuser<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"rest-framework\"><a href=\"#rest-framework\" class=\"headerlink\" title=\"rest_framework\"></a>rest_framework</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>\t\t<span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决时区问题\"><a href=\"#解决时区问题\" class=\"headerlink\" title=\"解决时区问题\"></a>解决时区问题</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">TIME_ZONE = <span class=\"hljs-string\">&#x27;Asia/Shanghai&#x27;</span> <span class=\"hljs-comment\">#时区改成上海</span><br><span class=\"hljs-comment\"># USE_TZ = True #这行注释</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决跨域\"><a href=\"#解决跨域\" class=\"headerlink\" title=\"解决跨域\"></a>解决跨域</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br><br>MIDDLEWARE = [<br>\t\t<span class=\"hljs-comment\">#中间件修改成如下</span><br>    <span class=\"hljs-string\">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django默认样式不好看\"><a href=\"#Django默认样式不好看\" class=\"headerlink\" title=\"Django默认样式不好看\"></a>Django默认样式不好看</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;simpleui&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;mall.apps.MallConfig&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br></code></pre></td></tr></table></figure>\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 去掉默认Logo或换成自己Logo链接</span><br>SIMPLEUI_LOGO = <span class=\"hljs-string\">&#x27;&lt;https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png&gt;&#x27;</span><br><span class=\"hljs-comment\"># 默认语言换成中文</span><br>LANGUAGE_CODE = <span class=\"hljs-string\">&#x27;zh-hans&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django的时间返回中间带T\"><a href=\"#Django的时间返回中间带T\" class=\"headerlink\" title=\"Django的时间返回中间带T\"></a>Django的时间返回中间带<code>T</code></h2><p><code>settings.py</code>中增加如下配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">REST_FRAMEWORK = &#123;<br>    <span class=\"hljs-string\">&#x27;DATETIME_FORMAT&#x27;</span>: <span class=\"hljs-string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":2123,"excerpt":"","more":"<h2 id=\"官方文档（含教程）\"><a href=\"#官方文档（含教程）\" class=\"headerlink\" title=\"官方文档（含教程）\"></a>官方文档（含教程）</h2><p><a href=\"https://www.djangoproject.com/\">Django</a></p>\n<p><a href=\"https://www.django-rest-framework.org/\">Home - Django REST framework</a></p>\n<h2 id=\"基本操作（终端中执行）\"><a href=\"#基本操作（终端中执行）\" class=\"headerlink\" title=\"基本操作（终端中执行）\"></a>基本操作（终端中执行）</h2><p>新建一个Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startproject mysite<br></code></pre></td></tr></table></figure>\n\n<p>新建一个接口组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">django-admin startapp test_app<br></code></pre></td></tr></table></figure>\n\n<p>启动Django项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py runserver<br></code></pre></td></tr></table></figure>\n\n<p>创建管理员账户</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python manage.py createsuperuser<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"rest-framework\"><a href=\"#rest-framework\" class=\"headerlink\" title=\"rest_framework\"></a>rest_framework</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>\t\t<span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决时区问题\"><a href=\"#解决时区问题\" class=\"headerlink\" title=\"解决时区问题\"></a>解决时区问题</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">TIME_ZONE = <span class=\"hljs-string\">&#x27;Asia/Shanghai&#x27;</span> <span class=\"hljs-comment\">#时区改成上海</span><br><span class=\"hljs-comment\"># USE_TZ = True #这行注释</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解决跨域\"><a href=\"#解决跨域\" class=\"headerlink\" title=\"解决跨域\"></a>解决跨域</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br><br>MIDDLEWARE = [<br>\t\t<span class=\"hljs-comment\">#中间件修改成如下</span><br>    <span class=\"hljs-string\">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django默认样式不好看\"><a href=\"#Django默认样式不好看\" class=\"headerlink\" title=\"Django默认样式不好看\"></a>Django默认样式不好看</h2><p>在<code>settings.py</code>中修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">INSTALLED_APPS = [<br>    <span class=\"hljs-string\">&#x27;simpleui&#x27;</span>, <span class=\"hljs-comment\">#增加这一行</span><br>    <span class=\"hljs-string\">&#x27;mall.apps.MallConfig&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;rest_framework&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;django.contrib.staticfiles&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;corsheaders&#x27;</span>,  <span class=\"hljs-comment\"># 这里增加允许跨域请求头配置</span><br>]<br></code></pre></td></tr></table></figure>\n\n<aside> 💡 simpleui的一些基本配置⬇️，在`settings.py`中增加\n\n</aside>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 去掉默认Logo或换成自己Logo链接</span><br>SIMPLEUI_LOGO = <span class=\"hljs-string\">&#x27;&lt;https://cdn.jsdelivr.net/gh/Alndaly/imgsrc/img/202109211712667.png&gt;&#x27;</span><br><span class=\"hljs-comment\"># 默认语言换成中文</span><br>LANGUAGE_CODE = <span class=\"hljs-string\">&#x27;zh-hans&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Django的时间返回中间带T\"><a href=\"#Django的时间返回中间带T\" class=\"headerlink\" title=\"Django的时间返回中间带T\"></a>Django的时间返回中间带<code>T</code></h2><p><code>settings.py</code>中增加如下配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">REST_FRAMEWORK = &#123;<br>    <span class=\"hljs-string\">&#x27;DATETIME_FORMAT&#x27;</span>: <span class=\"hljs-string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"Nginx转发后会默认会自动去掉请求头中带有下划线的参数","date":"2022-04-05T03:35:19.000Z","description":"Nginx相关文档","_content":"\n## Nginx转发后会默认会自动去掉请求头中带有下划线的参数\n解决方法如下：\n\n在nginx里的nginx.conf配置文件中的http部分中添加如下配置：\n> 记得带上结尾的分号！\n```conf\nunderscores_in_headers on; （默认 underscores_in_headers 为off）\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716093635506.png)","source":"_posts/Server/Nginx/Nginx.md","raw":"---\ntitle: Nginx转发后会默认会自动去掉请求头中带有下划线的参数\ndate: 2022-04-05 11:35:19\ntags:\n  - [nginx]\ncategories:\n  - [技术]\ndescription: Nginx相关文档\n---\n\n## Nginx转发后会默认会自动去掉请求头中带有下划线的参数\n解决方法如下：\n\n在nginx里的nginx.conf配置文件中的http部分中添加如下配置：\n> 记得带上结尾的分号！\n```conf\nunderscores_in_headers on; （默认 underscores_in_headers 为off）\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716093635506.png)","slug":"Server/Nginx/Nginx","published":1,"updated":"2022-08-28T07:38:59.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2l004rscvm61bj7zhn","content":"<h2 id=\"Nginx转发后会默认会自动去掉请求头中带有下划线的参数\"><a href=\"#Nginx转发后会默认会自动去掉请求头中带有下划线的参数\" class=\"headerlink\" title=\"Nginx转发后会默认会自动去掉请求头中带有下划线的参数\"></a>Nginx转发后会默认会自动去掉请求头中带有下划线的参数</h2><p>解决方法如下：</p>\n<p>在nginx里的nginx.conf配置文件中的http部分中添加如下配置：</p>\n<blockquote>\n<p>记得带上结尾的分号！</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs conf\">underscores_in_headers on; （默认 underscores_in_headers 为off）<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20200716093635506.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"wordcount":139,"excerpt":"","more":"<h2 id=\"Nginx转发后会默认会自动去掉请求头中带有下划线的参数\"><a href=\"#Nginx转发后会默认会自动去掉请求头中带有下划线的参数\" class=\"headerlink\" title=\"Nginx转发后会默认会自动去掉请求头中带有下划线的参数\"></a>Nginx转发后会默认会自动去掉请求头中带有下划线的参数</h2><p>解决方法如下：</p>\n<p>在nginx里的nginx.conf配置文件中的http部分中添加如下配置：</p>\n<blockquote>\n<p>记得带上结尾的分号！</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs conf\">underscores_in_headers on; （默认 underscores_in_headers 为off）<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20200716093635506.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"Nginx详解","date":"2022-04-05T03:36:04.000Z","description":"Nginx相关文档","_content":"\nNginx联合创始人安德鲁·阿列克谢夫（Andrew Alexeev）曾说：Nginx是为对Apache性能不满意的人而构建的。随着Internet需求的变化，Web服务器的工作也在变化。Nginx的构建比以往任何时候都更有效率，更可扩展，更安全，更强大。\n\n本文提供了Nginx的基本概念及知识。以开发者必备的Nginx基础知识为主，罗列了一些Nginx教程，希望对大家有所帮助。**免费Nginx学习资料见文末！**\n\n**Nginx的产生**\n\nNginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。\n\n然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。\n\nApache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。\n\n它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。\n\n它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。\n\n操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。\n\n这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。\n\n俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。\n\nNginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。\n\n**由于以下这几点，所以，Nginx 火了：**\n\n-   Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。\n-   高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。\n-   Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。\n-   这些优秀的设计带来的极大的稳定性。\n\n## **Nginx 基本概念**\n\n### 正向代理与反向代理\n\n为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？\n\n代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。\n\n不管是正向代理还是反向代理，实现的都是上面的功能。\n\n如果你对OSI 七层模型与 TCP/IP 四层模型不是很熟悉可以再回顾下\n\n> 正向代理\n\n正向代理（forward）意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。\n\n正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。\n\n正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。\n\n> 反向代理\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。\n\n反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。\n\n### 负载均衡\n\n如果请求数过大，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器的情况改为请求分发到多个服务器上，就是负载均衡。\n\nUpstream 指定后端服务器地址列表，在 server 中拦截响应请求，并将请求转发到 Upstream 中配置的服务器列表。\n\n```\nupstream balanceServer {    \n\t\tserver 10.1.22.33:12345;    \n\t\tserver 10.1.22.34:12345;\n    server 10.1.22.35:12345;\n}\nserver {    \n\t\tserver_name  fe.server.com;    \n\t\tlisten 80;    \n\t\tlocation /api {       \n\t\t\tproxy_pass <http://balanceServer>;  \n\t\t}\n}\n```\n\n上面的配置只是指定了 nginx 需要转发的服务端列表，并没有指定分配策略。\n\n默认情况下采用的是轮询策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。\n\n**Nginx支持的负载均衡调度算法方式如下：**\n\n**weight轮询(默认，常用)：**接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。\n\n**fair：**智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。\n\n### 动静分离\n\n为了加快服务器的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。\n\n### Nginx常用命令\n\n```\n# 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务\nnginx -s stop\n# 平稳关闭Nginx，保存相关信息，有安排的结束web服务\nnginx -s quit\n# 因改变了Nginx相关配置，需要重新加载配置而重载\nnginx -s reload\n# 重新打开日志文件\nnginx -s reopen\n# 为 Nginx 指定一个配置文件，来代替缺省的\nnginx -c filename\n# 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件\nnginx -t\n#  显示 nginx 的版本\nnginx -v\n# 显示 nginx 的版本，编译器版本和配置参数\nnginx -V\n# 格式换显示 nginx 配置参数2>&1 \nnginx -V | xargs -n12>&1 \nnginx -V | xargs -n1 | grep lua\n```\n\n**为什么选择Nginx**\n\nNginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。在Nginx网站上，其功能包括：\n\n-   HTTP和HTTPS（TLS / SSL / SNI）\n-   超快速的Web服务器用于静态内容\n-   FastCGI，WSGI，SCGI用于动态内容\n-   具有负载平衡和缓存功能的加速Web代理\n-   不间断实时二进制升级和配置\n-   压缩和内容过滤器\n-   虚拟主机\n-   FLV和MP4的媒体流\n-   带宽和连接策略\n-   全面的访问控制\n-   自定义日志\n-   嵌入式脚本\n-   带有TLS的SMTP / IMAP / POP3的邮件代理\n-   逻辑，灵活，可扩展的配置\n-   在Linux，FreeBSD，Mac OS X，Solaris和Windows上运行\n\n## **Nginx有如下优势：**\n\n### IO多路复用epoll（IO复用）\n\n如何理解呢？举个例子吧！\n\n有A、B、C三个老师，他们都遇到一个难题，要帮助一个班级的学生解决课堂作业。老师A采用从第一排开始一个学生一个学生轮流解答的方式去回答问题，老师A浪费了很多时间，并且有的学生作业还没有完成呢，老师就来了，反反复复效率极慢。老师B是一个忍者，他发现老师A的方法行不通，于是他使用了影分身术，分身出好几个自己同一时间去帮好几个同学回答问题，最后还没回答完，老师B消耗光了能量累倒了。\n\n老师C比较精明，他告诉学生，谁完成了作业举手，有举手的同学他才去指导问题，他让学生主动发声，分开了“并发”。\n\n这个老师C就是Nginx。\n\n### 轻量级\n\n-   功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加\n-   代码模块化 - 更适合二次开发，如阿里巴巴Tengine\n\n### CPU亲和\n\n把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。\n\n**Nginx配置**\n\n```\n#打开主配置文件，若你是用lnmp环境安装vim /usr/local/nginx/conf/nginx.conf\n----------------------------------------\nuser #设置nginx服务的系统使用用户\nworker_processes #工作进程数 一般情况与CPU核数保持一致\nerror_log #nginx的错误日志\npid #nginx启动时的pid\nevents {    \n\tworker_connections#每个进程允许最大连接数    \n\tuse#nginx使用的内核模型\n}\n```\n\n我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。\n\n```\nhttp {\n    ... ...        #后面再详细介绍 http 配置项目    \n\t\tserver {        \n\t\t\tlisten 80                          #监听端口;        \n\t\t\tserver_name localhost              #地址        \n\t\t\tlocation / {                       #访问首页路径            \n\t\t\t\troot /xxx/xxx/index.html       #默认目录            \n\t\t\t\tindex index.html index.htm     #默认文件        \n\t\t\t}        \n\t\t\terror_page  500 504   /50x.html    #当出现以上状态码时从新定义到50x.html        \n\t\t\tlocation = /50x.html {             #当访问50x.html时            \n\t\t\t\troot /xxx/xxx/html             #50x.html 页面所在位置        \n\t\t\t}    \n\t\t}    \n\t\tserver {        \n\t\t\t... ...    \n\t\t}\n}\n```\n\n一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置。\n\n我们再来看看 http 的配置详情\n\n```\nhttp {    \nsendfile  on#高效传输文件的模式 一定要开启    keepalive_timeout   65#客户端服务端请求超时时间    log_format  main   XXX#定义日志格式 代号为main    access_log  /usr/local/access.log  main#日志保存地址 格式代码 main\n}\n```","source":"_posts/Server/Nginx/Nginx详解.md","raw":"---\ntitle: Nginx详解\ndate: 2022-04-05 11:36:04\ntags:\n  - [nginx]\ncategories:\n  - [技术]\ndescription: Nginx相关文档\n---\n\nNginx联合创始人安德鲁·阿列克谢夫（Andrew Alexeev）曾说：Nginx是为对Apache性能不满意的人而构建的。随着Internet需求的变化，Web服务器的工作也在变化。Nginx的构建比以往任何时候都更有效率，更可扩展，更安全，更强大。\n\n本文提供了Nginx的基本概念及知识。以开发者必备的Nginx基础知识为主，罗列了一些Nginx教程，希望对大家有所帮助。**免费Nginx学习资料见文末！**\n\n**Nginx的产生**\n\nNginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。\n\n然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。\n\nApache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。\n\n它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。\n\n它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。\n\n操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。\n\n这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。\n\n俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。\n\nNginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。\n\n**由于以下这几点，所以，Nginx 火了：**\n\n-   Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。\n-   高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。\n-   Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。\n-   这些优秀的设计带来的极大的稳定性。\n\n## **Nginx 基本概念**\n\n### 正向代理与反向代理\n\n为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？\n\n代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。\n\n不管是正向代理还是反向代理，实现的都是上面的功能。\n\n如果你对OSI 七层模型与 TCP/IP 四层模型不是很熟悉可以再回顾下\n\n> 正向代理\n\n正向代理（forward）意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。\n\n正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。\n\n正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。\n\n> 反向代理\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。\n\n反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。\n\n### 负载均衡\n\n如果请求数过大，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器的情况改为请求分发到多个服务器上，就是负载均衡。\n\nUpstream 指定后端服务器地址列表，在 server 中拦截响应请求，并将请求转发到 Upstream 中配置的服务器列表。\n\n```\nupstream balanceServer {    \n\t\tserver 10.1.22.33:12345;    \n\t\tserver 10.1.22.34:12345;\n    server 10.1.22.35:12345;\n}\nserver {    \n\t\tserver_name  fe.server.com;    \n\t\tlisten 80;    \n\t\tlocation /api {       \n\t\t\tproxy_pass <http://balanceServer>;  \n\t\t}\n}\n```\n\n上面的配置只是指定了 nginx 需要转发的服务端列表，并没有指定分配策略。\n\n默认情况下采用的是轮询策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。\n\n**Nginx支持的负载均衡调度算法方式如下：**\n\n**weight轮询(默认，常用)：**接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。\n\n**fair：**智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。\n\n### 动静分离\n\n为了加快服务器的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。\n\n### Nginx常用命令\n\n```\n# 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务\nnginx -s stop\n# 平稳关闭Nginx，保存相关信息，有安排的结束web服务\nnginx -s quit\n# 因改变了Nginx相关配置，需要重新加载配置而重载\nnginx -s reload\n# 重新打开日志文件\nnginx -s reopen\n# 为 Nginx 指定一个配置文件，来代替缺省的\nnginx -c filename\n# 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件\nnginx -t\n#  显示 nginx 的版本\nnginx -v\n# 显示 nginx 的版本，编译器版本和配置参数\nnginx -V\n# 格式换显示 nginx 配置参数2>&1 \nnginx -V | xargs -n12>&1 \nnginx -V | xargs -n1 | grep lua\n```\n\n**为什么选择Nginx**\n\nNginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。在Nginx网站上，其功能包括：\n\n-   HTTP和HTTPS（TLS / SSL / SNI）\n-   超快速的Web服务器用于静态内容\n-   FastCGI，WSGI，SCGI用于动态内容\n-   具有负载平衡和缓存功能的加速Web代理\n-   不间断实时二进制升级和配置\n-   压缩和内容过滤器\n-   虚拟主机\n-   FLV和MP4的媒体流\n-   带宽和连接策略\n-   全面的访问控制\n-   自定义日志\n-   嵌入式脚本\n-   带有TLS的SMTP / IMAP / POP3的邮件代理\n-   逻辑，灵活，可扩展的配置\n-   在Linux，FreeBSD，Mac OS X，Solaris和Windows上运行\n\n## **Nginx有如下优势：**\n\n### IO多路复用epoll（IO复用）\n\n如何理解呢？举个例子吧！\n\n有A、B、C三个老师，他们都遇到一个难题，要帮助一个班级的学生解决课堂作业。老师A采用从第一排开始一个学生一个学生轮流解答的方式去回答问题，老师A浪费了很多时间，并且有的学生作业还没有完成呢，老师就来了，反反复复效率极慢。老师B是一个忍者，他发现老师A的方法行不通，于是他使用了影分身术，分身出好几个自己同一时间去帮好几个同学回答问题，最后还没回答完，老师B消耗光了能量累倒了。\n\n老师C比较精明，他告诉学生，谁完成了作业举手，有举手的同学他才去指导问题，他让学生主动发声，分开了“并发”。\n\n这个老师C就是Nginx。\n\n### 轻量级\n\n-   功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加\n-   代码模块化 - 更适合二次开发，如阿里巴巴Tengine\n\n### CPU亲和\n\n把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。\n\n**Nginx配置**\n\n```\n#打开主配置文件，若你是用lnmp环境安装vim /usr/local/nginx/conf/nginx.conf\n----------------------------------------\nuser #设置nginx服务的系统使用用户\nworker_processes #工作进程数 一般情况与CPU核数保持一致\nerror_log #nginx的错误日志\npid #nginx启动时的pid\nevents {    \n\tworker_connections#每个进程允许最大连接数    \n\tuse#nginx使用的内核模型\n}\n```\n\n我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。\n\n```\nhttp {\n    ... ...        #后面再详细介绍 http 配置项目    \n\t\tserver {        \n\t\t\tlisten 80                          #监听端口;        \n\t\t\tserver_name localhost              #地址        \n\t\t\tlocation / {                       #访问首页路径            \n\t\t\t\troot /xxx/xxx/index.html       #默认目录            \n\t\t\t\tindex index.html index.htm     #默认文件        \n\t\t\t}        \n\t\t\terror_page  500 504   /50x.html    #当出现以上状态码时从新定义到50x.html        \n\t\t\tlocation = /50x.html {             #当访问50x.html时            \n\t\t\t\troot /xxx/xxx/html             #50x.html 页面所在位置        \n\t\t\t}    \n\t\t}    \n\t\tserver {        \n\t\t\t... ...    \n\t\t}\n}\n```\n\n一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置。\n\n我们再来看看 http 的配置详情\n\n```\nhttp {    \nsendfile  on#高效传输文件的模式 一定要开启    keepalive_timeout   65#客户端服务端请求超时时间    log_format  main   XXX#定义日志格式 代号为main    access_log  /usr/local/access.log  main#日志保存地址 格式代码 main\n}\n```","slug":"Server/Nginx/Nginx详解","published":1,"updated":"2022-08-28T07:38:59.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2m004vscvm0mv7dq05","content":"<p>Nginx联合创始人安德鲁·阿列克谢夫（Andrew Alexeev）曾说：Nginx是为对Apache性能不满意的人而构建的。随着Internet需求的变化，Web服务器的工作也在变化。Nginx的构建比以往任何时候都更有效率，更可扩展，更安全，更强大。</p>\n<p>本文提供了Nginx的基本概念及知识。以开发者必备的Nginx基础知识为主，罗列了一些Nginx教程，希望对大家有所帮助。<strong>免费Nginx学习资料见文末！</strong></p>\n<p><strong>Nginx的产生</strong></p>\n<p>Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。</p>\n<p>然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。</p>\n<p>Apache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。</p>\n<p>它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。</p>\n<p>它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。</p>\n<p>操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。</p>\n<p>这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。</p>\n<p>俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。</p>\n<p>Nginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。</p>\n<p><strong>由于以下这几点，所以，Nginx 火了：</strong></p>\n<ul>\n<li>Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。</li>\n<li>高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。</li>\n<li>Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。</li>\n<li>这些优秀的设计带来的极大的稳定性。</li>\n</ul>\n<h2 id=\"Nginx-基本概念\"><a href=\"#Nginx-基本概念\" class=\"headerlink\" title=\"Nginx 基本概念\"></a><strong>Nginx 基本概念</strong></h2><h3 id=\"正向代理与反向代理\"><a href=\"#正向代理与反向代理\" class=\"headerlink\" title=\"正向代理与反向代理\"></a>正向代理与反向代理</h3><p>为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？</p>\n<p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>\n<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>\n<p>如果你对OSI 七层模型与 TCP&#x2F;IP 四层模型不是很熟悉可以再回顾下</p>\n<blockquote>\n<p>正向代理</p>\n</blockquote>\n<p>正向代理（forward）意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>\n<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>\n<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>\n<blockquote>\n<p>反向代理</p>\n</blockquote>\n<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>\n<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>如果请求数过大，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器的情况改为请求分发到多个服务器上，就是负载均衡。</p>\n<p>Upstream 指定后端服务器地址列表，在 server 中拦截响应请求，并将请求转发到 Upstream 中配置的服务器列表。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-section\">upstream</span> balanceServer &#123;    <br>\t\t<span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">10.1.22.33:12345</span>;    <br>\t\t<span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">10.1.22.34:12345</span>;<br>    <span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">10.1.22.35:12345</span>;<br>&#125;<br><span class=\"hljs-section\">server</span> &#123;    <br>\t\t<span class=\"hljs-attribute\">server_name</span>  fe.server.com;    <br>\t\t<span class=\"hljs-attribute\">listen</span> <span class=\"hljs-number\">80</span>;    <br>\t\t<span class=\"hljs-section\">location</span> /api &#123;       <br>\t\t\t<span class=\"hljs-attribute\">proxy_pass</span> &lt;http://balanceServer&gt;;  <br>\t\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的配置只是指定了 nginx 需要转发的服务端列表，并没有指定分配策略。</p>\n<p>默认情况下采用的是轮询策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p>\n<p><strong>Nginx支持的负载均衡调度算法方式如下：</strong></p>\n<p><strong>weight轮询(默认，常用)：</strong>接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</p>\n<p><strong>fair：</strong>智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</p>\n<h3 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h3><p>为了加快服务器的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>\n<h3 id=\"Nginx常用命令\"><a href=\"#Nginx常用命令\" class=\"headerlink\" title=\"Nginx常用命令\"></a>Nginx常用命令</h3><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gherkin\"><span class=\"hljs-comment\"># 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务</span><br>nginx -s stop<br><span class=\"hljs-comment\"># 平稳关闭Nginx，保存相关信息，有安排的结束web服务</span><br>nginx -s quit<br><span class=\"hljs-comment\"># 因改变了Nginx相关配置，需要重新加载配置而重载</span><br>nginx -s reload<br><span class=\"hljs-comment\"># 重新打开日志文件</span><br>nginx -s reopen<br><span class=\"hljs-comment\"># 为 Nginx 指定一个配置文件，来代替缺省的</span><br>nginx -c filename<br><span class=\"hljs-comment\"># 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件</span><br>nginx -t<br><span class=\"hljs-comment\">#  显示 nginx 的版本</span><br>nginx -v<br><span class=\"hljs-comment\"># 显示 nginx 的版本，编译器版本和配置参数</span><br>nginx -V<br><span class=\"hljs-comment\"># 格式换显示 nginx 配置参数2&gt;&amp;1 </span><br>nginx -V |<span class=\"hljs-string\"> xargs -n12&gt;&amp;1 </span><br><span class=\"hljs-string\">nginx -V </span>|<span class=\"hljs-string\"> xargs -n1 </span>|<span class=\"hljs-string\"> grep lua</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>为什么选择Nginx</strong></p>\n<p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。在Nginx网站上，其功能包括：</p>\n<ul>\n<li>HTTP和HTTPS（TLS &#x2F; SSL &#x2F; SNI）</li>\n<li>超快速的Web服务器用于静态内容</li>\n<li>FastCGI，WSGI，SCGI用于动态内容</li>\n<li>具有负载平衡和缓存功能的加速Web代理</li>\n<li>不间断实时二进制升级和配置</li>\n<li>压缩和内容过滤器</li>\n<li>虚拟主机</li>\n<li>FLV和MP4的媒体流</li>\n<li>带宽和连接策略</li>\n<li>全面的访问控制</li>\n<li>自定义日志</li>\n<li>嵌入式脚本</li>\n<li>带有TLS的SMTP &#x2F; IMAP &#x2F; POP3的邮件代理</li>\n<li>逻辑，灵活，可扩展的配置</li>\n<li>在Linux，FreeBSD，Mac OS X，Solaris和Windows上运行</li>\n</ul>\n<h2 id=\"Nginx有如下优势：\"><a href=\"#Nginx有如下优势：\" class=\"headerlink\" title=\"Nginx有如下优势：\"></a><strong>Nginx有如下优势：</strong></h2><h3 id=\"IO多路复用epoll（IO复用）\"><a href=\"#IO多路复用epoll（IO复用）\" class=\"headerlink\" title=\"IO多路复用epoll（IO复用）\"></a>IO多路复用epoll（IO复用）</h3><p>如何理解呢？举个例子吧！</p>\n<p>有A、B、C三个老师，他们都遇到一个难题，要帮助一个班级的学生解决课堂作业。老师A采用从第一排开始一个学生一个学生轮流解答的方式去回答问题，老师A浪费了很多时间，并且有的学生作业还没有完成呢，老师就来了，反反复复效率极慢。老师B是一个忍者，他发现老师A的方法行不通，于是他使用了影分身术，分身出好几个自己同一时间去帮好几个同学回答问题，最后还没回答完，老师B消耗光了能量累倒了。</p>\n<p>老师C比较精明，他告诉学生，谁完成了作业举手，有举手的同学他才去指导问题，他让学生主动发声，分开了“并发”。</p>\n<p>这个老师C就是Nginx。</p>\n<h3 id=\"轻量级\"><a href=\"#轻量级\" class=\"headerlink\" title=\"轻量级\"></a>轻量级</h3><ul>\n<li>功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加</li>\n<li>代码模块化 - 更适合二次开发，如阿里巴巴Tengine</li>\n</ul>\n<h3 id=\"CPU亲和\"><a href=\"#CPU亲和\" class=\"headerlink\" title=\"CPU亲和\"></a>CPU亲和</h3><p>把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。</p>\n<p><strong>Nginx配置</strong></p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-section\">#打开主配置文件，若你是用lnmp环境安装vim /usr/local/nginx/conf/nginx.conf</span><br><span class=\"hljs-section\">----------------------------------------</span><br>user #设置nginx服务的系统使用用户<br>worker<span class=\"hljs-emphasis\">_processes #工作进程数 一般情况与CPU核数保持一致</span><br><span class=\"hljs-emphasis\">error_log #nginx的错误日志</span><br><span class=\"hljs-emphasis\">pid #nginx启动时的pid</span><br><span class=\"hljs-emphasis\">events &#123;    </span><br><span class=\"hljs-emphasis\">\tworker_</span>connections#每个进程允许最大连接数    <br><span class=\"hljs-code\">\tuse#nginx使用的内核模型</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">http &#123;<br>    <span class=\"hljs-string\">...</span> <span class=\"hljs-string\">...</span>        <span class=\"hljs-comment\">#后面再详细介绍 http 配置项目    </span><br>\t\tserver &#123;        <br>\t\t\tlisten 80                          <span class=\"hljs-comment\">#监听端口;        </span><br>\t\t\tserver_name localhost              <span class=\"hljs-comment\">#地址        </span><br>\t\t\tlocation / &#123;                       <span class=\"hljs-comment\">#访问首页路径            </span><br>\t\t\t\troot <span class=\"hljs-string\">/xxx/xxx/index.html</span>       <span class=\"hljs-comment\">#默认目录            </span><br>\t\t\t\tindex index.html index.htm     <span class=\"hljs-comment\">#默认文件        </span><br>\t\t\t&#125;        <br>\t\t\terror_page  500 504   <span class=\"hljs-string\">/50x.html</span>    <span class=\"hljs-comment\">#当出现以上状态码时从新定义到50x.html        </span><br>\t\t\tlocation = <span class=\"hljs-string\">/50x.html</span> &#123;             <span class=\"hljs-comment\">#当访问50x.html时            </span><br>\t\t\t\troot <span class=\"hljs-string\">/xxx/xxx/html</span>             <span class=\"hljs-comment\">#50x.html 页面所在位置        </span><br>\t\t\t&#125;    <br>\t\t&#125;    <br>\t\tserver &#123;        <br>\t\t\t<span class=\"hljs-string\">...</span> <span class=\"hljs-string\">...</span>    <br>\t\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置。</p>\n<p>我们再来看看 http 的配置详情</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">http &#123;    <br>sendfile  on#高效传输文件的模式 一定要开启    keepalive_timeout   <span class=\"hljs-number\">65</span>#客户端服务端请求超时时间    log_format  main   XXX#定义日志格式 代号为main    access_log  /usr/local/access.log  main#日志保存地址 格式代码 main<br>&#125;<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":4912,"excerpt":"","more":"<p>Nginx联合创始人安德鲁·阿列克谢夫（Andrew Alexeev）曾说：Nginx是为对Apache性能不满意的人而构建的。随着Internet需求的变化，Web服务器的工作也在变化。Nginx的构建比以往任何时候都更有效率，更可扩展，更安全，更强大。</p>\n<p>本文提供了Nginx的基本概念及知识。以开发者必备的Nginx基础知识为主，罗列了一些Nginx教程，希望对大家有所帮助。<strong>免费Nginx学习资料见文末！</strong></p>\n<p><strong>Nginx的产生</strong></p>\n<p>Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。</p>\n<p>然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。</p>\n<p>Apache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。</p>\n<p>它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。</p>\n<p>它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。</p>\n<p>操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。</p>\n<p>这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。</p>\n<p>俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。</p>\n<p>Nginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。</p>\n<p><strong>由于以下这几点，所以，Nginx 火了：</strong></p>\n<ul>\n<li>Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。</li>\n<li>高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。</li>\n<li>Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。</li>\n<li>这些优秀的设计带来的极大的稳定性。</li>\n</ul>\n<h2 id=\"Nginx-基本概念\"><a href=\"#Nginx-基本概念\" class=\"headerlink\" title=\"Nginx 基本概念\"></a><strong>Nginx 基本概念</strong></h2><h3 id=\"正向代理与反向代理\"><a href=\"#正向代理与反向代理\" class=\"headerlink\" title=\"正向代理与反向代理\"></a>正向代理与反向代理</h3><p>为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？</p>\n<p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>\n<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>\n<p>如果你对OSI 七层模型与 TCP&#x2F;IP 四层模型不是很熟悉可以再回顾下</p>\n<blockquote>\n<p>正向代理</p>\n</blockquote>\n<p>正向代理（forward）意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>\n<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>\n<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>\n<blockquote>\n<p>反向代理</p>\n</blockquote>\n<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>\n<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>如果请求数过大，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器的情况改为请求分发到多个服务器上，就是负载均衡。</p>\n<p>Upstream 指定后端服务器地址列表，在 server 中拦截响应请求，并将请求转发到 Upstream 中配置的服务器列表。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-section\">upstream</span> balanceServer &#123;    <br>\t\t<span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">10.1.22.33:12345</span>;    <br>\t\t<span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">10.1.22.34:12345</span>;<br>    <span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">10.1.22.35:12345</span>;<br>&#125;<br><span class=\"hljs-section\">server</span> &#123;    <br>\t\t<span class=\"hljs-attribute\">server_name</span>  fe.server.com;    <br>\t\t<span class=\"hljs-attribute\">listen</span> <span class=\"hljs-number\">80</span>;    <br>\t\t<span class=\"hljs-section\">location</span> /api &#123;       <br>\t\t\t<span class=\"hljs-attribute\">proxy_pass</span> &lt;http://balanceServer&gt;;  <br>\t\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的配置只是指定了 nginx 需要转发的服务端列表，并没有指定分配策略。</p>\n<p>默认情况下采用的是轮询策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p>\n<p><strong>Nginx支持的负载均衡调度算法方式如下：</strong></p>\n<p><strong>weight轮询(默认，常用)：</strong>接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</p>\n<p><strong>fair：</strong>智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</p>\n<h3 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h3><p>为了加快服务器的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>\n<h3 id=\"Nginx常用命令\"><a href=\"#Nginx常用命令\" class=\"headerlink\" title=\"Nginx常用命令\"></a>Nginx常用命令</h3><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gherkin\"><span class=\"hljs-comment\"># 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务</span><br>nginx -s stop<br><span class=\"hljs-comment\"># 平稳关闭Nginx，保存相关信息，有安排的结束web服务</span><br>nginx -s quit<br><span class=\"hljs-comment\"># 因改变了Nginx相关配置，需要重新加载配置而重载</span><br>nginx -s reload<br><span class=\"hljs-comment\"># 重新打开日志文件</span><br>nginx -s reopen<br><span class=\"hljs-comment\"># 为 Nginx 指定一个配置文件，来代替缺省的</span><br>nginx -c filename<br><span class=\"hljs-comment\"># 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件</span><br>nginx -t<br><span class=\"hljs-comment\">#  显示 nginx 的版本</span><br>nginx -v<br><span class=\"hljs-comment\"># 显示 nginx 的版本，编译器版本和配置参数</span><br>nginx -V<br><span class=\"hljs-comment\"># 格式换显示 nginx 配置参数2&gt;&amp;1 </span><br>nginx -V |<span class=\"hljs-string\"> xargs -n12&gt;&amp;1 </span><br><span class=\"hljs-string\">nginx -V </span>|<span class=\"hljs-string\"> xargs -n1 </span>|<span class=\"hljs-string\"> grep lua</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>为什么选择Nginx</strong></p>\n<p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。在Nginx网站上，其功能包括：</p>\n<ul>\n<li>HTTP和HTTPS（TLS &#x2F; SSL &#x2F; SNI）</li>\n<li>超快速的Web服务器用于静态内容</li>\n<li>FastCGI，WSGI，SCGI用于动态内容</li>\n<li>具有负载平衡和缓存功能的加速Web代理</li>\n<li>不间断实时二进制升级和配置</li>\n<li>压缩和内容过滤器</li>\n<li>虚拟主机</li>\n<li>FLV和MP4的媒体流</li>\n<li>带宽和连接策略</li>\n<li>全面的访问控制</li>\n<li>自定义日志</li>\n<li>嵌入式脚本</li>\n<li>带有TLS的SMTP &#x2F; IMAP &#x2F; POP3的邮件代理</li>\n<li>逻辑，灵活，可扩展的配置</li>\n<li>在Linux，FreeBSD，Mac OS X，Solaris和Windows上运行</li>\n</ul>\n<h2 id=\"Nginx有如下优势：\"><a href=\"#Nginx有如下优势：\" class=\"headerlink\" title=\"Nginx有如下优势：\"></a><strong>Nginx有如下优势：</strong></h2><h3 id=\"IO多路复用epoll（IO复用）\"><a href=\"#IO多路复用epoll（IO复用）\" class=\"headerlink\" title=\"IO多路复用epoll（IO复用）\"></a>IO多路复用epoll（IO复用）</h3><p>如何理解呢？举个例子吧！</p>\n<p>有A、B、C三个老师，他们都遇到一个难题，要帮助一个班级的学生解决课堂作业。老师A采用从第一排开始一个学生一个学生轮流解答的方式去回答问题，老师A浪费了很多时间，并且有的学生作业还没有完成呢，老师就来了，反反复复效率极慢。老师B是一个忍者，他发现老师A的方法行不通，于是他使用了影分身术，分身出好几个自己同一时间去帮好几个同学回答问题，最后还没回答完，老师B消耗光了能量累倒了。</p>\n<p>老师C比较精明，他告诉学生，谁完成了作业举手，有举手的同学他才去指导问题，他让学生主动发声，分开了“并发”。</p>\n<p>这个老师C就是Nginx。</p>\n<h3 id=\"轻量级\"><a href=\"#轻量级\" class=\"headerlink\" title=\"轻量级\"></a>轻量级</h3><ul>\n<li>功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加</li>\n<li>代码模块化 - 更适合二次开发，如阿里巴巴Tengine</li>\n</ul>\n<h3 id=\"CPU亲和\"><a href=\"#CPU亲和\" class=\"headerlink\" title=\"CPU亲和\"></a>CPU亲和</h3><p>把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。</p>\n<p><strong>Nginx配置</strong></p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-section\">#打开主配置文件，若你是用lnmp环境安装vim /usr/local/nginx/conf/nginx.conf</span><br><span class=\"hljs-section\">----------------------------------------</span><br>user #设置nginx服务的系统使用用户<br>worker<span class=\"hljs-emphasis\">_processes #工作进程数 一般情况与CPU核数保持一致</span><br><span class=\"hljs-emphasis\">error_log #nginx的错误日志</span><br><span class=\"hljs-emphasis\">pid #nginx启动时的pid</span><br><span class=\"hljs-emphasis\">events &#123;    </span><br><span class=\"hljs-emphasis\">\tworker_</span>connections#每个进程允许最大连接数    <br><span class=\"hljs-code\">\tuse#nginx使用的内核模型</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">http &#123;<br>    <span class=\"hljs-string\">...</span> <span class=\"hljs-string\">...</span>        <span class=\"hljs-comment\">#后面再详细介绍 http 配置项目    </span><br>\t\tserver &#123;        <br>\t\t\tlisten 80                          <span class=\"hljs-comment\">#监听端口;        </span><br>\t\t\tserver_name localhost              <span class=\"hljs-comment\">#地址        </span><br>\t\t\tlocation / &#123;                       <span class=\"hljs-comment\">#访问首页路径            </span><br>\t\t\t\troot <span class=\"hljs-string\">/xxx/xxx/index.html</span>       <span class=\"hljs-comment\">#默认目录            </span><br>\t\t\t\tindex index.html index.htm     <span class=\"hljs-comment\">#默认文件        </span><br>\t\t\t&#125;        <br>\t\t\terror_page  500 504   <span class=\"hljs-string\">/50x.html</span>    <span class=\"hljs-comment\">#当出现以上状态码时从新定义到50x.html        </span><br>\t\t\tlocation = <span class=\"hljs-string\">/50x.html</span> &#123;             <span class=\"hljs-comment\">#当访问50x.html时            </span><br>\t\t\t\troot <span class=\"hljs-string\">/xxx/xxx/html</span>             <span class=\"hljs-comment\">#50x.html 页面所在位置        </span><br>\t\t\t&#125;    <br>\t\t&#125;    <br>\t\tserver &#123;        <br>\t\t\t<span class=\"hljs-string\">...</span> <span class=\"hljs-string\">...</span>    <br>\t\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置。</p>\n<p>我们再来看看 http 的配置详情</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">http &#123;    <br>sendfile  on#高效传输文件的模式 一定要开启    keepalive_timeout   <span class=\"hljs-number\">65</span>#客户端服务端请求超时时间    log_format  main   XXX#定义日志格式 代号为main    access_log  /usr/local/access.log  main#日志保存地址 格式代码 main<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"Nginx转发","date":"2022-04-05T03:36:27.000Z","description":"Nginx相关文档","_content":"\n## 前言\n\nLocation 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。\n\n## 语法\n\n关于 Location，举个简单的配置例子：\n\n```\nhttp {\n  server {\n      listen 80;\n    \tserver_name www.yayujs.com;\n    \tlocation / {\n      \troot /home/www/ts/;\n\t      index index.html;\n    \t}\n  }\n}\n```\n\n大致的意思是，当你访问 `www.yayujs.com` 的 `80` 端口的时候，返回 `/home/www/ts/index.html` 文件。\n\n我们看下 Location 的具体语法：\n\n```\nlocation [ = | ~ | ~* | ^~ ] uri { ... }\n```\n\n重点看方括号中的 `[ = | ~ | ~* | ^~ ]`，其中 `|` 分隔的内容表示你可能会用到的语法，其中：\n\n-   `=` 表示精确匹配，比如：\n\n```\nlocation = /test {\n  return 200 \"hello\";\n}\n\n# /test ok\n# /test/ not ok\n# /test2 not ok\n# /test/2 not ok\n```\n\n-   `~` 表示区分大小写的正则匹配，比如：\n\n```\nlocation ~ ^/test$ {\n  [ configuration ]\n}\n\n# /test ok\n# /Test not ok\n# /test/ not ok\n# /test2 not ok\n```\n\n-   `~*` 表示不区分大小写的正则匹配\n\n```\nlocation ~* ^/test$ {\n\t[ configuration ]\n}\n\n# /test ok\n# /Test ok\n# /test/ not ok\n# /test2 not ok\n```\n\n-   `^~` 表示 uri 以某个字符串开头\n\n```\nlocation ^~ /images/ {\n\t[ configuration ]\n}\n\n# /images/1.gif ok\n```\n\n而当你不使用这些语法的时候，只写 uri 的时候：\n\n`/` 表示通用匹配：\n\n```\nlocation / {\n\t[ configuration ]\n}\n\n# /index.html ok\n```\n\n```\nlocation /test {\n    [ configuration ]\n}\n\n# /test ok\n# /test2 ok\n# /test/ ok\n```\n\n## 匹配顺序\n\n当存在多个 location 的时候，他们的匹配顺序引用 [Nginx 官方文档](https://link.juejin.cn/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdocs%2Fhttp%2Fngx_http_core_module.html%23location)就是：\n\n> A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “~*” modifier (for case-insensitive matching), or the “~” modifier (for case-sensitive matching). To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.\n\n> If the longest matching prefix location has the “^~” modifier then regular expressions are not checked.\n\n> Also, using the “=” modifier it is possible to define an exact match of URI and location. If an exact match is found, the search terminates. For example, if a “/” request happens frequently, defining “location = /” will speed up the processing of these requests, as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.\n\n翻译整理后就是：\n\nlocation 的定义分为两种：\n\n-   前缀字符串（prefix string）\n-   正则表达式（regular expression），具体为前面带 `~*` 和 `~` 修饰符的\n\n而匹配 location 的顺序为：\n\n1.  检查使用前缀字符串的 locations，在使用前缀字符串的 locations 中选择最长匹配的，并将结果进行储存\n2.  如果符合带有 `=` 修饰符的 URI，则立刻停止匹配\n3.  如果符合带有 `^~` 修饰符的 URI，则也立刻停止匹配。\n4.  然后按照定义文件的顺序，检查正则表达式，匹配到就停止\n5.  当正则表达式匹配不到的时候，使用之前储存的前缀字符串\n\n再总结一下就是：\n\n在顺序上，前缀字符串顺序不重要，按照匹配长度来确定，正则表达式则按照定义顺序。\n\n在优先级上，`=` 修饰符最高，`^~` 次之，再者是正则，最后是前缀字符串匹配。\n\n我们举几个简单的例子复习下：\n\n```\nserver {\n    location /doc {\n        [ configuration A ]\n    }\n    location /docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration B\n# 虽然 /doc 也能匹配到，但在顺序上，前缀字符串顺序不重要，按照匹配长度来确定\n```\n\n```\nserver {\n    location ~ ^/doc {\n        [ configuration A ]\n    }\n    location ~ ^/docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration A\n# 虽然 ~ ^/docu 也能匹配到，但正则表达式则按照定义顺序\n复制代码\n```\n\n```\nserver {\n    location ^~ /doc {\n        [ configuration A ]\n    }\n    location ~ ^/docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration A\n# 虽然 ~ ^/docu 也能匹配到，但 ^~ 的优先级更高\n```\n\n```\nserver {\n    location /document {\n        [ configuration A ]\n    }\n    location ~ ^/docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration B\n# 虽然 /document 也能匹配到，但正则的优先级更高\n复制代码\n```\n\n## root 与 alias 的区别\n\n当我们这样设置 `root` 的时候：\n\n```\nlocation /i/ {\n    root /data/w3;\n}\n```\n\n当请求 `/i/top.gif` ，`/data/w3/i/top.gif` 会被返回。\n\n当我们这样设置 `alias` 的时候：\n\n```\nlocation /i/ {\n    alias /data/w3/images/;\n}\n```\n\n当请求 `/i/top.gif` ，`/data/w3/images/top.gif` 会被返回。\n\n乍一看两者很像，但细一看，就能看出两者的区别，root 是直接拼接 `root` + `location` 而 alias 是用 `alias` 替换 `location`，所以 root 中最后的路径里有 `/i/`，而 alias 中最后的路径里没有  `/i/` 。\n\n所以如果你这样使用 allias 定义一个路径：\n\n```\nlocation /images/ {\n    alias /data/w3/images/;\n}\n```\n\n其实使用 root 会更好：\n\n```\nlocation /images/ {\n    root /data/w3;\n}\n```\n\n## server 和 location 中的 root\n\nserver 和 location 中都可以使用 root，举个例子：\n\n```\nhttp {\n  server {\n      listen 80;\n    \tserver_name www.yayujs.com;\n    \troot /home/www/website/;\n    \tlocation / {\n      \troot /home/www/ts/;\n\t      index index.html;\n    \t}\n  }\n}\n```\n\n如果两者都出现，是怎样的优先级呢？\n\n简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。","source":"_posts/Server/Nginx/Nginx转发.md","raw":"---\ntitle: Nginx转发\ndate: 2022-04-05 11:36:27\ntags:\n  - [nginx]\ncategories:\n  - [技术]\ndescription: Nginx相关文档\n---\n\n## 前言\n\nLocation 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。\n\n## 语法\n\n关于 Location，举个简单的配置例子：\n\n```\nhttp {\n  server {\n      listen 80;\n    \tserver_name www.yayujs.com;\n    \tlocation / {\n      \troot /home/www/ts/;\n\t      index index.html;\n    \t}\n  }\n}\n```\n\n大致的意思是，当你访问 `www.yayujs.com` 的 `80` 端口的时候，返回 `/home/www/ts/index.html` 文件。\n\n我们看下 Location 的具体语法：\n\n```\nlocation [ = | ~ | ~* | ^~ ] uri { ... }\n```\n\n重点看方括号中的 `[ = | ~ | ~* | ^~ ]`，其中 `|` 分隔的内容表示你可能会用到的语法，其中：\n\n-   `=` 表示精确匹配，比如：\n\n```\nlocation = /test {\n  return 200 \"hello\";\n}\n\n# /test ok\n# /test/ not ok\n# /test2 not ok\n# /test/2 not ok\n```\n\n-   `~` 表示区分大小写的正则匹配，比如：\n\n```\nlocation ~ ^/test$ {\n  [ configuration ]\n}\n\n# /test ok\n# /Test not ok\n# /test/ not ok\n# /test2 not ok\n```\n\n-   `~*` 表示不区分大小写的正则匹配\n\n```\nlocation ~* ^/test$ {\n\t[ configuration ]\n}\n\n# /test ok\n# /Test ok\n# /test/ not ok\n# /test2 not ok\n```\n\n-   `^~` 表示 uri 以某个字符串开头\n\n```\nlocation ^~ /images/ {\n\t[ configuration ]\n}\n\n# /images/1.gif ok\n```\n\n而当你不使用这些语法的时候，只写 uri 的时候：\n\n`/` 表示通用匹配：\n\n```\nlocation / {\n\t[ configuration ]\n}\n\n# /index.html ok\n```\n\n```\nlocation /test {\n    [ configuration ]\n}\n\n# /test ok\n# /test2 ok\n# /test/ ok\n```\n\n## 匹配顺序\n\n当存在多个 location 的时候，他们的匹配顺序引用 [Nginx 官方文档](https://link.juejin.cn/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdocs%2Fhttp%2Fngx_http_core_module.html%23location)就是：\n\n> A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “~*” modifier (for case-insensitive matching), or the “~” modifier (for case-sensitive matching). To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.\n\n> If the longest matching prefix location has the “^~” modifier then regular expressions are not checked.\n\n> Also, using the “=” modifier it is possible to define an exact match of URI and location. If an exact match is found, the search terminates. For example, if a “/” request happens frequently, defining “location = /” will speed up the processing of these requests, as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.\n\n翻译整理后就是：\n\nlocation 的定义分为两种：\n\n-   前缀字符串（prefix string）\n-   正则表达式（regular expression），具体为前面带 `~*` 和 `~` 修饰符的\n\n而匹配 location 的顺序为：\n\n1.  检查使用前缀字符串的 locations，在使用前缀字符串的 locations 中选择最长匹配的，并将结果进行储存\n2.  如果符合带有 `=` 修饰符的 URI，则立刻停止匹配\n3.  如果符合带有 `^~` 修饰符的 URI，则也立刻停止匹配。\n4.  然后按照定义文件的顺序，检查正则表达式，匹配到就停止\n5.  当正则表达式匹配不到的时候，使用之前储存的前缀字符串\n\n再总结一下就是：\n\n在顺序上，前缀字符串顺序不重要，按照匹配长度来确定，正则表达式则按照定义顺序。\n\n在优先级上，`=` 修饰符最高，`^~` 次之，再者是正则，最后是前缀字符串匹配。\n\n我们举几个简单的例子复习下：\n\n```\nserver {\n    location /doc {\n        [ configuration A ]\n    }\n    location /docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration B\n# 虽然 /doc 也能匹配到，但在顺序上，前缀字符串顺序不重要，按照匹配长度来确定\n```\n\n```\nserver {\n    location ~ ^/doc {\n        [ configuration A ]\n    }\n    location ~ ^/docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration A\n# 虽然 ~ ^/docu 也能匹配到，但正则表达式则按照定义顺序\n复制代码\n```\n\n```\nserver {\n    location ^~ /doc {\n        [ configuration A ]\n    }\n    location ~ ^/docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration A\n# 虽然 ~ ^/docu 也能匹配到，但 ^~ 的优先级更高\n```\n\n```\nserver {\n    location /document {\n        [ configuration A ]\n    }\n    location ~ ^/docu {\n        [ configuration B ]\n    }\n}\n\n# 请求 /document 使用 configuration B\n# 虽然 /document 也能匹配到，但正则的优先级更高\n复制代码\n```\n\n## root 与 alias 的区别\n\n当我们这样设置 `root` 的时候：\n\n```\nlocation /i/ {\n    root /data/w3;\n}\n```\n\n当请求 `/i/top.gif` ，`/data/w3/i/top.gif` 会被返回。\n\n当我们这样设置 `alias` 的时候：\n\n```\nlocation /i/ {\n    alias /data/w3/images/;\n}\n```\n\n当请求 `/i/top.gif` ，`/data/w3/images/top.gif` 会被返回。\n\n乍一看两者很像，但细一看，就能看出两者的区别，root 是直接拼接 `root` + `location` 而 alias 是用 `alias` 替换 `location`，所以 root 中最后的路径里有 `/i/`，而 alias 中最后的路径里没有  `/i/` 。\n\n所以如果你这样使用 allias 定义一个路径：\n\n```\nlocation /images/ {\n    alias /data/w3/images/;\n}\n```\n\n其实使用 root 会更好：\n\n```\nlocation /images/ {\n    root /data/w3;\n}\n```\n\n## server 和 location 中的 root\n\nserver 和 location 中都可以使用 root，举个例子：\n\n```\nhttp {\n  server {\n      listen 80;\n    \tserver_name www.yayujs.com;\n    \troot /home/www/website/;\n    \tlocation / {\n      \troot /home/www/ts/;\n\t      index index.html;\n    \t}\n  }\n}\n```\n\n如果两者都出现，是怎样的优先级呢？\n\n简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。","slug":"Server/Nginx/Nginx转发","published":1,"updated":"2022-08-28T07:38:59.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ec3i2n004yscvmgjsqf29h","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Location 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>关于 Location，举个简单的配置例子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-section\">http</span> &#123;<br>  <span class=\"hljs-section\">server</span> &#123;<br>      <span class=\"hljs-attribute\">listen</span> <span class=\"hljs-number\">80</span>;<br>    \t<span class=\"hljs-attribute\">server_name</span> www.yayujs.com;<br>    \t<span class=\"hljs-section\">location</span> / &#123;<br>      \t<span class=\"hljs-attribute\">root</span> /home/www/ts/;<br>\t      <span class=\"hljs-attribute\">index</span> index.html;<br>    \t&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>大致的意思是，当你访问 <code>www.yayujs.com</code> 的 <code>80</code> 端口的时候，返回 <code>/home/www/ts/index.html</code> 文件。</p>\n<p>我们看下 Location 的具体语法：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">[ = | ~ | ~* | ^~ ] uri</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>\n\n<p>重点看方括号中的 <code>[ = | ~ | ~* | ^~ ]</code>，其中 <code>|</code> 分隔的内容表示你可能会用到的语法，其中：</p>\n<ul>\n<li><code>=</code> 表示精确匹配，比如：</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">= /test</span> &#123;<br>  return <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /test/ not ok</span><br><span class=\"hljs-comment\"># /test2 not ok</span><br><span class=\"hljs-comment\"># /test/2 not ok</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>~</code> 表示区分大小写的正则匹配，比如：</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/test</span>$ &#123;<br>  [ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /Test not ok</span><br><span class=\"hljs-comment\"># /test/ not ok</span><br><span class=\"hljs-comment\"># /test2 not ok</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>~*</code> 表示不区分大小写的正则匹配</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~* ^/test</span>$ &#123;<br>\t[ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /Test ok</span><br><span class=\"hljs-comment\"># /test/ not ok</span><br><span class=\"hljs-comment\"># /test2 not ok</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>^~</code> 表示 uri 以某个字符串开头</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">^~ /images</span>/ &#123;<br>\t[ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /images/1.gif ok</span><br></code></pre></td></tr></table></figure>\n\n<p>而当你不使用这些语法的时候，只写 uri 的时候：</p>\n<p><code>/</code> 表示通用匹配：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/ &#123;</span><br><span class=\"hljs-title\">\t[ configuration</span> ]<br>&#125;<br><br><span class=\"hljs-comment\"># /index.html ok</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/test</span> &#123;<br>    [ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /test2 ok</span><br><span class=\"hljs-comment\"># /test/ ok</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"匹配顺序\"><a href=\"#匹配顺序\" class=\"headerlink\" title=\"匹配顺序\"></a>匹配顺序</h2><p>当存在多个 location 的时候，他们的匹配顺序引用 <a href=\"https://link.juejin.cn/?target=http://nginx.org/en/docs/http/ngx_http_core_module.html%23location\">Nginx 官方文档</a>就是：</p>\n<blockquote>\n<p>A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “<del>*” modifier (for case-insensitive matching), or the “</del>” modifier (for case-sensitive matching). To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.</p>\n</blockquote>\n<blockquote>\n<p>If the longest matching prefix location has the “^~” modifier then regular expressions are not checked.</p>\n</blockquote>\n<blockquote>\n<p>Also, using the “&#x3D;” modifier it is possible to define an exact match of URI and location. If an exact match is found, the search terminates. For example, if a “&#x2F;” request happens frequently, defining “location &#x3D; &#x2F;” will speed up the processing of these requests, as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.</p>\n</blockquote>\n<p>翻译整理后就是：</p>\n<p>location 的定义分为两种：</p>\n<ul>\n<li>前缀字符串（prefix string）</li>\n<li>正则表达式（regular expression），具体为前面带 <code>~*</code> 和 <code>~</code> 修饰符的</li>\n</ul>\n<p>而匹配 location 的顺序为：</p>\n<ol>\n<li>检查使用前缀字符串的 locations，在使用前缀字符串的 locations 中选择最长匹配的，并将结果进行储存</li>\n<li>如果符合带有 <code>=</code> 修饰符的 URI，则立刻停止匹配</li>\n<li>如果符合带有 <code>^~</code> 修饰符的 URI，则也立刻停止匹配。</li>\n<li>然后按照定义文件的顺序，检查正则表达式，匹配到就停止</li>\n<li>当正则表达式匹配不到的时候，使用之前储存的前缀字符串</li>\n</ol>\n<p>再总结一下就是：</p>\n<p>在顺序上，前缀字符串顺序不重要，按照匹配长度来确定，正则表达式则按照定义顺序。</p>\n<p>在优先级上，<code>=</code> 修饰符最高，<code>^~</code> 次之，再者是正则，最后是前缀字符串匹配。</p>\n<p>我们举几个简单的例子复习下：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/doc</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration B</span><br><span class=\"hljs-comment\"># 虽然 /doc 也能匹配到，但在顺序上，前缀字符串顺序不重要，按照匹配长度来确定</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/doc</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration A</span><br><span class=\"hljs-comment\"># 虽然 ~ ^/docu 也能匹配到，但正则表达式则按照定义顺序</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">^~ /doc</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration A</span><br><span class=\"hljs-comment\"># 虽然 ~ ^/docu 也能匹配到，但 ^~ 的优先级更高</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/document</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration B</span><br><span class=\"hljs-comment\"># 虽然 /document 也能匹配到，但正则的优先级更高</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"root-与-alias-的区别\"><a href=\"#root-与-alias-的区别\" class=\"headerlink\" title=\"root 与 alias 的区别\"></a>root 与 alias 的区别</h2><p>当我们这样设置 <code>root</code> 的时候：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/i/</span> &#123;<br>    root <span class=\"hljs-regexp\">/data/</span>w3;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/i/top.gif</code> 会被返回。</p>\n<p>当我们这样设置 <code>alias</code> 的时候：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/i/</span> &#123;<br>    alias <span class=\"hljs-regexp\">/data/</span>w3<span class=\"hljs-regexp\">/images/</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/images/top.gif</code> 会被返回。</p>\n<p>乍一看两者很像，但细一看，就能看出两者的区别，root 是直接拼接 <code>root</code> + <code>location</code> 而 alias 是用 <code>alias</code> 替换 <code>location</code>，所以 root 中最后的路径里有 <code>/i/</code>，而 alias 中最后的路径里没有  <code>/i/</code> 。</p>\n<p>所以如果你这样使用 allias 定义一个路径：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/images/</span> &#123;<br>    alias <span class=\"hljs-regexp\">/data/</span>w3<span class=\"hljs-regexp\">/images/</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实使用 root 会更好：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/images/</span> &#123;<br>    root <span class=\"hljs-regexp\">/data/</span>w3;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"server-和-location-中的-root\"><a href=\"#server-和-location-中的-root\" class=\"headerlink\" title=\"server 和 location 中的 root\"></a>server 和 location 中的 root</h2><p>server 和 location 中都可以使用 root，举个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">http &#123;<br>  server &#123;<br>      listen <span class=\"hljs-number\">80</span>;<br>    \tserver_name www.yayujs.com;<br>    \troot <span class=\"hljs-regexp\">/home/</span>www<span class=\"hljs-regexp\">/website/</span>;<br>    \tlocation / &#123;<br>      \troot <span class=\"hljs-regexp\">/home/</span>www<span class=\"hljs-regexp\">/ts/</span>;<br>\t      index index.html;<br>    \t&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果两者都出现，是怎样的优先级呢？</p>\n<p>简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。</p>\n","site":{"data":{}},"wordcount":3901,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Location 是 Nginx 中一个非常核心的配置，这篇重点讲解一下 Location 的配置问题以及一些注意事项。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>关于 Location，举个简单的配置例子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-section\">http</span> &#123;<br>  <span class=\"hljs-section\">server</span> &#123;<br>      <span class=\"hljs-attribute\">listen</span> <span class=\"hljs-number\">80</span>;<br>    \t<span class=\"hljs-attribute\">server_name</span> www.yayujs.com;<br>    \t<span class=\"hljs-section\">location</span> / &#123;<br>      \t<span class=\"hljs-attribute\">root</span> /home/www/ts/;<br>\t      <span class=\"hljs-attribute\">index</span> index.html;<br>    \t&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>大致的意思是，当你访问 <code>www.yayujs.com</code> 的 <code>80</code> 端口的时候，返回 <code>/home/www/ts/index.html</code> 文件。</p>\n<p>我们看下 Location 的具体语法：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">[ = | ~ | ~* | ^~ ] uri</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>\n\n<p>重点看方括号中的 <code>[ = | ~ | ~* | ^~ ]</code>，其中 <code>|</code> 分隔的内容表示你可能会用到的语法，其中：</p>\n<ul>\n<li><code>=</code> 表示精确匹配，比如：</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">= /test</span> &#123;<br>  return <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /test/ not ok</span><br><span class=\"hljs-comment\"># /test2 not ok</span><br><span class=\"hljs-comment\"># /test/2 not ok</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>~</code> 表示区分大小写的正则匹配，比如：</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/test</span>$ &#123;<br>  [ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /Test not ok</span><br><span class=\"hljs-comment\"># /test/ not ok</span><br><span class=\"hljs-comment\"># /test2 not ok</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>~*</code> 表示不区分大小写的正则匹配</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~* ^/test</span>$ &#123;<br>\t[ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /Test ok</span><br><span class=\"hljs-comment\"># /test/ not ok</span><br><span class=\"hljs-comment\"># /test2 not ok</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>^~</code> 表示 uri 以某个字符串开头</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">^~ /images</span>/ &#123;<br>\t[ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /images/1.gif ok</span><br></code></pre></td></tr></table></figure>\n\n<p>而当你不使用这些语法的时候，只写 uri 的时候：</p>\n<p><code>/</code> 表示通用匹配：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/ &#123;</span><br><span class=\"hljs-title\">\t[ configuration</span> ]<br>&#125;<br><br><span class=\"hljs-comment\"># /index.html ok</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/test</span> &#123;<br>    [ configuration ]<br>&#125;<br><br><span class=\"hljs-comment\"># /test ok</span><br><span class=\"hljs-comment\"># /test2 ok</span><br><span class=\"hljs-comment\"># /test/ ok</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"匹配顺序\"><a href=\"#匹配顺序\" class=\"headerlink\" title=\"匹配顺序\"></a>匹配顺序</h2><p>当存在多个 location 的时候，他们的匹配顺序引用 <a href=\"https://link.juejin.cn/?target=http://nginx.org/en/docs/http/ngx_http_core_module.html%23location\">Nginx 官方文档</a>就是：</p>\n<blockquote>\n<p>A location can either be defined by a prefix string, or by a regular expression. Regular expressions are specified with the preceding “<del>*” modifier (for case-insensitive matching), or the “</del>” modifier (for case-sensitive matching). To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). Among them, the location with the longest matching prefix is selected and remembered. Then regular expressions are checked, in the order of their appearance in the configuration file. The search of regular expressions terminates on the first match, and the corresponding configuration is used. If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.</p>\n</blockquote>\n<blockquote>\n<p>If the longest matching prefix location has the “^~” modifier then regular expressions are not checked.</p>\n</blockquote>\n<blockquote>\n<p>Also, using the “&#x3D;” modifier it is possible to define an exact match of URI and location. If an exact match is found, the search terminates. For example, if a “&#x2F;” request happens frequently, defining “location &#x3D; &#x2F;” will speed up the processing of these requests, as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.</p>\n</blockquote>\n<p>翻译整理后就是：</p>\n<p>location 的定义分为两种：</p>\n<ul>\n<li>前缀字符串（prefix string）</li>\n<li>正则表达式（regular expression），具体为前面带 <code>~*</code> 和 <code>~</code> 修饰符的</li>\n</ul>\n<p>而匹配 location 的顺序为：</p>\n<ol>\n<li>检查使用前缀字符串的 locations，在使用前缀字符串的 locations 中选择最长匹配的，并将结果进行储存</li>\n<li>如果符合带有 <code>=</code> 修饰符的 URI，则立刻停止匹配</li>\n<li>如果符合带有 <code>^~</code> 修饰符的 URI，则也立刻停止匹配。</li>\n<li>然后按照定义文件的顺序，检查正则表达式，匹配到就停止</li>\n<li>当正则表达式匹配不到的时候，使用之前储存的前缀字符串</li>\n</ol>\n<p>再总结一下就是：</p>\n<p>在顺序上，前缀字符串顺序不重要，按照匹配长度来确定，正则表达式则按照定义顺序。</p>\n<p>在优先级上，<code>=</code> 修饰符最高，<code>^~</code> 次之，再者是正则，最后是前缀字符串匹配。</p>\n<p>我们举几个简单的例子复习下：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/doc</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration B</span><br><span class=\"hljs-comment\"># 虽然 /doc 也能匹配到，但在顺序上，前缀字符串顺序不重要，按照匹配长度来确定</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/doc</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration A</span><br><span class=\"hljs-comment\"># 虽然 ~ ^/docu 也能匹配到，但正则表达式则按照定义顺序</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">^~ /doc</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration A</span><br><span class=\"hljs-comment\"># 虽然 ~ ^/docu 也能匹配到，但 ^~ 的优先级更高</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">server &#123;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/document</span> &#123;<br>        [ configuration A ]<br>    &#125;<br>    <span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ ^/docu</span> &#123;<br>        [ configuration B ]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># 请求 /document 使用 configuration B</span><br><span class=\"hljs-comment\"># 虽然 /document 也能匹配到，但正则的优先级更高</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"root-与-alias-的区别\"><a href=\"#root-与-alias-的区别\" class=\"headerlink\" title=\"root 与 alias 的区别\"></a>root 与 alias 的区别</h2><p>当我们这样设置 <code>root</code> 的时候：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/i/</span> &#123;<br>    root <span class=\"hljs-regexp\">/data/</span>w3;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/i/top.gif</code> 会被返回。</p>\n<p>当我们这样设置 <code>alias</code> 的时候：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/i/</span> &#123;<br>    alias <span class=\"hljs-regexp\">/data/</span>w3<span class=\"hljs-regexp\">/images/</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当请求 <code>/i/top.gif</code> ，<code>/data/w3/images/top.gif</code> 会被返回。</p>\n<p>乍一看两者很像，但细一看，就能看出两者的区别，root 是直接拼接 <code>root</code> + <code>location</code> 而 alias 是用 <code>alias</code> 替换 <code>location</code>，所以 root 中最后的路径里有 <code>/i/</code>，而 alias 中最后的路径里没有  <code>/i/</code> 。</p>\n<p>所以如果你这样使用 allias 定义一个路径：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/images/</span> &#123;<br>    alias <span class=\"hljs-regexp\">/data/</span>w3<span class=\"hljs-regexp\">/images/</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实使用 root 会更好：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">location <span class=\"hljs-regexp\">/images/</span> &#123;<br>    root <span class=\"hljs-regexp\">/data/</span>w3;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"server-和-location-中的-root\"><a href=\"#server-和-location-中的-root\" class=\"headerlink\" title=\"server 和 location 中的 root\"></a>server 和 location 中的 root</h2><p>server 和 location 中都可以使用 root，举个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">http &#123;<br>  server &#123;<br>      listen <span class=\"hljs-number\">80</span>;<br>    \tserver_name www.yayujs.com;<br>    \troot <span class=\"hljs-regexp\">/home/</span>www<span class=\"hljs-regexp\">/website/</span>;<br>    \tlocation / &#123;<br>      \troot <span class=\"hljs-regexp\">/home/</span>www<span class=\"hljs-regexp\">/ts/</span>;<br>\t      index index.html;<br>    \t&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果两者都出现，是怎样的优先级呢？</p>\n<p>简单的来说，就是就近原则，如果 location 中能匹配到，就是用 location 中的 root 配置，忽略 server 中的 root，当 location 中匹配不到的时候，则使用 server 中的 root 配置。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl7ec3i1e0006scvme7v1fwuy","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1l000iscvm442p4ssk"},{"post_id":"cl7ec3i160001scvm4yezei93","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1m000lscvmhjx06gtu"},{"post_id":"cl7ec3i1f0007scvmae4s2zet","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1o000pscvmcf8n0mlh"},{"post_id":"cl7ec3i1h000bscvm2na932oz","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1o000sscvm88peafys"},{"post_id":"cl7ec3i190002scvmc3isbfll","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1p000vscvmdb1hguoc"},{"post_id":"cl7ec3i1i000dscvm91lnf30f","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1q000xscvm98h1frnx"},{"post_id":"cl7ec3i1k000hscvmduvm9m8n","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1r0011scvm1zptbuv0"},{"post_id":"cl7ec3i1c0004scvm9avugh1d","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1s0014scvm8i4gc8d5"},{"post_id":"cl7ec3i1m000kscvm8klv98wc","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1s0018scvmabje5jme"},{"post_id":"cl7ec3i1n000oscvm6xey1aes","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1t001ascvm08oohq84"},{"post_id":"cl7ec3i1o000rscvmbvjs3zx9","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1u001cscvm02l23zt8"},{"post_id":"cl7ec3i1q000wscvm9t3wdp97","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1u001gscvmgnt32obj"},{"post_id":"cl7ec3i1q000zscvm1vaz87ol","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1v001jscvmauo7c7fp"},{"post_id":"cl7ec3i1r0013scvmgqg6amdz","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1w001mscvmed31801a"},{"post_id":"cl7ec3i1s0017scvmfq9t8aff","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1y001oscvmh85p10k1"},{"post_id":"cl7ec3i1p000uscvm66fs3g38","category_id":"cl7ec3i1r0010scvmf1jqcy4e","_id":"cl7ec3i1z001rscvmfupl91la"},{"post_id":"cl7ec3i1p000uscvm66fs3g38","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i1z001uscvmdx2u3cnb"},{"post_id":"cl7ec3i1t0019scvmgg60ejuz","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i20001yscvm9qyehuu2"},{"post_id":"cl7ec3i1t001bscvmac5bae67","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i210021scvmbuhl7nex"},{"post_id":"cl7ec3i1u001fscvm543obtck","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i210023scvm00435tey"},{"post_id":"cl7ec3i1v001iscvm97z0f96o","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i220027scvmaaqhhadz"},{"post_id":"cl7ec3i1w001lscvmhrjf9lji","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i230029scvm30y0hr74"},{"post_id":"cl7ec3i1w001nscvm8jgo929e","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i23002cscvmhb615uh5"},{"post_id":"cl7ec3i1y001qscvmg3w6h8uy","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i24002fscvm4cwq4b8h"},{"post_id":"cl7ec3i1z001tscvm9gdn4557","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i25002iscvm71x4dnwq"},{"post_id":"cl7ec3i20001xscvm34qwede1","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i25002kscvma0aw4g99"},{"post_id":"cl7ec3i200020scvm75dg668h","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i26002oscvm3z599mny"},{"post_id":"cl7ec3i210022scvm0ffv3irp","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i27002rscvmbmxi8e5w"},{"post_id":"cl7ec3i220026scvm2842gvi2","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i28002vscvmc6qdgx6w"},{"post_id":"cl7ec3i220028scvmd9508wrz","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i28002yscvm3nux8hc8"},{"post_id":"cl7ec3i23002bscvmb9aw71tc","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i290032scvm8gm38zsj"},{"post_id":"cl7ec3i24002escvm47o16z61","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2a0035scvmgyjvhvzx"},{"post_id":"cl7ec3i24002hscvme6wwdgsx","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2a0039scvm1arghijj"},{"post_id":"cl7ec3i25002jscvmbugkb2i1","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2b003cscvm076u0ikz"},{"post_id":"cl7ec3i26002nscvmgb6pdsda","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2c003hscvmd0vkfjw4"},{"post_id":"cl7ec3i27002qscvmg55v5tlm","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2d003kscvmcagv45nc"},{"post_id":"cl7ec3i27002uscvm4kcs516i","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2d003oscvmb7j1hznb"},{"post_id":"cl7ec3i28002xscvmhjkd9hlr","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2e003rscvm2v5lbhbe"},{"post_id":"cl7ec3i290031scvm6xx94pbh","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2f003vscvm2eec8ul9"},{"post_id":"cl7ec3i290034scvm55vcgwpm","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2g003yscvm1e890sap"},{"post_id":"cl7ec3i2b003bscvm1a9r6l8v","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2g0043scvm2hooe17f"},{"post_id":"cl7ec3i2c003fscvm98zj3wmh","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2h0046scvmh70b60m3"},{"post_id":"cl7ec3i2c003jscvmeu2l8f2d","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2i004ascvmhhcb6xs6"},{"post_id":"cl7ec3i2a0038scvm0d4ab8g4","category_id":"cl7ec3i2c003gscvmf2v69idi","_id":"cl7ec3i2i004dscvm9155c6uf"},{"post_id":"cl7ec3i2d003nscvm89oj90id","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2j004hscvm04atc13s"},{"post_id":"cl7ec3i2e003qscvmalmgev78","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2k004lscvm28u69d7u"},{"post_id":"cl7ec3i2f003xscvmd82p7eil","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2l004pscvmaxruhw4x"},{"post_id":"cl7ec3i2g0041scvm8it50wio","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2l004sscvmanjr9aag"},{"post_id":"cl7ec3i2h0045scvm092adh7z","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2n004wscvmbvw12t0i"},{"post_id":"cl7ec3i2f003uscvm86zhf5bf","category_id":"cl7ec3i2g0042scvm6kjecxal","_id":"cl7ec3i2n004zscvm0kgwa94a"},{"post_id":"cl7ec3i2h0049scvm7v1i4a6e","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2p0051scvm5fyc762c"},{"post_id":"cl7ec3i2j004gscvm7bn40gaw","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2p0053scvmfamq5i23"},{"post_id":"cl7ec3i2j004jscvm8czhfjg9","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2q0056scvm1na87zhn"},{"post_id":"cl7ec3i2k004oscvmdjoj6joj","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2q0057scvmhn3e63a7"},{"post_id":"cl7ec3i2i004cscvm04ps04nn","category_id":"cl7ec3i2k004kscvm5vfye1lx","_id":"cl7ec3i2q0059scvm3hqz2krb"},{"post_id":"cl7ec3i2l004rscvm61bj7zhn","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2q005bscvmdbzv7klk"},{"post_id":"cl7ec3i2m004vscvm0mv7dq05","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2q005escvm3yuj1afi"},{"post_id":"cl7ec3i2n004yscvmgjsqf29h","category_id":"cl7ec3i1d0005scvm2l4h9x1n","_id":"cl7ec3i2r005fscvm8206gyvp"}],"PostTag":[{"post_id":"cl7ec3i160001scvm4yezei93","tag_id":"cl7ec3i1b0003scvm13bi8dvn","_id":"cl7ec3i1h000ascvm0b1yg1it"},{"post_id":"cl7ec3i1f0007scvmae4s2zet","tag_id":"cl7ec3i1b0003scvm13bi8dvn","_id":"cl7ec3i1i000cscvm3c5gh49j"},{"post_id":"cl7ec3i1h000bscvm2na932oz","tag_id":"cl7ec3i1b0003scvm13bi8dvn","_id":"cl7ec3i1k000gscvmch4mgrgc"},{"post_id":"cl7ec3i190002scvmc3isbfll","tag_id":"cl7ec3i1b0003scvm13bi8dvn","_id":"cl7ec3i1m000jscvm0e8t5d0t"},{"post_id":"cl7ec3i1i000dscvm91lnf30f","tag_id":"cl7ec3i1b0003scvm13bi8dvn","_id":"cl7ec3i1n000nscvmfaxf0dee"},{"post_id":"cl7ec3i1c0004scvm9avugh1d","tag_id":"cl7ec3i1j000escvm8k3p0wh4","_id":"cl7ec3i1o000qscvm7l3b85jt"},{"post_id":"cl7ec3i1e0006scvme7v1fwuy","tag_id":"cl7ec3i1n000mscvm0vaf8dt6","_id":"cl7ec3i1r0012scvme0eu8q8h"},{"post_id":"cl7ec3i1e0006scvme7v1fwuy","tag_id":"cl7ec3i1p000tscvm7vhdgg94","_id":"cl7ec3i1s0015scvmepk8bknm"},{"post_id":"cl7ec3i1k000hscvmduvm9m8n","tag_id":"cl7ec3i1n000mscvm0vaf8dt6","_id":"cl7ec3i1u001escvm461a8rxx"},{"post_id":"cl7ec3i1k000hscvmduvm9m8n","tag_id":"cl7ec3i1s0016scvmgjm618pw","_id":"cl7ec3i1v001hscvmf3ko5o79"},{"post_id":"cl7ec3i1m000kscvm8klv98wc","tag_id":"cl7ec3i1u001dscvmfk9hfyqo","_id":"cl7ec3i1z001sscvm6l36e4lv"},{"post_id":"cl7ec3i1m000kscvm8klv98wc","tag_id":"cl7ec3i1v001kscvm6jzufooj","_id":"cl7ec3i20001vscvmh4fa26rm"},{"post_id":"cl7ec3i1n000oscvm6xey1aes","tag_id":"cl7ec3i1y001pscvmby5p4gcg","_id":"cl7ec3i20001zscvm0ujx7roe"},{"post_id":"cl7ec3i1o000rscvmbvjs3zx9","tag_id":"cl7ec3i20001wscvmcqy17dhq","_id":"cl7ec3i220025scvmexai6dey"},{"post_id":"cl7ec3i1p000uscvm66fs3g38","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i23002dscvm8dzy3pbe"},{"post_id":"cl7ec3i24002hscvme6wwdgsx","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i26002mscvm28zif01i"},{"post_id":"cl7ec3i24002hscvme6wwdgsx","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i26002pscvm88ur2wko"},{"post_id":"cl7ec3i1q000wscvm9t3wdp97","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i27002tscvmdqblgevh"},{"post_id":"cl7ec3i1q000wscvm9t3wdp97","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i28002wscvm6xvp2jz2"},{"post_id":"cl7ec3i25002jscvmbugkb2i1","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i290030scvm8db1atx2"},{"post_id":"cl7ec3i25002jscvmbugkb2i1","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i290033scvm5nhvgeq6"},{"post_id":"cl7ec3i26002nscvmgb6pdsda","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2a0037scvm07px06k6"},{"post_id":"cl7ec3i26002nscvmgb6pdsda","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2b003ascvmbsb8d4tx"},{"post_id":"cl7ec3i27002qscvmg55v5tlm","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2b003escvm6ph3fkev"},{"post_id":"cl7ec3i27002qscvmg55v5tlm","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2c003iscvm929ectii"},{"post_id":"cl7ec3i27002uscvm4kcs516i","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2d003mscvm3k3e16di"},{"post_id":"cl7ec3i27002uscvm4kcs516i","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2e003pscvm52sug4ta"},{"post_id":"cl7ec3i1q000zscvm1vaz87ol","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2e003tscvmf64d6nwc"},{"post_id":"cl7ec3i1q000zscvm1vaz87ol","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2f003wscvm3q5adwbp"},{"post_id":"cl7ec3i28002xscvmhjkd9hlr","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2g0040scvm5u080oz5"},{"post_id":"cl7ec3i28002xscvmhjkd9hlr","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2h0044scvm2sife49v"},{"post_id":"cl7ec3i1r0013scvmgqg6amdz","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2h0048scvmh3gh1v43"},{"post_id":"cl7ec3i1r0013scvmgqg6amdz","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2i004bscvm6tcgfyx9"},{"post_id":"cl7ec3i1s0017scvmfq9t8aff","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2j004fscvm70lu5h4w"},{"post_id":"cl7ec3i1s0017scvmfq9t8aff","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2j004iscvm3ir706b5"},{"post_id":"cl7ec3i1t0019scvmgg60ejuz","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2k004nscvmhegm3l8r"},{"post_id":"cl7ec3i1t0019scvmgg60ejuz","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2l004qscvmev5vbt01"},{"post_id":"cl7ec3i1t001bscvmac5bae67","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2m004uscvm60u9eldd"},{"post_id":"cl7ec3i1t001bscvmac5bae67","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2n004xscvm4qkjawqn"},{"post_id":"cl7ec3i1u001fscvm543obtck","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2p0052scvmgvjhcxu3"},{"post_id":"cl7ec3i1u001fscvm543obtck","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2p0054scvm7zbngprg"},{"post_id":"cl7ec3i1v001iscvm97z0f96o","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2q005ascvmeyr5f9tl"},{"post_id":"cl7ec3i1v001iscvm97z0f96o","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2q005cscvm7p2saz0h"},{"post_id":"cl7ec3i1w001lscvmhrjf9lji","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2r005hscvmhhnmcaa0"},{"post_id":"cl7ec3i1w001lscvmhrjf9lji","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2r005iscvm4rtk9yxw"},{"post_id":"cl7ec3i1w001nscvm8jgo929e","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2s005lscvmdjbi4r4n"},{"post_id":"cl7ec3i1w001nscvm8jgo929e","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2s005mscvm070g1q34"},{"post_id":"cl7ec3i1y001qscvmg3w6h8uy","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2t005pscvm5iqogj00"},{"post_id":"cl7ec3i1y001qscvmg3w6h8uy","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2t005qscvmebai0c96"},{"post_id":"cl7ec3i1z001tscvm9gdn4557","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2t005tscvm2vro2awh"},{"post_id":"cl7ec3i1z001tscvm9gdn4557","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2t005uscvmehu5f28y"},{"post_id":"cl7ec3i20001xscvm34qwede1","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2u005xscvm83169umq"},{"post_id":"cl7ec3i20001xscvm34qwede1","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2u005yscvm1ofy5ov0"},{"post_id":"cl7ec3i200020scvm75dg668h","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2u0061scvm8q10ca6h"},{"post_id":"cl7ec3i200020scvm75dg668h","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2u0062scvm8x72dai8"},{"post_id":"cl7ec3i210022scvm0ffv3irp","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2v0065scvmb5wv2uw6"},{"post_id":"cl7ec3i210022scvm0ffv3irp","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2v0066scvm27132jn2"},{"post_id":"cl7ec3i220026scvm2842gvi2","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2w0068scvm3li27s1a"},{"post_id":"cl7ec3i220026scvm2842gvi2","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2w0069scvmaiw758lm"},{"post_id":"cl7ec3i220028scvmd9508wrz","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2w006bscvmdwfjffbd"},{"post_id":"cl7ec3i220028scvmd9508wrz","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2w006cscvm1gw07mqq"},{"post_id":"cl7ec3i23002bscvmb9aw71tc","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2w006escvm3fwm58g6"},{"post_id":"cl7ec3i23002bscvmb9aw71tc","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2w006fscvmhbytfdti"},{"post_id":"cl7ec3i24002escvm47o16z61","tag_id":"cl7ec3i210024scvm3yj1b1a8","_id":"cl7ec3i2x006iscvm1bvqbcha"},{"post_id":"cl7ec3i24002escvm47o16z61","tag_id":"cl7ec3i24002gscvmelnr2umr","_id":"cl7ec3i2x006jscvmf6tm45hv"},{"post_id":"cl7ec3i24002escvm47o16z61","tag_id":"cl7ec3i2x006gscvm1t7x1rrr","_id":"cl7ec3i2x006lscvm38m31x4b"},{"post_id":"cl7ec3i290031scvm6xx94pbh","tag_id":"cl7ec3i2x006hscvmgibvfqpi","_id":"cl7ec3i2y006nscvm6cysdc8d"},{"post_id":"cl7ec3i290031scvm6xx94pbh","tag_id":"cl7ec3i2x006kscvmaq3tbtgr","_id":"cl7ec3i2y006oscvmcvj5bnh5"},{"post_id":"cl7ec3i290034scvm55vcgwpm","tag_id":"cl7ec3i2y006mscvmc3cy4wc3","_id":"cl7ec3i2y006rscvmbn601f50"},{"post_id":"cl7ec3i290034scvm55vcgwpm","tag_id":"cl7ec3i1b0003scvm13bi8dvn","_id":"cl7ec3i2y006sscvm8b9d70b0"},{"post_id":"cl7ec3i290034scvm55vcgwpm","tag_id":"cl7ec3i2y006pscvmad9zad87","_id":"cl7ec3i2z006uscvm7jww0q0f"},{"post_id":"cl7ec3i2a0038scvm0d4ab8g4","tag_id":"cl7ec3i2y006qscvma1oz1i96","_id":"cl7ec3i30006wscvmediobxmk"},{"post_id":"cl7ec3i2a0038scvm0d4ab8g4","tag_id":"cl7ec3i2y006tscvmgf5g1ck8","_id":"cl7ec3i30006xscvmcj0h595b"},{"post_id":"cl7ec3i2b003bscvm1a9r6l8v","tag_id":"cl7ec3i30006vscvm95nh01ih","_id":"cl7ec3i310070scvmhiqc1p6m"},{"post_id":"cl7ec3i2b003bscvm1a9r6l8v","tag_id":"cl7ec3i30006yscvmbv2u08gi","_id":"cl7ec3i310071scvmcamofv30"},{"post_id":"cl7ec3i2c003fscvm98zj3wmh","tag_id":"cl7ec3i30006vscvm95nh01ih","_id":"cl7ec3i320075scvmfpzwbyud"},{"post_id":"cl7ec3i2c003fscvm98zj3wmh","tag_id":"cl7ec3i30006yscvmbv2u08gi","_id":"cl7ec3i320076scvm4eyl5z1e"},{"post_id":"cl7ec3i2c003fscvm98zj3wmh","tag_id":"cl7ec3i310073scvmcmwnaaae","_id":"cl7ec3i320078scvmd7c50xia"},{"post_id":"cl7ec3i2c003jscvmeu2l8f2d","tag_id":"cl7ec3i310074scvmd78xhtk3","_id":"cl7ec3i32007ascvm1fuc47m1"},{"post_id":"cl7ec3i2c003jscvmeu2l8f2d","tag_id":"cl7ec3i320077scvm8f7y3kp2","_id":"cl7ec3i32007bscvm1ai7f28k"},{"post_id":"cl7ec3i2d003nscvm89oj90id","tag_id":"cl7ec3i320079scvm849y8lhg","_id":"cl7ec3i33007escvm3i8a0oio"},{"post_id":"cl7ec3i2d003nscvm89oj90id","tag_id":"cl7ec3i33007cscvmd8fx5d65","_id":"cl7ec3i34007fscvm37ezelao"},{"post_id":"cl7ec3i2e003qscvmalmgev78","tag_id":"cl7ec3i33007dscvmgvti5tpc","_id":"cl7ec3i34007iscvme2dcgc8f"},{"post_id":"cl7ec3i2e003qscvmalmgev78","tag_id":"cl7ec3i2x006kscvmaq3tbtgr","_id":"cl7ec3i34007jscvmaw544k8d"},{"post_id":"cl7ec3i2f003uscvm86zhf5bf","tag_id":"cl7ec3i34007hscvmd21scidm","_id":"cl7ec3i35007mscvm3zyg37ca"},{"post_id":"cl7ec3i2f003uscvm86zhf5bf","tag_id":"cl7ec3i34007kscvmakdagect","_id":"cl7ec3i35007nscvm99lcbfcc"},{"post_id":"cl7ec3i2f003xscvmd82p7eil","tag_id":"cl7ec3i34007lscvm1t56faci","_id":"cl7ec3i35007pscvm8e3d8qri"},{"post_id":"cl7ec3i2f003xscvmd82p7eil","tag_id":"cl7ec3i1n000mscvm0vaf8dt6","_id":"cl7ec3i35007qscvm5eozhgi1"},{"post_id":"cl7ec3i2g0041scvm8it50wio","tag_id":"cl7ec3i35007oscvm7gv50aq9","_id":"cl7ec3i36007tscvmckvv2ytn"},{"post_id":"cl7ec3i2g0041scvm8it50wio","tag_id":"cl7ec3i35007rscvmb2yq0jjn","_id":"cl7ec3i36007uscvmhp70gxx6"},{"post_id":"cl7ec3i2h0045scvm092adh7z","tag_id":"cl7ec3i1n000mscvm0vaf8dt6","_id":"cl7ec3i36007wscvmcnzlbpu2"},{"post_id":"cl7ec3i2h0045scvm092adh7z","tag_id":"cl7ec3i35007sscvma6ty0am6","_id":"cl7ec3i36007xscvm2068b75c"},{"post_id":"cl7ec3i2h0049scvm7v1i4a6e","tag_id":"cl7ec3i36007vscvmhh9tf9vy","_id":"cl7ec3i370082scvm6oz6grmn"},{"post_id":"cl7ec3i2h0049scvm7v1i4a6e","tag_id":"cl7ec3i36007yscvmglb4fb1e","_id":"cl7ec3i370083scvm5ls92dj1"},{"post_id":"cl7ec3i2h0049scvm7v1i4a6e","tag_id":"cl7ec3i36007zscvm00d65tlg","_id":"cl7ec3i370085scvm9tludhxt"},{"post_id":"cl7ec3i2h0049scvm7v1i4a6e","tag_id":"cl7ec3i360080scvmc144cphu","_id":"cl7ec3i370086scvmcvl12t1v"},{"post_id":"cl7ec3i2i004cscvm04ps04nn","tag_id":"cl7ec3i370081scvmhwzjejhn","_id":"cl7ec3i370088scvm9133dm1w"},{"post_id":"cl7ec3i2j004gscvm7bn40gaw","tag_id":"cl7ec3i370084scvma1df07aj","_id":"cl7ec3i38008ascvmcs2vch6y"},{"post_id":"cl7ec3i2j004gscvm7bn40gaw","tag_id":"cl7ec3i370087scvm1wl123f3","_id":"cl7ec3i38008bscvmeh3n8v3b"},{"post_id":"cl7ec3i2j004jscvm8czhfjg9","tag_id":"cl7ec3i370084scvma1df07aj","_id":"cl7ec3i38008dscvmd6mxe7qy"},{"post_id":"cl7ec3i2k004oscvmdjoj6joj","tag_id":"cl7ec3i310074scvmd78xhtk3","_id":"cl7ec3i39008fscvm7s797b4s"},{"post_id":"cl7ec3i2l004rscvm61bj7zhn","tag_id":"cl7ec3i36007yscvmglb4fb1e","_id":"cl7ec3i39008hscvm6xbb2rgs"},{"post_id":"cl7ec3i2m004vscvm0mv7dq05","tag_id":"cl7ec3i36007yscvmglb4fb1e","_id":"cl7ec3i39008jscvm7eky1nux"},{"post_id":"cl7ec3i2n004yscvmgjsqf29h","tag_id":"cl7ec3i36007yscvmglb4fb1e","_id":"cl7ec3i3a008kscvme051ep2a"}],"Tag":[{"name":"git","_id":"cl7ec3i1b0003scvm13bi8dvn"},{"name":"curl","_id":"cl7ec3i1j000escvm8k3p0wh4"},{"name":"python","_id":"cl7ec3i1n000mscvm0vaf8dt6"},{"name":"anaconda","_id":"cl7ec3i1p000tscvm7vhdgg94"},{"name":"pip","_id":"cl7ec3i1s0016scvmgjm618pw"},{"name":"npm","_id":"cl7ec3i1u001dscvmfk9hfyqo"},{"name":"node","_id":"cl7ec3i1v001kscvm6jzufooj"},{"name":"ngrok","_id":"cl7ec3i1y001pscvmby5p4gcg"},{"name":"matplotlib","_id":"cl7ec3i20001wscvmcqy17dhq"},{"name":"VIM","_id":"cl7ec3i210024scvm3yj1b1a8"},{"name":"编辑器","_id":"cl7ec3i24002gscvmelnr2umr"},{"name":"Git","_id":"cl7ec3i2x006gscvm1t7x1rrr"},{"name":"webpack","_id":"cl7ec3i2x006hscvmgibvfqpi"},{"name":"前端","_id":"cl7ec3i2x006kscvmaq3tbtgr"},{"name":"hexo","_id":"cl7ec3i2y006mscvmc3cy4wc3"},{"name":"actions","_id":"cl7ec3i2y006pscvmad9zad87"},{"name":"贴吧","_id":"cl7ec3i2y006qscvma1oz1i96"},{"name":"创业","_id":"cl7ec3i2y006tscvmgf5g1ck8"},{"name":"vue","_id":"cl7ec3i30006vscvm95nh01ih"},{"name":"组件","_id":"cl7ec3i30006yscvmbv2u08gi"},{"name":"双向绑定","_id":"cl7ec3i310073scvmcmwnaaae"},{"name":"django","_id":"cl7ec3i310074scvmd78xhtk3"},{"name":"后端","_id":"cl7ec3i320077scvm8f7y3kp2"},{"name":"web","_id":"cl7ec3i320079scvm849y8lhg"},{"name":"css","_id":"cl7ec3i33007cscvmd8fx5d65"},{"name":"小程序","_id":"cl7ec3i33007dscvmgvti5tpc"},{"name":"三亚","_id":"cl7ec3i34007hscvmd21scidm"},{"name":"旅行","_id":"cl7ec3i34007kscvmakdagect"},{"name":"数据分析","_id":"cl7ec3i34007lscvm1t56faci"},{"name":"SSH","_id":"cl7ec3i35007oscvm7gv50aq9"},{"name":"服务器","_id":"cl7ec3i35007rscvmb2yq0jjn"},{"name":"爬虫","_id":"cl7ec3i35007sscvma6ty0am6"},{"name":"内网穿透","_id":"cl7ec3i36007vscvmhh9tf9vy"},{"name":"nginx","_id":"cl7ec3i36007yscvmglb4fb1e"},{"name":"frp","_id":"cl7ec3i36007zscvm00d65tlg"},{"name":"supervisor","_id":"cl7ec3i360080scvmc144cphu"},{"name":"自媒体","_id":"cl7ec3i370081scvmhwzjejhn"},{"name":"面试","_id":"cl7ec3i370084scvma1df07aj"},{"name":"tcp","_id":"cl7ec3i370087scvm1wl123f3"}]}}